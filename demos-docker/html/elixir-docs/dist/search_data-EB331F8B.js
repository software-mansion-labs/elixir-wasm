searchData={"items":[{"type":"module","title":"Kernel","doc":"`Kernel` is Elixir's default environment.\n\nIt mainly consists of:\n\n  * basic language primitives, such as arithmetic operators, spawning of processes,\n    data type handling, and others\n  * macros for control-flow and defining new functionality (modules, functions, and the like)\n  * guard checks for augmenting pattern matching\n\nYou can invoke `Kernel` functions and macros anywhere in Elixir code\nwithout the use of the `Kernel.` prefix since they have all been\nautomatically imported. For example, in IEx, you can call:\n\n    iex> is_number(13)\n    true\n\nIf you don't want to import a function or macro from `Kernel`, use the `:except`\noption and then list the function/macro by arity:\n\n    import Kernel, except: [if: 2, unless: 2]\n\nSee `import/2` for more information on importing.\n\nElixir also has special forms that are always imported and\ncannot be skipped. These are described in `Kernel.SpecialForms`.","ref":"Kernel.html"},{"type":"module","title":"The standard library - Kernel","doc":"`Kernel` provides the basic capabilities the Elixir standard library\nis built on top of. It is recommended to explore the standard library\nfor advanced functionality. Here are the main groups of modules in the\nstandard library (this list is not a complete reference, see the\ndocumentation sidebar for all entries).","ref":"Kernel.html#module-the-standard-library"},{"type":"module","title":"Built-in types - Kernel","doc":"The following modules handle Elixir built-in data types:\n\n  * `Atom` - literal constants with a name (`true`, `false`, and `nil` are atoms)\n  * `Float` - numbers with floating point precision\n  * `Function` - a reference to code chunk, created with the `fn/1` special form\n  * `Integer` - whole numbers (not fractions)\n  * `List` - collections of a variable number of elements (linked lists)\n  * `Map` - collections of key-value pairs\n  * `Process` - light-weight threads of execution\n  * `Port` - mechanisms to interact with the external world\n  * `Tuple` - collections of a fixed number of elements\n\nThere are two data types without an accompanying module:\n\n  * Bitstring - a sequence of bits, created with `<<>>/1`.\n    When the number of bits is divisible by 8, they are called binaries and can\n    be manipulated with Erlang's `:binary` module\n  * Reference - a unique value in the runtime system, created with `make_ref/0`","ref":"Kernel.html#module-built-in-types"},{"type":"module","title":"Data types - Kernel","doc":"Elixir also provides other data types that are built on top of the types\nlisted above. Some of them are:\n\n  * `Date` - `year-month-day` structs in a given calendar\n  * `DateTime` - date and time with time zone in a given calendar\n  * `Exception` - data raised from errors and unexpected scenarios\n  * `MapSet` - unordered collections of unique elements\n  * `NaiveDateTime` - date and time without time zone in a given calendar\n  * `Keyword` - lists of two-element tuples, often representing optional values\n  * `Range` - inclusive ranges between two integers\n  * `Regex` - regular expressions\n  * `String` - UTF-8 encoded binaries representing characters\n  * `Time` - `hour:minute:second` structs in a given calendar\n  * `URI` - representation of URIs that identify resources\n  * `Version` - representation of versions and requirements","ref":"Kernel.html#module-data-types"},{"type":"module","title":"System modules - Kernel","doc":"Modules that interface with the underlying system, such as:\n\n  * `IO` - handles input and output\n  * `File` - interacts with the underlying file system\n  * `Path` - manipulates file system paths\n  * `System` - reads and writes system information","ref":"Kernel.html#module-system-modules"},{"type":"module","title":"Protocols - Kernel","doc":"Protocols add polymorphic dispatch to Elixir. They are contracts\nimplementable by data types. See `Protocol` for more information on\nprotocols. Elixir provides the following protocols in the standard library:\n\n  * `Collectable` - collects data into a data type\n  * `Enumerable` - handles collections in Elixir. The `Enum` module\n    provides eager functions for working with collections, the `Stream`\n    module provides lazy functions\n  * `Inspect` - converts data types into their programming language\n    representation\n  * `List.Chars` - converts data types to their outside world\n    representation as charlists (non-programming based)\n  * `String.Chars` - converts data types to their outside world\n    representation as strings (non-programming based)","ref":"Kernel.html#module-protocols"},{"type":"module","title":"Process-based and application-centric functionality - Kernel","doc":"The following modules build on top of processes to provide concurrency,\nfault-tolerance, and more.\n\n  * `Agent` - a process that encapsulates mutable state\n  * `Application` - functions for starting, stopping and configuring\n    applications\n  * `GenServer` - a generic client-server API\n  * `Registry` - a key-value process-based storage\n  * `Supervisor` - a process that is responsible for starting,\n    supervising and shutting down other processes\n  * `Task` - a process that performs computations\n  * `Task.Supervisor` - a supervisor for managing tasks exclusively","ref":"Kernel.html#module-process-based-and-application-centric-functionality"},{"type":"module","title":"Supporting documents - Kernel","doc":"Under the \"Pages\" section in sidebar you will find tutorials, guides,\nand reference documents that outline Elixir semantics and behaviors\nin more detail. Those are:\n\n  * [Compatibility and deprecations](compatibility-and-deprecations.md) - lists\n    compatibility between every Elixir version and Erlang/OTP, release schema;\n    lists all deprecated functions, when they were deprecated and alternatives\n  * [Library guidelines](library-guidelines.md) - general guidelines, anti-patterns,\n    and rules for those writing libraries\n  * [Naming conventions](naming-conventions.md) - naming conventions for Elixir code\n  * [Operators reference](operators.md) - lists all Elixir operators and their precedences\n  * [Patterns and guards](patterns-and-guards.md) - an introduction to patterns,\n    guards, and extensions\n  * [Syntax reference](syntax-reference.md) - the language syntax reference\n  * [Typespecs reference](typespecs.md)- types and function specifications, including list of types\n  * [Unicode syntax](unicode-syntax.md) - outlines Elixir support for Unicode","ref":"Kernel.html#module-supporting-documents"},{"type":"module","title":"Guards - Kernel","doc":"This module includes the built-in guards used by Elixir developers.\nThey are a predefined set of functions and macros that augment pattern\nmatching, typically invoked after the `when` operator. For example:\n\n    def drive(%User{age: age}) when age >= 16 do\n      ...\n    end\n\nThe clause above will only be invoked if the user's age is more than\nor equal to 16. Guards also support joining multiple conditions with\n`and` and `or`. The whole guard is true if all guard expressions will\nevaluate to `true`. A more complete introduction to guards is available\nin the [Patterns and guards](patterns-and-guards.md) page.","ref":"Kernel.html#module-guards"},{"type":"module","title":"Truthy and falsy values - Kernel","doc":"Besides the booleans `true` and `false`, Elixir has the\nconcept of a \"truthy\" or \"falsy\" value.\n\n  *  a value is truthy when it is neither `false` nor `nil`\n  *  a value is falsy when it is either `false` or `nil`\n\nElixir has functions, like `and/2`, that *only* work with\nbooleans, but also functions that work with these\ntruthy/falsy values, like `&&/2` and `!/1`.","ref":"Kernel.html#module-truthy-and-falsy-values"},{"type":"module","title":"Structural comparison - Kernel","doc":"The functions in this module perform structural comparison. This allows\ndifferent data types to be compared using comparison operators:\n\n    1 < :an_atom\n\nThis is possible so Elixir developers can create collections, such as\ndictionaries and ordered sets, that store a mixture of data types in them.\nTo understand why this matters, let's discuss the two types of comparisons\nwe find in software: _structural_ and _semantic_.\n\nStructural means we are comparing the underlying data structures and we often\nwant those operations to be as fast as possible, because it is used to power\nseveral algorithms and data structures in the language. A semantic comparison\nworries about what each data type represents. For example, semantically\nspeaking, it doesn't make sense to compare `Time` with `Date`.\n\nOne example that shows the differences between structural and semantic\ncomparisons are strings: \"alien\" sorts less than \"office\" (`\"alien\" < \"office\"`)\nbut \"álien\" is greater than \"office\". This happens because `<` compares the\nunderlying bytes that form the string. If you were doing alphabetical listing,\nyou may want \"álien\" to also appear before \"office\".\n\nThis means **comparisons in Elixir are structural**, as it has the goal\nof comparing data types as efficiently as possible to create flexible\nand performant data structures. This distinction is specially important\nfor functions that provide ordering, such as `>/2`, `</2`, `>=/2`,\n`<=/2`, `min/2`, and `max/2`. For example:\n\n    ~D[2017-03-31] > ~D[2017-04-01]\n\nwill return `true` because structural comparison compares the `:day`\nfield before `:month` or `:year`. Luckily, the Elixir compiler will\ndetect whenever comparing structs or whenever comparing code that is\neither always true or false, and emit a warning accordingly.\n\nIn order to perform semantic comparisons, the relevant data-types\nprovide a `compare/2` function, such as `Date.compare/2`:\n\n    iex> Date.compare(~D[2017-03-31], ~D[2017-04-01])\n    :lt\n\nAlternatively, you can use the functions in the `Enum` module to\nsort or compute a maximum/minimum:\n\n    iex> Enum.sort([~D[2017-03-31], ~D[2017-04-01]], Date)\n    [~D[2017-03-31], ~D[2017-04-01]]\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-04-01]\n\nThe second argument is precisely the module to be used for semantic\ncomparison. Keeping this distinction is important, because if semantic\ncomparison was used by default for implementing data structures and\nalgorithms, they could become orders of magnitude slower!\n\nFinally, note there is an overall structural sorting order, called\n\"Term Ordering\", defined below. This order is provided for reference\npurposes, it is not required by Elixir developers to know it by heart.","ref":"Kernel.html#module-structural-comparison"},{"type":"module","title":"Term ordering - Kernel","doc":"```\nnumber < atom < reference < function < port < pid < tuple < map < list < bitstring\n```\n\nWhen comparing two numbers of different types (a number being either\nan integer or a float), a conversion to the type with greater precision\nwill always occur, unless the comparison operator used is either `===/2`\nor `!==`. A float will be considered more precise than an integer, unless\nthe float is greater/less than +/-9007199254740992.0 respectively,\nat which point all the significant figures of the float are to the left\nof the decimal point. This behavior exists so that the comparison of large\nnumbers remains transitive.\n\nThe collection types are compared using the following rules:\n\n* Tuples are compared by size, then element by element.\n* Maps are compared by size, then by keys in ascending term order,\n  then by values in key order. In the specific case of maps' key\n  ordering, integers are always considered to be less than floats.\n* Lists are compared element by element.\n* Bitstrings are compared byte by byte, incomplete bytes are compared bit by bit.\n* Atoms are compared using their string value, codepoint by codepoint.","ref":"Kernel.html#module-term-ordering"},{"type":"module","title":"Examples - Kernel","doc":"We can check the truthiness of a value by using the `!/1`\nfunction twice.\n\nTruthy values:\n\n    iex> !!true\n    true\n    iex> !!5\n    true\n    iex> !![1,2]\n    true\n    iex> !!\"foo\"\n    true\n\nFalsy values (of which there are exactly two):\n\n    iex> !!false\n    false\n    iex> !!nil\n    false","ref":"Kernel.html#module-examples"},{"type":"module","title":"Inlining - Kernel","doc":"Some of the functions described in this module are inlined by\nthe Elixir compiler into their Erlang counterparts in the\n[`:erlang`](`:erlang`) module.\nThose functions are called BIFs (built-in internal functions)\nin Erlang-land and they exhibit interesting properties, as some\nof them are allowed in guards and others are used for compiler\noptimizations.\n\nMost of the inlined functions can be seen in effect when\ncapturing the function:\n\n    iex> &Kernel.is_atom/1\n    &:erlang.is_atom/1\n\nThose functions will be explicitly marked in their docs as\n\"inlined by the compiler\".","ref":"Kernel.html#module-inlining"},{"type":"macro","title":"Kernel.&&/2","doc":"Boolean \"and\" operator.\n\nProvides a short-circuit operator that evaluates and returns\nthe second expression only if the first one evaluates to a truthy value\n(neither `false` nor `nil`). Returns the first expression\notherwise.\n\nNot allowed in guard clauses.","ref":"Kernel.html#&&/2"},{"type":"macro","title":"Examples - Kernel.&&/2","doc":"iex> Enum.empty?([]) && Enum.empty?([])\n    true\n\n    iex> List.first([]) && true\n    nil\n\n    iex> Enum.empty?([]) && List.first([1])\n    1\n\n    iex> false && throw(:bad)\n    false\n\nNote that, unlike `and/2`, this operator accepts any expression\nas the first argument, not only booleans.","ref":"Kernel.html#&&/2-examples"},{"type":"function","title":"Kernel.**/2","doc":"Power operator.\n\nIt takes two numbers for input. If both are integers and the right-hand\nside (the `exponent`) is also greater than or equal to 0, then the result\nwill also be an integer. Otherwise it returns a float.","ref":"Kernel.html#**/2"},{"type":"function","title":"Examples - Kernel.**/2","doc":"iex> 2 ** 2\n    4\n    iex> 2 ** -4\n    0.0625\n\n    iex> 2.0 ** 2\n    4.0\n    iex> 2 ** 2.0\n    4.0","ref":"Kernel.html#**/2-examples"},{"type":"function","title":"Kernel.*/2","doc":"Arithmetic multiplication operator.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#*/2"},{"type":"function","title":"Examples - Kernel.*/2","doc":"iex> 1 * 2\n    2","ref":"Kernel.html#*/2-examples"},{"type":"function","title":"Kernel.++/2","doc":"List concatenation operator. Concatenates a proper list and a term, returning a list.\n\nThe complexity of `a ++ b` is proportional to `length(a)`, so avoid repeatedly\nappending to lists of arbitrary length, for example, `list ++ [element]`.\nInstead, consider prepending via `[element | rest]` and then reversing.\n\nIf the `right` operand is not a proper list, it returns an improper list.\nIf the `left` operand is not a proper list, it raises `ArgumentError`.\nIf the `left` operand is an empty list, it returns the `right` operand.\n\nInlined by the compiler.","ref":"Kernel.html#++/2"},{"type":"function","title":"Examples - Kernel.++/2","doc":"iex> [1] ++ [2, 3]\n    [1, 2, 3]\n\n    iex> ~c\"foo\" ++ ~c\"bar\"\n    ~c\"foobar\"\n\n    # a non-list on the right will return an improper list\n    # with said element at the end\n    iex> [1, 2] ++ 3\n    [1, 2 | 3]\n    iex> [1, 2] ++ {3, 4}\n    [1, 2 | {3, 4}]\n\n    # improper list on the right will return an improper list\n    iex> [1] ++ [2 | 3]\n    [1, 2 | 3]\n\n    # empty list on the left will return the right operand\n    iex> [] ++ 1\n    1\n\nThe `++/2` operator is right associative, meaning:\n\n    iex> [1, 2, 3] -- [1] ++ [2]\n    [3]\n\nAs it is equivalent to:\n\n    iex> [1, 2, 3] -- ([1] ++ [2])\n    [3]","ref":"Kernel.html#++/2-examples"},{"type":"function","title":"Kernel.+/1","doc":"Arithmetic positive unary operator.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#+/1"},{"type":"function","title":"Examples - Kernel.+/1","doc":"iex> +1\n    1","ref":"Kernel.html#+/1-examples"},{"type":"function","title":"Kernel.+/2","doc":"Arithmetic addition operator.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#+/2"},{"type":"function","title":"Examples - Kernel.+/2","doc":"iex> 1 + 2\n    3","ref":"Kernel.html#+/2-examples"},{"type":"function","title":"Kernel.--/2","doc":"List subtraction operator. Removes the first occurrence of an element\non the left list for each element on the right.\n\nThis function is optimized so the complexity of `a -- b` is proportional\nto `length(a) * log(length(b))`. See also the [Erlang efficiency\nguide](https://www.erlang.org/doc/efficiency_guide/retired_myths.html).\n\nInlined by the compiler.","ref":"Kernel.html#--/2"},{"type":"function","title":"Examples - Kernel.--/2","doc":"iex> [1, 2, 3] -- [1, 2]\n    [3]\n\n    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n    [3, 1]\n\nThe `--/2` operator is right associative, meaning:\n\n    iex> [1, 2, 3] -- [2] -- [3]\n    [1, 3]\n\nAs it is equivalent to:\n\n    iex> [1, 2, 3] -- ([2] -- [3])\n    [1, 3]","ref":"Kernel.html#--/2-examples"},{"type":"function","title":"Kernel.-/1","doc":"Arithmetic negative unary operator.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#-/1"},{"type":"function","title":"Examples - Kernel.-/1","doc":"iex> -2\n    -2","ref":"Kernel.html#-/1-examples"},{"type":"function","title":"Kernel.-/2","doc":"Arithmetic subtraction operator.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#-/2"},{"type":"function","title":"Examples - Kernel.-/2","doc":"iex> 1 - 2\n    -1","ref":"Kernel.html#-/2-examples"},{"type":"macro","title":"Kernel.../0","doc":"Creates the full-slice range `0..-1//1`.\n\nThis macro returns a range with the following properties:\n\n  * When enumerated, it is empty\n\n  * When used as a `slice`, it returns the sliced element as is\n\nSee `..///3` and the `Range` module for more information.","ref":"Kernel.html#../0"},{"type":"macro","title":"Examples - Kernel.../0","doc":"iex> Enum.to_list(..)\n    []\n\n    iex> String.slice(\"Hello world!\", ..)\n    \"Hello world!\"","ref":"Kernel.html#../0-examples"},{"type":"macro","title":"Kernel.../2","doc":"Creates a range from `first` to `last`.\n\nIf first is less than last, the range will be increasing from\nfirst to last. If first is equal to last, the range will contain\none element, which is the number itself.\n\nIf first is more than last, the range will be decreasing from first\nto last, albeit this behavior is deprecated. Instead prefer to\nexplicitly list the step with `first..last//-1`.\n\nSee the `Range` module for more information.","ref":"Kernel.html#../2"},{"type":"macro","title":"Examples - Kernel.../2","doc":"iex> 0 in 1..3\n    false\n    iex> 2 in 1..3\n    true\n\n    iex> Enum.to_list(1..3)\n    [1, 2, 3]","ref":"Kernel.html#../2-examples"},{"type":"macro","title":"Kernel...///3","doc":"Creates a range from `first` to `last` with `step`.\n\nSee the `Range` module for more information.","ref":"Kernel.html#..///3"},{"type":"macro","title":"Examples - Kernel...///3","doc":"iex> 0 in 1..3//1\n    false\n    iex> 2 in 1..3//1\n    true\n    iex> 2 in 1..3//2\n    false\n\n    iex> Enum.to_list(1..3//1)\n    [1, 2, 3]\n    iex> Enum.to_list(1..3//2)\n    [1, 3]\n    iex> Enum.to_list(3..1//-1)\n    [3, 2, 1]\n    iex> Enum.to_list(1..0//1)\n    []","ref":"Kernel.html#..///3-examples"},{"type":"function","title":"Kernel.//2","doc":"Arithmetic division operator.\n\nThe result is always a float. Use `div/2` and `rem/2` if you want\nan integer division or the remainder.\n\nRaises `ArithmeticError` if `right` is 0 or 0.0.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#//2"},{"type":"function","title":"Examples - Kernel.//2","doc":"1 / 2\n    #=> 0.5\n\n    -3.0 / 2.0\n    #=> -1.5\n\n    5 / 1\n    #=> 5.0\n\n    7 / 0\n    ** (ArithmeticError) bad argument in arithmetic expression","ref":"Kernel.html#//2-examples"},{"type":"macro","title":"Kernel.!/1","doc":"Boolean \"not\" operator.\n\nReceives any value (not just booleans) and returns `true` if `value`\nis `false` or `nil`; returns `false` otherwise.\n\nNot allowed in guard clauses.","ref":"Kernel.html#!/1"},{"type":"macro","title":"Examples - Kernel.!/1","doc":"iex> !Enum.empty?([])\n    false\n\n    iex> !List.first([])\n    true","ref":"Kernel.html#!/1-examples"},{"type":"function","title":"Kernel.!=/2","doc":"Not equal to operator.\n\nReturns `true` if the two terms are not equal.\n\nThis operator considers 1 and 1.0 to be equal. For match\ncomparison, use `!==/2` instead.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\"](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#!=/2"},{"type":"function","title":"Examples - Kernel.!=/2","doc":"iex> 1 != 2\n    true\n\n    iex> 1 != 1.0\n    false","ref":"Kernel.html#!=/2-examples"},{"type":"function","title":"Kernel.!==/2","doc":"Strictly not equal to operator.\n\nReturns `true` if the two terms are not exactly equal.\nSee `===/2` for a definition of what is considered \"exactly equal\".\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\"](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#!==/2"},{"type":"function","title":"Examples - Kernel.!==/2","doc":"iex> 1 !== 2\n    true\n\n    iex> 1 !== 1.0\n    true","ref":"Kernel.html#!==/2-examples"},{"type":"function","title":"Kernel.</2","doc":"Less-than operator.\n\nReturns `true` if `left` is less than `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\"](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#%3C/2"},{"type":"function","title":"Examples - Kernel.</2","doc":"iex> 1 < 2\n    true","ref":"Kernel.html#%3C/2-examples"},{"type":"function","title":"Kernel.<=/2","doc":"Less-than or equal to operator.\n\nReturns `true` if `left` is less than or equal to `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\"](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#%3C=/2"},{"type":"function","title":"Examples - Kernel.<=/2","doc":"iex> 1 <= 2\n    true","ref":"Kernel.html#%3C=/2-examples"},{"type":"macro","title":"Kernel.<>/2","doc":"Binary concatenation operator. Concatenates two binaries.\n\nRaises an `ArgumentError` if one of the sides aren't binaries.","ref":"Kernel.html#%3C%3E/2"},{"type":"macro","title":"Examples - Kernel.<>/2","doc":"iex> \"foo\" <> \"bar\"\n    \"foobar\"\n\nThe `<>/2` operator can also be used in pattern matching (and guard clauses) as\nlong as the left argument is a literal binary:\n\n    iex> \"foo\" <> x = \"foobar\"\n    iex> x\n    \"bar\"\n\n`x <> \"bar\" = \"foobar\"` would result in an `ArgumentError` exception.","ref":"Kernel.html#%3C%3E/2-examples"},{"type":"function","title":"Kernel.==/2","doc":"Equal to operator. Returns `true` if the two terms are equal.\n\nThis operator considers 1 and 1.0 to be equal. For stricter\nsemantics, use `===/2` instead.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\"](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#==/2"},{"type":"function","title":"Examples - Kernel.==/2","doc":"iex> 1 == 2\n    false\n\n    iex> 1 == 1.0\n    true","ref":"Kernel.html#==/2-examples"},{"type":"function","title":"Kernel.===/2","doc":"Strictly equal to operator.\n\nReturns `true` if the two terms are exactly equal.\n\nThe terms are only considered to be exactly equal if they\nhave the same value and are of the same type. For example,\n`1 == 1.0` returns `true`, but since they are of different\ntypes, `1 === 1.0` returns `false`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\"](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#===/2"},{"type":"function","title":"Examples - Kernel.===/2","doc":"iex> 1 === 2\n    false\n\n    iex> 1 === 1.0\n    false","ref":"Kernel.html#===/2-examples"},{"type":"function","title":"Kernel.=~/2","doc":"Text-based match operator. Matches the term on the `left`\nagainst the regular expression or string on the `right`.\n\nIf `right` is a regular expression, returns `true` if `left` matches right.\n\nIf `right` is a string, returns `true` if `left` contains `right`.","ref":"Kernel.html#=~/2"},{"type":"function","title":"Examples - Kernel.=~/2","doc":"iex> \"abcd\" =~ ~r/c(d)/\n    true\n\n    iex> \"abcd\" =~ ~r/e/\n    false\n\n    iex> \"abcd\" =~ ~r//\n    true\n\n    iex> \"abcd\" =~ \"bc\"\n    true\n\n    iex> \"abcd\" =~ \"ad\"\n    false\n\n    iex> \"abcd\" =~ \"abcd\"\n    true\n\n    iex> \"abcd\" =~ \"\"\n    true\n\nFor more information about regular expressions, please check the `Regex` module.","ref":"Kernel.html#=~/2-examples"},{"type":"function","title":"Kernel.>/2","doc":"Greater-than operator.\n\nReturns `true` if `left` is more than `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\"](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#%3E/2"},{"type":"function","title":"Examples - Kernel.>/2","doc":"iex> 1 > 2\n    false","ref":"Kernel.html#%3E/2-examples"},{"type":"function","title":"Kernel.>=/2","doc":"Greater-than or equal to operator.\n\nReturns `true` if `left` is more than or equal to `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\"](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#%3E=/2"},{"type":"function","title":"Examples - Kernel.>=/2","doc":"iex> 1 >= 2\n    false","ref":"Kernel.html#%3E=/2-examples"},{"type":"macro","title":"Kernel.@/1","doc":"Module attribute unary operator.\n\nReads and writes attributes in the current module.\n\nThe canonical example for attributes is annotating that a module\nimplements an OTP behaviour, such as `GenServer`:\n\n    defmodule MyServer do\n      @behaviour GenServer\n      # ... callbacks ...\n    end\n\nBy default Elixir supports all the module attributes supported by Erlang, but\ncustom attributes can be used as well:\n\n    defmodule MyServer do\n      @my_data 13\n      IO.inspect(@my_data)\n      #=> 13\n    end\n\nUnlike Erlang, such attributes are not stored in the module by default since\nit is common in Elixir to use custom attributes to store temporary data that\nwill be available at compile-time. Custom attributes may be configured to\nbehave closer to Erlang by using `Module.register_attribute/3`.\n\n> #### Prefixing module attributes {: .tip}\n>\n> Libraries and frameworks should consider prefixing any\n> module attributes that are private by underscore, such as `@_my_data`,\n> so code completion tools do not show them on suggestions and prompts.\n\nFinally, note that attributes can also be read inside functions:\n\n    defmodule MyServer do\n      @my_data 11\n      def first_data, do: @my_data\n      @my_data 13\n      def second_data, do: @my_data\n    end\n\n    MyServer.first_data()\n    #=> 11\n\n    MyServer.second_data()\n    #=> 13\n\nIt is important to note that reading an attribute takes a snapshot of\nits current value. In other words, the value is read at compilation\ntime and not at runtime. Check the `Module` module for other functions\nto manipulate module attributes.","ref":"Kernel.html#@/1"},{"type":"macro","title":"Attention! Multiple references of the same attribute - Kernel.@/1","doc":"As mentioned above, every time you read a module attribute, a snapshot\nof its current value is taken. Therefore, if you are storing large\nvalues inside module attributes (for example, embedding external files\nin module attributes), you should avoid referencing the same attribute\nmultiple times. For example, don't do this:\n\n    @files %{\n      example1: File.read!(\"lib/example1.data\"),\n      example2: File.read!(\"lib/example2.data\")\n    }\n\n    def example1, do: @files[:example1]\n    def example2, do: @files[:example2]\n\nIn the above, each reference to `@files` may end-up with a complete\nand individual copy of the whole `@files` module attribute. Instead,\nreference the module attribute once in a private function:\n\n    @files %{\n      example1: File.read!(\"lib/example1.data\"),\n      example2: File.read!(\"lib/example2.data\")\n    }\n\n    defp files(), do: @files\n    def example1, do: files()[:example1]\n    def example2, do: files()[:example2]","ref":"Kernel.html#@/1-attention-multiple-references-of-the-same-attribute"},{"type":"function","title":"Kernel.abs/1","doc":"Returns an integer or float which is the arithmetical absolute value of `number`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#abs/1"},{"type":"function","title":"Examples - Kernel.abs/1","doc":"iex> abs(-3.33)\n    3.33\n\n    iex> abs(-3)\n    3","ref":"Kernel.html#abs/1-examples"},{"type":"macro","title":"Kernel.alias!/1","doc":"When used inside quoting, marks that the given alias should not\nbe hygienized. This means the alias will be expanded when\nthe macro is expanded.\n\nCheck `quote/2` for more information.","ref":"Kernel.html#alias!/1"},{"type":"macro","title":"Kernel.and/2","doc":"Strictly boolean \"and\" operator.\n\nIf `left` is `false`, returns `false`, otherwise returns `right`.\n\nRequires only the `left` operand to be a boolean since it short-circuits. If\nthe `left` operand is not a boolean, a `BadBooleanError` exception is raised.\n\nAllowed in guard tests.","ref":"Kernel.html#and/2"},{"type":"macro","title":"Examples - Kernel.and/2","doc":"iex> true and false\n    false\n\n    iex> true and \"yay!\"\n    \"yay!\"\n\n    iex> \"yay!\" and true\n    ** (BadBooleanError) expected a boolean on left-side of \"and\", got: \"yay!\"","ref":"Kernel.html#and/2-examples"},{"type":"function","title":"Kernel.apply/2","doc":"Invokes the given anonymous function `fun` with the list of\narguments `args`.\n\nIf the number of arguments is known at compile time, prefer\n`fun.(arg_1, arg_2, ..., arg_n)` as it is clearer than\n`apply(fun, [arg_1, arg_2, ..., arg_n])`.\n\nInlined by the compiler.","ref":"Kernel.html#apply/2"},{"type":"function","title":"Examples - Kernel.apply/2","doc":"iex> apply(fn x -> x * 2 end, [2])\n    4","ref":"Kernel.html#apply/2-examples"},{"type":"function","title":"Kernel.apply/3","doc":"Invokes the given function from `module` with the list of\narguments `args`.\n\n`apply/3` is used to invoke functions where the module, function\nname or arguments are defined dynamically at runtime. For this\nreason, you can't invoke macros using `apply/3`, only functions.\n\nIf the number of arguments and the function name are known at compile time,\nprefer `module.function(arg_1, arg_2, ..., arg_n)` as it is clearer than\n`apply(module, :function, [arg_1, arg_2, ..., arg_n])`.\n\n`apply/3` cannot be used to call private functions.\n\nInlined by the compiler.","ref":"Kernel.html#apply/3"},{"type":"function","title":"Examples - Kernel.apply/3","doc":"iex> apply(Enum, :reverse, [[1, 2, 3]])\n    [3, 2, 1]","ref":"Kernel.html#apply/3-examples"},{"type":"function","title":"Kernel.binary_part/3","doc":"Extracts the part of the binary at `start` with `size`.\n\nIf `start` or `size` reference in any way outside the binary,\nan `ArgumentError` exception is raised.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#binary_part/3"},{"type":"function","title":"Examples - Kernel.binary_part/3","doc":"iex> binary_part(\"foo\", 1, 2)\n    \"oo\"\n\nA negative `size` can be used to extract bytes that come *before* the byte\nat `start`:\n\n    iex> binary_part(\"Hello\", 5, -3)\n    \"llo\"\n\nAn `ArgumentError` is raised when the `size` is outside of the binary:\n\n    binary_part(\"Hello\", 0, 10)\n    ** (ArgumentError) argument error","ref":"Kernel.html#binary_part/3-examples"},{"type":"function","title":"Kernel.binary_slice/2","doc":"Returns a binary from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nIf the start or end of the range are negative, they are converted\ninto positive indices based on the binary size. For example,\n`-1` means the last byte of the binary.\n\nThis is similar to `binary_part/3` except that it works with ranges\nand it is not allowed in guards.\n\nThis function works with bytes. For a slicing operation that\nconsiders characters, see `String.slice/2`.","ref":"Kernel.html#binary_slice/2"},{"type":"function","title":"Examples - Kernel.binary_slice/2","doc":"iex> binary_slice(\"elixir\", 0..5)\n    \"elixir\"\n    iex> binary_slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> binary_slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> binary_slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", -10..10)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> binary_slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole binary as is:\n\n    iex> binary_slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the binary:\n\n    iex> binary_slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> binary_slice(\"elixir\", 10..3//1)\n    \"\"\n    iex> binary_slice(\"elixir\", -10..-7)\n    \"\"\n    iex> binary_slice(\"a\", 1..1500)\n    \"\"","ref":"Kernel.html#binary_slice/2-examples"},{"type":"function","title":"Kernel.binary_slice/3","doc":"Returns a binary starting at the offset `start` and of the given `size`.\n\nThis is similar to `binary_part/3` except that if `start + size`\nis greater than the binary size, it automatically clips it to\nthe binary size instead of raising. Opposite to `binary_part/3`,\nthis function is not allowed in guards.\n\nThis function works with bytes. For a slicing operation that\nconsiders characters, see `String.slice/3`.","ref":"Kernel.html#binary_slice/3"},{"type":"function","title":"Examples - Kernel.binary_slice/3","doc":"iex> binary_slice(\"elixir\", 0, 6)\n    \"elixir\"\n    iex> binary_slice(\"elixir\", 0, 5)\n    \"elixi\"\n    iex> binary_slice(\"elixir\", 1, 4)\n    \"lixi\"\n    iex> binary_slice(\"elixir\", 0, 10)\n    \"elixir\"\n\nIf `start` is negative, it is normalized against the binary\nsize and clamped to 0:\n\n    iex> binary_slice(\"elixir\", -3, 10)\n    \"xir\"\n    iex> binary_slice(\"elixir\", -10, 10)\n    \"elixir\"\n\nIf the `size` is zero, an empty binary is returned:\n\n    iex> binary_slice(\"elixir\", 1, 0)\n    \"\"\n\nIf `start` is greater than or equal to the binary size,\nan empty binary is returned:\n\n    iex> binary_slice(\"elixir\", 10, 10)\n    \"\"","ref":"Kernel.html#binary_slice/3-examples"},{"type":"macro","title":"Kernel.binding/1","doc":"Returns the binding for the given context as a keyword list.\n\nIn the returned result, keys are variable names and values are the\ncorresponding variable values.\n\nIf the given `context` is `nil` (by default it is), the binding for the\ncurrent context is returned.","ref":"Kernel.html#binding/1"},{"type":"macro","title":"Examples - Kernel.binding/1","doc":"iex> x = 1\n    iex> binding()\n    [x: 1]\n    iex> x = 2\n    iex> binding()\n    [x: 2]\n\n    iex> binding(:foo)\n    []\n    iex> var!(x, :foo) = 1\n    1\n    iex> binding(:foo)\n    [x: 1]","ref":"Kernel.html#binding/1-examples"},{"type":"function","title":"Kernel.bit_size/1","doc":"Returns an integer which is the size in bits of `bitstring`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#bit_size/1"},{"type":"function","title":"Examples - Kernel.bit_size/1","doc":"iex> bit_size(<<433::16, 3::3>>)\n    19\n\n    iex> bit_size(<<1, 2, 3>>)\n    24","ref":"Kernel.html#bit_size/1-examples"},{"type":"function","title":"Kernel.byte_size/1","doc":"Returns the number of bytes needed to contain `bitstring`.\n\nThat is, if the number of bits in `bitstring` is not divisible by 8, the\nresulting number of bytes will be rounded up (by excess). This operation\nhappens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#byte_size/1"},{"type":"function","title":"Examples - Kernel.byte_size/1","doc":"iex> byte_size(<<433::16, 3::3>>)\n    3\n\n    iex> byte_size(<<1, 2, 3>>)\n    3","ref":"Kernel.html#byte_size/1-examples"},{"type":"function","title":"Kernel.ceil/1","doc":"Returns the smallest integer greater than or equal to `number`.\n\nIf you want to perform ceil operation on other decimal places,\nuse `Float.ceil/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#ceil/1"},{"type":"function","title":"Examples - Kernel.ceil/1","doc":"iex> ceil(10)\n    10\n\n    iex> ceil(10.1)\n    11\n\n    iex> ceil(-10.1)\n    -10","ref":"Kernel.html#ceil/1-examples"},{"type":"macro","title":"Kernel.dbg/2","doc":"Debugs the given `code`.\n\n`dbg/2` can be used to debug the given `code` through a configurable debug function.\nIt returns the result of the given code.","ref":"Kernel.html#dbg/2"},{"type":"macro","title":"Examples - Kernel.dbg/2","doc":"Let's take this call to `dbg/2`:\n\n    dbg(Atom.to_string(:debugging))\n    #=> \"debugging\"\n\nIt returns the string `\"debugging\"`, which is the result of the `Atom.to_string/1` call.\nAdditionally, the call above prints:\n\n    [my_file.ex:10: MyMod.my_fun/0]\n    Atom.to_string(:debugging) #=> \"debugging\"\n\nThe default debugging function prints additional debugging info when dealing with\npipelines. It prints the values at every \"step\" of the pipeline.\n\n    \"Elixir is cool!\"\n    |> String.trim_trailing(\"!\")\n    |> String.split()\n    |> List.first()\n    |> dbg()\n    #=> \"Elixir\"\n\nThe code above prints:\n\n    [my_file.ex:10: MyMod.my_fun/0]\n    \"Elixir is cool!\" #=> \"Elixir is cool!\"\n    |> String.trim_trailing(\"!\") #=> \"Elixir is cool\"\n    |> String.split() #=> [\"Elixir\", \"is\", \"cool\"]\n    |> List.first() #=> \"Elixir\"\n\nWith no arguments, `dbg()` debugs information about the current binding. See `binding/1`.\n\n## `dbg` inside IEx\n\nYou can enable IEx to replace `dbg` with its `IEx.pry/0` backend by calling:\n\n    $ iex --dbg pry\n\nIn such cases, `dbg` will start a `pry` session where you can interact with\nthe imports, aliases, and variables of the current environment at the location\nof the `dbg` call.\n\nIf you call `dbg` at the end of a pipeline (using `|>`) within IEx, you are able\nto go through each step of the pipeline one by one by entering \"next\" (or \"n\").\n\nNote `dbg` only supports stepping for pipelines (in other words, it can only\nstep through the code it sees). For general stepping, you can set breakpoints\nusing `IEx.break!/4`.\n\nFor more information, [see IEx documentation](https://hexdocs.pm/iex/IEx.html#module-dbg-and-breakpoints).","ref":"Kernel.html#dbg/2-examples"},{"type":"macro","title":"Configuring the debug function - Kernel.dbg/2","doc":"One of the benefits of `dbg/2` is that its debugging logic is configurable,\nallowing tools to extend `dbg` with enhanced behaviour. This is done, for\nexample, by `IEx` which extends `dbg` with an interactive shell where you\ncan directly inspect and access values.\n\nThe debug function can be configured at compile time through the `:dbg_callback`\nkey of the `:elixir` application. The debug function must be a\n`{module, function, args}` tuple. The `function` function in `module` will be\ninvoked with three arguments *prepended* to `args`:\n\n  1. The AST of `code`\n  2. The AST of `options`\n  3. The `Macro.Env` environment of where `dbg/2` is invoked\n\nThe debug function is invoked at compile time and it must also return an AST.\nThe AST is expected to ultimately return the result of evaluating the debugged\nexpression.\n\nHere's a simple example:\n\n    defmodule MyMod do\n      def debug_fun(code, options, caller, device) do\n        quote do\n          result = unquote(code)\n          IO.inspect(unquote(device), result, label: unquote(Macro.to_string(code)))\n        end\n      end\n    end\n\nTo configure the debug function:\n\n    # In config/config.exs\n    config :elixir, :dbg_callback, {MyMod, :debug_fun, [:stdio]}","ref":"Kernel.html#dbg/2-configuring-the-debug-function"},{"type":"macro","title":"Default debug function - Kernel.dbg/2","doc":"By default, the debug function we use is `Macro.dbg/3`. It just prints\ninformation about the code to standard output and returns the value\nreturned by evaluating `code`. `options` are used to control how terms\nare inspected. They are the same options accepted by `inspect/2`.","ref":"Kernel.html#dbg/2-default-debug-function"},{"type":"macro","title":"Kernel.def/2","doc":"Defines a public function with the given name and body.","ref":"Kernel.html#def/2"},{"type":"macro","title":"Examples - Kernel.def/2","doc":"defmodule Foo do\n      def bar, do: :baz\n    end\n\n    Foo.bar()\n    #=> :baz\n\nA function that expects arguments can be defined as follows:\n\n    defmodule Foo do\n      def sum(a, b) do\n        a + b\n      end\n    end\n\nIn the example above, a `sum/2` function is defined; this function receives\ntwo arguments and returns their sum.","ref":"Kernel.html#def/2-examples"},{"type":"macro","title":"Default arguments - Kernel.def/2","doc":"`\\\\` is used to specify a default value for a parameter of a function. For\nexample:\n\n    defmodule MyMath do\n      def multiply_by(number, factor \\\\ 2) do\n        number * factor\n      end\n    end\n\n    MyMath.multiply_by(4, 3)\n    #=> 12\n\n    MyMath.multiply_by(4)\n    #=> 8\n\nThe compiler translates this into multiple functions with different arities,\nhere `MyMath.multiply_by/1` and `MyMath.multiply_by/2`, that represent cases when\narguments for parameters with default values are passed or not passed.\n\nWhen defining a function with default arguments as well as multiple\nexplicitly declared clauses, you must write a function head that declares the\ndefaults. For example:\n\n    defmodule MyString do\n      def join(string1, string2 \\\\ nil, separator \\\\ \" \")\n\n      def join(string1, nil, _separator) do\n        string1\n      end\n\n      def join(string1, string2, separator) do\n        string1 <> separator <> string2\n      end\n    end\n\nNote that `\\\\` can't be used with anonymous functions because they\ncan only have a sole arity.","ref":"Kernel.html#def/2-default-arguments"},{"type":"macro","title":"Keyword lists with default arguments - Kernel.def/2","doc":"Functions containing many arguments can benefit from using `Keyword`\nlists to group and pass attributes as a single value.\n\n    defmodule MyConfiguration do\n      @default_opts [storage: \"local\"]\n\n      def configure(resource, opts \\\\ []) do\n        opts = Keyword.merge(@default_opts, opts)\n        storage = opts[:storage]\n        # ...\n      end\n    end\n\nThe difference between using `Map` and `Keyword` to store many\narguments is `Keyword`'s keys:\n\n  * must be atoms\n  * can be given more than once\n  * ordered, as specified by the developer","ref":"Kernel.html#def/2-keyword-lists-with-default-arguments"},{"type":"macro","title":"Function names - Kernel.def/2","doc":"Function and variable names in Elixir must start with an underscore or a\nUnicode letter that is not in uppercase or titlecase. They may continue\nusing a sequence of Unicode letters, numbers, and underscores. They may\nend in `?` or `!`. Elixir's [Naming Conventions](naming-conventions.md)\nsuggest for function and variable names to be written in the `snake_case`\nformat.\n\n## `rescue`/`catch`/`after`/`else`\n\nFunction bodies support `rescue`, `catch`, `after`, and `else` as `try/1`\ndoes (known as \"implicit try\"). For example, the following two functions are equivalent:\n\n    def convert(number) do\n      try do\n        String.to_integer(number)\n      rescue\n        e in ArgumentError -> {:error, e.message}\n      end\n    end\n\n    def convert(number) do\n      String.to_integer(number)\n    rescue\n      e in ArgumentError -> {:error, e.message}\n    end","ref":"Kernel.html#def/2-function-names"},{"type":"macro","title":"Kernel.defdelegate/2","doc":"Defines a function that delegates to another module.\n\nFunctions defined with `defdelegate/2` are public and can be invoked from\noutside the module they're defined in, as if they were defined using `def/2`.\nTherefore, `defdelegate/2` is about extending the current module's public API.\nIf what you want is to invoke a function defined in another module without\nusing its full module name, then use `alias/2` to shorten the module name or use\n`import/2` to be able to invoke the function without the module name altogether.\n\nDelegation only works with functions; delegating macros is not supported.\n\nCheck `def/2` for rules on naming and default arguments.","ref":"Kernel.html#defdelegate/2"},{"type":"macro","title":"Options - Kernel.defdelegate/2","doc":"* `:to` - the module to dispatch to.\n\n  * `:as` - the function to call on the target given in `:to`.\n    This parameter is optional and defaults to the name being\n    delegated (`funs`).","ref":"Kernel.html#defdelegate/2-options"},{"type":"macro","title":"Examples - Kernel.defdelegate/2","doc":"defmodule MyList do\n      defdelegate reverse(list), to: Enum\n      defdelegate other_reverse(list), to: Enum, as: :reverse\n    end\n\n    MyList.reverse([1, 2, 3])\n    #=> [3, 2, 1]\n\n    MyList.other_reverse([1, 2, 3])\n    #=> [3, 2, 1]","ref":"Kernel.html#defdelegate/2-examples"},{"type":"macro","title":"Kernel.defexception/1","doc":"Defines an exception.\n\nExceptions are structs backed by a module that implements\nthe `Exception` behaviour. The `Exception` behaviour requires\ntwo functions to be implemented:\n\n  * [`exception/1`](`c:Exception.exception/1`) - receives the arguments given to `raise/2`\n    and returns the exception struct. The default implementation\n    accepts either a set of keyword arguments that is merged into\n    the struct or a string to be used as the exception's message.\n\n  * [`message/1`](`c:Exception.message/1`) - receives the exception struct and must return its\n    message. Most commonly exceptions have a message field which\n    by default is accessed by this function. However, if an exception\n    does not have a message field, this function must be explicitly\n    implemented.\n\nSince exceptions are structs, the API supported by `defstruct/1`\nis also available in `defexception/1`.","ref":"Kernel.html#defexception/1"},{"type":"macro","title":"Raising exceptions - Kernel.defexception/1","doc":"The most common way to raise an exception is via `raise/2`:\n\n    defmodule MyAppError do\n      defexception [:message]\n    end\n\n    value = [:hello]\n\n    raise MyAppError,\n      message: \"did not get what was expected, got: #{inspect(value)}\"\n\nIn many cases it is more convenient to pass the expected value to\n`raise/2` and generate the message in the `c:Exception.exception/1` callback:\n\n    defmodule MyAppError do\n      defexception [:message]\n\n      @impl true\n      def exception(value) do\n        msg = \"did not get what was expected, got: #{inspect(value)}\"\n        %MyAppError{message: msg}\n      end\n    end\n\n    raise MyAppError, value\n\nThe example above shows the preferred strategy for customizing\nexception messages.","ref":"Kernel.html#defexception/1-raising-exceptions"},{"type":"macro","title":"Kernel.defguard/1","doc":"Generates a macro suitable for use in guard expressions.\n\nIt raises at compile time if the definition uses expressions that aren't\nallowed in guards, and otherwise creates a macro that can be used both inside\nor outside guards.\n\nNote the convention in Elixir is to prefix all guards that return a boolean\nwith the `is_` prefix, such as `is_list/1`. If, however, the function/macro\nreturns a boolean and is not allowed in guards, it should have no prefix and\nend with a question mark, such as `Keyword.keyword?/1`.","ref":"Kernel.html#defguard/1"},{"type":"macro","title":"Example - Kernel.defguard/1","doc":"defmodule Integer.Guards do\n      defguard is_even(value) when is_integer(value) and rem(value, 2) == 0\n    end\n\n    defmodule Collatz do\n      @moduledoc \"Tools for working with the Collatz sequence.\"\n      import Integer.Guards\n\n      @doc \"Determines the number of steps `n` takes to reach `1`.\"\n      # If this function never converges, please let me know what `n` you used.\n      def converge(n) when n > 0, do: step(n, 0)\n\n      defp step(1, step_count) do\n        step_count\n      end\n\n      defp step(n, step_count) when is_even(n) do\n        step(div(n, 2), step_count + 1)\n      end\n\n      defp step(n, step_count) do\n        step(3 * n + 1, step_count + 1)\n      end\n    end","ref":"Kernel.html#defguard/1-example"},{"type":"macro","title":"Kernel.defguardp/1","doc":"Generates a private macro suitable for use in guard expressions.\n\nIt raises at compile time if the definition uses expressions that aren't\nallowed in guards, and otherwise creates a private macro that can be used\nboth inside or outside guards in the current module.\n\nSimilar to `defmacrop/2`, `defguardp/1` must be defined before its use\nin the current module.","ref":"Kernel.html#defguardp/1"},{"type":"macro","title":"Kernel.defimpl/3","doc":"Defines an implementation for the given protocol.\n\nSee the `Protocol` module for more information.","ref":"Kernel.html#defimpl/3"},{"type":"macro","title":"Kernel.defmacro/2","doc":"Defines a public macro with the given name and body.\n\nMacros must be defined before its usage.\n\nCheck `def/2` for rules on naming and default arguments.","ref":"Kernel.html#defmacro/2"},{"type":"macro","title":"Examples - Kernel.defmacro/2","doc":"defmodule MyLogic do\n      defmacro unless(expr, opts) do\n        quote do\n          if !unquote(expr), unquote(opts)\n        end\n      end\n    end\n\n    require MyLogic\n\n    MyLogic.unless false do\n      IO.puts(\"It works\")\n    end","ref":"Kernel.html#defmacro/2-examples"},{"type":"macro","title":"Kernel.defmacrop/2","doc":"Defines a private macro with the given name and body.\n\nPrivate macros are only accessible from the same module in which they are\ndefined.\n\nPrivate macros must be defined before its usage.\n\nCheck `defmacro/2` for more information, and check `def/2` for rules on\nnaming and default arguments.","ref":"Kernel.html#defmacrop/2"},{"type":"macro","title":"Kernel.defmodule/2","doc":"Defines a module given by name with the given contents.\n\nThis macro defines a module with the given `alias` as its name and with the\ngiven contents. It returns a tuple with four elements:\n\n  * `:module`\n  * the module name\n  * the binary contents of the module\n  * the result of evaluating the contents block","ref":"Kernel.html#defmodule/2"},{"type":"macro","title":"Examples - Kernel.defmodule/2","doc":"defmodule Number do\n      def one, do: 1\n      def two, do: 2\n    end\n    #=> {:module, Number, <<70, 79, 82, ...>>, {:two, 0}}\n\n    Number.one()\n    #=> 1\n\n    Number.two()\n    #=> 2","ref":"Kernel.html#defmodule/2-examples"},{"type":"macro","title":"Module names and aliases - Kernel.defmodule/2","doc":"Module names (and aliases) must start with an ASCII uppercase character which\nmay be followed by any ASCII letter, number, or underscore. Elixir's\n[Naming Conventions](naming-conventions.md) suggest for module names and aliases\nto be written in the `CamelCase` format.\n\nYou can also use atoms as the module name, although they must only contain ASCII\ncharacters.","ref":"Kernel.html#defmodule/2-module-names-and-aliases"},{"type":"macro","title":"Nesting - Kernel.defmodule/2","doc":"Nesting a module inside another module affects the name of the nested module:\n\n    defmodule Foo do\n      defmodule Bar do\n      end\n    end\n\nIn the example above, two modules - `Foo` and `Foo.Bar` - are created.\nWhen nesting, Elixir automatically creates an alias to the inner module,\nallowing the second module `Foo.Bar` to be accessed as `Bar` in the same\nlexical scope where it's defined (the `Foo` module). This only happens\nif the nested module is defined via an alias.\n\nIf the `Foo.Bar` module is moved somewhere else, the references to `Bar` in\nthe `Foo` module need to be updated to the fully-qualified name (`Foo.Bar`) or\nan alias has to be explicitly set in the `Foo` module with the help of\n`alias/2`.\n\n    defmodule Foo.Bar do\n      # code\n    end\n\n    defmodule Foo do\n      alias Foo.Bar\n      # code here can refer to \"Foo.Bar\" as just \"Bar\"\n    end","ref":"Kernel.html#defmodule/2-nesting"},{"type":"macro","title":"Dynamic names - Kernel.defmodule/2","doc":"Elixir module names can be dynamically generated. This is very\nuseful when working with macros. For instance, one could write:\n\n    defmodule Module.concat([\"Foo\", \"Bar\"]) do\n      # contents ...\n    end\n\nElixir will accept any module name as long as the expression passed as the\nfirst argument to `defmodule/2` evaluates to an atom.\nNote that, when a dynamic name is used, Elixir won't nest the name under\nthe current module nor automatically set up an alias.","ref":"Kernel.html#defmodule/2-dynamic-names"},{"type":"macro","title":"Reserved module names - Kernel.defmodule/2","doc":"If you attempt to define a module that already exists, you will get a\nwarning saying that a module has been redefined.\n\nThere are some modules that Elixir does not currently implement but it\nmay be implement in the future. Those modules are reserved and defining\nthem will result in a compilation error:\n\n    defmodule Any do\n      # code\n    end\n    ** (CompileError) iex:1: module Any is reserved and cannot be defined\n\nElixir reserves the following module names: `Elixir`, `Any`, `BitString`,\n`PID`, and `Reference`.","ref":"Kernel.html#defmodule/2-reserved-module-names"},{"type":"macro","title":"Kernel.defoverridable/1","doc":"Makes the given definitions in the current module overridable.\n\nIf the user defines a new function or macro with the same name\nand arity, then the overridable ones are discarded. Otherwise, the\noriginal definitions are used.\n\nIt is possible for the overridden definition to have a different visibility\nthan the original: a public function can be overridden by a private\nfunction and vice-versa.\n\nMacros cannot be overridden as functions and vice-versa.","ref":"Kernel.html#defoverridable/1"},{"type":"macro","title":"Example - Kernel.defoverridable/1","doc":"defmodule DefaultMod do\n      defmacro __using__(_opts) do\n        quote do\n          def test(x, y) do\n            x + y\n          end\n\n          defoverridable test: 2\n        end\n      end\n    end\n\n    defmodule ChildMod do\n      use DefaultMod\n\n      def test(x, y) do\n        x * y + super(x, y)\n      end\n    end\n\nAs seen as in the example above, `super` can be used to call the default\nimplementation.\n\n> #### Disclaimer {: .tip}\n>\n> Use `defoverridable` with care. If you need to define multiple modules\n> with the same behaviour, it may be best to move the default implementation\n> to the caller, and check if a callback exists via `Code.ensure_loaded?/1` and\n> `function_exported?/3`.\n>\n> For example, in the example above, imagine there is a module that calls the\n> `test/2` function. This module could be defined as such:\n>\n>     defmodule CallsTest do\n>       def receives_module_and_calls_test(module, x, y) do\n>         if Code.ensure_loaded?(module) and function_exported?(module, :test, 2) do\n>           module.test(x, y)\n>         else\n>           x + y\n>         end\n>       end\n>     end","ref":"Kernel.html#defoverridable/1-example"},{"type":"macro","title":"Example with behaviour - Kernel.defoverridable/1","doc":"You can also pass a behaviour to `defoverridable` and it will mark all of the\ncallbacks in the behaviour as overridable:\n\n\n    defmodule Behaviour do\n      @callback test(number(), number()) :: number()\n    end\n\n    defmodule DefaultMod do\n      defmacro __using__(_opts) do\n        quote do\n          @behaviour Behaviour\n\n          def test(x, y) do\n            x + y\n          end\n\n          defoverridable Behaviour\n        end\n      end\n    end\n\n    defmodule ChildMod do\n      use DefaultMod\n\n      def test(x, y) do\n        x * y + super(x, y)\n      end\n    end","ref":"Kernel.html#defoverridable/1-example-with-behaviour"},{"type":"macro","title":"Kernel.defp/2","doc":"Defines a private function with the given name and body.\n\nPrivate functions are only accessible from within the module in which they are\ndefined. Trying to access a private function from outside the module it's\ndefined in results in an `UndefinedFunctionError` exception.\n\nCheck `def/2` for more information.","ref":"Kernel.html#defp/2"},{"type":"macro","title":"Examples - Kernel.defp/2","doc":"defmodule Foo do\n      def bar do\n        sum(1, 2)\n      end\n\n      defp sum(a, b), do: a + b\n    end\n\n    Foo.bar()\n    #=> 3\n\n    Foo.sum(1, 2)\n    ** (UndefinedFunctionError) undefined function Foo.sum/2","ref":"Kernel.html#defp/2-examples"},{"type":"macro","title":"Kernel.defprotocol/2","doc":"Defines a protocol.\n\nSee the `Protocol` module for more information.","ref":"Kernel.html#defprotocol/2"},{"type":"macro","title":"Kernel.defstruct/1","doc":"Defines a struct.\n\nA struct is a tagged map that allows developers to provide\ndefault values for keys, tags to be used in polymorphic\ndispatches and compile time assertions. For more information\nabout structs, please check `%/2`.\n\nIt is only possible to define a struct per module, as the\nstruct is tied to the module itself. Calling `defstruct/1`\nalso defines a `__struct__/0` function that returns the\nstruct itself.","ref":"Kernel.html#defstruct/1"},{"type":"macro","title":"Examples - Kernel.defstruct/1","doc":"defmodule User do\n      defstruct name: nil, age: nil\n    end\n\nStruct fields are evaluated at compile-time, which allows\nthem to be dynamic. In the example below, `10 + 11` is\nevaluated at compile-time and the age field is stored\nwith value `21`:\n\n    defmodule User do\n      defstruct name: nil, age: 10 + 11\n    end\n\nThe `fields` argument is usually a keyword list with field names\nas atom keys and default values as corresponding values. `defstruct/1`\nalso supports a list of atoms as its argument: in that case, the atoms\nin the list will be used as the struct's field names and they will all\ndefault to `nil`.\n\n    defmodule Post do\n      defstruct [:title, :content, :author]\n    end\n\nAdd documentation to a struct with the `@doc` attribute, like a function.\n\n    defmodule Post do\n      @doc \"A post. The content should be valid Markdown.\"\n      defstruct [:title, :content, :author]\n    end","ref":"Kernel.html#defstruct/1-examples"},{"type":"macro","title":"Deriving - Kernel.defstruct/1","doc":"Although structs are maps, by default structs do not implement\nany of the protocols implemented for maps. For example, attempting\nto use a protocol with the `User` struct leads to an error:\n\n    john = %User{name: \"John\"}\n    MyProtocol.call(john)\n    ** (Protocol.UndefinedError) protocol MyProtocol not implemented for %User{...}\n\n`defstruct/1`, however, allows protocol implementations to be\n*derived*. This can be done by defining a `@derive` attribute as a\nlist before invoking `defstruct/1`:\n\n    defmodule User do\n      @derive MyProtocol\n      defstruct name: nil, age: nil\n    end\n\n    MyProtocol.call(john) # it works!\n\nA common example is to `@derive` the `Inspect` protocol to hide certain fields\nwhen the struct is printed:\n\n    defmodule User do\n      @derive {Inspect, only: :name}\n      defstruct name: nil, age: nil\n    end\n\nFor each protocol in `@derive`, Elixir will assert the protocol has\nbeen implemented for `Any`. If the `Any` implementation defines a\n`__deriving__/3` callback, the callback will be invoked and it should define\nthe implementation module. Otherwise an implementation that simply points to\nthe `Any` implementation is automatically derived. For more information on\nthe `__deriving__/3` callback, see `Protocol.derive/3`.","ref":"Kernel.html#defstruct/1-deriving"},{"type":"macro","title":"Enforcing keys - Kernel.defstruct/1","doc":"When building a struct, Elixir will automatically guarantee all keys\nbelong to the struct:\n\n    %User{name: \"john\", unknown: :key}\n    ** (KeyError) key :unknown not found in: %User{age: 21, name: nil}\n\nElixir also allows developers to enforce that certain keys must always be\ngiven when building the struct:\n\n    defmodule User do\n      @enforce_keys [:name]\n      defstruct name: nil, age: 10 + 11\n    end\n\nNow trying to build a struct without the name key will fail:\n\n    %User{age: 21}\n    ** (ArgumentError) the following keys must also be given when building struct User: [:name]\n\nKeep in mind `@enforce_keys` is a simple compile-time guarantee\nto aid developers when building structs. It is not enforced on\nupdates and it does not provide any sort of value-validation.","ref":"Kernel.html#defstruct/1-enforcing-keys"},{"type":"macro","title":"Types - Kernel.defstruct/1","doc":"It is recommended to define types for structs. By convention, such a type\nis called `t`. To define a struct inside a type, the struct literal syntax\nis used:\n\n    defmodule User do\n      defstruct name: \"John\", age: 25\n      @type t :: %__MODULE__{name: String.t(), age: non_neg_integer}\n    end\n\nIt is recommended to only use the struct syntax when defining the struct's\ntype. When referring to another struct, it's better to use `User.t()` instead of\n`%User{}`.\n\nThe types of the struct fields that are not included in `%User{}` default to\n`term()` (see `t:term/0`).\n\nStructs whose internal structure is private to the local module (pattern\nmatching them or directly accessing their fields should not be allowed) should\nuse the `@opaque` attribute. Structs whose internal structure is public should\nuse `@type`.","ref":"Kernel.html#defstruct/1-types"},{"type":"macro","title":"Kernel.destructure/2","doc":"Destructures two lists, assigning each term in the\nright one to the matching term in the left one.\n\nUnlike pattern matching via `=`, if the sizes of the left\nand right lists don't match, destructuring simply stops\ninstead of raising an error.","ref":"Kernel.html#destructure/2"},{"type":"macro","title":"Examples - Kernel.destructure/2","doc":"iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n    iex> {x, y, z}\n    {1, 2, 3}\n\nIn the example above, even though the right list has more entries than the\nleft one, destructuring works fine. If the right list is smaller, the\nremaining elements are simply set to `nil`:\n\n    iex> destructure([x, y, z], [1])\n    iex> {x, y, z}\n    {1, nil, nil}\n\nThe left-hand side supports any expression you would use\non the left-hand side of a match:\n\n    x = 1\n    destructure([^x, y, z], [1, 2, 3])\n\nThe example above will only work if `x` matches the first value in the right\nlist. Otherwise, it will raise a `MatchError` (like the `=` operator would\ndo).","ref":"Kernel.html#destructure/2-examples"},{"type":"function","title":"Kernel.div/2","doc":"Performs an integer division.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\n`div/2` performs *truncated* integer division. This means that\nthe result is always rounded towards zero.\n\nIf you want to perform floored integer division (rounding towards negative infinity),\nuse `Integer.floor_div/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#div/2"},{"type":"function","title":"Examples - Kernel.div/2","doc":"div(5, 2)\n    #=> 2\n\n    div(6, -4)\n    #=> -1\n\n    div(-99, 2)\n    #=> -49\n\n    div(100, 0)\n    ** (ArithmeticError) bad argument in arithmetic expression","ref":"Kernel.html#div/2-examples"},{"type":"function","title":"Kernel.elem/2","doc":"Gets the element at the zero-based `index` in `tuple`.\n\nIt raises `ArgumentError` when index is negative or it is out of range of the tuple elements.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#elem/2"},{"type":"function","title":"Examples - Kernel.elem/2","doc":"tuple = {:foo, :bar, 3}\n    elem(tuple, 1)\n    #=> :bar\n\n    elem({}, 0)\n    ** (ArgumentError) argument error\n\n    elem({:foo, :bar}, 2)\n    ** (ArgumentError) argument error","ref":"Kernel.html#elem/2-examples"},{"type":"function","title":"Kernel.exit/1","doc":"Stops the execution of the calling process with the given reason.\n\nSince evaluating this function causes the process to terminate,\nit has no return value.\n\nInlined by the compiler.","ref":"Kernel.html#exit/1"},{"type":"function","title":"Examples - Kernel.exit/1","doc":"When a process reaches its end, by default it exits with\nreason `:normal`. You can also call `exit/1` explicitly if you\nwant to terminate a process but not signal any failure:\n\n    exit(:normal)\n\nIn case something goes wrong, you can also use `exit/1` with\na different reason:\n\n    exit(:seems_bad)\n\nIf the exit reason is not `:normal`, all the processes linked to the process\nthat exited will crash (unless they are trapping exits).","ref":"Kernel.html#exit/1-examples"},{"type":"function","title":"OTP exits - Kernel.exit/1","doc":"Exits are used by the OTP to determine if a process exited abnormally\nor not. The following exits are considered \"normal\":\n\n  * `exit(:normal)`\n  * `exit(:shutdown)`\n  * `exit({:shutdown, term})`\n\nExiting with any other reason is considered abnormal and treated\nas a crash. This means the default supervisor behavior kicks in,\nerror reports are emitted, and so forth.\n\nThis behavior is relied on in many different places. For example,\n`ExUnit` uses `exit(:shutdown)` when exiting the test process to\nsignal linked processes, supervision trees and so on to politely\nshut down too.","ref":"Kernel.html#exit/1-otp-exits"},{"type":"function","title":"CLI exits - Kernel.exit/1","doc":"Building on top of the exit signals mentioned above, if the\nprocess started by the command line exits with any of the three\nreasons above, its exit is considered normal and the Operating\nSystem process will exit with status 0.\n\nIt is, however, possible to customize the operating system exit\nsignal by invoking:\n\n    exit({:shutdown, integer})\n\nThis will cause the operating system process to exit with the status given by\n`integer` while signaling all linked Erlang processes to politely\nshut down.\n\nAny other exit reason will cause the operating system process to exit with\nstatus `1` and linked Erlang processes to crash.","ref":"Kernel.html#exit/1-cli-exits"},{"type":"function","title":"Kernel.floor/1","doc":"Returns the largest integer smaller than or equal to `number`.\n\nIf you want to perform floor operation on other decimal places,\nuse `Float.floor/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#floor/1"},{"type":"function","title":"Examples - Kernel.floor/1","doc":"iex> floor(10)\n    10\n\n    iex> floor(9.7)\n    9\n\n    iex> floor(-9.7)\n    -10","ref":"Kernel.html#floor/1-examples"},{"type":"function","title":"Kernel.function_exported?/3","doc":"Returns `true` if `module` is loaded and contains a\npublic `function` with the given `arity`, otherwise `false`.\n\nNote that this function does not load the module in case\nit is not loaded. Check `Code.ensure_loaded/1` for more\ninformation.\n\nInlined by the compiler.","ref":"Kernel.html#function_exported?/3"},{"type":"function","title":"Examples - Kernel.function_exported?/3","doc":"iex> function_exported?(Enum, :map, 2)\n    true\n\n    iex> function_exported?(Enum, :map, 10)\n    false\n\n    iex> function_exported?(List, :to_string, 1)\n    true","ref":"Kernel.html#function_exported?/3-examples"},{"type":"macro","title":"Kernel.get_and_update_in/2","doc":"Gets a value and updates a nested data structure via the given `path`.\n\nThis is similar to `get_and_update_in/3`, except the path is extracted\nvia a macro rather than passing a list. For example:\n\n    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n\nIs equivalent to:\n\n    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n\nThis also works with nested structs and the `struct.path.to.value` way to specify\npaths:\n\n    get_and_update_in(struct.foo.bar, &{&1, &1 + 1})\n\nNote that in order for this macro to work, the complete path must always\nbe visible by this macro. See the \"Paths\" section below.","ref":"Kernel.html#get_and_update_in/2"},{"type":"macro","title":"Examples - Kernel.get_and_update_in/2","doc":"iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}","ref":"Kernel.html#get_and_update_in/2-examples"},{"type":"macro","title":"Paths - Kernel.get_and_update_in/2","doc":"A path may start with a variable, local or remote call, and must be\nfollowed by one or more:\n\n  * `foo[bar]` - accesses the key `bar` in `foo`; in case `foo` is nil,\n    `nil` is returned\n\n  * `foo.bar` - accesses a map/struct field; in case the field is not\n    present, an error is raised\n\nHere are some valid paths:\n\n    users[\"john\"][:age]\n    users[\"john\"].age\n    User.all()[\"john\"].age\n    all_users()[\"john\"].age\n\nHere are some invalid ones:\n\n    # Does a remote call after the initial value\n    users[\"john\"].do_something(arg1, arg2)\n\n    # Does not access any key or field\n    users","ref":"Kernel.html#get_and_update_in/2-paths"},{"type":"function","title":"Kernel.get_and_update_in/3","doc":"Gets a value and updates a nested structure.\n\n`data` is a nested structure (that is, a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nThe `fun` argument receives the value of `key` (or `nil` if `key`\nis not present) and must return one of the following values:\n\n  * a two-element tuple `{current_value, new_value}`. In this case,\n    `current_value` is the retrieved value which can possibly be operated on before\n    being returned. `new_value` is the new value to be stored under `key`.\n\n  * `:pop`, which implies that the current value under `key`\n    should be removed from the structure and returned.\n\nThis function uses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a function,\nwhich is detailed in a later section.","ref":"Kernel.html#get_and_update_in/3"},{"type":"function","title":"Examples - Kernel.get_and_update_in/3","doc":"This function is useful when there is a need to retrieve the current\nvalue (or something calculated in function of the current value) and\nupdate it at the same time. For example, it could be used to read the\ncurrent age of a user while increasing it by one in one pass:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n\nNote the current value given to the anonymous function may be `nil`.\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users, [\"jane\", :age], &{&1, &1 + 1})\n    ** (ArgumentError) could not put/update key :age on a nil value","ref":"Kernel.html#get_and_update_in/3-examples"},{"type":"function","title":"Functions as keys - Kernel.get_and_update_in/3","doc":"If a key is a function, the function will be invoked passing three\narguments:\n\n  * the operation (`:get_and_update`)\n  * the data to be accessed\n  * a function to be invoked next\n\nThis means `get_and_update_in/3` can be extended to provide custom\nlookups. The downside is that functions cannot be stored as keys\nin the accessed data structures.\n\nWhen one of the keys is a function, the function is invoked.\nIn the example below, we use a function to get and increment all\nages inside a list:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> all = fn :get_and_update, data, next ->\n    ...>   data |> Enum.map(next) |> Enum.unzip()\n    ...> end\n    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n\nIf the previous value before invoking the function is `nil`,\nthe function *will* receive `nil` as a value and must handle it\naccordingly (be it by failing or providing a sane default).\n\nThe `Access` module ships with many convenience accessor functions,\nlike the `all` anonymous function defined above. See `Access.all/0`,\n`Access.key/2`, and others as examples.","ref":"Kernel.html#get_and_update_in/3-functions-as-keys"},{"type":"macro","title":"Kernel.get_in/1","doc":"Gets a key from the nested structure via the given `path`, with\nnil-safe handling.\n\nThis is similar to `get_in/2`, except the path is extracted via\na macro rather than passing a list. For example:\n\n    get_in(opts[:foo][:bar])\n\nIs equivalent to:\n\n    get_in(opts, [:foo, :bar])\n\nAdditionally, this macro can traverse structs:\n\n    get_in(struct.foo.bar)\n\nIn case any of the keys returns `nil`, then `nil` will be returned\nand `get_in/1` won't traverse any further.\n\nNote that in order for this macro to work, the complete path must always\nbe visible by this macro. For more information about the supported path\nexpressions, please check `get_and_update_in/2` docs.","ref":"Kernel.html#get_in/1"},{"type":"macro","title":"Examples - Kernel.get_in/1","doc":"iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users[\"john\"].age)\n    27\n    iex> get_in(users[\"unknown\"].age)\n    nil","ref":"Kernel.html#get_in/1-examples"},{"type":"function","title":"Kernel.get_in/2","doc":"Gets a value from a nested structure with nil-safe handling.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction, which is detailed in a later section.","ref":"Kernel.html#get_in/2"},{"type":"function","title":"Examples - Kernel.get_in/2","doc":"iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users, [\"john\", :age])\n    27\n    iex> # Equivalent to:\n    iex> users[\"john\"][:age]\n    27\n\n`get_in/2` can also use the accessors in the `Access` module\nto traverse more complex data structures. For example, here we\nuse `Access.all/0` to traverse a list:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> get_in(users, [Access.all(), :age])\n    [27, 23]\n\nIn case any of the components returns `nil`, `nil` will be returned\nand `get_in/2` won't traverse any further:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users, [\"unknown\", :age])\n    nil\n    iex> # Equivalent to:\n    iex> users[\"unknown\"][:age]\n    nil","ref":"Kernel.html#get_in/2-examples"},{"type":"function","title":"Functions as keys - Kernel.get_in/2","doc":"If a key given to `get_in/2` is a function, the function will be invoked\npassing three arguments:\n\n  * the operation (`:get`)\n  * the data to be accessed\n  * a function to be invoked next\n\nThis means `get_in/2` can be extended to provide custom lookups.\nThat's precisely how the `Access.all/0` key in the previous section\nbehaves. For example, we can manually implement such traversal as\nfollows:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> all = fn :get, data, next -> Enum.map(data, next) end\n    iex> get_in(users, [all, :age])\n    [27, 23]\n\nThe `Access` module ships with many convenience accessor functions.\nSee `Access.all/0`, `Access.key/2`, and others as examples.","ref":"Kernel.html#get_in/2-functions-as-keys"},{"type":"function","title":"Working with structs - Kernel.get_in/2","doc":"By default, structs do not implement the `Access` behaviour required\nby this function. Therefore, you can't do this:\n\n    get_in(some_struct, [:some_key, :nested_key])\n\nThere are two alternatives. Given structs have predefined keys,\nwe can use the `struct.field` notation:\n\n    some_struct.some_key.nested_key\n\nHowever, the code above will fail if any of the values return `nil`.\nIf you also want to handle nil values, you can use `get_in/1`:\n\n    get_in(some_struct.some_key.nested_key)\n\nPattern-matching is another option for handling such cases,\nwhich can be especially useful if you want to match on several\nfields at once or provide custom return values:\n\n    case some_struct do\n      %{some_key: %{nested_key: value}} -> value\n      %{} -> nil\n    end","ref":"Kernel.html#get_in/2-working-with-structs"},{"type":"function","title":"Kernel.hd/1","doc":"Returns the head of a list. Raises `ArgumentError` if the list is empty.\n\nThe head of a list is its first element.\n\nIt works with improper lists.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#hd/1"},{"type":"function","title":"Examples - Kernel.hd/1","doc":"hd([1, 2, 3, 4])\n    #=> 1\n\n    hd([1 | 2])\n    #=> 1\n\nGiving it an empty list raises:\n\n    hd([])\n    ** (ArgumentError) argument error","ref":"Kernel.html#hd/1-examples"},{"type":"macro","title":"Kernel.if/2","doc":"Provides an `if/2` macro.\n\nThis macro expects the first argument to be a condition and the second\nargument to be a keyword list. Generally speaking, Elixir developers\nprefer to use pattern matching and guards in function definitions and\n`case/2`, as they are succinct and precise. However, not all conditions\ncan be expressed through patterns and guards, which makes `if/2` a viable\nalternative.\n\nSimilar to `case/2`, any assignment in the condition will be available\non both clauses, as well as after the `if` expression.","ref":"Kernel.html#if/2"},{"type":"macro","title":"One-liner examples - Kernel.if/2","doc":"if(foo, do: bar)\n\nIn the example above, `bar` will be returned if `foo` evaluates to\na truthy value (neither `false` nor `nil`). Otherwise, `nil` will be\nreturned.\n\nAn `else` option can be given to specify the opposite:\n\n    if(foo, do: bar, else: baz)","ref":"Kernel.html#if/2-one-liner-examples"},{"type":"macro","title":"Blocks examples - Kernel.if/2","doc":"It's also possible to pass a block to the `if/2` macro. The first\nexample above would be translated to:\n\n    if foo do\n      bar\n    end\n\nNote that `do`-`end` become delimiters. The second example would\ntranslate to:\n\n    if foo do\n      bar\n    else\n      baz\n    end\n\nIf you find yourself nesting conditionals inside conditionals,\nconsider using `cond/1`.","ref":"Kernel.html#if/2-blocks-examples"},{"type":"macro","title":"Kernel.in/2","doc":"Membership operator.\n\nChecks if the element on the left-hand side is a member of the\ncollection on the right-hand side.","ref":"Kernel.html#in/2"},{"type":"macro","title":"Examples - Kernel.in/2","doc":"iex> x = 1\n    iex> x in [1, 2, 3]\n    true\n\nThis operator (which is a macro) simply translates to a call to\n`Enum.member?/2`. The example above would translate to:\n\n    Enum.member?([1, 2, 3], x)\n\nElixir also supports `left not in right`, which evaluates to\n`not(left in right)`:\n\n    iex> x = 1\n    iex> x not in [1, 2, 3]\n    false","ref":"Kernel.html#in/2-examples"},{"type":"macro","title":"Guards - Kernel.in/2","doc":"The `in/2` operator (as well as `not in`) can be used in guard clauses as\nlong as the right-hand side is a range or a list.\n\nIf the right-hand side is a list, Elixir will expand the operator to a valid\nguard expression which needs to check each value. For example:\n\n    when x in [1, 2, 3]\n\ntranslates to:\n\n    when x === 1 or x === 2 or x === 3\n\nHowever, this construct will be inefficient for large lists. In such cases, it\nis best to stop using guards and use a more appropriate data structure, such\nas `MapSet`.\n\nIf the right-hand side is a range, a more efficient comparison check will be\ndone. For example:\n\n    when x in 1..1000\n\ntranslates roughly to:\n\n    when x >= 1 and x <= 1000","ref":"Kernel.html#in/2-guards"},{"type":"macro","title":"AST considerations - Kernel.in/2","doc":"`left not in right` is parsed by the compiler into the AST:\n\n    {:not, _, [{:in, _, [left, right]}]}\n\nThis is the same AST as `not(left in right)`.\n\nAdditionally, `Macro.to_string/2` and `Code.format_string!/2`\nwill translate all occurrences of this AST to `left not in right`.","ref":"Kernel.html#in/2-ast-considerations"},{"type":"function","title":"Kernel.inspect/2","doc":"Inspects the given argument according to the `Inspect` protocol.\nThe second argument is a keyword list with options to control\ninspection.","ref":"Kernel.html#inspect/2"},{"type":"function","title":"Options - Kernel.inspect/2","doc":"`inspect/2` accepts a list of options that are internally\ntranslated to an `Inspect.Opts` struct. Check the docs for\n`Inspect.Opts` to see the supported options.","ref":"Kernel.html#inspect/2-options"},{"type":"function","title":"Examples - Kernel.inspect/2","doc":"iex> inspect(:foo)\n    \":foo\"\n\n    iex> inspect([1, 2, 3, 4, 5], limit: 3)\n    \"[1, 2, 3, ...]\"\n\n    iex> inspect([1, 2, 3], pretty: true, width: 0)\n    \"[1,\\n 2,\\n 3]\"\n\n    iex> inspect(\"olá\" <> <<0>>)\n    \"<<111, 108, 195, 161, 0>>\"\n\n    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n    \"\\\"olá\\\\0\\\"\"\n\n    iex> inspect(\"olá\", binaries: :as_binaries)\n    \"<<111, 108, 195, 161>>\"\n\n    iex> inspect(~c\"bar\")\n    \"~c\\\"bar\\\"\"\n\n    iex> inspect([0 | ~c\"bar\"])\n    \"[0, 98, 97, 114]\"\n\n    iex> inspect(100, base: :octal)\n    \"0o144\"\n\n    iex> inspect(100, base: :hex)\n    \"0x64\"\n\nNote that the `Inspect` protocol does not necessarily return a valid\nrepresentation of an Elixir term. In such cases, the inspected result\nmust start with `#`. For example, inspecting a function will return:\n\n    inspect(fn a, b -> a + b end)\n    #=> #Function<...>\n\nThe `Inspect` protocol can be derived to hide certain fields\nfrom structs, so they don't show up in logs, inspects and similar.\nSee the \"Deriving\" section of the documentation of the `Inspect`\nprotocol for more information.","ref":"Kernel.html#inspect/2-examples"},{"type":"function","title":"Kernel.is_atom/1","doc":"Returns `true` if `term` is an atom, otherwise returns `false`.\n\nNote `true`, `false`, and `nil` are atoms in Elixir, as well as\nmodule names. Therefore this function will return `true` to all\nof those values.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_atom/1"},{"type":"function","title":"Examples - Kernel.is_atom/1","doc":"iex> is_atom(:name)\n    true\n\n    iex> is_atom(false)\n    true\n\n    iex> is_atom(AnAtom)\n    true\n\n    iex> is_atom(\"string\")\n    false","ref":"Kernel.html#is_atom/1-examples"},{"type":"function","title":"Kernel.is_binary/1","doc":"Returns `true` if `term` is a binary, otherwise returns `false`.\n\nA binary always contains a complete number of bytes.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_binary/1"},{"type":"function","title":"Examples - Kernel.is_binary/1","doc":"iex> is_binary(\"foo\")\n    true\n    iex> is_binary(<<1::3>>)\n    false","ref":"Kernel.html#is_binary/1-examples"},{"type":"function","title":"Kernel.is_bitstring/1","doc":"Returns `true` if `term` is a bitstring (including a binary), otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_bitstring/1"},{"type":"function","title":"Examples - Kernel.is_bitstring/1","doc":"iex> is_bitstring(\"foo\")\n    true\n    iex> is_bitstring(<<1::3>>)\n    true","ref":"Kernel.html#is_bitstring/1-examples"},{"type":"function","title":"Kernel.is_boolean/1","doc":"Returns `true` if `term` is either the atom `true` or the atom `false` (i.e.,\na boolean), otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_boolean/1"},{"type":"function","title":"Examples - Kernel.is_boolean/1","doc":"iex> is_boolean(false)\n    true\n\n    iex> is_boolean(true)\n    true\n\n    iex> is_boolean(:test)\n    false","ref":"Kernel.html#is_boolean/1-examples"},{"type":"macro","title":"Kernel.is_exception/1","doc":"Returns `true` if `term` is an exception, otherwise returns `false`.\n\nAllowed in guard tests.","ref":"Kernel.html#is_exception/1"},{"type":"macro","title":"Examples - Kernel.is_exception/1","doc":"iex> is_exception(%RuntimeError{})\n    true\n\n    iex> is_exception(%{})\n    false","ref":"Kernel.html#is_exception/1-examples"},{"type":"macro","title":"Kernel.is_exception/2","doc":"Returns `true` if `term` is an exception of `name`, otherwise returns `false`.\n\nAllowed in guard tests.","ref":"Kernel.html#is_exception/2"},{"type":"macro","title":"Examples - Kernel.is_exception/2","doc":"iex> is_exception(%RuntimeError{}, RuntimeError)\n    true\n\n    iex> is_exception(%RuntimeError{}, Macro.Env)\n    false","ref":"Kernel.html#is_exception/2-examples"},{"type":"function","title":"Kernel.is_float/1","doc":"Returns `true` if `term` is a floating-point number, otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_float/1"},{"type":"function","title":"Kernel.is_function/1","doc":"Returns `true` if `term` is a function, otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_function/1"},{"type":"function","title":"Examples - Kernel.is_function/1","doc":"iex> is_function(fn x -> x + x end)\n    true\n\n    iex> is_function(\"not a function\")\n    false","ref":"Kernel.html#is_function/1-examples"},{"type":"function","title":"Kernel.is_function/2","doc":"Returns `true` if `term` is a function that can be applied with `arity` number of arguments;\notherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_function/2"},{"type":"function","title":"Examples - Kernel.is_function/2","doc":"iex> is_function(fn x -> x * 2 end, 1)\n    true\n    iex> is_function(fn x -> x * 2 end, 2)\n    false","ref":"Kernel.html#is_function/2-examples"},{"type":"function","title":"Kernel.is_integer/1","doc":"Returns `true` if `term` is an integer, otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_integer/1"},{"type":"function","title":"Kernel.is_list/1","doc":"Returns `true` if `term` is a list with zero or more elements, otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_list/1"},{"type":"function","title":"Kernel.is_map/1","doc":"Returns `true` if `term` is a map, otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n> #### Structs are maps {: .info}\n>\n> Structs are also maps, and many of Elixir data structures are implemented\n> using structs: `Range`s, `Regex`es, `Date`s...\n>\n>     iex> is_map(1..10)\n>     true\n>     iex> is_map(~D[2024-04-18])\n>     true\n>\n> If you mean to specifically check for non-struct maps, use\n> `is_non_struct_map/1` instead.\n>\n>     iex> is_non_struct_map(1..10)\n>     false","ref":"Kernel.html#is_map/1"},{"type":"function","title":"Kernel.is_map_key/2","doc":"Returns `true` if `key` is a key in `map`, otherwise returns `false`.\n\nIt raises `BadMapError` if the first element is not a map.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_map_key/2"},{"type":"function","title":"Examples - Kernel.is_map_key/2","doc":"iex> is_map_key(%{a: \"foo\", b: \"bar\"}, :a)\n    true\n\n    iex> is_map_key(%{a: \"foo\", b: \"bar\"}, :c)\n    false","ref":"Kernel.html#is_map_key/2-examples"},{"type":"macro","title":"Kernel.is_nil/1","doc":"Returns `true` if `term` is `nil`, `false` otherwise.\n\nAllowed in guard clauses.","ref":"Kernel.html#is_nil/1"},{"type":"macro","title":"Examples - Kernel.is_nil/1","doc":"iex> is_nil(1)\n    false\n\n    iex> is_nil(nil)\n    true","ref":"Kernel.html#is_nil/1-examples"},{"type":"macro","title":"Kernel.is_non_struct_map/1","doc":"Returns `true` if `term` is a map that is not a struct, otherwise\nreturns `false`.\n\nAllowed in guard tests.","ref":"Kernel.html#is_non_struct_map/1"},{"type":"macro","title":"Examples - Kernel.is_non_struct_map/1","doc":"iex> is_non_struct_map(%{})\n    true\n\n    iex> is_non_struct_map(URI.parse(\"/\"))\n    false\n\n    iex> is_non_struct_map(nil)\n    false","ref":"Kernel.html#is_non_struct_map/1-examples"},{"type":"function","title":"Kernel.is_number/1","doc":"Returns `true` if `term` is either an integer or a floating-point number;\notherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_number/1"},{"type":"function","title":"Kernel.is_pid/1","doc":"Returns `true` if `term` is a PID (process identifier), otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_pid/1"},{"type":"function","title":"Kernel.is_port/1","doc":"Returns `true` if `term` is a port identifier, otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_port/1"},{"type":"function","title":"Kernel.is_reference/1","doc":"Returns `true` if `term` is a reference, otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_reference/1"},{"type":"macro","title":"Kernel.is_struct/1","doc":"Returns `true` if `term` is a struct, otherwise returns `false`.\n\nAllowed in guard tests.","ref":"Kernel.html#is_struct/1"},{"type":"macro","title":"Examples - Kernel.is_struct/1","doc":"iex> is_struct(URI.parse(\"/\"))\n    true\n\n    iex> is_struct(%{})\n    false","ref":"Kernel.html#is_struct/1-examples"},{"type":"macro","title":"Kernel.is_struct/2","doc":"Returns `true` if `term` is a struct of `name`, otherwise returns `false`.\n\n`is_struct/2` does not check that `name` exists and is a valid struct.\nIf you want such validations, you must pattern match on the struct\ninstead, such as `match?(%URI{}, arg)`.\n\nAllowed in guard tests.","ref":"Kernel.html#is_struct/2"},{"type":"macro","title":"Examples - Kernel.is_struct/2","doc":"iex> is_struct(URI.parse(\"/\"), URI)\n    true\n\n    iex> is_struct(URI.parse(\"/\"), Macro.Env)\n    false","ref":"Kernel.html#is_struct/2-examples"},{"type":"function","title":"Kernel.is_tuple/1","doc":"Returns `true` if `term` is a tuple, otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_tuple/1"},{"type":"function","title":"Kernel.length/1","doc":"Returns the length of `list`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#length/1"},{"type":"function","title":"Examples - Kernel.length/1","doc":"iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    9","ref":"Kernel.html#length/1-examples"},{"type":"function","title":"Kernel.macro_exported?/3","doc":"Returns `true` if `module` is loaded and contains a\npublic `macro` with the given `arity`, otherwise `false`.\n\nNote that this function does not load the module in case\nit is not loaded. Check `Code.ensure_loaded/1` for more\ninformation.\n\nIf `module` is an Erlang module (as opposed to an Elixir module), this\nfunction always returns `false`.","ref":"Kernel.html#macro_exported?/3"},{"type":"function","title":"Examples - Kernel.macro_exported?/3","doc":"iex> macro_exported?(Kernel, :use, 2)\n    true\n\n    iex> macro_exported?(:erlang, :abs, 1)\n    false","ref":"Kernel.html#macro_exported?/3-examples"},{"type":"function","title":"Kernel.make_ref/0","doc":"Returns an almost unique reference.\n\nThe returned reference will re-occur after approximately 2^82 calls;\ntherefore it is unique enough for practical purposes.\n\nInlined by the compiler.","ref":"Kernel.html#make_ref/0"},{"type":"function","title":"Examples - Kernel.make_ref/0","doc":"make_ref()\n    #=> #Reference<0.0.0.135>","ref":"Kernel.html#make_ref/0-examples"},{"type":"function","title":"Kernel.map_size/1","doc":"Returns the size of a map.\n\nThe size of a map is the number of key-value pairs that the map contains.\n\nThis operation happens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#map_size/1"},{"type":"function","title":"Examples - Kernel.map_size/1","doc":"iex> map_size(%{a: \"foo\", b: \"bar\"})\n    2","ref":"Kernel.html#map_size/1-examples"},{"type":"macro","title":"Kernel.match?/2","doc":"A convenience macro that checks if the right side (an expression) matches the\nleft side (a pattern).","ref":"Kernel.html#match?/2"},{"type":"macro","title":"Examples - Kernel.match?/2","doc":"iex> match?(1, 1)\n    true\n\n    iex> match?({1, _}, {1, 2})\n    true\n\n    iex> map = %{a: 1, b: 2}\n    iex> match?(%{a: _}, map)\n    true\n\n    iex> a = 1\n    iex> match?(^a, 1)\n    true\n\n`match?/2` is very useful when filtering or finding a value in an enumerable:\n\n    iex> list = [a: 1, b: 2, a: 3]\n    iex> Enum.filter(list, &match?({:a, _}, &1))\n    [a: 1, a: 3]\n\nGuard clauses can also be given to the match:\n\n    iex> list = [a: 1, b: 2, a: 3]\n    iex> Enum.filter(list, &match?({:a, x} when x < 2, &1))\n    [a: 1]\n\nVariables assigned in the match will not be available outside of the\nfunction call (unlike regular pattern matching with the `=` operator):\n\n    iex> match?(_x, 1)\n    true\n    iex> binding()\n    []","ref":"Kernel.html#match?/2-examples"},{"type":"macro","title":"Values vs patterns - Kernel.match?/2","doc":"Remember the pin operator matches _values_, not _patterns_.\nPassing a variable as the pattern will always return `true` and will\nresult in a warning that the variable is unused:\n\n    # don't do this\n    pattern = %{a: :a}\n    match?(pattern, %{b: :b})\n\nSimilarly, moving an expression out the pattern may no longer preserve\nits semantics. For example:\n\n    match?([_ | _], [1, 2, 3])\n    #=> true\n\n    pattern = [_ | _]\n    match?(pattern, [1, 2, 3])\n    ** (CompileError) invalid use of _. _ can only be used inside patterns to ignore values and cannot be used in expressions. Make sure you are inside a pattern or change it accordingly\n\nAnother example is that a map as a pattern performs a subset match, but not\nonce assigned to a variable:\n\n    match?(%{x: 1}, %{x: 1, y: 2})\n    #=> true\n\n    attrs = %{x: 1}\n    match?(^attrs, %{x: 1, y: 2})\n    #=> false\n\nThe pin operator will check if the values are equal, using `===/2`, while\npatterns have their own rules when matching maps, lists, and so forth.\nSuch behavior is not specific to `match?/2`. The following code also\nthrows an exception:\n\n    attrs = %{x: 1}\n    ^attrs = %{x: 1, y: 2}\n    #=> (MatchError) no match of right hand side value: %{x: 1, y: 2}","ref":"Kernel.html#match?/2-values-vs-patterns"},{"type":"function","title":"Kernel.max/2","doc":"Returns the biggest of the two given terms according to\ntheir structural comparison.\n\nIf the terms compare equal, the first one is returned.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\"](#module-structural-comparison) section\nfor more information.\n\nInlined by the compiler.","ref":"Kernel.html#max/2"},{"type":"function","title":"Examples - Kernel.max/2","doc":"iex> max(1, 2)\n    2\n    iex> max(\"a\", \"b\")\n    \"b\"","ref":"Kernel.html#max/2-examples"},{"type":"function","title":"Kernel.min/2","doc":"Returns the smallest of the two given terms according to\ntheir structural comparison.\n\nIf the terms compare equal, the first one is returned.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\"](#module-structural-comparison) section\nfor more information.\n\nInlined by the compiler.","ref":"Kernel.html#min/2"},{"type":"function","title":"Examples - Kernel.min/2","doc":"iex> min(1, 2)\n    1\n    iex> min(\"foo\", \"bar\")\n    \"bar\"","ref":"Kernel.html#min/2-examples"},{"type":"function","title":"Kernel.node/0","doc":"Returns an atom representing the name of the local node.\nIf the node is not alive, `:nonode@nohost` is returned instead.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#node/0"},{"type":"function","title":"Kernel.node/1","doc":"Returns the node where the given argument is located.\nThe argument can be a PID, a reference, or a port.\nIf the local node is not alive, `:nonode@nohost` is returned.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#node/1"},{"type":"function","title":"Kernel.not/1","doc":"Strictly boolean \"not\" operator.\n\n`value` must be a boolean; if it's not, an `ArgumentError` exception is raised.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#not/1"},{"type":"function","title":"Examples - Kernel.not/1","doc":"iex> not false\n    true","ref":"Kernel.html#not/1-examples"},{"type":"macro","title":"Kernel.or/2","doc":"Strictly boolean \"or\" operator.\n\nIf `left` is `true`, returns `true`, otherwise returns `right`.\n\nRequires only the `left` operand to be a boolean since it short-circuits.\nIf the `left` operand is not a boolean, a `BadBooleanError` exception is\nraised.\n\nAllowed in guard tests.","ref":"Kernel.html#or/2"},{"type":"macro","title":"Examples - Kernel.or/2","doc":"iex> true or false\n    true\n\n    iex> false or 42\n    42\n\n    iex> 42 or false\n    ** (BadBooleanError) expected a boolean on left-side of \"or\", got: 42","ref":"Kernel.html#or/2-examples"},{"type":"macro","title":"Kernel.pop_in/1","doc":"Pops a key from the nested structure via the given `path`.\n\nThis is similar to `pop_in/2`, except the path is extracted via\na macro rather than passing a list. For example:\n\n    pop_in(opts[:foo][:bar])\n\nIs equivalent to:\n\n    pop_in(opts, [:foo, :bar])\n\nNote that in order for this macro to work, the complete path must always\nbe visible by this macro. For more information about the supported path\nexpressions, please check `get_and_update_in/2` docs.","ref":"Kernel.html#pop_in/1"},{"type":"macro","title":"Examples - Kernel.pop_in/1","doc":"iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users[\"john\"][:age])\n    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n\n    iex> users = %{john: %{age: 27}, meg: %{age: 23}}\n    iex> pop_in(users.john[:age])\n    {27, %{john: %{}, meg: %{age: 23}}}\n\nIn case any entry returns `nil`, its key will be removed\nand the deletion will be considered a success.","ref":"Kernel.html#pop_in/1-examples"},{"type":"function","title":"Kernel.pop_in/2","doc":"Pops a key from the given nested structure.\n\nUses the `Access` protocol to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.","ref":"Kernel.html#pop_in/2"},{"type":"function","title":"Examples - Kernel.pop_in/2","doc":"iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users, [\"john\", :age])\n    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n\nIn case any entry returns `nil`, its key will be removed\nand the deletion will be considered a success.\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users, [\"jane\", :age])\n    {nil, %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}}","ref":"Kernel.html#pop_in/2-examples"},{"type":"function","title":"Kernel.put_elem/3","doc":"Puts `value` at the given zero-based `index` in `tuple`.\n\nInlined by the compiler.","ref":"Kernel.html#put_elem/3"},{"type":"function","title":"Examples - Kernel.put_elem/3","doc":"iex> tuple = {:foo, :bar, 3}\n    iex> put_elem(tuple, 0, :baz)\n    {:baz, :bar, 3}","ref":"Kernel.html#put_elem/3-examples"},{"type":"macro","title":"Kernel.put_in/2","doc":"Puts a value in a nested structure via the given `path`.\n\nThis is similar to `put_in/3`, except the path is extracted via\na macro rather than passing a list. For example:\n\n    put_in(opts[:foo][:bar], :baz)\n\nIs equivalent to:\n\n    put_in(opts, [:foo, :bar], :baz)\n\nThis also works with nested structs and the `struct.path.to.value` way to specify\npaths:\n\n    put_in(struct.foo.bar, :baz)\n\nNote that in order for this macro to work, the complete path must always\nbe visible by this macro. For more information about the supported path\nexpressions, please check `get_and_update_in/2` docs.","ref":"Kernel.html#put_in/2"},{"type":"macro","title":"Examples - Kernel.put_in/2","doc":"iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users[\"john\"][:age], 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users[\"john\"].age, 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}","ref":"Kernel.html#put_in/2-examples"},{"type":"function","title":"Kernel.put_in/3","doc":"Puts a value in a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.","ref":"Kernel.html#put_in/3"},{"type":"function","title":"Examples - Kernel.put_in/3","doc":"iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users, [\"john\", :age], 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users, [\"jane\", :age], \"oops\")\n    ** (ArgumentError) could not put/update key :age on a nil value","ref":"Kernel.html#put_in/3-examples"},{"type":"macro","title":"Kernel.raise/1","doc":"Raises an exception.\n\nIf `message` is a string, it raises a `RuntimeError` exception with it.\n\nIf `message` is an atom, it just calls `raise/2` with the atom as the first\nargument and `[]` as the second one.\n\nIf `message` is an exception struct, it is raised as is.\n\nIf `message` is anything else, `raise` will fail with an `ArgumentError`\nexception.","ref":"Kernel.html#raise/1"},{"type":"macro","title":"Examples - Kernel.raise/1","doc":"iex> raise \"oops\"\n    ** (RuntimeError) oops\n\n    try do\n      1 + :foo\n    rescue\n      x in [ArithmeticError] ->\n        IO.puts(\"that was expected\")\n        raise x\n    end","ref":"Kernel.html#raise/1-examples"},{"type":"macro","title":"Kernel.raise/2","doc":"Raises an exception.\n\nCalls the `exception/1` function on the given argument (which has to be a\nmodule name like `ArgumentError` or `RuntimeError`) passing `attributes`\nin order to retrieve the exception struct.\n\nAny module that contains a call to the `defexception/1` macro automatically\nimplements the `c:Exception.exception/1` callback expected by `raise/2`.\nFor more information, see `defexception/1`.","ref":"Kernel.html#raise/2"},{"type":"macro","title":"Examples - Kernel.raise/2","doc":"iex> raise(ArgumentError, \"Sample\")\n    ** (ArgumentError) Sample","ref":"Kernel.html#raise/2-examples"},{"type":"function","title":"Kernel.rem/2","doc":"Computes the remainder of an integer division.\n\n`rem/2` uses truncated division, which means that\nthe result will always have the sign of the `dividend`.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#rem/2"},{"type":"function","title":"Examples - Kernel.rem/2","doc":"iex> rem(5, 2)\n    1\n    iex> rem(6, -4)\n    2","ref":"Kernel.html#rem/2-examples"},{"type":"macro","title":"Kernel.reraise/2","doc":"Raises an exception preserving a previous stacktrace.\n\nWorks like `raise/1` but does not generate a new stacktrace.\n\nNote that `__STACKTRACE__` can be used inside catch/rescue\nto retrieve the current stacktrace.","ref":"Kernel.html#reraise/2"},{"type":"macro","title":"Examples - Kernel.reraise/2","doc":"try do\n      raise \"oops\"\n    rescue\n      exception ->\n        reraise exception, __STACKTRACE__\n    end","ref":"Kernel.html#reraise/2-examples"},{"type":"macro","title":"Kernel.reraise/3","doc":"Raises an exception preserving a previous stacktrace.\n\n`reraise/3` works like `reraise/2`, except it passes arguments to the\n`exception/1` function as explained in `raise/2`.","ref":"Kernel.html#reraise/3"},{"type":"macro","title":"Examples - Kernel.reraise/3","doc":"try do\n      raise \"oops\"\n    rescue\n      exception ->\n        reraise WrapperError, [exception: exception], __STACKTRACE__\n    end","ref":"Kernel.html#reraise/3-examples"},{"type":"function","title":"Kernel.round/1","doc":"Rounds a number to the nearest integer.\n\nIf the number is equidistant to the two nearest integers, rounds away from zero.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#round/1"},{"type":"function","title":"Examples - Kernel.round/1","doc":"iex> round(5.6)\n    6\n\n    iex> round(5.2)\n    5\n\n    iex> round(-9.9)\n    -10\n\n    iex> round(-9)\n    -9\n\n    iex> round(2.5)\n    3\n\n    iex> round(-2.5)\n    -3","ref":"Kernel.html#round/1-examples"},{"type":"function","title":"Kernel.self/0","doc":"Returns the PID (process identifier) of the calling process.\n\nAllowed in guard clauses. Inlined by the compiler.","ref":"Kernel.html#self/0"},{"type":"function","title":"Kernel.send/2","doc":"Sends a message to the given `dest` and returns the message.\n\n`dest` may be a remote or local PID, a local port, a locally\nregistered name, or a tuple in the form of `{registered_name, node}` for a\nregistered name at another node.\n\nFor additional documentation, see the [`!` operator Erlang\ndocumentation](https://www.erlang.org/doc/reference_manual/expressions#send).\n\nInlined by the compiler.","ref":"Kernel.html#send/2"},{"type":"function","title":"Examples - Kernel.send/2","doc":"iex> send(self(), :hello)\n    :hello","ref":"Kernel.html#send/2-examples"},{"type":"macro","title":"Kernel.sigil_C/2","doc":"Handles the sigil `~C` for charlists.\n\nIt returns a charlist without interpolations and without escape\ncharacters.\n\nA charlist is a list of integers where all the integers are valid code points.\nThe three expressions below are equivalent:\n\n    ~C\"foo\\n\"\n    [?f, ?o, ?o, ?\\\\, ?n]\n    [102, 111, 111, 92, 110]\n\nIn practice, charlists are mostly used in specific scenarios such as\ninterfacing with older Erlang libraries that do not accept binaries as arguments.","ref":"Kernel.html#sigil_C/2"},{"type":"macro","title":"Examples - Kernel.sigil_C/2","doc":"iex> ~C(foo)\n    ~c\"foo\"\n\n    iex> ~C(f#{o}o)\n    ~c\"f\\#{o}o\"\n\n    iex> ~C(foo\\n)\n    ~c\"foo\\\\n\"","ref":"Kernel.html#sigil_C/2-examples"},{"type":"macro","title":"Kernel.sigil_c/2","doc":"Handles the sigil `~c` for charlists.\n\nIt returns a charlist, unescaping characters and replacing interpolations.\n\nA charlist is a list of integers where all the integers are valid code points.\nThe three expressions below are equivalent:\n\n    ~c\"foo\"\n    [?f, ?o, ?o]\n    [102, 111, 111]\n\nIn practice, charlists are mostly used in specific scenarios such as\ninterfacing with older Erlang libraries that do not accept binaries as arguments.","ref":"Kernel.html#sigil_c/2"},{"type":"macro","title":"Examples - Kernel.sigil_c/2","doc":"iex> ~c(foo)\n    ~c\"foo\"\n\n    iex> ~c(f#{:o}o)\n    ~c\"foo\"\n\n    iex> ~c(f\\#{:o}o)\n    ~c\"f\\#{:o}o\"\n\nThe list is only printed as a `~c` sigil if all code points are within the\nASCII range:\n\n    iex> ~c\"hełło\"\n    [104, 101, 322, 322, 111]\n\n    iex> [104, 101, 108, 108, 111]\n    ~c\"hello\"\n\nSee `Inspect.Opts` for more information.","ref":"Kernel.html#sigil_c/2-examples"},{"type":"macro","title":"Kernel.sigil_D/2","doc":"Handles the sigil `~D` for dates.\n\nBy default, this sigil uses the built-in `Calendar.ISO`, which\nrequires dates to be written in the ISO8601 format:\n\n    ~D[yyyy-mm-dd]\n\nsuch as:\n\n    ~D[2015-01-13]\n\nIf you are using alternative calendars, any representation can\nbe used as long as you follow the representation by a single space\nand the calendar name:\n\n    ~D[SOME-REPRESENTATION My.Alternative.Calendar]\n\nThe lower case `~d` variant does not exist as interpolation\nand escape characters are not useful for date sigils.\n\nMore information on dates can be found in the `Date` module.","ref":"Kernel.html#sigil_D/2"},{"type":"macro","title":"Examples - Kernel.sigil_D/2","doc":"iex> ~D[2015-01-13]\n    ~D[2015-01-13]","ref":"Kernel.html#sigil_D/2-examples"},{"type":"macro","title":"Kernel.sigil_N/2","doc":"Handles the sigil `~N` for naive date times.\n\nBy default, this sigil uses the built-in `Calendar.ISO`, which\nrequires naive date times to be written in the ISO8601 format:\n\n    ~N[yyyy-mm-dd hh:mm:ss]\n    ~N[yyyy-mm-dd hh:mm:ss.ssssss]\n    ~N[yyyy-mm-ddThh:mm:ss.ssssss]\n\nsuch as:\n\n    ~N[2015-01-13 13:00:07]\n    ~N[2015-01-13T13:00:07.123]\n\nIf you are using alternative calendars, any representation can\nbe used as long as you follow the representation by a single space\nand the calendar name:\n\n    ~N[SOME-REPRESENTATION My.Alternative.Calendar]\n\nThe lower case `~n` variant does not exist as interpolation\nand escape characters are not useful for date time sigils.\n\nMore information on naive date times can be found in the\n`NaiveDateTime` module.","ref":"Kernel.html#sigil_N/2"},{"type":"macro","title":"Examples - Kernel.sigil_N/2","doc":"iex> ~N[2015-01-13 13:00:07]\n    ~N[2015-01-13 13:00:07]\n    iex> ~N[2015-01-13T13:00:07.001]\n    ~N[2015-01-13 13:00:07.001]","ref":"Kernel.html#sigil_N/2-examples"},{"type":"macro","title":"Kernel.sigil_r/2","doc":"Handles the sigil `~r` for regular expressions.\n\nIt returns a regular expression pattern, unescaping characters and replacing\ninterpolations.\n\nMore information on regular expressions can be found in the `Regex` module.","ref":"Kernel.html#sigil_r/2"},{"type":"macro","title":"Examples - Kernel.sigil_r/2","doc":"iex> Regex.match?(~r/foo/, \"foo\")\n    true\n\n    iex> Regex.match?(~r/a#{:b}c/, \"abc\")\n    true\n\nWhile the `~r` sigil allows parens and brackets to be used as delimiters,\nit is preferred to use `\"` or `/` to avoid escaping conflicts with reserved\nregex characters.","ref":"Kernel.html#sigil_r/2-examples"},{"type":"macro","title":"Kernel.sigil_S/2","doc":"Handles the sigil `~S` for strings.\n\nIt returns a string without interpolations and without escape\ncharacters.","ref":"Kernel.html#sigil_S/2"},{"type":"macro","title":"Examples - Kernel.sigil_S/2","doc":"iex> ~S(foo)\n    \"foo\"\n    iex> ~S(f#{o}o)\n    \"f\\#{o}o\"\n    iex> ~S(\\o/)\n    \"\\\\o/\"","ref":"Kernel.html#sigil_S/2-examples"},{"type":"macro","title":"Kernel.sigil_s/2","doc":"Handles the sigil `~s` for strings.\n\nIt returns a string as if it was a double quoted string, unescaping characters\nand replacing interpolations.","ref":"Kernel.html#sigil_s/2"},{"type":"macro","title":"Examples - Kernel.sigil_s/2","doc":"iex> ~s(foo)\n    \"foo\"\n\n    iex> ~s(f#{:o}o)\n    \"foo\"\n\n    iex> ~s(f\\#{:o}o)\n    \"f\\#{:o}o\"","ref":"Kernel.html#sigil_s/2-examples"},{"type":"macro","title":"Kernel.sigil_T/2","doc":"Handles the sigil `~T` for times.\n\nBy default, this sigil uses the built-in `Calendar.ISO`, which\nrequires times to be written in the ISO8601 format:\n\n    ~T[hh:mm:ss]\n    ~T[hh:mm:ss.ssssss]\n\nsuch as:\n\n    ~T[13:00:07]\n    ~T[13:00:07.123]\n\nIf you are using alternative calendars, any representation can\nbe used as long as you follow the representation by a single space\nand the calendar name:\n\n    ~T[SOME-REPRESENTATION My.Alternative.Calendar]\n\nThe lower case `~t` variant does not exist as interpolation\nand escape characters are not useful for time sigils.\n\nMore information on times can be found in the `Time` module.","ref":"Kernel.html#sigil_T/2"},{"type":"macro","title":"Examples - Kernel.sigil_T/2","doc":"iex> ~T[13:00:07]\n    ~T[13:00:07]\n    iex> ~T[13:00:07.001]\n    ~T[13:00:07.001]","ref":"Kernel.html#sigil_T/2-examples"},{"type":"macro","title":"Kernel.sigil_U/2","doc":"Handles the sigil `~U` to create a UTC `DateTime`.\n\nBy default, this sigil uses the built-in `Calendar.ISO`, which\nrequires UTC date times to be written in the ISO8601 format:\n\n    ~U[yyyy-mm-dd hh:mm:ssZ]\n    ~U[yyyy-mm-dd hh:mm:ss.ssssssZ]\n    ~U[yyyy-mm-ddThh:mm:ss.ssssss+00:00]\n\nsuch as:\n\n    ~U[2015-01-13 13:00:07Z]\n    ~U[2015-01-13T13:00:07.123+00:00]\n\nIf you are using alternative calendars, any representation can\nbe used as long as you follow the representation by a single space\nand the calendar name:\n\n    ~U[SOME-REPRESENTATION My.Alternative.Calendar]\n\nThe given `datetime_string` must include \"Z\" or \"00:00\" offset\nwhich marks it as UTC, otherwise an error is raised.\n\nThe lower case `~u` variant does not exist as interpolation\nand escape characters are not useful for date time sigils.\n\nMore information on date times can be found in the `DateTime` module.","ref":"Kernel.html#sigil_U/2"},{"type":"macro","title":"Examples - Kernel.sigil_U/2","doc":"iex> ~U[2015-01-13 13:00:07Z]\n    ~U[2015-01-13 13:00:07Z]\n    iex> ~U[2015-01-13T13:00:07.001+00:00]\n    ~U[2015-01-13 13:00:07.001Z]","ref":"Kernel.html#sigil_U/2-examples"},{"type":"macro","title":"Kernel.sigil_W/2","doc":"Handles the sigil `~W` for list of words.\n\nIt returns a list of \"words\" split by whitespace without interpolations\nand without escape characters.","ref":"Kernel.html#sigil_W/2"},{"type":"macro","title":"Modifiers - Kernel.sigil_W/2","doc":"* `s`: words in the list are strings (default)\n  * `a`: words in the list are atoms\n  * `c`: words in the list are charlists","ref":"Kernel.html#sigil_W/2-modifiers"},{"type":"macro","title":"Examples - Kernel.sigil_W/2","doc":"iex> ~W(foo #{bar} baz)\n    [\"foo\", \"\\#{bar}\", \"baz\"]","ref":"Kernel.html#sigil_W/2-examples"},{"type":"macro","title":"Kernel.sigil_w/2","doc":"Handles the sigil `~w` for list of words.\n\nIt returns a list of \"words\" split by whitespace. Character unescaping and\ninterpolation happens for each word.","ref":"Kernel.html#sigil_w/2"},{"type":"macro","title":"Modifiers - Kernel.sigil_w/2","doc":"* `s`: words in the list are strings (default)\n  * `a`: words in the list are atoms\n  * `c`: words in the list are charlists","ref":"Kernel.html#sigil_w/2-modifiers"},{"type":"macro","title":"Examples - Kernel.sigil_w/2","doc":"iex> ~w(foo #{:bar} baz)\n    [\"foo\", \"bar\", \"baz\"]\n\n    iex> ~w(foo #{\" bar baz \"})\n    [\"foo\", \"bar\", \"baz\"]\n\n    iex> ~w(--source test/enum_test.exs)\n    [\"--source\", \"test/enum_test.exs\"]\n\n    iex> ~w(foo bar baz)a\n    [:foo, :bar, :baz]\n\n    iex> ~w(foo bar baz)c\n    [~c\"foo\", ~c\"bar\", ~c\"baz\"]","ref":"Kernel.html#sigil_w/2-examples"},{"type":"function","title":"Kernel.spawn/1","doc":"Spawns the given function and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.","ref":"Kernel.html#spawn/1"},{"type":"function","title":"Examples - Kernel.spawn/1","doc":"current = self()\n    child = spawn(fn -> send(current, {self(), 1 + 2}) end)\n\n    receive do\n      {^child, 3} -> IO.puts(\"Received 3 back\")\n    end","ref":"Kernel.html#spawn/1-examples"},{"type":"function","title":"Kernel.spawn/3","doc":"Spawns the given function `fun` from the given `module` passing it the given\n`args` and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nInlined by the compiler.","ref":"Kernel.html#spawn/3"},{"type":"function","title":"Examples - Kernel.spawn/3","doc":"spawn(SomeModule, :function, [1, 2, 3])","ref":"Kernel.html#spawn/3-examples"},{"type":"function","title":"Kernel.spawn_link/1","doc":"Spawns the given function, links it to the current process, and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions. For more\ninformation on linking, check `Process.link/1`.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.","ref":"Kernel.html#spawn_link/1"},{"type":"function","title":"Examples - Kernel.spawn_link/1","doc":"current = self()\n    child = spawn_link(fn -> send(current, {self(), 1 + 2}) end)\n\n    receive do\n      {^child, 3} -> IO.puts(\"Received 3 back\")\n    end","ref":"Kernel.html#spawn_link/1-examples"},{"type":"function","title":"Kernel.spawn_link/3","doc":"Spawns the given function `fun` from the given `module` passing it the given\n`args`, links it to the current process, and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions. For more\ninformation on linking, check `Process.link/1`.\n\nInlined by the compiler.","ref":"Kernel.html#spawn_link/3"},{"type":"function","title":"Examples - Kernel.spawn_link/3","doc":"spawn_link(SomeModule, :function, [1, 2, 3])","ref":"Kernel.html#spawn_link/3-examples"},{"type":"function","title":"Kernel.spawn_monitor/1","doc":"Spawns the given function, monitors it and returns its PID\nand monitoring reference.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.","ref":"Kernel.html#spawn_monitor/1"},{"type":"function","title":"Examples - Kernel.spawn_monitor/1","doc":"current = self()\n    spawn_monitor(fn -> send(current, {self(), 1 + 2}) end)","ref":"Kernel.html#spawn_monitor/1-examples"},{"type":"function","title":"Kernel.spawn_monitor/3","doc":"Spawns the given module and function passing the given args,\nmonitors it and returns its PID and monitoring reference.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nInlined by the compiler.","ref":"Kernel.html#spawn_monitor/3"},{"type":"function","title":"Examples - Kernel.spawn_monitor/3","doc":"spawn_monitor(SomeModule, :function, [1, 2, 3])","ref":"Kernel.html#spawn_monitor/3-examples"},{"type":"function","title":"Kernel.struct/2","doc":"Creates and updates a struct.\n\nThe `struct` argument may be an atom (which defines `defstruct`)\nor a `struct` itself. The second argument is any `Enumerable` that\nemits two-element tuples (key-value pairs) during enumeration.\n\nKeys in the `Enumerable` that don't exist in the struct are automatically\ndiscarded. Note that keys must be atoms, as only atoms are allowed when\ndefining a struct. If there are duplicate keys in the `Enumerable`, the last\nentry will be taken (same behavior as `Map.new/1`).\n\nThis function is useful for dynamically creating and updating structs, as\nwell as for converting maps to structs; in the latter case, just inserting\nthe appropriate `:__struct__` field into the map may not be enough and\n`struct/2` should be used instead.","ref":"Kernel.html#struct/2"},{"type":"function","title":"Examples - Kernel.struct/2","doc":"defmodule User do\n      defstruct name: \"john\"\n    end\n\n    struct(User)\n    #=> %User{name: \"john\"}\n\n    opts = [name: \"meg\"]\n    user = struct(User, opts)\n    #=> %User{name: \"meg\"}\n\n    struct(user, unknown: \"value\")\n    #=> %User{name: \"meg\"}\n\n    struct(User, %{name: \"meg\"})\n    #=> %User{name: \"meg\"}\n\n    # String keys are ignored\n    struct(User, %{\"name\" => \"meg\"})\n    #=> %User{name: \"john\"}","ref":"Kernel.html#struct/2-examples"},{"type":"function","title":"Kernel.struct!/2","doc":"Similar to `struct/2` but checks for key validity.\n\nThe function `struct!/2` emulates the compile time behavior\nof structs. This means that:\n\n  * when building a struct, as in `struct!(SomeStruct, key: :value)`,\n    it is equivalent to `%SomeStruct{key: :value}` and therefore this\n    function will check if every given key-value belongs to the struct.\n    If the struct is enforcing any key via `@enforce_keys`, those will\n    be enforced as well;\n\n  * when updating a struct, as in `struct!(%SomeStruct{}, key: :value)`,\n    it is equivalent to `%SomeStruct{struct | key: :value}` and therefore this\n    function will check if every given key-value belongs to the struct.\n    However, updating structs does not enforce keys, as keys are enforced\n    only when building;","ref":"Kernel.html#struct!/2"},{"type":"macro","title":"Kernel.tap/2","doc":"Pipes the first argument, `value`, into the second argument, a function `fun`,\nand returns `value` itself.\n\nUseful for running synchronous side effects in a pipeline, using the `|>/2` operator.","ref":"Kernel.html#tap/2"},{"type":"macro","title":"Examples - Kernel.tap/2","doc":"iex> tap(1, fn x -> x + 1 end)\n    1\n\nMost commonly, this is used in pipelines, using the `|>/2` operator.\nFor example, let's suppose you want to inspect part of a data structure.\nYou could write:\n\n    %{a: 1}\n    |> Map.update!(:a, & &1 + 2)\n    |> tap(&IO.inspect(&1.a))\n    |> Map.update!(:a, & &1 * 2)","ref":"Kernel.html#tap/2-examples"},{"type":"macro","title":"Kernel.then/2","doc":"Pipes the first argument, `value`, into the second argument, a function `fun`,\nand returns the result of calling `fun`.\n\nIn other words, it invokes the function `fun` with `value` as argument,\nand returns its result.\n\nThis is most commonly used in pipelines, using the `|>/2` operator, allowing you\nto pipe a value to a function outside of its first argument.","ref":"Kernel.html#then/2"},{"type":"macro","title":"Examples - Kernel.then/2","doc":"iex> 1 |> then(fn x -> x * 2 end)\n    2\n\n    iex> 1 |> then(fn x -> Enum.drop([\"a\", \"b\", \"c\"], x) end)\n    [\"b\", \"c\"]","ref":"Kernel.html#then/2-examples"},{"type":"function","title":"Kernel.throw/1","doc":"A non-local return from a function.\n\nUsing `throw/1` is generally discouraged, as it allows a function\nto escape from its regular execution flow, which can make the code\nharder to read. Furthermore, all thrown values must be caught by\n`try/catch`. See `try/1` for more information.\n\nInlined by the compiler.","ref":"Kernel.html#throw/1"},{"type":"function","title":"Kernel.tl/1","doc":"Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n\nThe tail of a list is the list without its first element.\n\nIt works with improper lists.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#tl/1"},{"type":"function","title":"Examples - Kernel.tl/1","doc":"tl([1, 2, 3, :go])\n    #=> [2, 3, :go]\n\n    tl([:one])\n    #=> []\n\n    tl([:a, :b | :improper_end])\n    #=> [:b | :improper_end]\n\n    tl([:a | %{b: 1}])\n    #=> %{b: 1}\n\nGiving it an empty list raises:\n\n    tl([])\n    ** (ArgumentError) argument error","ref":"Kernel.html#tl/1-examples"},{"type":"macro","title":"Kernel.to_charlist/1","doc":"Converts the given term to a charlist according to the `List.Chars` protocol.","ref":"Kernel.html#to_charlist/1"},{"type":"macro","title":"Examples - Kernel.to_charlist/1","doc":"iex> to_charlist(:foo)\n    ~c\"foo\"","ref":"Kernel.html#to_charlist/1-examples"},{"type":"macro","title":"Kernel.to_string/1","doc":"Converts the argument to a string according to the\n`String.Chars` protocol.\n\nThis is the function invoked when there is string interpolation.","ref":"Kernel.html#to_string/1"},{"type":"macro","title":"Examples - Kernel.to_string/1","doc":"iex> to_string(:foo)\n    \"foo\"","ref":"Kernel.html#to_string/1-examples"},{"type":"function","title":"Kernel.to_timeout/1","doc":"Constructs a millisecond timeout from the given components, duration, or timeout.\n\nThis function is useful for constructing timeouts to use in functions that\nexpect `t:timeout/0` values (such as `Process.send_after/4` and many others).","ref":"Kernel.html#to_timeout/1"},{"type":"function","title":"Argument - Kernel.to_timeout/1","doc":"The `duration` argument can be one of a `Duration`, a `t:timeout/0`, or a list\nof components. Each of these is described below.","ref":"Kernel.html#to_timeout/1-argument"},{"type":"function","title":"Passing `Duration`s - Kernel.to_timeout/1","doc":"`t:Duration.t/0` structs can be converted to timeouts. The given duration must have\n`year` and `month` fields set to `0`, since those cannot be reliably converted to\nmilliseconds (due to the varying number of days in a month and year).\n\nMicroseconds in durations are converted to milliseconds (through `System.convert_time_unit/3`).","ref":"Kernel.html#to_timeout/1-passing-duration-s"},{"type":"function","title":"Passing components - Kernel.to_timeout/1","doc":"The `duration` argument can also be keyword list which can contain the following\nkeys, each appearing at most once with a non-negative integer value:\n\n  * `:week` - the number of weeks (a week is always 7 days)\n  * `:day` - the number of days (a day is always 24 hours)\n  * `:hour` - the number of hours\n  * `:minute` - the number of minutes\n  * `:second` - the number of seconds\n  * `:millisecond` - the number of milliseconds\n\nThe timeout is calculated as the sum of the components, each multiplied by\nthe corresponding factor.","ref":"Kernel.html#to_timeout/1-passing-components"},{"type":"function","title":"Passing timeouts - Kernel.to_timeout/1","doc":"You can also pass timeouts directly to this functions, that is, milliseconds or\nthe atom `:infinity`. In this case, this function just returns the given argument.","ref":"Kernel.html#to_timeout/1-passing-timeouts"},{"type":"function","title":"Examples - Kernel.to_timeout/1","doc":"With a keyword list:\n\n    iex> to_timeout(hour: 1, minute: 30)\n    5400000\n\nWith a duration:\n\n    iex> to_timeout(%Duration{hour: 1, minute: 30})\n    5400000\n\nWith a timeout:\n\n    iex> to_timeout(5400000)\n    5400000\n    iex> to_timeout(:infinity)\n    :infinity","ref":"Kernel.html#to_timeout/1-examples"},{"type":"function","title":"Kernel.trunc/1","doc":"Returns the integer part of `number`.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#trunc/1"},{"type":"function","title":"Examples - Kernel.trunc/1","doc":"iex> trunc(5.4)\n    5\n\n    iex> trunc(-5.99)\n    -5\n\n    iex> trunc(-5)\n    -5","ref":"Kernel.html#trunc/1-examples"},{"type":"function","title":"Kernel.tuple_size/1","doc":"Returns the size of a tuple.\n\nThis operation happens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#tuple_size/1"},{"type":"function","title":"Examples - Kernel.tuple_size/1","doc":"iex> tuple_size({:a, :b, :c})\n    3","ref":"Kernel.html#tuple_size/1-examples"},{"type":"macro","title":"Kernel.unless/2","doc":"Provides an `unless` macro.\n\nThis macro evaluates and returns the `do` block passed in as the second\nargument if `condition` evaluates to a falsy value (`false` or `nil`).\nOtherwise, it returns the value of the `else` block if present or `nil` if not.\n\nSee also `if/2`.","ref":"Kernel.html#unless/2"},{"type":"macro","title":"Examples - Kernel.unless/2","doc":"iex> unless(Enum.empty?([]), do: \"Hello\")\n    nil\n\n    iex> unless(Enum.empty?([1, 2, 3]), do: \"Hello\")\n    \"Hello\"\n\n    iex> unless Enum.sum([2, 2]) == 5 do\n    ...>   \"Math still works\"\n    ...> else\n    ...>   \"Math is broken\"\n    ...> end\n    \"Math still works\"","ref":"Kernel.html#unless/2-examples"},{"type":"macro","title":"Kernel.update_in/2","doc":"Updates a nested structure via the given `path`.\n\nThis is similar to `update_in/3`, except the path is extracted via\na macro rather than passing a list. For example:\n\n    update_in(opts[:foo][:bar], &(&1 + 1))\n\nIs equivalent to:\n\n    update_in(opts, [:foo, :bar], &(&1 + 1))\n\nThis also works with nested structs and the `struct.path.to.value` way to specify\npaths:\n\n    update_in(struct.foo.bar, &(&1 + 1))\n\nNote that in order for this macro to work, the complete path must always\nbe visible by this macro. For more information about the supported path\nexpressions, please check `get_and_update_in/2` docs.","ref":"Kernel.html#update_in/2"},{"type":"macro","title":"Examples - Kernel.update_in/2","doc":"iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users[\"john\"].age, &(&1 + 1))\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}","ref":"Kernel.html#update_in/2-examples"},{"type":"function","title":"Kernel.update_in/3","doc":"Updates a key in a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n`data` is a nested structure (that is, a map, keyword\nlist, or struct that implements the `Access` behaviour).\nThe `fun` argument receives the value of `key` (or `nil`\nif `key` is not present) and the result replaces the value\nin the structure.","ref":"Kernel.html#update_in/3"},{"type":"function","title":"Examples - Kernel.update_in/3","doc":"iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nNote the current value given to the anonymous function may be `nil`.\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users, [\"jane\", :age], & &1 + 1)\n    ** (ArgumentError) could not put/update key :age on a nil value","ref":"Kernel.html#update_in/3-examples"},{"type":"macro","title":"Kernel.use/2","doc":"Uses the given module in the current context.\n\nWhen calling:\n\n    use MyModule, some: :options\n\nElixir will invoke `MyModule.__using__/1` passing the second argument of\n`use` as its argument. Since `__using__/1` is typically a macro, all\nthe usual macro rules apply, and its return value should be quoted code\nthat is then inserted where `use/2` is called.\n\n> #### Code injection {: .warning}\n>\n> `use MyModule` works as a **code-injection point** in the caller.\n> Given the caller of `use MyModule` has little control over how the\n> code is injected, `use/2` should be used with care. If you can,\n> avoid use in favor of `import/2` or `alias/2` whenever possible.","ref":"Kernel.html#use/2"},{"type":"macro","title":"Examples - Kernel.use/2","doc":"For example, to write test cases using the `ExUnit` framework provided\nwith Elixir, a developer should `use` the `ExUnit.Case` module:\n\n    defmodule AssertionTest do\n      use ExUnit.Case, async: true\n\n      test \"always pass\" do\n        assert true\n      end\n    end\n\nIn this example, Elixir will call the `__using__/1` macro in the\n`ExUnit.Case` module with the keyword list `[async: true]` as its\nargument.\n\nIn other words, `use/2` translates to:\n\n    defmodule AssertionTest do\n      require ExUnit.Case\n      ExUnit.Case.__using__(async: true)\n\n      test \"always pass\" do\n        assert true\n      end\n    end\n\nwhere `ExUnit.Case` defines the `__using__/1` macro:\n\n    defmodule ExUnit.Case do\n      defmacro __using__(opts) do\n        # do something with opts\n        quote do\n          # return some code to inject in the caller\n        end\n      end\n    end","ref":"Kernel.html#use/2-examples"},{"type":"macro","title":"Best practices - Kernel.use/2","doc":"`__using__/1` is typically used when there is a need to set some state\n(via module attributes) or callbacks (like `@before_compile`, see the\ndocumentation for `Module` for more information) into the caller.\n\n`__using__/1` may also be used to alias, require, or import functionality\nfrom different modules:\n\n    defmodule MyModule do\n      defmacro __using__(_opts) do\n        quote do\n          import MyModule.Foo\n          import MyModule.Bar\n          import MyModule.Baz\n\n          alias MyModule.Repo\n        end\n      end\n    end\n\nHowever, do not provide `__using__/1` if all it does is to import,\nalias or require the module itself. For example, avoid this:\n\n    defmodule MyModule do\n      defmacro __using__(_opts) do\n        quote do\n          import MyModule\n        end\n      end\n    end\n\nIn such cases, developers should instead import or alias the module\ndirectly, so that they can customize those as they wish,\nwithout the indirection behind `use/2`. Developers must also avoid\ndefining functions inside `__using__/1`.\n\nGiven `use MyModule` can generate any code, it may not be easy for\ndevelopers to understand the impact of `use MyModule`.\n\nFor this reason, to provide guidance and clarity, we recommend developers\nto include an admonition block in their `@moduledoc` that explains how\n`use MyModule` impacts their code. As an example, the `GenServer` documentation\noutlines:\n\n> #### `use GenServer` {: .info}\n>\n> When you `use GenServer`, the `GenServer` module will\n> set `@behaviour GenServer` and define a `child_spec/1`\n> function, so your module can be used as a child\n> in a supervision tree.\n\nThis provides a quick summary of how using a module impacts the user code.\nKeep in mind to only list changes made to the public API of the module.\nFor example, if `use MyModule` sets an internal attribute called\n`@_my_module_info` and this attribute is never meant to be public,\nit must not be listed.\n\nFor convenience, the markup notation to generate the admonition block\nabove is:\n\n```\n> #### `use GenServer` {: .info}\n>\n> When you `use GenServer`, the GenServer module will\n> set `@behaviour GenServer` and define a `child_spec/1`\n> function, so your module can be used as a child\n> in a supervision tree.\n```","ref":"Kernel.html#use/2-best-practices"},{"type":"macro","title":"Kernel.var!/2","doc":"Marks that the given variable should not be hygienized.\n\nThis macro expects a variable and it is typically invoked\ninside `quote/2` to mark that a variable\nshould not be hygienized. See `quote/2` for more information.","ref":"Kernel.html#var!/2"},{"type":"macro","title":"Examples - Kernel.var!/2","doc":"iex> Kernel.var!(example) = 1\n    1\n    iex> Kernel.var!(example)\n    1","ref":"Kernel.html#var!/2-examples"},{"type":"macro","title":"Kernel.|>/2","doc":"Pipe operator.\n\nThis operator introduces the expression on the left-hand side as\nthe first argument to the function call on the right-hand side.","ref":"Kernel.html#%7C%3E/2"},{"type":"macro","title":"Examples - Kernel.|>/2","doc":"iex> [1, [2], 3] |> List.flatten()\n    [1, 2, 3]\n\nThe example above is the same as calling `List.flatten([1, [2], 3])`.\n\nThe `|>/2` operator is mostly useful when there is a desire to execute a series\nof operations resembling a pipeline:\n\n    iex> [1, [2], 3] |> List.flatten() |> Enum.map(fn x -> x * 2 end)\n    [2, 4, 6]\n\nIn the example above, the list `[1, [2], 3]` is passed as the first argument\nto the `List.flatten/1` function, then the flattened list is passed as the\nfirst argument to the `Enum.map/2` function which doubles each element of the\nlist.\n\nIn other words, the expression above simply translates to:\n\n    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)","ref":"Kernel.html#%7C%3E/2-examples"},{"type":"macro","title":"Pitfalls - Kernel.|>/2","doc":"There are two common pitfalls when using the pipe operator.\n\nThe first one is related to operator precedence. For example,\nthe following expression:\n\n    String.graphemes \"Hello\" |> Enum.reverse\n\nTranslates to:\n\n    String.graphemes(\"Hello\" |> Enum.reverse())\n\nwhich results in an error as the `Enumerable` protocol is not defined\nfor binaries. Adding explicit parentheses resolves the ambiguity:\n\n    String.graphemes(\"Hello\") |> Enum.reverse()\n\nOr, even better:\n\n    \"Hello\" |> String.graphemes() |> Enum.reverse()\n\nThe second limitation is that Elixir always pipes to a function\ncall. Therefore, to pipe into an anonymous function, you need to\ninvoke it:\n\n    some_fun = &Regex.replace(~r/l/, &1, \"L\")\n    \"Hello\" |> some_fun.()\n\nAlternatively, you can use `then/2` for the same effect:\n\n    some_fun = &Regex.replace(~r/l/, &1, \"L\")\n    \"Hello\" |> then(some_fun)\n\n`then/2` is most commonly used when you want to pipe to a function\nbut the value is expected outside of the first argument, such as\nabove. By replacing `some_fun` by its value, we get:\n\n    \"Hello\" |> then(&Regex.replace(~r/l/, &1, \"L\"))","ref":"Kernel.html#%7C%3E/2-pitfalls"},{"type":"macro","title":"Kernel.||/2","doc":"Boolean \"or\" operator.\n\nProvides a short-circuit operator that evaluates and returns the second\nexpression only if the first one does not evaluate to a truthy value (that is,\nit is either `nil` or `false`). Returns the first expression otherwise.\n\nNot allowed in guard clauses.","ref":"Kernel.html#%7C%7C/2"},{"type":"macro","title":"Examples - Kernel.||/2","doc":"iex> Enum.empty?([1]) || Enum.empty?([1])\n    false\n\n    iex> List.first([]) || true\n    true\n\n    iex> Enum.empty?([1]) || 1\n    1\n\n    iex> Enum.empty?([]) || throw(:bad)\n    true\n\nNote that, unlike `or/2`, this operator accepts any expression\nas the first argument, not only booleans.","ref":"Kernel.html#%7C%7C/2-examples"},{"type":"module","title":"Kernel.SpecialForms","doc":"Special forms are the basic building blocks of Elixir, and therefore\ncannot be overridden by the developer.\n\nThe `Kernel.SpecialForms` module consists solely of macros that can be\ninvoked anywhere in Elixir code without the use of the\n`Kernel.SpecialForms.` prefix. This is possible because they all have\nbeen automatically imported, in the same fashion as the functions and\nmacros from the `Kernel` module.\n\nThese building blocks are defined in this module. Some of these special forms are lexical (such as\n`alias/2` and `case/2`). The macros `{}/1` and `<<>>/1` are also special\nforms used to define tuple and binary data structures respectively.\n\nThis module also documents macros that return information about Elixir's\ncompilation environment, such as (`__ENV__/0`, `__MODULE__/0`, `__DIR__/0`,\n`__STACKTRACE__/0`, and `__CALLER__/0`).\n\nAdditionally, it documents two special forms, `__block__/1` and\n`__aliases__/1`, which are not intended to be called directly by the\ndeveloper but they appear in quoted contents since they are essential\nin Elixir's constructs.","ref":"Kernel.SpecialForms.html"},{"type":"macro","title":"Kernel.SpecialForms.%/2","doc":"Matches on or builds a struct.\n\nA struct is a tagged map that allows developers to provide\ndefault values for keys, tags to be used in polymorphic\ndispatches and compile time assertions.\n\nStructs are usually defined with the `Kernel.defstruct/1` macro:\n\n    defmodule User do\n      defstruct name: \"john\", age: 27\n    end\n\nNow a struct can be created as follows:\n\n    %User{}\n\nUnderneath a struct is just a map with a `:__struct__` key\npointing to the `User` module:\n\n    %User{} == %{__struct__: User, name: \"john\", age: 27}\n\nThe struct fields can be given when building the struct:\n\n    %User{age: 31}\n    #=> %{__struct__: User, name: \"john\", age: 31}\n\nOr also on pattern matching to extract values out:\n\n    %User{age: age} = user\n\nAn update operation specific for structs is also available:\n\n    %User{user | age: 28}\n\nThe advantage of structs is that they validate that the given\nkeys are part of the defined struct. The example below will fail\nbecause there is no key `:full_name` in the `User` struct:\n\n    %User{full_name: \"john doe\"}\n\nThe syntax above will guarantee the given keys are valid at\ncompilation time and it will guarantee at runtime the given\nargument is a struct, failing with `BadStructError` otherwise.\n\nAlthough structs are maps, by default structs do not implement\nany of the protocols implemented for maps. Check\n`Kernel.defprotocol/2` for more information on how structs\ncan be used with protocols for polymorphic dispatch. Also\nsee `Kernel.struct/2` and `Kernel.struct!/2` for examples on\nhow to create and update structs dynamically.","ref":"Kernel.SpecialForms.html#%25/2"},{"type":"macro","title":"Pattern matching on struct names - Kernel.SpecialForms.%/2","doc":"Besides allowing pattern matching on struct fields, such as:\n\n    %User{age: age} = user\n\nStructs also allow pattern matching on the struct name:\n\n    %struct_name{} = user\n    struct_name #=> User\n\nYou can also assign the struct name to `_` when you want to\ncheck if something is a struct but you are not interested in\nits name:\n\n    %_{} = user","ref":"Kernel.SpecialForms.html#%25/2-pattern-matching-on-struct-names"},{"type":"macro","title":"Kernel.SpecialForms.%{}/1","doc":"Creates a map.\n\nSee the `Map` module for more information about maps, their syntax, and ways to\naccess and manipulate them.","ref":"Kernel.SpecialForms.html#%25%7B%7D/1"},{"type":"macro","title":"AST representation - Kernel.SpecialForms.%{}/1","doc":"Regardless of whether `=>` or the keyword syntax is used, key-value pairs in\nmaps are always represented internally as a list of two-element tuples for\nsimplicity:\n\n    iex> quote do\n    ...>   %{\"a\" => :b, c: :d}\n    ...> end\n    {:%{}, [], [{\"a\", :b}, {:c, :d}]}","ref":"Kernel.SpecialForms.html#%25%7B%7D/1-ast-representation"},{"type":"macro","title":"Kernel.SpecialForms.&/1","doc":"Capture operator. Captures or creates an anonymous function.","ref":"Kernel.SpecialForms.html#&/1"},{"type":"macro","title":"Capture - Kernel.SpecialForms.&/1","doc":"The capture operator is most commonly used to capture a\nfunction with given name and arity from a module:\n\n    iex> fun = &Kernel.is_atom/1\n    iex> fun.(:atom)\n    true\n    iex> fun.(\"string\")\n    false\n\nIn the example above, we captured `Kernel.is_atom/1` as an\nanonymous function and then invoked it.\n\nThe capture operator can also be used to capture local functions,\nincluding private ones, and imported functions by omitting the\nmodule name:\n\n    &local_function/1\n\nSee also `Function.capture/3`.","ref":"Kernel.SpecialForms.html#&/1-capture"},{"type":"macro","title":"Anonymous functions - Kernel.SpecialForms.&/1","doc":"The capture operator can also be used to partially apply\nfunctions, where `&1`, `&2` and so on can be used as value\nplaceholders. For example:\n\n    iex> double = &(&1 * 2)\n    iex> double.(2)\n    4\n\nIn other words, `&(&1 * 2)` is equivalent to `fn x -> x * 2 end`.\n\nWe can partially apply a remote function with placeholder:\n\n    iex> take_five = &Enum.take(&1, 5)\n    iex> take_five.(1..10)\n    [1, 2, 3, 4, 5]\n\nAnother example while using an imported or local function:\n\n    iex> first_elem = &elem(&1, 0)\n    iex> first_elem.({0, 1})\n    0\n\nThe `&` operator can be used with more complex expressions:\n\n    iex> fun = &(&1 + &2 + &3)\n    iex> fun.(1, 2, 3)\n    6\n\nAs well as with lists and tuples:\n\n    iex> fun = &{&1, &2}\n    iex> fun.(1, 2)\n    {1, 2}\n\n    iex> fun = &[&1 | &2]\n    iex> fun.(1, [2, 3])\n    [1, 2, 3]\n\nThe only restrictions when creating anonymous functions is that at\nleast one placeholder must be present, i.e. it must contain at least\n`&1`, and that block expressions are not supported:\n\n    # No placeholder, fails to compile.\n    &(:foo)\n\n    # Block expression, fails to compile.\n    &(&1; &2)","ref":"Kernel.SpecialForms.html#&/1-anonymous-functions"},{"type":"macro","title":"Kernel.SpecialForms../2","doc":"Dot operator. Defines a remote call, a call to an anonymous function, or an alias.\n\nThe dot (`.`) in Elixir can be used for remote calls:\n\n    iex> String.downcase(\"FOO\")\n    \"foo\"\n\nIn this example above, we have used `.` to invoke `downcase` in the\n`String` module, passing `\"FOO\"` as argument.\n\nThe dot may be used to invoke anonymous functions too:\n\n    iex> (fn n -> n end).(7)\n    7\n\nin which case there is a function on the left hand side.\n\nWe can also use the dot for creating aliases:\n\n    iex> Hello.World\n    Hello.World\n\nThis time, we have joined two aliases, defining the final alias\n`Hello.World`.","ref":"Kernel.SpecialForms.html#./2"},{"type":"macro","title":"Syntax - Kernel.SpecialForms../2","doc":"The right side of `.` may be a word starting with an uppercase letter, which represents\nan alias, a word starting with lowercase or underscore, any valid language\noperator or any name wrapped in single- or double-quotes. Those are all valid\nexamples:\n\n    iex> Kernel.Sample\n    Kernel.Sample\n\n    iex> Kernel.length([1, 2, 3])\n    3\n\n    iex> Kernel.+(1, 2)\n    3\n\n    iex> Kernel.\"+\"(1, 2)\n    3\n\nWrapping the function name in single- or double-quotes is always a\nremote call. Therefore `Kernel.\"Foo\"` will attempt to call the function \"Foo\"\nand not return the alias `Kernel.Foo`. This is done by design as module names\nare more strict than function names.\n\nWhen the dot is used to invoke an anonymous function there is only one\noperand, but it is still written using a postfix notation:\n\n    iex> negate = fn n -> -n end\n    iex> negate.(7)\n    -7","ref":"Kernel.SpecialForms.html#./2-syntax"},{"type":"macro","title":"Quoted expression - Kernel.SpecialForms../2","doc":"When `.` is used, the quoted expression may take two distinct\nforms. When the right side starts with a lowercase letter (or\nunderscore):\n\n    iex> quote do\n    ...>   String.downcase(\"FOO\")\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n\nNote that we have an inner tuple, containing the atom `:.` representing\nthe dot as first element:\n\n    {:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}\n\nThis tuple follows the general quoted expression structure in Elixir,\nwith the name as first argument, some keyword list as metadata as second,\nand the list of arguments as third. In this case, the arguments are the\nalias `String` and the atom `:downcase`. The second argument in a remote call\nis **always** an atom.\n\nIn the case of calls to anonymous functions, the inner tuple with the dot\nspecial form has only one argument, reflecting the fact that the operator is\nunary:\n\n    iex> quote do\n    ...>   negate.(0)\n    ...> end\n    {{:., [], [{:negate, [], __MODULE__}]}, [], [0]}\n\nWhen the right side is an alias (i.e. starts with uppercase), we get instead:\n\n    iex> quote do\n    ...>   Hello.World\n    ...> end\n    {:__aliases__, [alias: false], [:Hello, :World]}\n\nWe go into more details about aliases in the `__aliases__/1` special form\ndocumentation.","ref":"Kernel.SpecialForms.html#./2-quoted-expression"},{"type":"macro","title":"Unquoting - Kernel.SpecialForms../2","doc":"We can also use unquote to generate a remote call in a quoted expression:\n\n    iex> x = :downcase\n    iex> quote do\n    ...>   String.unquote(x)(\"FOO\")\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n\nSimilar to `Kernel.\"FUNCTION_NAME\"`, `unquote(x)` will always generate a remote call,\nindependent of the value of `x`. To generate an alias via the quoted expression,\none needs to rely on `Module.concat/2`:\n\n    iex> x = Sample\n    iex> quote do\n    ...>   Module.concat(String, unquote(x))\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n     [{:__aliases__, [alias: false], [:String]}, Sample]}","ref":"Kernel.SpecialForms.html#./2-unquoting"},{"type":"macro","title":"Kernel.SpecialForms.__aliases__/1","doc":"Internal special form to hold aliases information.\n\nIt is usually compiled to an atom:\n\n    iex> quote do\n    ...>   Foo.Bar\n    ...> end\n    {:__aliases__, [alias: false], [:Foo, :Bar]}\n\nElixir represents `Foo.Bar` as `__aliases__` so calls can be\nunambiguously identified by the operator `:.`. For example:\n\n    iex> quote do\n    ...>   Foo.bar()\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}\n\nWhenever an expression iterator sees a `:.` as the tuple key,\nit can be sure that it represents a call and the second argument\nin the list is an atom.\n\nOn the other hand, aliases hold some properties:\n\n  1. The head element of aliases can be any term that must expand to\n     an atom at compilation time.\n\n  2. The tail elements of aliases are guaranteed to always be atoms.\n\n  3. When the head element of aliases is the atom `:Elixir`, no expansion happens.","ref":"Kernel.SpecialForms.html#__aliases__/1"},{"type":"macro","title":"Kernel.SpecialForms.__block__/1","doc":"Internal special form for block expressions.\n\nThis is the special form used whenever we have a block\nof expressions in Elixir. This special form is private\nand should not be invoked directly:\n\n    iex> quote do\n    ...>   1\n    ...>   2\n    ...>   3\n    ...> end\n    {:__block__, [], [1, 2, 3]}","ref":"Kernel.SpecialForms.html#__block__/1"},{"type":"macro","title":"Kernel.SpecialForms.__CALLER__/0","doc":"Returns the current calling environment as a `Macro.Env` struct.\n\nIn the environment you can access the filename, line numbers,\nset up aliases, the function and others.","ref":"Kernel.SpecialForms.html#__CALLER__/0"},{"type":"macro","title":"Kernel.SpecialForms.__cursor__/1","doc":"Internal special form for cursor position.\n\nThis is the special form used whenever we need to represent\nthe cursor position in Elixir's AST. See `Code.Fragment` for\nmore information.","ref":"Kernel.SpecialForms.html#__cursor__/1"},{"type":"macro","title":"Kernel.SpecialForms.__DIR__/0","doc":"Returns the absolute path of the directory of the current file as a binary.\n\nAlthough the directory can be accessed as `Path.dirname(__ENV__.file)`,\nthis macro is a convenient shortcut.","ref":"Kernel.SpecialForms.html#__DIR__/0"},{"type":"macro","title":"Kernel.SpecialForms.__ENV__/0","doc":"Returns the current environment information as a `Macro.Env` struct.\n\nIn the environment you can access the current filename,\nline numbers, set up aliases, the current function and others.","ref":"Kernel.SpecialForms.html#__ENV__/0"},{"type":"macro","title":"Kernel.SpecialForms.__MODULE__/0","doc":"Returns the current module name as an atom or `nil` otherwise.\n\nAlthough the module can be accessed in the `__ENV__/0`, this macro\nis a convenient shortcut.","ref":"Kernel.SpecialForms.html#__MODULE__/0"},{"type":"macro","title":"Kernel.SpecialForms.__STACKTRACE__/0","doc":"Returns the stacktrace for the currently handled exception.\n\nIt is available only in the `catch` and `rescue` clauses of `try/1`\nexpressions.\n\nTo retrieve the stacktrace of the current process, use\n`Process.info(self(), :current_stacktrace)` instead.","ref":"Kernel.SpecialForms.html#__STACKTRACE__/0"},{"type":"macro","title":"Kernel.SpecialForms.::/2","doc":"Type operator. Used by types and bitstrings to specify types.\n\nThis operator is used in two distinct occasions in Elixir.\nIt is used in typespecs to specify the type of a variable,\nfunction or of a type itself:\n\n    @type number :: integer | float\n    @spec add(number, number) :: number\n\nIt may also be used in bit strings to specify the type\nof a given bit segment:\n\n    < > = bits\n\nRead the documentation on the [Typespecs page](typespecs.md) and\n`<<>>/1` for more information on typespecs and\nbitstrings respectively.","ref":"Kernel.SpecialForms.html#::/2"},{"type":"macro","title":"Kernel.SpecialForms.<<>>/1","doc":"Defines a new bitstring.","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1"},{"type":"macro","title":"Examples - Kernel.SpecialForms.<<>>/1","doc":"iex> <<1, 2, 3>>\n    <<1, 2, 3>>","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1-examples"},{"type":"macro","title":"Types - Kernel.SpecialForms.<<>>/1","doc":"A bitstring is made of many segments and each segment has a\ntype. There are 9 types used in bitstrings:\n\n- `integer`\n- `float`\n- `bits` (alias for `bitstring`)\n- `bitstring`\n- `binary`\n- `bytes` (alias for `binary`)\n- `utf8`\n- `utf16`\n- `utf32`\n\nWhen no type is specified, the default is `integer`:\n\n    iex> <<1, 2, 3>>\n    <<1, 2, 3>>\n\nElixir also accepts by default the segment to be a literal\nstring which expands to integers:\n\n    iex> <<0, \"foo\">>\n    <<0, 102, 111, 111>>\n\nYou can use one of `utf8` (the default), `utf16`, and `utf32` to\ncontrol how the string is encoded:\n\n    iex> <<\"foo\"::utf16>>\n    <<0, 102, 0, 111, 0, 111>>\n\nWhich is equivalent to writing:\n\n    iex> <<?f::utf16, ?o::utf16, ?o::utf16>>\n    <<0, 102, 0, 111, 0, 111>>\n\nAt runtime, binaries need to be explicitly tagged as `binary`:\n\n    iex> rest = \"oo\"\n    iex> <<102, rest::binary>>\n    \"foo\"\n\nOtherwise we get an `ArgumentError` when constructing the binary:\n\n    rest = \"oo\"\n    <<102, rest>>\n    ** (ArgumentError) argument error","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1-types"},{"type":"macro","title":"Options - Kernel.SpecialForms.<<>>/1","doc":"Many options can be given by using `-` as separator. Order is\narbitrary, so the following are all equivalent:\n\n    <<102::integer-native, rest::binary>>\n    <<102::native-integer, rest::binary>>\n    <<102::unsigned-big-integer, rest::binary>>\n    <<102::unsigned-big-integer-size(8), rest::binary>>\n    <<102::unsigned-big-integer-8, rest::binary>>\n    <<102::8-integer-big-unsigned, rest::binary>>\n    <<102, rest::binary>>","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1-options"},{"type":"macro","title":"Unit and Size - Kernel.SpecialForms.<<>>/1","doc":"The length of the match is equal to the `unit` (a number of bits) times the\n`size` (the number of repeated segments of length `unit`).\n\nType      | Default Unit\n--------- | ------------\n`integer` | 1 bit\n`float`   | 1 bit\n`binary`  | 8 bits\n\nSizes for types are a bit more nuanced. The default size for integers is 8.\n\nFor floats, it is 64. For floats, `size * unit` must result in 16, 32, or 64,\ncorresponding to [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point)\nbinary16, binary32, and binary64, respectively.\n\nFor binaries, the default is the size of the binary. Only the last binary in a\nmatch can use the default size. All others must have their size specified\nexplicitly, even if the match is unambiguous. For example:\n\n    iex> < > = <<\"Frank the Walrus\">>\n    \"Frank the Walrus\"\n    iex> {name, species}\n    {\"Frank\", \"Walrus\"}\n\nThe size can be a variable or any valid guard expression:\n\n    iex> name_size = 5\n    iex> < > = <<\"Frank the Walrus\">>\n    iex> {name, species}\n    {\"Frank\", \"Walrus\"}\n\nThe size can access prior variables defined in the binary itself:\n\n    iex> < > = <<5, \"Frank the Walrus\">>\n    iex> {name, species}\n    {\"Frank\", \"Walrus\"}\n\nHowever, it cannot access variables defined in the match outside of the binary/bitstring:\n\n    {name_size, < >} = {5, <<\"Frank the Walrus\">>}\n    ** (CompileError): undefined variable \"name_size\" in bitstring segment\n\nFailing to specify the size for the non-last causes compilation to fail:\n\n    < > = <<\"Frank the Walrus\">>\n    ** (CompileError): a binary field without size is only allowed at the end of a binary pattern\n\n#### Shortcut Syntax\n\nSize and unit can also be specified using a syntax shortcut\nwhen passing integer values:\n\n    iex> x = 1\n    iex> < > == < >\n    true\n    iex> < > == < >\n    true\n\nThis syntax reflects the fact the effective size is given by\nmultiplying the size by the unit.","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1-unit-and-size"},{"type":"macro","title":"Modifiers - Kernel.SpecialForms.<<>>/1","doc":"Some types have associated modifiers to clear up ambiguity in byte\nrepresentation.\n\nModifier             | Relevant Type(s)\n-------------------- | ----------------\n`signed`             | `integer`\n`unsigned` (default) | `integer`\n`little`             | `integer`, `float`, `utf16`, `utf32`\n`big` (default)      | `integer`, `float`, `utf16`, `utf32`\n`native`             | `integer`, `float`, `utf16`, `utf32`","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1-modifiers"},{"type":"macro","title":"Sign - Kernel.SpecialForms.<<>>/1","doc":"Integers can be `signed` or `unsigned`, defaulting to `unsigned`.\n\n    iex> < > = <<-100>>\n    <<156>>\n    iex> int\n    156\n    iex> < > = <<-100>>\n    <<156>>\n    iex> int\n    -100\n\n`signed` and `unsigned` are only used for matching binaries (see below) and\nare only used for integers.\n\n    iex> <<-100::signed, _rest::binary>> = <<-100, \"foo\">>\n    <<156, 102, 111, 111>>","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1-sign"},{"type":"macro","title":"Endianness - Kernel.SpecialForms.<<>>/1","doc":"Elixir has three options for endianness: `big`, `little`, and `native`.\nThe default is `big`:\n\n    iex> < > = <<0, 1>>\n    <<0, 1>>\n    iex> number\n    256\n    iex> < > = <<0, 1>>\n    <<0, 1>>\n    iex> number\n    1\n\n`native` is determined by the VM at startup and will depend on the\nhost operating system.","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1-endianness"},{"type":"macro","title":"Binary/Bitstring Matching - Kernel.SpecialForms.<<>>/1","doc":"Binary matching is a powerful feature in Elixir that is useful for extracting\ninformation from binaries as well as pattern matching.\n\nBinary matching can be used by itself to extract information from binaries:\n\n    iex> <<\"Hello, \", place::binary>> = \"Hello, World\"\n    \"Hello, World\"\n    iex> place\n    \"World\"\n\nOr as a part of function definitions to pattern match:\n\n    defmodule ImageType do\n      @png_signature <<137::size(8), 80::size(8), 78::size(8), 71::size(8),\n                       13::size(8), 10::size(8), 26::size(8), 10::size(8)>>\n      @jpg_signature <<255::size(8), 216::size(8)>>\n\n      def type(<<@png_signature, _rest::binary>>), do: :png\n      def type(<<@jpg_signature, _rest::binary>>), do: :jpg\n      def type(_), do: :unknown\n    end","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1-binary-bitstring-matching"},{"type":"macro","title":"Performance & Optimizations - Kernel.SpecialForms.<<>>/1","doc":"The Erlang compiler can provide a number of optimizations on binary creation\nand matching. To see optimization output, set the `bin_opt_info` compiler\noption:\n\n    ERL_COMPILER_OPTIONS=bin_opt_info mix compile\n\nTo learn more about specific optimizations and performance considerations,\ncheck out the\n[\"Constructing and matching binaries\" chapter of the Erlang's Efficiency Guide](https://www.erlang.org/doc/efficiency_guide/binaryhandling.html).","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1-performance-optimizations"},{"type":"macro","title":"Kernel.SpecialForms.=/2","doc":"Match operator. Matches the value on the right against the pattern on the left.","ref":"Kernel.SpecialForms.html#=/2"},{"type":"macro","title":"Kernel.SpecialForms.alias/2","doc":"`alias/2` is used to set up aliases, often useful with modules' names.","ref":"Kernel.SpecialForms.html#alias/2"},{"type":"macro","title":"Examples - Kernel.SpecialForms.alias/2","doc":"`alias/2` can be used to set up an alias for any module:\n\n    defmodule Math do\n      alias MyKeyword, as: Keyword\n    end\n\nIn the example above, we have set up `MyKeyword` to be aliased\nas `Keyword`. So now, any reference to `Keyword` will be\nautomatically replaced by `MyKeyword`.\n\nIn case one wants to access the original `Keyword`, it can be done\nby accessing `Elixir`:\n\n    Keyword.values #=> uses MyKeyword.values\n    Elixir.Keyword.values #=> uses Keyword.values\n\nNote that calling `alias` without the `:as` option automatically\nsets an alias based on the last part of the module. For example:\n\n    alias Foo.Bar.Baz\n\nIs the same as:\n\n    alias Foo.Bar.Baz, as: Baz\n\nWe can also alias multiple modules in one line:\n\n    alias Foo.{Bar, Baz, Biz}\n\nIs the same as:\n\n    alias Foo.Bar\n    alias Foo.Baz\n    alias Foo.Biz","ref":"Kernel.SpecialForms.html#alias/2-examples"},{"type":"macro","title":"Lexical scope - Kernel.SpecialForms.alias/2","doc":"`import/2`, `require/2` and `alias/2` are called directives and all\nhave lexical scope. This means you can set up aliases inside\nspecific functions and it won't affect the overall scope.","ref":"Kernel.SpecialForms.html#alias/2-lexical-scope"},{"type":"macro","title":"Warnings - Kernel.SpecialForms.alias/2","doc":"If you alias a module and you don't use the alias, Elixir is\ngoing to issue a warning implying the alias is not being used.\n\nIn case the alias is generated automatically by a macro,\nElixir won't emit any warnings though, since the alias\nwas not explicitly defined.\n\nBoth warning behaviors could be changed by explicitly\nsetting the `:warn` option to `true` or `false`.","ref":"Kernel.SpecialForms.html#alias/2-warnings"},{"type":"macro","title":"Kernel.SpecialForms.case/2","doc":"Matches the given expression against the given clauses.\n\n`case/2` relies on pattern matching and guards to choose\nwhich clause to execute. If your logic cannot be expressed\nwithin patterns and guards, consider using `if/2` or `cond/1`\ninstead.","ref":"Kernel.SpecialForms.html#case/2"},{"type":"macro","title":"Examples - Kernel.SpecialForms.case/2","doc":"case File.read(file) do\n      {:ok, contents} when is_binary(contents) ->\n        String.split(contents, \"\\n\")\n\n      {:error, _reason} ->\n        Logger.warning \"could not find #{file}, assuming empty...\"\n        []\n    end\n\nIn the example above, we match the result of `File.read/1`\nagainst each clause \"head\" and execute the clause \"body\"\ncorresponding to the first clause that matches.\n\nIf no clause matches, an error is raised. For this reason,\nit may be necessary to add a final catch-all clause (like `_`)\nwhich will always match.\n\n    x = 10\n\n    case x do\n      0 ->\n        \"This clause won't match\"\n\n      _ ->\n        \"This clause would match any value (x = #{x})\"\n    end\n    #=> \"This clause would match any value (x = 10)\"\n\nIf you find yourself nesting `case` expressions inside\n`case` expressions, consider using `with/1`.","ref":"Kernel.SpecialForms.html#case/2-examples"},{"type":"macro","title":"Variable handling - Kernel.SpecialForms.case/2","doc":"Note that variables bound in a clause do not leak to the outer context:\n\n    case data do\n      {:ok, value} -> value\n      :error -> nil\n    end\n\n    value\n    #=> unbound variable value\n\nVariables in the outer context cannot be overridden either:\n\n    value = 7\n\n    case lucky? do\n      false -> value = 13\n      true -> true\n    end\n\n    value\n    #=> 7\n\nIn the example above, `value` is going to be `7` regardless of the value of\n`lucky?`. The variable `value` bound in the clause and the variable `value`\nbound in the outer context are two entirely separate variables.\n\nIf you want to pattern match against an existing variable,\nyou need to use the `^/1` operator:\n\n    x = 1\n\n    case 10 do\n      ^x -> \"Won't match\"\n      _ -> \"Will match\"\n    end\n    #=> \"Will match\"","ref":"Kernel.SpecialForms.html#case/2-variable-handling"},{"type":"macro","title":"Using guards to match against multiple values - Kernel.SpecialForms.case/2","doc":"While it is not possible to match against multiple patterns in a single\nclause, it's possible to match against multiple values by using guards:\n\n    case data do\n      value when value in [:one, :two] ->\n        \"#{value} has been matched\"\n\n      :three ->\n        \"three has been matched\"\n    end","ref":"Kernel.SpecialForms.html#case/2-using-guards-to-match-against-multiple-values"},{"type":"macro","title":"Kernel.SpecialForms.cond/1","doc":"Evaluates the expression corresponding to the first clause that\nevaluates to a truthy value.","ref":"Kernel.SpecialForms.html#cond/1"},{"type":"macro","title":"Examples - Kernel.SpecialForms.cond/1","doc":"The following example has a single clause that always evaluates\nto true:\n\n    cond do\n      hd([1, 2, 3]) ->\n        \"1 is considered as true\"\n    end\n    #=> \"1 is considered as true\"\n\nIf all clauses evaluate to `nil` or `false`, `cond` raises an error.\nFor this reason, it may be necessary to add a final always-truthy condition\n(anything non-`false` and non-`nil`), which will always match:\n\n    cond do\n      1 + 1 == 1 ->\n        \"This will never match\"\n      2 * 2 != 4 ->\n        \"Nor this\"\n      true ->\n        \"This will\"\n    end\n    #=> \"This will\"\n\n\nIf your `cond` has two clauses, and the last one falls back to\n`true`, you may consider using `if/2` instead.","ref":"Kernel.SpecialForms.html#cond/1-examples"},{"type":"macro","title":"Kernel.SpecialForms.fn/1","doc":"Defines an anonymous function.\n\nSee `Function` for more information.","ref":"Kernel.SpecialForms.html#fn/1"},{"type":"macro","title":"Examples - Kernel.SpecialForms.fn/1","doc":"iex> add = fn a, b -> a + b end\n    iex> add.(1, 2)\n    3\n\nAnonymous functions can also have multiple clauses. All clauses\nshould expect the same number of arguments:\n\n    iex> negate = fn\n    ...>   true -> false\n    ...>   false -> true\n    ...> end\n    iex> negate.(false)\n    true","ref":"Kernel.SpecialForms.html#fn/1-examples"},{"type":"macro","title":"Kernel.SpecialForms.for/1","doc":"Comprehensions allow you to quickly build a data structure from\nan enumerable or a bitstring.\n\nLet's start with an example:\n\n    iex> for n <- [1, 2, 3, 4], do: n * 2\n    [2, 4, 6, 8]\n\nA comprehension accepts many generators and filters. `for` uses\nthe `<-` operator to extract values from the enumerable on its\nright side and match them against the pattern on the left.\nWe call them generators:\n\n    # A list generator:\n    iex> for n <- [1, 2, 3, 4], do: n * 2\n    [2, 4, 6, 8]\n\n    # A comprehension with two generators\n    iex> for x <- [1, 2], y <- [2, 3], do: x * y\n    [2, 3, 4, 6]\n\nFilters can also be given:\n\n    # A comprehension with a generator and a filter\n    iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n    [2, 4, 6]\n\nFilters must evaluate to truthy values (everything but `nil`\nand `false`). If a filter is falsy, then the current value is\ndiscarded.\n\nGenerators can also be used to filter as it removes any value\nthat doesn't match the pattern on the left side of `<-`:\n\n    iex> users = [user: \"john\", admin: \"meg\", guest: \"barbara\"]\n    iex> for {type, name} when type != :guest <- users do\n    ...>   String.upcase(name)\n    ...> end\n    [\"JOHN\", \"MEG\"]\n\nBitstring generators are also supported and are very useful when you\nneed to organize bitstring streams:\n\n    iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\n    iex> for < >, do: {r, g, b}\n    [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]\n\nVariable assignments inside the comprehension, be it in generators,\nfilters or inside the block, are not reflected outside of the\ncomprehension.\n\nVariable assignments inside filters must still return a truthy value,\notherwise values are discarded. Let's see an example. Imagine you have\na keyword list where the key is a programming language and the value\nis its direct parent. Then let's try to compute the grandparent of each\nlanguage. You could try this:\n\n    iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil]\n    iex> for {language, parent} <- languages, grandparent = languages[parent], do: {language, grandparent}\n    [elixir: :prolog]\n\nGiven the grandparents of Erlang and Prolog were nil, those values were\nfiltered out. If you don't want this behavior, a simple option is to\nmove the filter inside the do-block:\n\n    iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil]\n    iex> for {language, parent} <- languages do\n    ...>   grandparent = languages[parent]\n    ...>   {language, grandparent}\n    ...> end\n    [elixir: :prolog, erlang: nil, prolog: nil]\n\nHowever, such option is not always available, as you may have further\nfilters. An alternative is to convert the filter into a generator by\nwrapping the right side of `=` in a list:\n\n    iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil]\n    iex> for {language, parent} <- languages, grandparent <- [languages[parent]], do: {language, grandparent}\n    [elixir: :prolog, erlang: nil, prolog: nil]","ref":"Kernel.SpecialForms.html#for/1"},{"type":"macro","title":"The `:into` and `:uniq` options - Kernel.SpecialForms.for/1","doc":"In the examples above, the result returned by the comprehension was\nalways a list. The returned result can be configured by passing an\n`:into` option, that accepts any structure as long as it implements\nthe `Collectable` protocol.\n\nFor example, we can use bitstring generators with the `:into` option\nto easily remove all spaces in a string:\n\n    iex> for < >, c != ?\\s, into: \"\", do: < >\n    \"helloworld\"\n\nThe `IO` module provides streams, that are both `Enumerable` and\n`Collectable`, here is an upcase echo server using comprehensions:\n\n    for line <- IO.stream(), into: IO.stream() do\n      String.upcase(line)\n    end\n\nSimilarly, `uniq: true` can also be given to comprehensions to guarantee\nthe results are only added to the collection if they were not returned\nbefore. For example:\n\n    iex> for x <- [1, 1, 2, 3], uniq: true, do: x * 2\n    [2, 4, 6]\n\n    iex> for < >, uniq: true, into: \"\", do: < >\n    \"ABC\"","ref":"Kernel.SpecialForms.html#for/1-the-into-and-uniq-options"},{"type":"macro","title":"The `:reduce` option - Kernel.SpecialForms.for/1","doc":"*Available since Elixir v1.8*.\n\nWhile the `:into` option allows us to customize the comprehension behavior\nto a given data type, such as putting all of the values inside a map or inside\na binary, it is not always enough.\n\nFor example, imagine that you have a binary with letters where you want to\ncount how many times each lowercase letter happens, ignoring all uppercase\nones. For instance, for the string `\"AbCabCABc\"`, we want to return the map\n`%{\"a\" => 1, \"b\" => 2, \"c\" => 1}`.\n\nIf we were to use `:into`, we would need a data type that computes the\nfrequency of each element it holds. While there is no such data type in\nElixir, you could implement one yourself.\n\nA simpler option would be to use comprehensions for the mapping and\nfiltering of letters, and then we invoke `Enum.reduce/3` to build a map,\nfor example:\n\n    iex> letters = for < >, x in ?a..?z, do: < >\n    iex> Enum.reduce(letters, %{}, fn x, acc -> Map.update(acc, x, 1, & &1 + 1) end)\n    %{\"a\" => 1, \"b\" => 2, \"c\" => 1}\n\nWhile the above is straight-forward, it has the downside of traversing the\ndata at least twice. If you are expecting long strings as inputs, this can\nbe quite expensive.\n\nLuckily, comprehensions also support the `:reduce` option, which would allow\nus to fuse both steps above into a single step:\n\n    iex> for < >, x in ?a..?z, reduce: %{} do\n    ...>   acc -> Map.update(acc, < >, 1, & &1 + 1)\n    ...> end\n    %{\"a\" => 1, \"b\" => 2, \"c\" => 1}\n\nWhen the `:reduce` key is given, its value is used as the initial accumulator\nand the `do` block must be changed to use `->` clauses, where the left side\nof `->` receives the accumulated value of the previous iteration and the\nexpression on the right side must return the new accumulator value. Once there are no more\nelements, the final accumulated value is returned. If there are no elements\nat all, then the initial accumulator value is returned.","ref":"Kernel.SpecialForms.html#for/1-the-reduce-option"},{"type":"macro","title":"Kernel.SpecialForms.import/2","doc":"Imports functions and macros from other modules.\n\n`import/2` allows one to easily access functions or macros from\nother modules without using the qualified name.","ref":"Kernel.SpecialForms.html#import/2"},{"type":"macro","title":"Examples - Kernel.SpecialForms.import/2","doc":"If you are using several functions from a given module, you can\nimport those functions and reference them as local functions,\nfor example:\n\n    iex> import List\n    iex> flatten([1, [2], 3])\n    [1, 2, 3]","ref":"Kernel.SpecialForms.html#import/2-examples"},{"type":"macro","title":"Selector - Kernel.SpecialForms.import/2","doc":"By default, Elixir imports functions and macros from the given\nmodule, except the ones starting with an underscore (which are\nusually callbacks):\n\n    import List\n\nA developer can filter to import only functions, macros, or sigils\n(which can be functions or macros) via the `:only` option:\n\n    import List, only: :functions\n    import List, only: :macros\n    import Kernel, only: :sigils\n\nAlternatively, Elixir allows a developer to pass pairs of\nname/arities to `:only` or `:except` as a fine grained control\non what to import (or not):\n\n    import List, only: [flatten: 1]\n    import String, except: [split: 2]\n\nImporting the same module again will erase the previous imports,\nexcept when the `except` option is used, which is always exclusive\non a previously declared `import/2`. If there is no previous import,\nthen it applies to all functions and macros in the module. For\nexample:\n\n    import List, only: [flatten: 1, keyfind: 4]\n    import List, except: [flatten: 1]\n\nAfter the two import calls above, only `List.keyfind/4` will be\nimported.","ref":"Kernel.SpecialForms.html#import/2-selector"},{"type":"macro","title":"Underscore functions - Kernel.SpecialForms.import/2","doc":"By default functions starting with `_` are not imported. If you really want\nto import a function starting with `_` you must explicitly include it in the\n`:only` selector.\n\n    import File.Stream, only: [__build__: 3]","ref":"Kernel.SpecialForms.html#import/2-underscore-functions"},{"type":"macro","title":"Lexical scope - Kernel.SpecialForms.import/2","doc":"It is important to note that `import/2` is lexical. This means you\ncan import specific macros inside specific functions:\n\n    defmodule Math do\n      def some_function do\n        # 1) Disable \"if/2\" from Kernel\n        import Kernel, except: [if: 2]\n\n        # 2) Require the new \"if/2\" macro from MyMacros\n        import MyMacros\n\n        # 3) Use the new macro\n        if do_something, it_works\n      end\n    end\n\nIn the example above, we imported macros from `MyMacros`,\nreplacing the original `if/2` implementation by our own\nwithin that specific function. All other functions in that\nmodule will still be able to use the original one.","ref":"Kernel.SpecialForms.html#import/2-lexical-scope"},{"type":"macro","title":"Warnings - Kernel.SpecialForms.import/2","doc":"If you import a module and you don't use any of the imported\nfunctions or macros from this module, Elixir is going to issue\na warning implying the import is not being used.\n\nIn case the import is generated automatically by a macro,\nElixir won't emit any warnings though, since the import\nwas not explicitly defined.\n\nBoth warning behaviors could be changed by explicitly\nsetting the `:warn` option to `true` or `false`.","ref":"Kernel.SpecialForms.html#import/2-warnings"},{"type":"macro","title":"Ambiguous function/macro names - Kernel.SpecialForms.import/2","doc":"If two modules `A` and `B` are imported and they both contain\na `foo` function with an arity of `1`, an error is only emitted\nif an ambiguous call to `foo/1` is actually made; that is, the\nerrors are emitted lazily, not eagerly.","ref":"Kernel.SpecialForms.html#import/2-ambiguous-function-macro-names"},{"type":"macro","title":"Kernel.SpecialForms.quote/2","doc":"Gets the representation of any expression.","ref":"Kernel.SpecialForms.html#quote/2"},{"type":"macro","title":"Examples - Kernel.SpecialForms.quote/2","doc":"iex> quote do\n    ...>   sum(1, 2, 3)\n    ...> end\n    {:sum, [], [1, 2, 3]}","ref":"Kernel.SpecialForms.html#quote/2-examples"},{"type":"macro","title":"Elixir's AST (Abstract Syntax Tree) - Kernel.SpecialForms.quote/2","doc":"Any Elixir code can be represented using Elixir data structures.\nThe building block of Elixir macros is a tuple with three elements,\nfor example:\n\n    {:sum, [], [1, 2, 3]}\n\nThe tuple above represents a function call to `sum` passing 1, 2 and\n3 as arguments. The tuple elements are:\n\n  * The first element of the tuple is always an atom or\n    another tuple in the same representation.\n\n  * The second element of the tuple represents [metadata](`t:Macro.metadata/0`).\n\n  * The third element of the tuple are the arguments for the\n    function call. The third argument may be an atom, which is\n    usually a variable (or a local call).\n\nBesides the tuple described above, Elixir has a few literals that\nare also part of its AST. Those literals return themselves when\nquoted. They are:\n\n    :sum         #=> Atoms\n    1            #=> Integers\n    2.0          #=> Floats\n    [1, 2]       #=> Lists\n    \"strings\"    #=> Strings\n    {key, value} #=> Tuples with two elements\n\nAny other value, such as a map or a four-element tuple, must be escaped\n(`Macro.escape/1`) before being introduced into an AST.","ref":"Kernel.SpecialForms.html#quote/2-elixir-s-ast-abstract-syntax-tree"},{"type":"macro","title":"Options - Kernel.SpecialForms.quote/2","doc":"* `:bind_quoted` - passes a binding to the macro. Whenever a binding is\n    given, `unquote/1` is automatically disabled.\n\n  * `:context` - sets the resolution context.\n\n  * `:generated` - marks the given chunk as generated so it does not emit warnings.\n    It is also useful to avoid dialyzer reporting errors when macros generate\n    unused clauses.\n\n  * `:file` - sets the quoted expressions to have the given file.\n\n  * `:line` - sets the quoted expressions to have the given line.\n\n  * `:location` - when set to `:keep`, keeps the current line and file from\n    quote. Read the \"Stacktrace information\" section below for more information.\n\n  * `:unquote` - when `false`, disables unquoting. This means any `unquote`\n    call will be kept as is in the AST, instead of replaced by the `unquote`\n    arguments. For example:\n\n        iex> quote do\n        ...>   unquote(\"hello\")\n        ...> end\n        \"hello\"\n\n        iex> quote unquote: false do\n        ...>   unquote(\"hello\")\n        ...> end\n        {:unquote, [], [\"hello\"]}","ref":"Kernel.SpecialForms.html#quote/2-options"},{"type":"macro","title":"Quote and macros - Kernel.SpecialForms.quote/2","doc":"`quote/2` is commonly used with macros for code generation. As an exercise,\nlet's define a macro that multiplies a number by itself (squared). In practice,\nthere is no reason to define such a macro (and it would actually be\nseen as a bad practice), but it is simple enough that it allows us to focus\non the important aspects of quotes and macros:\n\n    defmodule Math do\n      defmacro squared(x) do\n        quote do\n          unquote(x) * unquote(x)\n        end\n      end\n    end\n\nWe can invoke it as:\n\n    import Math\n    IO.puts(\"Got #{squared(5)}\")\n\nAt first, there is nothing in this example that actually reveals it is a\nmacro. But what is happening is that, at compilation time, `squared(5)`\nbecomes `5 * 5`. The argument `5` is duplicated in the produced code, we\ncan see this behavior in practice though because our macro actually has\na bug:\n\n    import Math\n    my_number = fn ->\n      IO.puts(\"Returning 5\")\n      5\n    end\n    IO.puts(\"Got #{squared(my_number.())}\")\n\nThe example above will print:\n\n    Returning 5\n    Returning 5\n    Got 25\n\nNotice how \"Returning 5\" was printed twice, instead of just once. This is\nbecause a macro receives an expression and not a value (which is what we\nwould expect in a regular function). This means that:\n\n    squared(my_number.())\n\nActually expands to:\n\n    my_number.() * my_number.()\n\nWhich invokes the function twice, explaining why we get the printed value\ntwice! In the majority of the cases, this is actually unexpected behavior,\nand that's why one of the first things you need to keep in mind when it\ncomes to macros is to **not unquote the same value more than once**.\n\nLet's fix our macro:\n\n    defmodule Math do\n      defmacro squared(x) do\n        quote do\n          x = unquote(x)\n          x * x\n        end\n      end\n    end\n\nNow invoking `squared(my_number.())` as before will print the value just\nonce.\n\nIn fact, this pattern is so common that most of the times you will want\nto use the `bind_quoted` option with `quote/2`:\n\n    defmodule Math do\n      defmacro squared(x) do\n        quote bind_quoted: [x: x] do\n          x * x\n        end\n      end\n    end\n\n`:bind_quoted` will translate to the same code as the example above.\n`:bind_quoted` can be used in many cases and is seen as good practice,\nnot only because it helps prevent us from running into common mistakes, but also\nbecause it allows us to leverage other tools exposed by macros, such as\nunquote fragments discussed in some sections below.\n\nBefore we finish this brief introduction, you will notice that, even though\nwe defined a variable `x` inside our quote:\n\n    quote do\n      x = unquote(x)\n      x * x\n    end\n\nWhen we call:\n\n    import Math\n    squared(5)\n    x\n    ** (CompileError) undefined variable \"x\"\n\nWe can see that `x` did not leak to the user context. This happens\nbecause Elixir macros are hygienic, a topic we will discuss at length\nin the next sections as well.","ref":"Kernel.SpecialForms.html#quote/2-quote-and-macros"},{"type":"macro","title":"Hygiene in variables - Kernel.SpecialForms.quote/2","doc":"Consider the following example:\n\n    defmodule Hygiene do\n      defmacro no_interference do\n        quote do\n          a = 1\n        end\n      end\n    end\n\n    require Hygiene\n\n    a = 10\n    Hygiene.no_interference()\n    a\n    #=> 10\n\nIn the example above, `a` returns 10 even if the macro\nis apparently setting it to 1 because variables defined\nin the macro do not affect the context the macro is executed in.\nIf you want to set or get a variable in the caller's context, you\ncan do it with the help of the `var!` macro:\n\n    defmodule NoHygiene do\n      defmacro interference do\n        quote do\n          var!(a) = 1\n        end\n      end\n    end\n\n    require NoHygiene\n\n    a = 10\n    NoHygiene.interference()\n    a\n    #=> 1\n\nYou cannot even access variables defined in the same module unless\nyou explicitly give it a context:\n\n    defmodule Hygiene do\n      defmacro write do\n        quote do\n          a = 1\n        end\n      end\n\n      defmacro read do\n        quote do\n          a\n        end\n      end\n    end\n\n    require Hygiene\n    Hygiene.write()\n    Hygiene.read()\n    ** (CompileError) undefined variable \"a\" (context Hygiene)\n\nFor such, you can explicitly pass the current module scope as\nargument:\n\n    defmodule ContextHygiene do\n      defmacro write do\n        quote do\n          var!(a, ContextHygiene) = 1\n        end\n      end\n\n      defmacro read do\n        quote do\n          var!(a, ContextHygiene)\n        end\n      end\n    end\n\n    require Hygiene\n    ContextHygiene.write()\n    ContextHygiene.read()\n    #=> 1\n\nThe contexts of a variable is identified by the third element of the tuple.\nThe default context is `nil` and `quote` assigns another context to all\nvariables within:\n\n    quote(do: var)\n    #=> {:var, [], Elixir}\n\nIn case of variables returned by macros, there may also be a `:counter` key\nin the metadata, which is used to further refine its contexts and guarantee\nisolation between macro invocations as seen in the previous example.","ref":"Kernel.SpecialForms.html#quote/2-hygiene-in-variables"},{"type":"macro","title":"Hygiene in aliases - Kernel.SpecialForms.quote/2","doc":"Aliases inside quote are hygienic by default.\nConsider the following example:\n\n    defmodule Hygiene do\n      alias Map, as: M\n\n      defmacro no_interference do\n        quote do\n          M.new()\n        end\n      end\n    end\n\n    require Hygiene\n    Hygiene.no_interference()\n    #=> %{}\n\nNote that, even though the alias `M` is not available\nin the context the macro is expanded, the code above works\nbecause `M` still expands to `Map`.\n\nSimilarly, even if we defined an alias with the same name\nbefore invoking a macro, it won't affect the macro's result:\n\n    defmodule Hygiene do\n      alias Map, as: M\n\n      defmacro no_interference do\n        quote do\n          M.new()\n        end\n      end\n    end\n\n    require Hygiene\n    alias SomethingElse, as: M\n    Hygiene.no_interference()\n    #=> %{}\n\nIn some cases, you want to access an alias or a module defined\nin the caller. For such, you can use the `alias!` macro:\n\n    defmodule Hygiene do\n      # This will expand to Elixir.Nested.hello()\n      defmacro no_interference do\n        quote do\n          Nested.hello()\n        end\n      end\n\n      # This will expand to Nested.hello() for\n      # whatever is Nested in the caller\n      defmacro interference do\n        quote do\n          alias!(Nested).hello()\n        end\n      end\n    end\n\n    defmodule Parent do\n      defmodule Nested do\n        def hello, do: \"world\"\n      end\n\n      require Hygiene\n      Hygiene.no_interference()\n      ** (UndefinedFunctionError) ...\n\n      Hygiene.interference()\n      #=> \"world\"\n    end","ref":"Kernel.SpecialForms.html#quote/2-hygiene-in-aliases"},{"type":"macro","title":"Hygiene in imports - Kernel.SpecialForms.quote/2","doc":"Similar to aliases, imports in Elixir are hygienic. Consider the\nfollowing code:\n\n    defmodule Hygiene do\n      defmacrop get_length do\n        quote do\n          length([1, 2, 3])\n        end\n      end\n\n      def return_length do\n        import Kernel, except: [length: 1]\n        get_length\n      end\n    end\n\n    Hygiene.return_length()\n    #=> 3\n\nNotice how `Hygiene.return_length/0` returns `3` even though the `Kernel.length/1`\nfunction is not imported. In fact, even if `return_length/0`\nimported a function with the same name and arity from another\nmodule, it wouldn't affect the function result:\n\n    def return_length do\n      import String, only: [length: 1]\n      get_length\n    end\n\nCalling this new `return_length/0` will still return `3` as result.\n\nElixir is smart enough to delay the resolution to the latest\npossible moment. So, if you call `length([1, 2, 3])` inside quote,\nbut no `length/1` function is available, it is then expanded in\nthe caller:\n\n    defmodule Lazy do\n      defmacrop get_length do\n        import Kernel, except: [length: 1]\n\n        quote do\n          length(\"hello\")\n        end\n      end\n\n      def return_length do\n        import Kernel, except: [length: 1]\n        import String, only: [length: 1]\n        get_length\n      end\n    end\n\n    Lazy.return_length()\n    #=> 5","ref":"Kernel.SpecialForms.html#quote/2-hygiene-in-imports"},{"type":"macro","title":"Stacktrace information - Kernel.SpecialForms.quote/2","doc":"When defining functions via macros, developers have the option of\nchoosing if runtime errors will be reported from the caller or from\ninside the quote. Let's see an example:\n\n    # adder.ex\n    defmodule Adder do\n      @doc \"Defines a function that adds two numbers\"\n      defmacro defadd do\n        quote location: :keep do\n          def add(a, b), do: a + b\n        end\n      end\n    end\n\n    # sample.ex\n    defmodule Sample do\n      import Adder\n      defadd\n    end\n\n    require Sample\n    Sample.add(:one, :two)\n    ** (ArithmeticError) bad argument in arithmetic expression\n        adder.ex:5: Sample.add/2\n\nWhen using `location: :keep` and invalid arguments are given to\n`Sample.add/2`, the stacktrace information will point to the file\nand line inside the quote. Without `location: :keep`, the error is\nreported to where `defadd` was invoked. `location: :keep` affects\nonly definitions inside the quote.\n\n> #### `location: :keep` and unquote {: .warning}\n>\n> Do not use `location: :keep` if the function definition\n> also `unquote`s some of the macro arguments. If you do so, Elixir\n> will store the file definition of the current location but the\n> unquoted arguments may contain line information of the macro caller,\n> leading to erroneous stacktraces.","ref":"Kernel.SpecialForms.html#quote/2-stacktrace-information"},{"type":"macro","title":"Binding and unquote fragments - Kernel.SpecialForms.quote/2","doc":"Elixir quote/unquote mechanisms provide a functionality called\nunquote fragments. Unquote fragments provide an easy way to generate\nfunctions on the fly. Consider this example:\n\n    kv = [foo: 1, bar: 2]\n    Enum.each(kv, fn {k, v} ->\n      def unquote(k)(), do: unquote(v)\n    end)\n\nIn the example above, we have generated the functions `foo/0` and\n`bar/0` dynamically. Now, imagine that we want to convert this\nfunctionality into a macro:\n\n    defmacro defkv(kv) do\n      Enum.map(kv, fn {k, v} ->\n        quote do\n          def unquote(k)(), do: unquote(v)\n        end\n      end)\n    end\n\nWe can invoke this macro as:\n\n    defkv [foo: 1, bar: 2]\n\nHowever, we can't invoke it as follows:\n\n    kv = [foo: 1, bar: 2]\n    defkv kv\n\nThis is because the macro is expecting its arguments to be a\nkeyword list at **compilation** time. Since in the example above\nwe are passing the representation of the variable `kv`, our\ncode fails.\n\nThis is actually a common pitfall when developing macros. We are\nassuming a particular shape in the macro. We can work around it\nby unquoting the variable inside the quoted expression:\n\n    defmacro defkv(kv) do\n      quote do\n        Enum.each(unquote(kv), fn {k, v} ->\n          def unquote(k)(), do: unquote(v)\n        end)\n      end\n    end\n\nIf you try to run our new macro, you will notice it won't\neven compile, complaining that the variables `k` and `v`\ndo not exist. This is because of the ambiguity: `unquote(k)`\ncan either be an unquote fragment, as previously, or a regular\nunquote as in `unquote(kv)`.\n\nOne solution to this problem is to disable unquoting in the\nmacro, however, doing that would make it impossible to inject the\n`kv` representation into the tree. That's when the `:bind_quoted`\noption comes to the rescue (again!). By using `:bind_quoted`, we\ncan automatically disable unquoting while still injecting the\ndesired variables into the tree:\n\n    defmacro defkv(kv) do\n      quote bind_quoted: [kv: kv] do\n        Enum.each(kv, fn {k, v} ->\n          def unquote(k)(), do: unquote(v)\n        end)\n      end\n    end\n\nIn fact, the `:bind_quoted` option is recommended every time\none desires to inject a value into the quote.","ref":"Kernel.SpecialForms.html#quote/2-binding-and-unquote-fragments"},{"type":"macro","title":"Kernel.SpecialForms.receive/1","doc":"Checks if there is a message matching any of the given clauses in the current\nprocess mailbox.\n\nIf there is no matching message, the current process waits until a matching\nmessage arrives or until after a given timeout value.\n\nAny new and existing messages that do not match will remain in the mailbox.","ref":"Kernel.SpecialForms.html#receive/1"},{"type":"macro","title":"Examples - Kernel.SpecialForms.receive/1","doc":"receive do\n      {:selector, number, name} when is_integer(number) ->\n        name\n      name when is_atom(name) ->\n        name\n      _ ->\n        IO.puts(:stderr, \"Unexpected message received\")\n    end\n\nAn optional `after` clause can be given in case no matching message is\nreceived during the given timeout period, specified in milliseconds:\n\n    receive do\n      {:selector, number, name} when is_integer(number) ->\n        name\n      name when is_atom(name) ->\n        name\n      _ ->\n        IO.puts(:stderr, \"Unexpected message received\")\n    after\n      5000 ->\n        IO.puts(:stderr, \"No message in 5 seconds\")\n    end\n\nThe `after` clause can be specified even if there are no match clauses.\nThe timeout value given to `after` can be any expression evaluating to\none of the allowed values:\n\n  * `:infinity` - the process should wait indefinitely for a matching\n    message, this is the same as not using the after clause\n\n  * `0` - if there is no matching message in the mailbox, the timeout\n    will occur immediately\n\n  * positive integer smaller than or equal to `4_294_967_295` (`0xFFFFFFFF`\n    in hexadecimal notation) - it should be possible to represent the timeout\n    value as an unsigned 32-bit integer.","ref":"Kernel.SpecialForms.html#receive/1-examples"},{"type":"macro","title":"Variable handling - Kernel.SpecialForms.receive/1","doc":"The `receive/1` special form handles variables exactly as the `case/2`\nspecial macro. For more information, check the docs for `case/2`.","ref":"Kernel.SpecialForms.html#receive/1-variable-handling"},{"type":"macro","title":"Kernel.SpecialForms.require/2","doc":"Requires a module in order to use its macros.","ref":"Kernel.SpecialForms.html#require/2"},{"type":"macro","title":"Examples - Kernel.SpecialForms.require/2","doc":"Public functions in modules are globally available, but in order to use\nmacros, you need to opt-in by requiring the module they are defined in.\n\nLet's suppose you created your own `if/2` implementation in the module\n`MyMacros`. If you want to invoke it, you need to first explicitly\nrequire the `MyMacros`:\n\n    defmodule Math do\n      require MyMacros\n      MyMacros.if do_something, it_works\n    end\n\nAn attempt to call a macro that was not loaded will raise an error.","ref":"Kernel.SpecialForms.html#require/2-examples"},{"type":"macro","title":"Alias shortcut - Kernel.SpecialForms.require/2","doc":"`require/2` also accepts `:as` as an option so it automatically sets\nup an alias. Please check `alias/2` for more information.","ref":"Kernel.SpecialForms.html#require/2-alias-shortcut"},{"type":"macro","title":"Kernel.SpecialForms.super/1","doc":"Calls the overridden function when overriding it with `Kernel.defoverridable/1`.\n\nSee `Kernel.defoverridable/1` for more information and documentation.","ref":"Kernel.SpecialForms.html#super/1"},{"type":"macro","title":"Kernel.SpecialForms.try/1","doc":"Evaluates the given expressions and handles any error, exit,\nor throw that may have happened.","ref":"Kernel.SpecialForms.html#try/1"},{"type":"macro","title":"Examples - Kernel.SpecialForms.try/1","doc":"try do\n      do_something_that_may_fail(some_arg)\n    rescue\n      ArgumentError ->\n        IO.puts(\"Invalid argument given\")\n    catch\n      value ->\n        IO.puts(\"Caught #{inspect(value)}\")\n    else\n      value ->\n        IO.puts(\"Success! The result was #{inspect(value)}\")\n    after\n      IO.puts(\"This is printed regardless if it failed or succeeded\")\n    end\n\nThe `rescue` clause is used to handle exceptions while the `catch`\nclause can be used to catch thrown values and exits.\nThe `else` clause can be used to control flow based on the result of\nthe expression. `catch`, `rescue`, and `else` clauses work based on\npattern matching (similar to the `case` special form).\n\nCalls inside `try/1` are not tail recursive since the VM needs to keep\nthe stacktrace in case an exception happens. To retrieve the stacktrace,\naccess `__STACKTRACE__/0` inside the `rescue` or `catch` clause.\n\n## `rescue` clauses\n\nBesides relying on pattern matching, `rescue` clauses provide some\nconveniences around exceptions that allow one to rescue an\nexception by its name. All the following formats are valid patterns\nin `rescue` clauses:\n\n    # Rescue a single exception without binding the exception\n    # to a variable\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      UndefinedFunctionError -> nil\n    end\n\n    # Rescue any of the given exception without binding\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      [UndefinedFunctionError, ArgumentError] -> nil\n    end\n\n    # Rescue and bind the exception to the variable \"x\"\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      x in [UndefinedFunctionError] -> nil\n    end\n\n    # Rescue all kinds of exceptions and bind the rescued exception\n    # to the variable \"x\"\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      x -> nil\n    end","ref":"Kernel.SpecialForms.html#try/1-examples"},{"type":"macro","title":"Erlang errors - Kernel.SpecialForms.try/1","doc":"Erlang errors are transformed into Elixir ones when rescuing:\n\n    try do\n      :erlang.error(:badarg)\n    rescue\n      ArgumentError -> :ok\n    end\n    #=> :ok\n\nThe most common Erlang errors will be transformed into their\nElixir counterpart. Those which are not will be transformed\ninto the more generic `ErlangError`:\n\n    try do\n      :erlang.error(:unknown)\n    rescue\n      ErlangError -> :ok\n    end\n    #=> :ok\n\nIn fact, `ErlangError` can be used to rescue any error that is\nnot a proper Elixir error. For example, it can be used to rescue\nthe earlier `:badarg` error too, prior to transformation:\n\n    try do\n      :erlang.error(:badarg)\n    rescue\n      ErlangError -> :ok\n    end\n    #=> :ok\n\n## `catch` clauses\n\nThe `catch` clause can be used to catch thrown values, exits, and errors.","ref":"Kernel.SpecialForms.html#try/1-erlang-errors"},{"type":"macro","title":"Catching thrown values - Kernel.SpecialForms.try/1","doc":"`catch` can be used to catch values thrown by `Kernel.throw/1`:\n\n    try do\n      throw(:some_value)\n    catch\n      thrown_value ->\n        IO.puts(\"A value was thrown: #{inspect(thrown_value)}\")\n    end","ref":"Kernel.SpecialForms.html#try/1-catching-thrown-values"},{"type":"macro","title":"Catching values of any kind - Kernel.SpecialForms.try/1","doc":"The `catch` clause also supports catching exits and errors. To do that, it\nallows matching on both the *kind* of the caught value as well as the value\nitself:\n\n    try do\n      exit(:shutdown)\n    catch\n      :exit, value ->\n        IO.puts(\"Exited with value #{inspect(value)}\")\n    end\n\n    try do\n      exit(:shutdown)\n    catch\n      kind, value when kind in [:exit, :throw] ->\n        IO.puts(\"Caught exit or throw with value #{inspect(value)}\")\n    end\n\nThe `catch` clause also supports `:error` alongside `:exit` and `:throw` as\nin Erlang, although this is commonly avoided in favor of `raise`/`rescue` control\nmechanisms. One reason for this is that when catching `:error`, the error is\nnot automatically transformed into an Elixir error:\n\n    try do\n      :erlang.error(:badarg)\n    catch\n      :error, :badarg -> :ok\n    end\n    #=> :ok\n\n## `after` clauses\n\nAn `after` clause allows you to define cleanup logic that will be invoked both\nwhen the block of code passed to `try/1` succeeds and also when an error is raised. Note\nthat the process will exit as usual when receiving an exit signal that causes\nit to exit abruptly and so the `after` clause is not guaranteed to be executed.\nLuckily, most resources in Elixir (such as open files, ETS tables, ports, sockets,\nand so on) are linked to or monitor the owning process and will automatically clean\nthemselves up if that process exits.\n\n    File.write!(\"tmp/story.txt\", \"Hello, World\")\n    try do\n      do_something_with(\"tmp/story.txt\")\n    after\n      File.rm(\"tmp/story.txt\")\n    end\n\nAlthough `after` clauses are invoked whether or not there was an error, they do not\nmodify the return value. All of the following examples return `:return_me`:\n\n    try do\n      :return_me\n    after\n      IO.puts(\"I will be printed\")\n      :not_returned\n    end\n\n    try do\n      raise \"boom\"\n    rescue\n      _ -> :return_me\n    after\n      IO.puts(\"I will be printed\")\n      :not_returned\n    end\n\n## `else` clauses\n\n`else` clauses allow the result of the body passed to `try/1` to be pattern\nmatched on:\n\n    x = 2\n    try do\n      1 / x\n    rescue\n      ArithmeticError ->\n        :infinity\n    else\n      y when y < 1 and y > -1 ->\n        :small\n      _ ->\n        :large\n    end\n\nIf an `else` clause is not present and no exceptions are raised,\nthe result of the expression will be returned:\n\n    x = 1\n    ^x =\n      try do\n        1 / x\n      rescue\n        ArithmeticError ->\n          :infinity\n      end\n\nHowever, when an `else` clause is present but the result of the expression\ndoes not match any of the patterns then an exception will be raised. This\nexception will not be caught by a `catch` or `rescue` in the same `try`:\n\n    x = 1\n    try do\n      try do\n        1 / x\n      rescue\n        # The TryClauseError cannot be rescued here:\n        TryClauseError ->\n          :error_a\n      else\n        0 ->\n          :small\n      end\n    rescue\n      # The TryClauseError is rescued here:\n      TryClauseError ->\n        :error_b\n    end\n\nSimilarly, an exception inside an `else` clause is not caught or rescued\ninside the same `try`:\n\n    try do\n      try do\n        nil\n      catch\n        # The exit(1) call below can not be caught here:\n        :exit, _ ->\n          :exit_a\n      else\n        _ ->\n          exit(1)\n      end\n    catch\n      # The exit is caught here:\n      :exit, _ ->\n        :exit_b\n    end\n\nThis means the VM no longer needs to keep the stacktrace once inside\nan `else` clause and so tail recursion is possible when using a `try`\nwith a tail call as the final call inside an `else` clause. The same\nis true for `rescue` and `catch` clauses.\n\nOnly the result of the tried expression falls down to the `else` clause.\nIf the `try` ends up in the `rescue` or `catch` clauses, their result\nwill not fall down to `else`:\n\n    try do\n      throw(:catch_this)\n    catch\n      :throw, :catch_this ->\n        :it_was_caught\n    else\n      # :it_was_caught will not fall down to this \"else\" clause.\n      other ->\n        {:else, other}\n    end","ref":"Kernel.SpecialForms.html#try/1-catching-values-of-any-kind"},{"type":"macro","title":"Variable handling - Kernel.SpecialForms.try/1","doc":"Since an expression inside `try` may not have been evaluated\ndue to an exception, any variable created inside `try` cannot\nbe accessed externally. For instance:\n\n    try do\n      x = 1\n      do_something_that_may_fail(same_arg)\n      :ok\n    catch\n      _, _ -> :failed\n    end\n\n    x\n    #=> unbound variable \"x\"\n\nIn the example above, `x` cannot be accessed since it was defined\ninside the `try` clause. A common practice to address this issue\nis to return the variables defined inside `try`:\n\n    x =\n      try do\n        x = 1\n        do_something_that_may_fail(same_arg)\n        x\n      catch\n        _, _ -> :failed\n      end","ref":"Kernel.SpecialForms.html#try/1-variable-handling"},{"type":"macro","title":"Kernel.SpecialForms.unquote/1","doc":"Unquotes the given expression inside a quoted expression.\n\nThis function expects a valid Elixir AST, also known as\nquoted expression, as argument. If you would like to `unquote`\nany value, such as a map or a four-element tuple, you should\ncall `Macro.escape/1` before unquoting.","ref":"Kernel.SpecialForms.html#unquote/1"},{"type":"macro","title":"Examples - Kernel.SpecialForms.unquote/1","doc":"Imagine the situation you have a quoted expression and\nyou want to inject it inside some quote. The first attempt\nwould be:\n\n    value =\n      quote do\n        13\n      end\n\n    quote do\n      sum(1, value, 3)\n    end\n\n\nWhich the argument for the `:sum` function call is not the\nexpected result:\n\n    {:sum, [], [1, {:value, [], Elixir}, 3]}\n\nFor this, we use `unquote`:\n\n    iex> value =\n    ...>   quote do\n    ...>     13\n    ...>   end\n    iex> quote do\n    ...>   sum(1, unquote(value), 3)\n    ...> end\n    {:sum, [], [1, 13, 3]}\n\nIf you want to unquote a value that is not a quoted expression,\nsuch as a map, you need to call `Macro.escape/1` before:\n\n    iex> value = %{foo: :bar}\n    iex> quote do\n    ...>   process_map(unquote(Macro.escape(value)))\n    ...> end\n    {:process_map, [], [{:%{}, [], [foo: :bar]}]}\n\nIf you forget to escape it, Elixir will raise an error\nwhen compiling the code.","ref":"Kernel.SpecialForms.html#unquote/1-examples"},{"type":"macro","title":"Kernel.SpecialForms.unquote_splicing/1","doc":"Unquotes the given list expanding its arguments.\n\nSimilar to `unquote/1`.","ref":"Kernel.SpecialForms.html#unquote_splicing/1"},{"type":"macro","title":"Examples - Kernel.SpecialForms.unquote_splicing/1","doc":"iex> values = [2, 3, 4]\n    iex> quote do\n    ...>   sum(1, unquote_splicing(values), 5)\n    ...> end\n    {:sum, [], [1, 2, 3, 4, 5]}","ref":"Kernel.SpecialForms.html#unquote_splicing/1-examples"},{"type":"macro","title":"Kernel.SpecialForms.with/1","doc":"Combine matching clauses.\n\nOne of the ways to understand with is to show which code\npatterns it improves. Imagine you have a map where the fields\n`width` and `height` are optional and you want to compute its\narea, as `{:ok, area}` or return `:error`. We could implement\nthis function as:\n\n    def area(opts) do\n      case Map.fetch(opts, :width) do\n        {:ok, width} ->\n          case Map.fetch(opts, :height) do\n            {:ok, height} -> {:ok, width * height}\n            :error -> :error\n          end\n\n        :error ->\n          :error\n      end\n    end\n\nwhen called as `area(%{width: 10, height: 15})`, it should return\n`{:ok, 150}`. If any of the fields are missing, it returns `:error`.\n\nWhile the code above works, it is quite verbose. Using `with`,\nwe could rewrite it as:\n\n    def area(opts) do\n      with {:ok, width} <- Map.fetch(opts, :width),\n           {:ok, height} <- Map.fetch(opts, :height) do\n        {:ok, width * height}\n      end\n    end\n\nInstead of defining nested `case`s with clauses, we use `with`\nalongside the `PATTERN <- EXPRESSION` operator to match\nexpressions on its right side against the pattern on the left.\nConsider `<-` as a sibling to `=`, except that, while `=` raises\nin case of not matches, `<-` will simply abort the `with` chain\nand return the non-matched value.\n\nLet's give it a try on IEx:\n\n    iex> opts = %{width: 10, height: 15}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, width * height}\n    ...> end\n    {:ok, 150}\n\nIf all clauses match, the `do` block is executed, returning its result.\nOtherwise the chain is aborted and the non-matched value is returned:\n\n    iex> opts = %{width: 10}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, width * height}\n    ...> end\n    :error\n\nGuards can be used in patterns as well:\n\n    iex> users = %{\"melany\" => \"guest\", \"bob\" => :admin}\n    iex> with {:ok, role} when not is_binary(role) <- Map.fetch(users, \"bob\") do\n    ...>   {:ok, to_string(role)}\n    ...> end\n    {:ok, \"admin\"}\n\nAs in `for/1`, variables bound inside `with/1` won't be accessible\noutside of `with/1`.\n\nExpressions without `<-` may also be used in clauses. For instance,\nyou can perform regular matches with the `=` operator:\n\n    iex> width = nil\n    iex> opts = %{width: 10, height: 15}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      double_width = width * 2,\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, double_width * height}\n    ...> end\n    {:ok, 300}\n    iex> width\n    nil\n\nThe behavior of any expression in a clause is the same as if it was\nwritten outside of `with`. For example, `=` will raise a `MatchError`\ninstead of returning the non-matched value:\n\n    with :foo = :bar, do: :ok\n    ** (MatchError) no match of right hand side value: :bar\n\nAs with any other function or macro call in Elixir, explicit parens can\nalso be used around the arguments before the `do`-`end` block:\n\n    iex> opts = %{width: 10, height: 15}\n    iex> with(\n    ...>   {:ok, width} <- Map.fetch(opts, :width),\n    ...>   {:ok, height} <- Map.fetch(opts, :height)\n    ...> ) do\n    ...>   {:ok, width * height}\n    ...> end\n    {:ok, 150}\n\nThe choice between parens and no parens is a matter of preference.","ref":"Kernel.SpecialForms.html#with/1"},{"type":"macro","title":"Else clauses - Kernel.SpecialForms.with/1","doc":"An `else` option can be given to modify what is being returned from\n`with` in the case of a failed match:\n\n    iex> opts = %{width: 10}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, width * height}\n    ...> else\n    ...>   :error ->\n    ...>     {:error, :wrong_data}\n    ...>\n    ...>   _other_error ->\n    ...>     :unexpected_error\n    ...> end\n    {:error, :wrong_data}\n\nThe `else` block works like a `case` clause: it can have multiple clauses,\nand the first match will be used. Variables bound inside `with` (such as\n`width` in this example) are not available in the `else` block.\n\nIf an `else` block is used and there are no matching clauses, a `WithClauseError`\nexception is raised.","ref":"Kernel.SpecialForms.html#with/1-else-clauses"},{"type":"macro","title":"Beware! - Kernel.SpecialForms.with/1","doc":"Keep in mind that, one of potential drawback of `with` is that all\nfailure clauses are flattened into a single `else` block. For example,\ntake this code that checks if a given path points to an Elixir file\nand that it exists before creating a backup copy:\n\n    with \".ex\" <- Path.extname(path),\n         true <- File.exists?(path) do\n      backup_path = path <> \".backup\"\n      File.cp!(path, backup_path)\n      {:ok, backup_path}\n    else\n      binary when is_binary(binary) ->\n        {:error, :invalid_extension}\n\n      false ->\n        {:error, :missing_file}\n    end\n\nNote how we are having to reconstruct the result types of `Path.extname/1`\nand `File.exists?/1` to build error messages. In this case, it is better\nto refactor the code so each `<-` already return the desired format in case\nof errors, like this:\n\n    with :ok <- validate_extension(path),\n         :ok <- validate_exists(path) do\n      backup_path = path <> \".backup\"\n      File.cp!(path, backup_path)\n      {:ok, backup_path}\n    end\n\n    defp validate_extension(path) do\n      if Path.extname(path) == \".ex\", do: :ok, else: {:error, :invalid_extension}\n    end\n\n    defp validate_exists(path) do\n      if File.exists?(path), do: :ok, else: {:error, :missing_file}\n    end\n\nNote how the code above is better organized and clearer once we\nmake sure each `<-` in `with` returns a normalized format.","ref":"Kernel.SpecialForms.html#with/1-beware"},{"type":"macro","title":"Kernel.SpecialForms.^/1","doc":"Pin operator. Accesses an already bound variable in match clauses.","ref":"Kernel.SpecialForms.html#%5E/1"},{"type":"macro","title":"Examples - Kernel.SpecialForms.^/1","doc":"Elixir allows variables to be rebound via static single assignment:\n\n    iex> x = 1\n    iex> x = x + 1\n    iex> x\n    2\n\nHowever, in some situations, it is useful to match against an existing\nvalue, instead of rebinding. This can be done with the `^` special form,\ncolloquially known as the pin operator:\n\n    iex> x = 1\n    iex> ^x = List.first([1])\n    iex> ^x = List.first([2])\n    ** (MatchError) no match of right hand side value: 2\n\nNote that `^x` always refers to the value of `x` prior to the match. The\nfollowing example will match:\n\n    iex> x = 0\n    iex> {x, ^x} = {1, 0}\n    iex> x\n    1","ref":"Kernel.SpecialForms.html#%5E/1-examples"},{"type":"macro","title":"Kernel.SpecialForms.{}/1","doc":"Creates a tuple.\n\nMore information about the tuple data type and about functions to manipulate\ntuples can be found in the `Tuple` module; some functions for working with\ntuples are also available in `Kernel` (such as `Kernel.elem/2` or\n`Kernel.tuple_size/1`).","ref":"Kernel.SpecialForms.html#%7B%7D/1"},{"type":"macro","title":"AST representation - Kernel.SpecialForms.{}/1","doc":"Only two-element tuples are considered literals in Elixir and return themselves\nwhen quoted. Therefore, all other tuples are represented in the AST as calls to\nthe `:{}` special form.\n\n    iex> quote do\n    ...>   {1, 2}\n    ...> end\n    {1, 2}\n\n    iex> quote do\n    ...>   {1, 2, 3}\n    ...> end\n    {:{}, [], [1, 2, 3]}","ref":"Kernel.SpecialForms.html#%7B%7D/1-ast-representation"},{"type":"module","title":"Atom","doc":"Atoms are constants whose values are their own name.\n\nThey are often useful to enumerate over distinct values, such as:\n\n    iex> :apple\n    :apple\n    iex> :orange\n    :orange\n    iex> :watermelon\n    :watermelon\n\nAtoms are equal if their names are equal.\n\n    iex> :apple == :apple\n    true\n    iex> :apple == :orange\n    false\n\nOften they are used to express the state of an operation, by using\nvalues such as `:ok` and `:error`.\n\nThe booleans `true` and `false` are also atoms:\n\n    iex> true == :true\n    true\n    iex> is_atom(false)\n    true\n    iex> is_boolean(:false)\n    true\n\nElixir allows you to skip the leading `:` for the atoms `false`, `true`,\nand `nil`.\n\nAtoms must be composed of Unicode characters such as letters, numbers,\nunderscore, and `@`. If the keyword has a character that does not\nbelong to the category above, such as spaces, you can wrap it in\nquotes:\n\n    iex> :\"this is an atom with spaces\"\n    :\"this is an atom with spaces\"","ref":"Atom.html"},{"type":"function","title":"Atom.to_charlist/1","doc":"Converts an atom to a charlist.\n\nInlined by the compiler.","ref":"Atom.html#to_charlist/1"},{"type":"function","title":"Examples - Atom.to_charlist/1","doc":"iex> Atom.to_charlist(:\"An atom\")\n    ~c\"An atom\"","ref":"Atom.html#to_charlist/1-examples"},{"type":"function","title":"Atom.to_string/1","doc":"Converts an atom to a string.\n\nInlined by the compiler.","ref":"Atom.html#to_string/1"},{"type":"function","title":"Examples - Atom.to_string/1","doc":"iex> Atom.to_string(:foo)\n    \"foo\"","ref":"Atom.html#to_string/1-examples"},{"type":"module","title":"Base","doc":"This module provides data encoding and decoding functions\naccording to [RFC 4648](https://tools.ietf.org/html/rfc4648).\n\nThis document defines the commonly used base 16, base 32, and base\n64 encoding schemes.","ref":"Base.html"},{"type":"module","title":"Base 16 alphabet - Base","doc":"| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | 0        |     4 | 4        |     8 | 8        |    12 | C        |\n|     1 | 1        |     5 | 5        |     9 | 9        |    13 | D        |\n|     2 | 2        |     6 | 6        |    10 | A        |    14 | E        |\n|     3 | 3        |     7 | 7        |    11 | B        |    15 | F        |","ref":"Base.html#module-base-16-alphabet"},{"type":"module","title":"Base 32 alphabet - Base","doc":"| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | A        |     9 | J        |    18 | S        |    27 | 3        |\n|     1 | B        |    10 | K        |    19 | T        |    28 | 4        |\n|     2 | C        |    11 | L        |    20 | U        |    29 | 5        |\n|     3 | D        |    12 | M        |    21 | V        |    30 | 6        |\n|     4 | E        |    13 | N        |    22 | W        |    31 | 7        |\n|     5 | F        |    14 | O        |    23 | X        |       |          |\n|     6 | G        |    15 | P        |    24 | Y        | (pad) | =        |\n|     7 | H        |    16 | Q        |    25 | Z        |       |          |\n|     8 | I        |    17 | R        |    26 | 2        |       |          |","ref":"Base.html#module-base-32-alphabet"},{"type":"module","title":"Base 32 (extended hex) alphabet - Base","doc":"| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | 0        |     9 | 9        |    18 | I        |    27 | R        |\n|     1 | 1        |    10 | A        |    19 | J        |    28 | S        |\n|     2 | 2        |    11 | B        |    20 | K        |    29 | T        |\n|     3 | 3        |    12 | C        |    21 | L        |    30 | U        |\n|     4 | 4        |    13 | D        |    22 | M        |    31 | V        |\n|     5 | 5        |    14 | E        |    23 | N        |       |          |\n|     6 | 6        |    15 | F        |    24 | O        | (pad) | =        |\n|     7 | 7        |    16 | G        |    25 | P        |       |          |\n|     8 | 8        |    17 | H        |    26 | Q        |       |          |","ref":"Base.html#module-base-32-extended-hex-alphabet"},{"type":"module","title":"Base 64 alphabet - Base","doc":"| Value |  Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:----------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | A         |    17 | R        |    34 | i        |    51 | z        |\n|     1 | B         |    18 | S        |    35 | j        |    52 | 0        |\n|     2 | C         |    19 | T        |    36 | k        |    53 | 1        |\n|     3 | D         |    20 | U        |    37 | l        |    54 | 2        |\n|     4 | E         |    21 | V        |    38 | m        |    55 | 3        |\n|     5 | F         |    22 | W        |    39 | n        |    56 | 4        |\n|     6 | G         |    23 | X        |    40 | o        |    57 | 5        |\n|     7 | H         |    24 | Y        |    41 | p        |    58 | 6        |\n|     8 | I         |    25 | Z        |    42 | q        |    59 | 7        |\n|     9 | J         |    26 | a        |    43 | r        |    60 | 8        |\n|    10 | K         |    27 | b        |    44 | s        |    61 | 9        |\n|    11 | L         |    28 | c        |    45 | t        |    62 | +        |\n|    12 | M         |    29 | d        |    46 | u        |    63 | /        |\n|    13 | N         |    30 | e        |    47 | v        |       |          |\n|    14 | O         |    31 | f        |    48 | w        | (pad) | =        |\n|    15 | P         |    32 | g        |    49 | x        |       |          |\n|    16 | Q         |    33 | h        |    50 | y        |       |          |","ref":"Base.html#module-base-64-alphabet"},{"type":"module","title":"Base 64 (URL and filename safe) alphabet - Base","doc":"| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | A        |    17 | R        |    34 | i        |    51 | z        |\n|     1 | B        |    18 | S        |    35 | j        |    52 | 0        |\n|     2 | C        |    19 | T        |    36 | k        |    53 | 1        |\n|     3 | D        |    20 | U        |    37 | l        |    54 | 2        |\n|     4 | E        |    21 | V        |    38 | m        |    55 | 3        |\n|     5 | F        |    22 | W        |    39 | n        |    56 | 4        |\n|     6 | G        |    23 | X        |    40 | o        |    57 | 5        |\n|     7 | H        |    24 | Y        |    41 | p        |    58 | 6        |\n|     8 | I        |    25 | Z        |    42 | q        |    59 | 7        |\n|     9 | J        |    26 | a        |    43 | r        |    60 | 8        |\n|    10 | K        |    27 | b        |    44 | s        |    61 | 9        |\n|    11 | L        |    28 | c        |    45 | t        |    62 | -        |\n|    12 | M        |    29 | d        |    46 | u        |    63 | _        |\n|    13 | N        |    30 | e        |    47 | v        |       |          |\n|    14 | O        |    31 | f        |    48 | w        | (pad) | =        |\n|    15 | P        |    32 | g        |    49 | x        |       |          |\n|    16 | Q        |    33 | h        |    50 | y        |       |          |","ref":"Base.html#module-base-64-url-and-filename-safe-alphabet"},{"type":"function","title":"Base.decode16/2","doc":"Decodes a base 16 encoded string into a binary string.","ref":"Base.html#decode16/2"},{"type":"function","title":"Options - Base.decode16/2","doc":"The accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters","ref":"Base.html#decode16/2-options"},{"type":"function","title":"Examples - Base.decode16/2","doc":"iex> Base.decode16(\"666F6F626172\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode16(\"666f6f626172\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode16(\"666f6F626172\", case: :mixed)\n    {:ok, \"foobar\"}","ref":"Base.html#decode16/2-examples"},{"type":"function","title":"Base.decode16!/2","doc":"Decodes a base 16 encoded string into a binary string.","ref":"Base.html#decode16!/2"},{"type":"function","title":"Options - Base.decode16!/2","doc":"The accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.","ref":"Base.html#decode16!/2-options"},{"type":"function","title":"Examples - Base.decode16!/2","doc":"iex> Base.decode16!(\"666F6F626172\")\n    \"foobar\"\n\n    iex> Base.decode16!(\"666f6f626172\", case: :lower)\n    \"foobar\"\n\n    iex> Base.decode16!(\"666f6F626172\", case: :mixed)\n    \"foobar\"","ref":"Base.html#decode16!/2-examples"},{"type":"function","title":"Base.decode32/2","doc":"Decodes a base 32 encoded string into a binary string.","ref":"Base.html#decode32/2"},{"type":"function","title":"Options - Base.decode32/2","doc":"The accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows  upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string","ref":"Base.html#decode32/2-options"},{"type":"function","title":"Examples - Base.decode32/2","doc":"iex> Base.decode32(\"MZXW6YTBOI======\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"mzxw6ytboi======\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"mzXW6ytBOi======\", case: :mixed)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"MZXW6YTBOI\", padding: false)\n    {:ok, \"foobar\"}","ref":"Base.html#decode32/2-examples"},{"type":"function","title":"Base.decode32!/2","doc":"Decodes a base 32 encoded string into a binary string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.","ref":"Base.html#decode32!/2"},{"type":"function","title":"Options - Base.decode32!/2","doc":"The accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string","ref":"Base.html#decode32!/2-options"},{"type":"function","title":"Examples - Base.decode32!/2","doc":"iex> Base.decode32!(\"MZXW6YTBOI======\")\n    \"foobar\"\n\n    iex> Base.decode32!(\"mzxw6ytboi======\", case: :lower)\n    \"foobar\"\n\n    iex> Base.decode32!(\"mzXW6ytBOi======\", case: :mixed)\n    \"foobar\"\n\n    iex> Base.decode32!(\"MZXW6YTBOI\", padding: false)\n    \"foobar\"","ref":"Base.html#decode32!/2-examples"},{"type":"function","title":"Base.decode64/2","doc":"Decodes a base 64 encoded string into a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.","ref":"Base.html#decode64/2"},{"type":"function","title":"Examples - Base.decode64/2","doc":"iex> Base.decode64(\"Zm9vYmFy\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode64(\"Zm9vYmFy\\n\", ignore: :whitespace)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode64(\"Zm9vYg==\")\n    {:ok, \"foob\"}\n\n    iex> Base.decode64(\"Zm9vYg\", padding: false)\n    {:ok, \"foob\"}","ref":"Base.html#decode64/2-examples"},{"type":"function","title":"Base.decode64!/2","doc":"Decodes a base 64 encoded string into a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.","ref":"Base.html#decode64!/2"},{"type":"function","title":"Examples - Base.decode64!/2","doc":"iex> Base.decode64!(\"Zm9vYmFy\")\n    \"foobar\"\n\n    iex> Base.decode64!(\"Zm9vYmFy\\n\", ignore: :whitespace)\n    \"foobar\"\n\n    iex> Base.decode64!(\"Zm9vYg==\")\n    \"foob\"\n\n    iex> Base.decode64!(\"Zm9vYg\", padding: false)\n    \"foob\"","ref":"Base.html#decode64!/2-examples"},{"type":"type","title":"Base.decode_case/0","doc":"","ref":"Base.html#t:decode_case/0"},{"type":"function","title":"Base.encode16/2","doc":"Encodes a binary string into a base 16 encoded string.","ref":"Base.html#encode16/2"},{"type":"function","title":"Options - Base.encode16/2","doc":"The accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters","ref":"Base.html#encode16/2-options"},{"type":"function","title":"Examples - Base.encode16/2","doc":"iex> Base.encode16(\"foobar\")\n    \"666F6F626172\"\n\n    iex> Base.encode16(\"foobar\", case: :lower)\n    \"666f6f626172\"","ref":"Base.html#encode16/2-examples"},{"type":"function","title":"Base.encode32/2","doc":"Encodes a binary string into a base 32 encoded string.","ref":"Base.html#encode32/2"},{"type":"function","title":"Options - Base.encode32/2","doc":"The accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n  * `:padding` - specifies whether to apply padding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters\n\nThe values for `:padding` can be:\n\n  * `true` - pad the output string to the nearest multiple of 8 (default)\n  * `false` - omit padding from the output string","ref":"Base.html#encode32/2-options"},{"type":"function","title":"Examples - Base.encode32/2","doc":"iex> Base.encode32(\"foobar\")\n    \"MZXW6YTBOI======\"\n\n    iex> Base.encode32(\"foobar\", case: :lower)\n    \"mzxw6ytboi======\"\n\n    iex> Base.encode32(\"foobar\", padding: false)\n    \"MZXW6YTBOI\"","ref":"Base.html#encode32/2-examples"},{"type":"function","title":"Base.encode64/2","doc":"Encodes a binary string into a base 64 encoded string.\n\nAccepts `padding: false` option which will omit padding from\nthe output string.","ref":"Base.html#encode64/2"},{"type":"function","title":"Examples - Base.encode64/2","doc":"iex> Base.encode64(\"foobar\")\n    \"Zm9vYmFy\"\n\n    iex> Base.encode64(\"foob\")\n    \"Zm9vYg==\"\n\n    iex> Base.encode64(\"foob\", padding: false)\n    \"Zm9vYg\"","ref":"Base.html#encode64/2-examples"},{"type":"type","title":"Base.encode_case/0","doc":"","ref":"Base.html#t:encode_case/0"},{"type":"function","title":"Base.hex_decode32/2","doc":"Decodes a base 32 encoded string with extended hexadecimal alphabet\ninto a binary string.","ref":"Base.html#hex_decode32/2"},{"type":"function","title":"Options - Base.hex_decode32/2","doc":"The accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string","ref":"Base.html#hex_decode32/2-options"},{"type":"function","title":"Examples - Base.hex_decode32/2","doc":"iex> Base.hex_decode32(\"CPNMUOJ1E8======\")\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"cpnmuoj1e8======\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"cpnMuOJ1E8======\", case: :mixed)\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"CPNMUOJ1E8\", padding: false)\n    {:ok, \"foobar\"}","ref":"Base.html#hex_decode32/2-examples"},{"type":"function","title":"Base.hex_decode32!/2","doc":"Decodes a base 32 encoded string with extended hexadecimal alphabet\ninto a binary string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.","ref":"Base.html#hex_decode32!/2"},{"type":"function","title":"Options - Base.hex_decode32!/2","doc":"The accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string","ref":"Base.html#hex_decode32!/2-options"},{"type":"function","title":"Examples - Base.hex_decode32!/2","doc":"iex> Base.hex_decode32!(\"CPNMUOJ1E8======\")\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"cpnmuoj1e8======\", case: :lower)\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"cpnMuOJ1E8======\", case: :mixed)\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"CPNMUOJ1E8\", padding: false)\n    \"foobar\"","ref":"Base.html#hex_decode32!/2-examples"},{"type":"function","title":"Base.hex_encode32/2","doc":"Encodes a binary string into a base 32 encoded string with an\nextended hexadecimal alphabet.","ref":"Base.html#hex_encode32/2"},{"type":"function","title":"Options - Base.hex_encode32/2","doc":"The accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n  * `:padding` - specifies whether to apply padding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters\n\nThe values for `:padding` can be:\n\n  * `true` - pad the output string to the nearest multiple of 8 (default)\n  * `false` - omit padding from the output string","ref":"Base.html#hex_encode32/2-options"},{"type":"function","title":"Examples - Base.hex_encode32/2","doc":"iex> Base.hex_encode32(\"foobar\")\n    \"CPNMUOJ1E8======\"\n\n    iex> Base.hex_encode32(\"foobar\", case: :lower)\n    \"cpnmuoj1e8======\"\n\n    iex> Base.hex_encode32(\"foobar\", padding: false)\n    \"CPNMUOJ1E8\"","ref":"Base.html#hex_encode32/2-examples"},{"type":"function","title":"Base.url_decode64/2","doc":"Decodes a base 64 encoded string with URL and filename safe alphabet\ninto a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.","ref":"Base.html#url_decode64/2"},{"type":"function","title":"Examples - Base.url_decode64/2","doc":"iex> Base.url_decode64(\"_3_-_A==\")\n    {:ok, <<255, 127, 254, 252>>}\n\n    iex> Base.url_decode64(\"_3_-_A==\\n\", ignore: :whitespace)\n    {:ok, <<255, 127, 254, 252>>}\n\n    iex> Base.url_decode64(\"_3_-_A\", padding: false)\n    {:ok, <<255, 127, 254, 252>>}","ref":"Base.html#url_decode64/2-examples"},{"type":"function","title":"Base.url_decode64!/2","doc":"Decodes a base 64 encoded string with URL and filename safe alphabet\ninto a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.","ref":"Base.html#url_decode64!/2"},{"type":"function","title":"Examples - Base.url_decode64!/2","doc":"iex> Base.url_decode64!(\"_3_-_A==\")\n    <<255, 127, 254, 252>>\n\n    iex> Base.url_decode64!(\"_3_-_A==\\n\", ignore: :whitespace)\n    <<255, 127, 254, 252>>\n\n    iex> Base.url_decode64!(\"_3_-_A\", padding: false)\n    <<255, 127, 254, 252>>","ref":"Base.html#url_decode64!/2-examples"},{"type":"function","title":"Base.url_encode64/2","doc":"Encodes a binary string into a base 64 encoded string with URL and filename\nsafe alphabet.\n\nAccepts `padding: false` option which will omit padding from\nthe output string.","ref":"Base.html#url_encode64/2"},{"type":"function","title":"Examples - Base.url_encode64/2","doc":"iex> Base.url_encode64(<<255, 127, 254, 252>>)\n    \"_3_-_A==\"\n\n    iex> Base.url_encode64(<<255, 127, 254, 252>>, padding: false)\n    \"_3_-_A\"","ref":"Base.html#url_encode64/2-examples"},{"type":"module","title":"Bitwise","doc":"A set of functions that perform calculations on bits.\n\nAll bitwise functions work only on integers, otherwise an\n`ArithmeticError` is raised. The functions `band/2`,\n`bor/2`, `bsl/2`, and `bsr/2` also have operators,\nrespectively: `&&&/2`, `|||/2`, `<<</2`, and `>>>/2`.","ref":"Bitwise.html"},{"type":"module","title":"Guards - Bitwise","doc":"All bitwise functions can be used in guards:\n\n    iex> odd? = fn\n    ...>   int when Bitwise.band(int, 1) == 1 -> true\n    ...>   _ -> false\n    ...> end\n    iex> odd?.(1)\n    true\n\nAll functions in this module are inlined by the compiler.","ref":"Bitwise.html#module-guards"},{"type":"function","title":"Bitwise.&&&/2","doc":"Bitwise AND operator.\n\nCalculates the bitwise AND of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Bitwise.html#&&&/2"},{"type":"function","title":"Examples - Bitwise.&&&/2","doc":"iex> 9 &&& 3\n    1","ref":"Bitwise.html#&&&/2-examples"},{"type":"function","title":"Bitwise.<<</2","doc":"Arithmetic left bitshift operator.\n\nCalculates the result of an arithmetic left bitshift.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Bitwise.html#%3C%3C%3C/2"},{"type":"function","title":"Examples - Bitwise.<<</2","doc":"iex> 1 <<< 2\n    4\n\n    iex> 1 <<< -2\n    0\n\n    iex> -1 <<< 2\n    -4\n\n    iex> -1 <<< -2\n    -1","ref":"Bitwise.html#%3C%3C%3C/2-examples"},{"type":"function","title":"Bitwise.>>>/2","doc":"Arithmetic right bitshift operator.\n\nCalculates the result of an arithmetic right bitshift.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Bitwise.html#%3E%3E%3E/2"},{"type":"function","title":"Examples - Bitwise.>>>/2","doc":"iex> 1 >>> 2\n    0\n\n    iex> 1 >>> -2\n    4\n\n    iex> -1 >>> 2\n    -1\n\n    iex> -1 >>> -2\n    -4","ref":"Bitwise.html#%3E%3E%3E/2-examples"},{"type":"function","title":"Bitwise.band/2","doc":"Calculates the bitwise AND of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Bitwise.html#band/2"},{"type":"function","title":"Examples - Bitwise.band/2","doc":"iex> band(9, 3)\n    1","ref":"Bitwise.html#band/2-examples"},{"type":"function","title":"Bitwise.bnot/1","doc":"Calculates the bitwise NOT of the argument.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Bitwise.html#bnot/1"},{"type":"function","title":"Examples - Bitwise.bnot/1","doc":"iex> bnot(2)\n    -3\n\n    iex> bnot(2) &&& 3\n    1","ref":"Bitwise.html#bnot/1-examples"},{"type":"function","title":"Bitwise.bor/2","doc":"Calculates the bitwise OR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Bitwise.html#bor/2"},{"type":"function","title":"Examples - Bitwise.bor/2","doc":"iex> bor(9, 3)\n    11","ref":"Bitwise.html#bor/2-examples"},{"type":"function","title":"Bitwise.bsl/2","doc":"Calculates the result of an arithmetic left bitshift.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Bitwise.html#bsl/2"},{"type":"function","title":"Examples - Bitwise.bsl/2","doc":"iex> bsl(1, 2)\n    4\n\n    iex> bsl(1, -2)\n    0\n\n    iex> bsl(-1, 2)\n    -4\n\n    iex> bsl(-1, -2)\n    -1","ref":"Bitwise.html#bsl/2-examples"},{"type":"function","title":"Bitwise.bsr/2","doc":"Calculates the result of an arithmetic right bitshift.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Bitwise.html#bsr/2"},{"type":"function","title":"Examples - Bitwise.bsr/2","doc":"iex> bsr(1, 2)\n    0\n\n    iex> bsr(1, -2)\n    4\n\n    iex> bsr(-1, 2)\n    -1\n\n    iex> bsr(-1, -2)\n    -4","ref":"Bitwise.html#bsr/2-examples"},{"type":"function","title":"Bitwise.bxor/2","doc":"Calculates the bitwise XOR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Bitwise.html#bxor/2"},{"type":"function","title":"Examples - Bitwise.bxor/2","doc":"iex> bxor(9, 3)\n    10","ref":"Bitwise.html#bxor/2-examples"},{"type":"function","title":"Bitwise.|||/2","doc":"Bitwise OR operator.\n\nCalculates the bitwise OR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.","ref":"Bitwise.html#%7C%7C%7C/2"},{"type":"function","title":"Examples - Bitwise.|||/2","doc":"iex> 9 ||| 3\n    11","ref":"Bitwise.html#%7C%7C%7C/2-examples"},{"type":"module","title":"Date","doc":"A Date struct and functions.\n\nThe Date struct contains the fields year, month, day and calendar.\nNew dates can be built with the `new/3` function or using the\n`~D` (see `sigil_D/2`) sigil:\n\n    iex> ~D[2000-01-01]\n    ~D[2000-01-01]\n\nBoth `new/3` and sigil return a struct where the date fields can\nbe accessed directly:\n\n    iex> date = ~D[2000-01-01]\n    iex> date.year\n    2000\n    iex> date.month\n    1\n\nThe functions on this module work with the `Date` struct as well\nas any struct that contains the same fields as the `Date` struct,\nsuch as `NaiveDateTime` and `DateTime`. Such functions expect\n`t:Calendar.date/0` in their typespecs (instead of `t:t/0`).\n\nDevelopers should avoid creating the Date structs directly\nand instead rely on the functions provided by this module as well\nas the ones in third-party calendar libraries.","ref":"Date.html"},{"type":"module","title":"Comparing dates - Date","doc":"Comparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `Date` struct fields. For proper comparison between\ndates, use the `compare/2` function. The existence of the `compare/2`\nfunction in this module also allows using `Enum.min/2` and `Enum.max/2`\nfunctions to get the minimum and maximum date of an `Enum`. For example:\n\n    iex>  Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-03-31]","ref":"Date.html#module-comparing-dates"},{"type":"module","title":"Using epochs - Date","doc":"The `add/2`, `diff/2` and `shift/2` functions can be used for computing dates\nor retrieving the number of days between instants. For example, if there\nis an interest in computing the number of days from the Unix epoch\n(1970-01-01):\n\n    iex> Date.diff(~D[2010-04-17], ~D[1970-01-01])\n    14716\n\n    iex> Date.add(~D[1970-01-01], 14716)\n    ~D[2010-04-17]\n\n    iex> Date.shift(~D[1970-01-01], year: 40, month: 3, week: 2, day: 2)\n    ~D[2010-04-17]\n\nThose functions are optimized to deal with common epochs, such\nas the Unix Epoch above or the Gregorian Epoch (0000-01-01).","ref":"Date.html#module-using-epochs"},{"type":"function","title":"Date.add/2","doc":"Adds the number of days to the given `date`.\n\nThe days are counted as Gregorian days. The date is returned in the same\ncalendar as it was given in.\n\nTo shift a date by a `Duration` and according to its underlying calendar, use `Date.shift/2`.","ref":"Date.html#add/2"},{"type":"function","title":"Examples - Date.add/2","doc":"iex> Date.add(~D[2000-01-03], -2)\n    ~D[2000-01-01]\n    iex> Date.add(~D[2000-01-01], 2)\n    ~D[2000-01-03]\n    iex> Date.add(~N[2000-01-01 09:00:00], 2)\n    ~D[2000-01-03]\n    iex> Date.add(~D[-0010-01-01], -2)\n    ~D[-0011-12-30]","ref":"Date.html#add/2-examples"},{"type":"function","title":"Date.after?/2","doc":"Returns `true` if the first date is strictly later than the second.","ref":"Date.html#after?/2"},{"type":"function","title":"Examples - Date.after?/2","doc":"iex> Date.after?(~D[2022-02-02], ~D[2021-01-01])\n    true\n    iex> Date.after?(~D[2021-01-01], ~D[2021-01-01])\n    false\n    iex> Date.after?(~D[2021-01-01], ~D[2022-02-02])\n    false","ref":"Date.html#after?/2-examples"},{"type":"function","title":"Date.before?/2","doc":"Returns `true` if the first date is strictly earlier than the second.","ref":"Date.html#before?/2"},{"type":"function","title":"Examples - Date.before?/2","doc":"iex> Date.before?(~D[2021-01-01], ~D[2022-02-02])\n    true\n    iex> Date.before?(~D[2021-01-01], ~D[2021-01-01])\n    false\n    iex> Date.before?(~D[2022-02-02], ~D[2021-01-01])\n    false","ref":"Date.html#before?/2-examples"},{"type":"function","title":"Date.beginning_of_month/1","doc":"Calculates a date that is the first day of the month for the given `date`.","ref":"Date.html#beginning_of_month/1"},{"type":"function","title":"Examples - Date.beginning_of_month/1","doc":"iex> Date.beginning_of_month(~D[2000-01-31])\n    ~D[2000-01-01]\n    iex> Date.beginning_of_month(~D[2000-01-01])\n    ~D[2000-01-01]\n    iex> Date.beginning_of_month(~N[2000-01-31 01:23:45])\n    ~D[2000-01-01]","ref":"Date.html#beginning_of_month/1-examples"},{"type":"function","title":"Date.beginning_of_week/2","doc":"Calculates a date that is the first day of the week for the given `date`.\n\nIf the day is already the first day of the week, it returns the\nday itself. For the built-in ISO calendar, the week starts on Monday.\nA weekday rather than `:default` can be given as `starting_on`.","ref":"Date.html#beginning_of_week/2"},{"type":"function","title":"Examples - Date.beginning_of_week/2","doc":"iex> Date.beginning_of_week(~D[2020-07-11])\n    ~D[2020-07-06]\n    iex> Date.beginning_of_week(~D[2020-07-06])\n    ~D[2020-07-06]\n    iex> Date.beginning_of_week(~D[2020-07-11], :sunday)\n    ~D[2020-07-05]\n    iex> Date.beginning_of_week(~D[2020-07-11], :saturday)\n    ~D[2020-07-11]\n    iex> Date.beginning_of_week(~N[2020-07-11 01:23:45])\n    ~D[2020-07-06]","ref":"Date.html#beginning_of_week/2-examples"},{"type":"function","title":"Date.compare/2","doc":"Compares two date structs.\n\nReturns `:gt` if first date is later than the second\nand `:lt` for vice versa. If the two dates are equal\n`:eq` is returned.","ref":"Date.html#compare/2"},{"type":"function","title":"Examples - Date.compare/2","doc":"iex> Date.compare(~D[2016-04-16], ~D[2016-04-28])\n    :lt\n\nThis function can also be used to compare across more\ncomplex calendar types by considering only the date fields:\n\n    iex> Date.compare(~D[2016-04-16], ~N[2016-04-28 01:23:45])\n    :lt\n    iex> Date.compare(~D[2016-04-16], ~N[2016-04-16 01:23:45])\n    :eq\n    iex> Date.compare(~N[2016-04-16 12:34:56], ~N[2016-04-16 01:23:45])\n    :eq","ref":"Date.html#compare/2-examples"},{"type":"function","title":"Date.convert/2","doc":"Converts the given `date` from its calendar to the given `calendar`.\n\nReturns `{:ok, date}` if the calendars are compatible,\nor `{:error, :incompatible_calendars}` if they are not.\n\nSee also `Calendar.compatible_calendars?/2`.","ref":"Date.html#convert/2"},{"type":"function","title":"Examples - Date.convert/2","doc":"Imagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Date.convert(~D[2000-01-01], Calendar.Holocene)\n    {:ok, %Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}}","ref":"Date.html#convert/2-examples"},{"type":"function","title":"Date.convert!/2","doc":"Similar to `Date.convert/2`, but raises an `ArgumentError`\nif the conversion between the two calendars is not possible.","ref":"Date.html#convert!/2"},{"type":"function","title":"Examples - Date.convert!/2","doc":"Imagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Date.convert!(~D[2000-01-01], Calendar.Holocene)\n    %Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}","ref":"Date.html#convert!/2-examples"},{"type":"function","title":"Date.day_of_era/1","doc":"Calculates the day-of-era and era for a given\ncalendar `date`.\n\nReturns a tuple `{day, era}` representing the\nday within the era and the era number.","ref":"Date.html#day_of_era/1"},{"type":"function","title":"Examples - Date.day_of_era/1","doc":"iex> Date.day_of_era(~D[0001-01-01])\n    {1, 1}\n\n    iex> Date.day_of_era(~D[0000-12-31])\n    {1, 0}","ref":"Date.html#day_of_era/1-examples"},{"type":"function","title":"Date.day_of_week/2","doc":"Calculates the day of the week of a given `date`.\n\nReturns the day of the week as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 7, where\n1 is Monday and 7 is Sunday.\n\nAn optional `starting_on` value may be supplied, which\nconfigures the weekday the week starts on. The default value\nfor it is `:default`, which translates to `:monday` for the\nbuilt-in ISO calendar. Any other weekday may be given to.","ref":"Date.html#day_of_week/2"},{"type":"function","title":"Examples - Date.day_of_week/2","doc":"iex> Date.day_of_week(~D[2016-10-31])\n    1\n    iex> Date.day_of_week(~D[2016-11-01])\n    2\n    iex> Date.day_of_week(~N[2016-11-01 01:23:45])\n    2\n    iex> Date.day_of_week(~D[-0015-10-30])\n    3\n\n    iex> Date.day_of_week(~D[2016-10-31], :sunday)\n    2\n    iex> Date.day_of_week(~D[2016-11-01], :sunday)\n    3\n    iex> Date.day_of_week(~N[2016-11-01 01:23:45], :sunday)\n    3\n    iex> Date.day_of_week(~D[-0015-10-30], :sunday)\n    4","ref":"Date.html#day_of_week/2-examples"},{"type":"function","title":"Date.day_of_year/1","doc":"Calculates the day of the year of a given `date`.\n\nReturns the day of the year as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 366.","ref":"Date.html#day_of_year/1"},{"type":"function","title":"Examples - Date.day_of_year/1","doc":"iex> Date.day_of_year(~D[2016-01-01])\n    1\n    iex> Date.day_of_year(~D[2016-11-01])\n    306\n    iex> Date.day_of_year(~D[-0015-10-30])\n    303\n    iex> Date.day_of_year(~D[2004-12-31])\n    366","ref":"Date.html#day_of_year/1-examples"},{"type":"function","title":"Date.days_in_month/1","doc":"Returns the number of days in the given `date` month.","ref":"Date.html#days_in_month/1"},{"type":"function","title":"Examples - Date.days_in_month/1","doc":"iex> Date.days_in_month(~D[1900-01-13])\n    31\n    iex> Date.days_in_month(~D[1900-02-09])\n    28\n    iex> Date.days_in_month(~N[2000-02-20 01:23:45])\n    29","ref":"Date.html#days_in_month/1-examples"},{"type":"function","title":"Date.diff/2","doc":"Calculates the difference between two dates, in a full number of days.\n\nIt returns the number of Gregorian days between the dates. Only `Date`\nstructs that follow the same or compatible calendars can be compared\nthis way. If two calendars are not compatible, it will raise.","ref":"Date.html#diff/2"},{"type":"function","title":"Examples - Date.diff/2","doc":"iex> Date.diff(~D[2000-01-03], ~D[2000-01-01])\n    2\n    iex> Date.diff(~D[2000-01-01], ~D[2000-01-03])\n    -2\n    iex> Date.diff(~D[0000-01-02], ~D[-0001-12-30])\n    3\n    iex> Date.diff(~D[2000-01-01], ~N[2000-01-03 09:00:00])\n    -2","ref":"Date.html#diff/2-examples"},{"type":"function","title":"Date.end_of_month/1","doc":"Calculates a date that is the last day of the month for the given `date`.","ref":"Date.html#end_of_month/1"},{"type":"function","title":"Examples - Date.end_of_month/1","doc":"iex> Date.end_of_month(~D[2000-01-01])\n    ~D[2000-01-31]\n    iex> Date.end_of_month(~D[2000-01-31])\n    ~D[2000-01-31]\n    iex> Date.end_of_month(~N[2000-01-01 01:23:45])\n    ~D[2000-01-31]","ref":"Date.html#end_of_month/1-examples"},{"type":"function","title":"Date.end_of_week/2","doc":"Calculates a date that is the last day of the week for the given `date`.\n\nIf the day is already the last day of the week, it returns the\nday itself. For the built-in ISO calendar, the week ends on Sunday.\nA weekday rather than `:default` can be given as `starting_on`.","ref":"Date.html#end_of_week/2"},{"type":"function","title":"Examples - Date.end_of_week/2","doc":"iex> Date.end_of_week(~D[2020-07-11])\n    ~D[2020-07-12]\n    iex> Date.end_of_week(~D[2020-07-05])\n    ~D[2020-07-05]\n    iex> Date.end_of_week(~D[2020-07-06], :sunday)\n    ~D[2020-07-11]\n    iex> Date.end_of_week(~D[2020-07-06], :saturday)\n    ~D[2020-07-10]\n    iex> Date.end_of_week(~N[2020-07-11 01:23:45])\n    ~D[2020-07-12]","ref":"Date.html#end_of_week/2-examples"},{"type":"function","title":"Date.from_erl/2","doc":"Converts an Erlang date tuple to a `Date` struct.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will return an error tuple.","ref":"Date.html#from_erl/2"},{"type":"function","title":"Examples - Date.from_erl/2","doc":"iex> Date.from_erl({2000, 1, 1})\n    {:ok, ~D[2000-01-01]}\n    iex> Date.from_erl({2000, 13, 1})\n    {:error, :invalid_date}","ref":"Date.html#from_erl/2-examples"},{"type":"function","title":"Date.from_erl!/2","doc":"Converts an Erlang date tuple but raises for invalid dates.","ref":"Date.html#from_erl!/2"},{"type":"function","title":"Examples - Date.from_erl!/2","doc":"iex> Date.from_erl!({2000, 1, 1})\n    ~D[2000-01-01]\n    iex> Date.from_erl!({2000, 13, 1})\n    ** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :invalid_date","ref":"Date.html#from_erl!/2-examples"},{"type":"function","title":"Date.from_gregorian_days/2","doc":"Converts a number of gregorian days to a `Date` struct.","ref":"Date.html#from_gregorian_days/2"},{"type":"function","title":"Examples - Date.from_gregorian_days/2","doc":"iex> Date.from_gregorian_days(1)\n    ~D[0000-01-02]\n    iex> Date.from_gregorian_days(730_485)\n    ~D[2000-01-01]\n    iex> Date.from_gregorian_days(-1)\n    ~D[-0001-12-31]","ref":"Date.html#from_gregorian_days/2-examples"},{"type":"function","title":"Date.from_iso8601/2","doc":"Parses the extended \"Dates\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nThe year parsed by this function is limited to four digits.","ref":"Date.html#from_iso8601/2"},{"type":"function","title":"Examples - Date.from_iso8601/2","doc":"iex> Date.from_iso8601(\"2015-01-23\")\n    {:ok, ~D[2015-01-23]}\n\n    iex> Date.from_iso8601(\"2015:01:23\")\n    {:error, :invalid_format}\n\n    iex> Date.from_iso8601(\"2015-01-32\")\n    {:error, :invalid_date}","ref":"Date.html#from_iso8601/2-examples"},{"type":"function","title":"Date.from_iso8601!/2","doc":"Parses the extended \"Dates\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.","ref":"Date.html#from_iso8601!/2"},{"type":"function","title":"Examples - Date.from_iso8601!/2","doc":"iex> Date.from_iso8601!(\"2015-01-23\")\n    ~D[2015-01-23]\n    iex> Date.from_iso8601!(\"2015:01:23\")\n    ** (ArgumentError) cannot parse \"2015:01:23\" as date, reason: :invalid_format","ref":"Date.html#from_iso8601!/2-examples"},{"type":"function","title":"Date.leap_year?/1","doc":"Returns `true` if the year in the given `date` is a leap year.","ref":"Date.html#leap_year?/1"},{"type":"function","title":"Examples - Date.leap_year?/1","doc":"iex> Date.leap_year?(~D[2000-01-01])\n    true\n    iex> Date.leap_year?(~D[2001-01-01])\n    false\n    iex> Date.leap_year?(~D[2004-01-01])\n    true\n    iex> Date.leap_year?(~D[1900-01-01])\n    false\n    iex> Date.leap_year?(~N[2004-01-01 01:23:45])\n    true","ref":"Date.html#leap_year?/1-examples"},{"type":"function","title":"Date.months_in_year/1","doc":"Returns the number of months in the given `date` year.","ref":"Date.html#months_in_year/1"},{"type":"function","title":"Example - Date.months_in_year/1","doc":"iex> Date.months_in_year(~D[1900-01-13])\n    12","ref":"Date.html#months_in_year/1-example"},{"type":"function","title":"Date.new/4","doc":"Builds a new ISO date.\n\nExpects all values to be integers. Returns `{:ok, date}` if each\nentry fits its appropriate range, returns `{:error, reason}` otherwise.","ref":"Date.html#new/4"},{"type":"function","title":"Examples - Date.new/4","doc":"iex> Date.new(2000, 1, 1)\n    {:ok, ~D[2000-01-01]}\n    iex> Date.new(2000, 13, 1)\n    {:error, :invalid_date}\n    iex> Date.new(2000, 2, 29)\n    {:ok, ~D[2000-02-29]}\n\n    iex> Date.new(2000, 2, 30)\n    {:error, :invalid_date}\n    iex> Date.new(2001, 2, 29)\n    {:error, :invalid_date}","ref":"Date.html#new/4-examples"},{"type":"function","title":"Date.new!/4","doc":"Builds a new ISO date.\n\nExpects all values to be integers. Returns `date` if each\nentry fits its appropriate range, raises if the date is invalid.","ref":"Date.html#new!/4"},{"type":"function","title":"Examples - Date.new!/4","doc":"iex> Date.new!(2000, 1, 1)\n    ~D[2000-01-01]\n    iex> Date.new!(2000, 13, 1)\n    ** (ArgumentError) cannot build date, reason: :invalid_date\n    iex> Date.new!(2000, 2, 29)\n    ~D[2000-02-29]","ref":"Date.html#new!/4-examples"},{"type":"function","title":"Date.quarter_of_year/1","doc":"Calculates the quarter of the year of a given `date`.\n\nReturns the day of the year as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 4.","ref":"Date.html#quarter_of_year/1"},{"type":"function","title":"Examples - Date.quarter_of_year/1","doc":"iex> Date.quarter_of_year(~D[2016-10-31])\n    4\n    iex> Date.quarter_of_year(~D[2016-01-01])\n    1\n    iex> Date.quarter_of_year(~N[2016-04-01 01:23:45])\n    2\n    iex> Date.quarter_of_year(~D[-0015-09-30])\n    3","ref":"Date.html#quarter_of_year/1-examples"},{"type":"function","title":"Date.range/2","doc":"Returns a range of dates.\n\nA range of dates represents a discrete number of dates where\nthe first and last values are dates with matching calendars.\n\nRanges of dates can be increasing (`first <= last`) and are\nalways inclusive. For a decreasing range, use `range/3` with\na step of -1 as first argument.","ref":"Date.html#range/2"},{"type":"function","title":"Examples - Date.range/2","doc":"iex> Date.range(~D[1999-01-01], ~D[2000-01-01])\n    Date.range(~D[1999-01-01], ~D[2000-01-01])\n\nA range of dates implements the `Enumerable` protocol, which means\nfunctions in the `Enum` module can be used to work with\nranges:\n\n    iex> range = Date.range(~D[2001-01-01], ~D[2002-01-01])\n    iex> range\n    Date.range(~D[2001-01-01], ~D[2002-01-01])\n    iex> Enum.count(range)\n    366\n    iex> ~D[2001-02-01] in range\n    true\n    iex> Enum.take(range, 3)\n    [~D[2001-01-01], ~D[2001-01-02], ~D[2001-01-03]]","ref":"Date.html#range/2-examples"},{"type":"function","title":"Date.range/3","doc":"Returns a range of dates with a step.","ref":"Date.html#range/3"},{"type":"function","title":"Examples - Date.range/3","doc":"iex> range = Date.range(~D[2001-01-01], ~D[2002-01-01], 2)\n    iex> range\n    Date.range(~D[2001-01-01], ~D[2002-01-01], 2)\n    iex> Enum.count(range)\n    183\n    iex> ~D[2001-01-03] in range\n    true\n    iex> Enum.take(range, 3)\n    [~D[2001-01-01], ~D[2001-01-03], ~D[2001-01-05]]","ref":"Date.html#range/3-examples"},{"type":"function","title":"Date.shift/2","doc":"Shifts given `date` by `duration` according to its calendar.\n\nAllowed units are: `:year`, `:month`, `:week`, `:day`.\n\nWhen using the default ISO calendar, durations are collapsed and\napplied in the order of months and then days:\n\n* when shifting by 1 year and 2 months the date is actually shifted by 14 months\n* when shifting by 2 weeks and 3 days the date is shifted by 17 days\n\nWhen shifting by month, days are rounded down to the nearest valid date.\n\nRaises an `ArgumentError` when called with time scale units.","ref":"Date.html#shift/2"},{"type":"function","title":"Examples - Date.shift/2","doc":"iex> Date.shift(~D[2016-01-03], month: 2)\n    ~D[2016-03-03]\n    iex> Date.shift(~D[2016-01-30], month: -1)\n    ~D[2015-12-30]\n    iex> Date.shift(~D[2016-01-31], year: 4, day: 1)\n    ~D[2020-02-01]\n    iex> Date.shift(~D[2016-01-03], Duration.new!(month: 2))\n    ~D[2016-03-03]\n\n    # leap years\n    iex> Date.shift(~D[2024-02-29], year: 1)\n    ~D[2025-02-28]\n    iex> Date.shift(~D[2024-02-29], year: 4)\n    ~D[2028-02-29]\n\n    # rounding down\n    iex> Date.shift(~D[2015-01-31], month: 1)\n    ~D[2015-02-28]","ref":"Date.html#shift/2-examples"},{"type":"type","title":"Date.t/0","doc":"","ref":"Date.html#t:t/0"},{"type":"function","title":"Date.to_erl/1","doc":"Converts the given `date` to an Erlang date tuple.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will raise.","ref":"Date.html#to_erl/1"},{"type":"function","title":"Examples - Date.to_erl/1","doc":"iex> Date.to_erl(~D[2000-01-01])\n    {2000, 1, 1}\n\n    iex> Date.to_erl(~N[2000-01-01 00:00:00])\n    {2000, 1, 1}","ref":"Date.html#to_erl/1-examples"},{"type":"function","title":"Date.to_gregorian_days/1","doc":"Converts a `date` struct to a number of gregorian days.","ref":"Date.html#to_gregorian_days/1"},{"type":"function","title":"Examples - Date.to_gregorian_days/1","doc":"iex> Date.to_gregorian_days(~D[0000-01-02])\n    1\n    iex> Date.to_gregorian_days(~D[2000-01-01])\n    730_485\n    iex> Date.to_gregorian_days(~N[2000-01-01 00:00:00])\n    730_485","ref":"Date.html#to_gregorian_days/1-examples"},{"type":"function","title":"Date.to_iso8601/2","doc":"Converts the given `date` to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `Date.to_iso8601/2` returns dates formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will raise an `ArgumentError`.","ref":"Date.html#to_iso8601/2"},{"type":"function","title":"Examples - Date.to_iso8601/2","doc":"iex> Date.to_iso8601(~D[2000-02-28])\n    \"2000-02-28\"\n\n    iex> Date.to_iso8601(~D[2000-02-28], :basic)\n    \"20000228\"\n\n    iex> Date.to_iso8601(~N[2000-02-28 00:00:00])\n    \"2000-02-28\"","ref":"Date.html#to_iso8601/2-examples"},{"type":"function","title":"Date.to_string/1","doc":"Converts the given date to a string according to its calendar.","ref":"Date.html#to_string/1"},{"type":"function","title":"Examples - Date.to_string/1","doc":"iex> Date.to_string(~D[2000-02-28])\n    \"2000-02-28\"\n    iex> Date.to_string(~N[2000-02-28 01:23:45])\n    \"2000-02-28\"\n    iex> Date.to_string(~D[-0100-12-15])\n    \"-0100-12-15\"","ref":"Date.html#to_string/1-examples"},{"type":"function","title":"Date.utc_today/1","doc":"Returns the current date in UTC.","ref":"Date.html#utc_today/1"},{"type":"function","title":"Examples - Date.utc_today/1","doc":"iex> date = Date.utc_today()\n    iex> date.year >= 2016\n    true","ref":"Date.html#utc_today/1-examples"},{"type":"function","title":"Date.year_of_era/1","doc":"Calculates the year-of-era and era for a given\ncalendar year.\n\nReturns a tuple `{year, era}` representing the\nyear within the era and the era number.","ref":"Date.html#year_of_era/1"},{"type":"function","title":"Examples - Date.year_of_era/1","doc":"iex> Date.year_of_era(~D[0001-01-01])\n    {1, 1}\n    iex> Date.year_of_era(~D[0000-12-31])\n    {1, 0}\n    iex> Date.year_of_era(~D[-0001-01-01])\n    {2, 0}","ref":"Date.html#year_of_era/1-examples"},{"type":"module","title":"DateTime","doc":"A datetime implementation with a time zone.\n\nThis datetime can be seen as a snapshot of a date and time\nat a given time zone. For such purposes, it also includes both\nUTC and Standard offsets, as well as the zone abbreviation\nfield used exclusively for formatting purposes. Note future\ndatetimes are not necessarily guaranteed to exist, as time\nzones may change any time in the future due to geopolitical\nreasons. See the \"Datetimes as snapshots\" section for more\ninformation.\n\nRemember, comparisons in Elixir using `==/2`, `>/2`, `</2` and friends\nare structural and based on the DateTime struct fields. For proper\ncomparison between datetimes, use the `compare/2` function. The\nexistence of the `compare/2` function in this module also allows\nusing `Enum.min/2` and `Enum.max/2` functions to get the minimum and\nmaximum datetime of an `Enum`. For example:\n\n    iex> Enum.min([~U[2022-01-12 00:01:00.00Z], ~U[2021-01-12 00:01:00.00Z]], DateTime)\n    ~U[2021-01-12 00:01:00.00Z]\n\nDevelopers should avoid creating the `DateTime` struct directly\nand instead rely on the functions provided by this module as\nwell as the ones in third-party calendar libraries.","ref":"DateTime.html"},{"type":"module","title":"Time zone database - DateTime","doc":"Many functions in this module require a time zone database.\nBy default, it uses the default time zone database returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase` which only handles \"Etc/UTC\"\ndatetimes and returns `{:error, :utc_only_time_zone_database}`\nfor any other time zone.\n\nOther time zone databases can also be configured. Here are some\navailable options and libraries:\n\n  * [`time_zone_info`](https://github.com/hrzndhrn/time_zone_info)\n  * [`tz`](https://github.com/mathieuprog/tz)\n  * [`tzdata`](https://github.com/lau/tzdata)\n  * [`zoneinfo`](https://github.com/smartrent/zoneinfo) -\n    recommended for embedded devices\n\nTo use them, first make sure it is added as a dependency in `mix.exs`.\nIt can then be configured either via configuration:\n\n    config :elixir, :time_zone_database, Tz.TimeZoneDatabase\n\nor by calling `Calendar.put_time_zone_database/1`:\n\n    Calendar.put_time_zone_database(Tz.TimeZoneDatabase)\n\nSee the proper names in the library installation instructions.","ref":"DateTime.html#module-time-zone-database"},{"type":"module","title":"Datetimes as snapshots - DateTime","doc":"In the first section, we described datetimes as a \"snapshot of\na date and time at a given time zone\". To understand precisely\nwhat we mean, let's see an example.\n\nImagine someone in Poland who wants to schedule a meeting with someone\nin Brazil in the next year. The meeting will happen at 2:30 AM\nin the Polish time zone. At what time will the meeting happen in\nBrazil?\n\nYou can consult the time zone database today, one year before,\nusing the API in this module and it will give you an answer that\nis valid right now. However, this answer may not be valid in the\nfuture. Why? Because both Brazil and Poland may change their timezone\nrules, ultimately affecting the result. For example, a country may\nchoose to enter or abandon \"Daylight Saving Time\", which is a\nprocess where we adjust the clock one hour forward or one hour\nback once per year. Whenever the rules change, the exact instant\nthat 2:30 AM in Polish time will be in Brazil may change.\n\nIn other words, whenever working with future DateTimes, there is\nno guarantee the results you get will always be correct, until\nthe event actually happens. Therefore, when you ask for a future\ntime, the answers you get are a snapshot that reflects the current\nstate of the time zone rules. For datetimes in the past, this is\nnot a problem, because time zone rules do not change for past\nevents.\n\nTo make matters worse, it may be that 2:30 AM in Polish time\ndoes not actually even exist or it is ambiguous. If a certain\ntime zone observes \"Daylight Saving Time\", they will move their\nclock forward once a year. When this happens, there is a whole\nhour that does not exist. Then, when they move the clock back,\nthere is a certain hour that will happen twice. So if you want to\nschedule a meeting when this shift back happens, you would need to\nexplicitly say which occurrence of 2:30 AM you mean: the one in\n\"Summer Time\", which occurs before the shift, or the one\nin \"Standard Time\", which occurs after it. Applications that are\ndate and time sensitive need to take these scenarios into account\nand correctly communicate them to users.\n\nThe good news is: Elixir contains all of the building blocks\nnecessary to tackle those problems. The default timezone database\nused by Elixir, `Calendar.UTCOnlyTimeZoneDatabase`, only works\nwith UTC, which does not observe those issues. Once you bring\na proper time zone database, the functions in this module will\nquery the database and return the relevant information. For\nexample, look at how `DateTime.new/4` returns different results\nbased on the scenarios described in this section.","ref":"DateTime.html#module-datetimes-as-snapshots"},{"type":"module","title":"Converting between timezones - DateTime","doc":"Bearing in mind the cautions above, and assuming you've brought in a full\ntimezone database, here are some examples of common shifts between time\nzones.\n\n    # Local time to UTC\n    new_york = DateTime.from_naive!(~N[2023-06-26T09:30:00], \"America/New_York\")\n    #=> #DateTime<2023-06-26 09:30:00-04:00 EDT America/New_York>\n\n    utc = DateTime.shift_zone!(new_york, \"Etc/UTC\")\n    #=> ~U[2023-06-26 13:30:00Z]\n\n    # UTC to local time\n    DateTime.shift_zone!(utc, \"Europe/Paris\")\n    #=> #DateTime<2023-06-26 15:30:00+02:00 CEST Europe/Paris>","ref":"DateTime.html#module-converting-between-timezones"},{"type":"function","title":"DateTime.add/4","doc":"Adds a specified amount of time to a `DateTime`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always considers the unit to be computed according\nto the `Calendar.ISO`.\n\nThis function relies on a contiguous representation of time,\nignoring the wall time and timezone changes. For example, if you add\none day when there are summer time/daylight saving time changes,\nit will also change the time forward or backward by one hour,\nso the elapsed time is precisely 24 hours. Similarly, adding just\na few seconds to a datetime just before \"spring forward\" can cause\nwall time to increase by more than an hour.\n\nWhile this means this function is precise in terms of elapsed time,\nits result may be misleading in certain use cases. For example, if a\nuser requests a meeting to happen every day at 15:00 and you use this\nfunction to compute all future meetings by adding day after day, this\nfunction may change the meeting time to 14:00 or 16:00 if there are\nchanges to the current timezone. Computing of recurring datetimes is\nnot currently supported in Elixir's standard library but it is available\nby third-party libraries.","ref":"DateTime.html#add/4"},{"type":"function","title":"Examples - DateTime.add/4","doc":"iex> dt = DateTime.from_naive!(~N[2018-11-15 10:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(3600, :second, FakeTimeZoneDatabase)\n    #DateTime<2018-11-15 11:00:00+01:00 CET Europe/Copenhagen>\n\n    iex> DateTime.add(~U[2018-11-15 10:00:00Z], 3600, :second)\n    ~U[2018-11-15 11:00:00Z]\n\nWhen adding 3 seconds just before \"spring forward\" we go from 1:59:59 to 3:00:02:\n\n    iex> dt = DateTime.from_naive!(~N[2019-03-31 01:59:59.123], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(3, :second, FakeTimeZoneDatabase)\n    #DateTime<2019-03-31 03:00:02.123+02:00 CEST Europe/Copenhagen>\n\nWhen adding 1 day during \"spring forward\", the hour also changes:\n\n    iex> dt = DateTime.from_naive!(~N[2019-03-31 01:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(1, :day, FakeTimeZoneDatabase)\n    #DateTime<2019-04-01 02:00:00+02:00 CEST Europe/Copenhagen>\n\nThis operation merges the precision of the naive date time with the given unit:\n\n    iex> result = DateTime.add(~U[2014-10-02 00:29:10Z], 21, :millisecond)\n    ~U[2014-10-02 00:29:10.021Z]\n    iex> result.microsecond\n    {21000, 3}\n\nTo shift a datetime by a `Duration` and according to its underlying calendar, use `DateTime.shift/3`.","ref":"DateTime.html#add/4-examples"},{"type":"function","title":"DateTime.after?/2","doc":"Returns `true` if the first datetime is strictly later than the second.","ref":"DateTime.html#after?/2"},{"type":"function","title":"Examples - DateTime.after?/2","doc":"iex> DateTime.after?(~U[2022-02-02 11:00:00Z], ~U[2021-01-01 11:00:00Z])\n    true\n    iex> DateTime.after?(~U[2021-01-01 11:00:00Z], ~U[2021-01-01 11:00:00Z])\n    false\n    iex> DateTime.after?(~U[2021-01-01 11:00:00Z], ~U[2022-02-02 11:00:00Z])\n    false","ref":"DateTime.html#after?/2-examples"},{"type":"function","title":"DateTime.before?/2","doc":"Returns `true` if the first datetime is strictly earlier than the second.","ref":"DateTime.html#before?/2"},{"type":"function","title":"Examples - DateTime.before?/2","doc":"iex> DateTime.before?(~U[2021-01-01 11:00:00Z], ~U[2022-02-02 11:00:00Z])\n    true\n    iex> DateTime.before?(~U[2021-01-01 11:00:00Z], ~U[2021-01-01 11:00:00Z])\n    false\n    iex> DateTime.before?(~U[2022-02-02 11:00:00Z], ~U[2021-01-01 11:00:00Z])\n    false","ref":"DateTime.html#before?/2-examples"},{"type":"function","title":"DateTime.compare/2","doc":"Compares two datetime structs.\n\nReturns `:gt` if the first datetime is later than the second\nand `:lt` for vice versa. If the two datetimes are equal\n`:eq` is returned.\n\nNote that both UTC and Standard offsets will be taken into\naccount when comparison is done.","ref":"DateTime.html#compare/2"},{"type":"function","title":"Examples - DateTime.compare/2","doc":"iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.compare(dt1, dt2)\n    :gt","ref":"DateTime.html#compare/2-examples"},{"type":"function","title":"DateTime.convert/2","doc":"Converts a given `datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an `{:error, :incompatible_calendars}` tuple\nis returned.","ref":"DateTime.html#convert/2"},{"type":"function","title":"Examples - DateTime.convert/2","doc":"Imagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.convert(dt1, Calendar.Holocene)\n    {:ok, %DateTime{calendar: Calendar.Holocene, day: 29, hour: 23,\n                    microsecond: {0, 0}, minute: 0, month: 2, second: 7, std_offset: 0,\n                    time_zone: \"America/Manaus\", utc_offset: -14400, year: 12000,\n                    zone_abbr: \"AMT\"}}","ref":"DateTime.html#convert/2-examples"},{"type":"function","title":"DateTime.convert!/2","doc":"Converts a given `datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an ArgumentError is raised.","ref":"DateTime.html#convert!/2"},{"type":"function","title":"Examples - DateTime.convert!/2","doc":"Imagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.convert!(dt1, Calendar.Holocene)\n    %DateTime{calendar: Calendar.Holocene, day: 29, hour: 23,\n              microsecond: {0, 0}, minute: 0, month: 2, second: 7, std_offset: 0,\n              time_zone: \"America/Manaus\", utc_offset: -14400, year: 12000,\n              zone_abbr: \"AMT\"}","ref":"DateTime.html#convert!/2-examples"},{"type":"function","title":"DateTime.diff/3","doc":"Subtracts `datetime2` from `datetime1`.\n\nThe answer can be returned in any `:day`, `:hour`, `:minute`, or any `unit`\navailable from `t:System.time_unit/0`. The unit is measured according to\n`Calendar.ISO` and defaults to `:second`.\n\nFractional results are not supported and are truncated.","ref":"DateTime.html#diff/3"},{"type":"function","title":"Examples - DateTime.diff/3","doc":"iex> DateTime.diff(~U[2024-01-15 10:00:10Z], ~U[2024-01-15 10:00:00Z])\n    10\n\nThis function also considers timezone offsets:\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.diff(dt1, dt2)\n    18000\n    iex> DateTime.diff(dt2, dt1)\n    -18000\n    iex> DateTime.diff(dt1, dt2, :hour)\n    5\n    iex> DateTime.diff(dt2, dt1, :hour)\n    -5","ref":"DateTime.html#diff/3-examples"},{"type":"function","title":"DateTime.from_gregorian_seconds/3","doc":"Converts a number of gregorian seconds to a `DateTime` struct.\n\nThe returned `DateTime` will have `UTC` timezone, if you want other timezone, please use\n`DateTime.shift_zone/3`.","ref":"DateTime.html#from_gregorian_seconds/3"},{"type":"function","title":"Examples - DateTime.from_gregorian_seconds/3","doc":"iex> DateTime.from_gregorian_seconds(1)\n    ~U[0000-01-01 00:00:01Z]\n    iex> DateTime.from_gregorian_seconds(63_755_511_991, {5000, 3})\n    ~U[2020-05-01 00:26:31.005Z]\n    iex> DateTime.from_gregorian_seconds(-1)\n    ~U[-0001-12-31 23:59:59Z]","ref":"DateTime.html#from_gregorian_seconds/3-examples"},{"type":"function","title":"DateTime.from_iso8601/2","doc":"Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nSince ISO 8601 does not include the proper time zone, the given\nstring will be converted to UTC and its offset in seconds will be\nreturned as part of this function. Therefore offset information\nmust be present in the string.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\nNote leap seconds are not supported by the built-in Calendar.ISO.","ref":"DateTime.html#from_iso8601/2"},{"type":"function","title":"Examples - DateTime.from_iso8601/2","doc":"iex> {:ok, datetime, 0} = DateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n    iex> datetime\n    ~U[2015-01-23 23:50:07Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07,123+02:30\")\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 0} = DateTime.from_iso8601(\"-2015-01-23T23:50:07Z\")\n    iex> datetime\n    ~U[-2015-01-23 23:50:07Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"-2015-01-23T23:50:07,123+02:30\")\n    iex> datetime\n    ~U[-2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"20150123T235007.123+0230\", :basic)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> DateTime.from_iso8601(\"2015-01-23P23:50:07\")\n    {:error, :invalid_format}\n    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07\")\n    {:error, :missing_offset}\n    iex> DateTime.from_iso8601(\"2015-01-23 23:50:61\")\n    {:error, :invalid_time}\n    iex> DateTime.from_iso8601(\"2015-01-32 23:50:07\")\n    {:error, :invalid_date}\n    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n    {:error, :invalid_format}","ref":"DateTime.html#from_iso8601/2-examples"},{"type":"function","title":"DateTime.from_iso8601/3","doc":"Converts from ISO8601 specifying both a calendar and a mode.\n\nSee `from_iso8601/2` for more information.","ref":"DateTime.html#from_iso8601/3"},{"type":"function","title":"Examples - DateTime.from_iso8601/3","doc":"iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07,123+02:30\", Calendar.ISO, :extended)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"20150123T235007.123+0230\", Calendar.ISO, :basic)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]","ref":"DateTime.html#from_iso8601/3-examples"},{"type":"function","title":"DateTime.from_naive/3","doc":"Converts the given `NaiveDateTime` to `DateTime`.\n\nIt expects a time zone to put the `NaiveDateTime` in.\nIf the time zone is \"Etc/UTC\", it always succeeds. Otherwise,\nthe NaiveDateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.","ref":"DateTime.html#from_naive/3"},{"type":"function","title":"Examples - DateTime.from_naive/3","doc":"iex> DateTime.from_naive(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n    {:ok, ~U[2016-05-24 13:26:08.003Z]}\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - the two possible valid datetimes are returned in a tuple.\nThe first datetime is also the one which comes first chronologically, while\nthe second one comes last.\n\n    iex> {:ambiguous, first_dt, second_dt} = DateTime.from_naive(~N[2018-10-28 02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> first_dt\n    #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen>\n    iex> second_dt\n    #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - the latest valid datetime just before the gap and the first\nvalid datetime just after the gap.\n\n    iex> {:gap, just_before, just_after} = DateTime.from_naive(~N[2019-03-31 02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> just_before\n    #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen>\n    iex> just_after\n    #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> {:ok, datetime} = DateTime.from_naive(~N[2018-07-28 12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>\n\nThis function accepts any map or struct that contains at least the same fields as a `NaiveDateTime`\nstruct. The most common example of that is a `DateTime`. In this case the information about the time\nzone of that `DateTime` is completely ignored. This is the same principle as passing a `DateTime` to\n`Date.to_iso8601/2`. `Date.to_iso8601/2` extracts only the date-specific fields (calendar, year,\nmonth and day) of the given structure and ignores all others.\n\nThis way if you have a `DateTime` in one time zone, you can get the same wall time in another time zone.\nFor instance if you have 2018-08-24 10:00:00 in Copenhagen and want a `DateTime` for 2018-08-24 10:00:00\nin UTC you can do:\n\n    iex> cph_datetime = DateTime.from_naive!(~N[2018-08-24 10:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> {:ok, utc_datetime} = DateTime.from_naive(cph_datetime, \"Etc/UTC\", FakeTimeZoneDatabase)\n    iex> utc_datetime\n    ~U[2018-08-24 10:00:00Z]\n\nIf instead you want a `DateTime` for the same point time in a different time zone see the\n`DateTime.shift_zone/3` function which would convert 2018-08-24 10:00:00 in Copenhagen\nto 2018-08-24 08:00:00 in UTC.","ref":"DateTime.html#from_naive/3-examples"},{"type":"function","title":"DateTime.from_naive!/3","doc":"Converts the given `NaiveDateTime` to `DateTime`.\n\nIt expects a time zone to put the NaiveDateTime in.\nIf the time zone is \"Etc/UTC\", it always succeeds. Otherwise,\nthe NaiveDateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.","ref":"DateTime.html#from_naive!/3"},{"type":"function","title":"Examples - DateTime.from_naive!/3","doc":"iex> DateTime.from_naive!(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n    ~U[2016-05-24 13:26:08.003Z]\n\n    iex> DateTime.from_naive!(~N[2018-05-24 13:26:08.003], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    #DateTime<2018-05-24 13:26:08.003+02:00 CEST Europe/Copenhagen>","ref":"DateTime.html#from_naive!/3-examples"},{"type":"function","title":"DateTime.from_unix/3","doc":"Converts the given Unix time to `DateTime`.\n\nThe integer can be given in different unit\naccording to `System.convert_time_unit/3` and it will\nbe converted to microseconds internally. Up to\n253402300799 seconds is supported.\n\nUnix times are always in UTC and therefore the DateTime\nwill be returned in UTC.","ref":"DateTime.html#from_unix/3"},{"type":"function","title":"Examples - DateTime.from_unix/3","doc":"iex> {:ok, datetime} = DateTime.from_unix(1_464_096_368)\n    iex> datetime\n    ~U[2016-05-24 13:26:08Z]\n\n    iex> {:ok, datetime} = DateTime.from_unix(1_432_560_368_868_569, :microsecond)\n    iex> datetime\n    ~U[2015-05-25 13:26:08.868569Z]\n\n    iex> {:ok, datetime} = DateTime.from_unix(253_402_300_799)\n    iex> datetime\n    ~U[9999-12-31 23:59:59Z]\n\n    iex> {:error, :invalid_unix_time} = DateTime.from_unix(253_402_300_800)\n\nThe unit can also be an integer as in `t:System.time_unit/0`:\n\n    iex> {:ok, datetime} = DateTime.from_unix(143_256_036_886_856, 1024)\n    iex> datetime\n    ~U[6403-03-17 07:05:22.320312Z]\n\nNegative Unix times are supported up to -377705116800 seconds:\n\n    iex> {:ok, datetime} = DateTime.from_unix(-377_705_116_800)\n    iex> datetime\n    ~U[-9999-01-01 00:00:00Z]\n\n    iex> {:error, :invalid_unix_time} = DateTime.from_unix(-377_705_116_801)","ref":"DateTime.html#from_unix/3-examples"},{"type":"function","title":"DateTime.from_unix!/3","doc":"Converts the given Unix time to `DateTime`.\n\nThe integer can be given in different unit\naccording to `System.convert_time_unit/3` and it will\nbe converted to microseconds internally.\n\nUnix times are always in UTC and therefore the DateTime\nwill be returned in UTC.","ref":"DateTime.html#from_unix!/3"},{"type":"function","title":"Examples - DateTime.from_unix!/3","doc":"# An easy way to get the Unix epoch is passing 0 to this function\n    iex> DateTime.from_unix!(0)\n    ~U[1970-01-01 00:00:00Z]\n\n    iex> DateTime.from_unix!(1_464_096_368)\n    ~U[2016-05-24 13:26:08Z]\n\n    iex> DateTime.from_unix!(1_432_560_368_868_569, :microsecond)\n    ~U[2015-05-25 13:26:08.868569Z]\n\n    iex> DateTime.from_unix!(143_256_036_886_856, 1024)\n    ~U[6403-03-17 07:05:22.320312Z]","ref":"DateTime.html#from_unix!/3-examples"},{"type":"function","title":"DateTime.new/4","doc":"Builds a datetime from date and time structs.\n\nIt expects a time zone to put the `DateTime` in.\nIf the time zone is not passed it will default to `\"Etc/UTC\"`,\nwhich always succeeds. Otherwise, the `DateTime` is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.","ref":"DateTime.html#new/4"},{"type":"function","title":"Examples - DateTime.new/4","doc":"iex> DateTime.new(~D[2016-05-24], ~T[13:26:08.003], \"Etc/UTC\")\n    {:ok, ~U[2016-05-24 13:26:08.003Z]}\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - the two possible valid datetimes are returned in a tuple.\nThe first datetime is also the one which comes first chronologically, while\nthe second one comes last.\n\n    iex> {:ambiguous, first_dt, second_dt} = DateTime.new(~D[2018-10-28], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> first_dt\n    #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen>\n    iex> second_dt\n    #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - the latest valid datetime just before the gap and the first\nvalid datetime just after the gap.\n\n    iex> {:gap, just_before, just_after} = DateTime.new(~D[2019-03-31], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> just_before\n    #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen>\n    iex> just_after\n    #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> {:ok, datetime} = DateTime.new(~D[2018-07-28], ~T[12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>","ref":"DateTime.html#new/4-examples"},{"type":"function","title":"DateTime.new!/4","doc":"Builds a datetime from date and time structs, raising on errors.\n\nIt expects a time zone to put the `DateTime` in.\nIf the time zone is not passed it will default to `\"Etc/UTC\"`,\nwhich always succeeds. Otherwise, the DateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.","ref":"DateTime.html#new!/4"},{"type":"function","title":"Examples - DateTime.new!/4","doc":"iex> DateTime.new!(~D[2016-05-24], ~T[13:26:08.003], \"Etc/UTC\")\n    ~U[2016-05-24 13:26:08.003Z]\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - an error will be raised.\n\n    iex> DateTime.new!(~D[2018-10-28], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot build datetime with ~D[2018-10-28] and ~T[02:30:00] because such instant is ambiguous in time zone Europe/Copenhagen as there is an overlap between #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen> and #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - an error will be raised.\n\n    iex> DateTime.new!(~D[2019-03-31], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot build datetime with ~D[2019-03-31] and ~T[02:30:00] because such instant does not exist in time zone Europe/Copenhagen as there is a gap between #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen> and #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> datetime = DateTime.new!(~D[2018-07-28], ~T[12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>","ref":"DateTime.html#new!/4-examples"},{"type":"function","title":"DateTime.now/2","doc":"Returns the current datetime in the provided time zone.\n\nBy default, it uses the default time_zone returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase` which only handles \"Etc/UTC\" datetimes.\nOther time zone databases can be passed as argument or set globally.\nSee the \"Time zone database\" section in the module docs.","ref":"DateTime.html#now/2"},{"type":"function","title":"Examples - DateTime.now/2","doc":"iex> {:ok, datetime} = DateTime.now(\"Etc/UTC\")\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> DateTime.now(\"Europe/Copenhagen\")\n    {:error, :utc_only_time_zone_database}\n\n    iex> DateTime.now(\"bad timezone\", FakeTimeZoneDatabase)\n    {:error, :time_zone_not_found}","ref":"DateTime.html#now/2-examples"},{"type":"function","title":"DateTime.now!/2","doc":"Returns the current datetime in the provided time zone or raises on errors\n\nSee `now/2` for more information.","ref":"DateTime.html#now!/2"},{"type":"function","title":"Examples - DateTime.now!/2","doc":"iex> datetime = DateTime.now!(\"Etc/UTC\")\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> DateTime.now!(\"Europe/Copenhagen\")\n    ** (ArgumentError) cannot get current datetime in \"Europe/Copenhagen\" time zone, reason: :utc_only_time_zone_database\n\n    iex> DateTime.now!(\"bad timezone\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot get current datetime in \"bad timezone\" time zone, reason: :time_zone_not_found","ref":"DateTime.html#now!/2-examples"},{"type":"function","title":"DateTime.shift/3","doc":"Shifts given `datetime` by `duration` according to its calendar.\n\nAllowed units are: `:year`, `:month`, `:week`, `:day`, `:hour`, `:minute`, `:second`, `:microsecond`.\n\nThis operation is equivalent to shifting the datetime wall clock\n(in other words, the value as someone in that timezone would see\non their watch), then applying the time zone offset to convert it\nto UTC, and finally computing the new timezone in case of shifts.\nThis ensures `shift/3` always returns a valid datetime.\n\nOn the other hand, time zones that observe \"Daylight Saving Time\"\nor other changes, across summer/winter time will add/remove hours\nfrom the resulting datetime:\n\n    dt = DateTime.new!(~D[2019-03-31], ~T[01:00:00], \"Europe/Copenhagen\")\n    DateTime.shift(dt, hour: 1)\n    #=> #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\n    dt = DateTime.new!(~D[2018-11-04], ~T[00:00:00], \"America/Los_Angeles\")\n    DateTime.shift(dt, hour: 2)\n    #=> #DateTime<2018-11-04 01:00:00-08:00 PST America/Los_Angeles>\n\nIn case you don't want these changes to happen automatically or you\nwant to surface time zone conflicts to the user, you can shift\nthe datetime as a naive datetime and then use `from_naive/2`:\n\n    dt |> NaiveDateTime.shift(duration) |> DateTime.from_naive(dt.time_zone)\n\nWhen using the default ISO calendar, durations are collapsed and\napplied in the order of months, then seconds and microseconds:\n\n* when shifting by 1 year and 2 months the date is actually shifted by 14 months\n* weeks, days and smaller units are collapsed into seconds and microseconds\n\nWhen shifting by month, days are rounded down to the nearest valid date.","ref":"DateTime.html#shift/3"},{"type":"function","title":"Examples - DateTime.shift/3","doc":"iex> DateTime.shift(~U[2016-01-01 00:00:00Z], month: 2)\n    ~U[2016-03-01 00:00:00Z]\n    iex> DateTime.shift(~U[2016-01-01 00:00:00Z], year: 1, week: 4)\n    ~U[2017-01-29 00:00:00Z]\n    iex> DateTime.shift(~U[2016-01-01 00:00:00Z], minute: -25)\n    ~U[2015-12-31 23:35:00Z]\n    iex> DateTime.shift(~U[2016-01-01 00:00:00Z], minute: 5, microsecond: {500, 4})\n    ~U[2016-01-01 00:05:00.0005Z]\n\n    # leap years\n    iex> DateTime.shift(~U[2024-02-29 00:00:00Z], year: 1)\n    ~U[2025-02-28 00:00:00Z]\n    iex> DateTime.shift(~U[2024-02-29 00:00:00Z], year: 4)\n    ~U[2028-02-29 00:00:00Z]\n\n    # rounding down\n    iex> DateTime.shift(~U[2015-01-31 00:00:00Z], month: 1)\n    ~U[2015-02-28 00:00:00Z]","ref":"DateTime.html#shift/3-examples"},{"type":"function","title":"DateTime.shift_zone/3","doc":"Changes the time zone of a `DateTime`.\n\nReturns a `DateTime` for the same point in time, but instead at\nthe time zone provided. It assumes that `DateTime` is valid and\nexists in the given time zone and calendar.\n\nBy default, it uses the default time zone database returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase` which only handles \"Etc/UTC\" datetimes.\nOther time zone databases can be passed as argument or set globally.\nSee the \"Time zone database\" section in the module docs.","ref":"DateTime.html#shift_zone/3"},{"type":"function","title":"Examples - DateTime.shift_zone/3","doc":"iex> {:ok, pacific_datetime} = DateTime.shift_zone(~U[2018-07-16 10:00:00Z], \"America/Los_Angeles\", FakeTimeZoneDatabase)\n    iex> pacific_datetime\n    #DateTime<2018-07-16 03:00:00-07:00 PDT America/Los_Angeles>\n\n    iex> DateTime.shift_zone(~U[2018-07-16 10:00:00Z], \"bad timezone\", FakeTimeZoneDatabase)\n    {:error, :time_zone_not_found}","ref":"DateTime.html#shift_zone/3-examples"},{"type":"function","title":"DateTime.shift_zone!/3","doc":"Changes the time zone of a `DateTime` or raises on errors.\n\nSee `shift_zone/3` for more information.","ref":"DateTime.html#shift_zone!/3"},{"type":"function","title":"Examples - DateTime.shift_zone!/3","doc":"iex> DateTime.shift_zone!(~U[2018-07-16 10:00:00Z], \"America/Los_Angeles\", FakeTimeZoneDatabase)\n    #DateTime<2018-07-16 03:00:00-07:00 PDT America/Los_Angeles>\n\n    iex> DateTime.shift_zone!(~U[2018-07-16 10:00:00Z], \"bad timezone\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot shift ~U[2018-07-16 10:00:00Z] to \"bad timezone\" time zone, reason: :time_zone_not_found","ref":"DateTime.html#shift_zone!/3-examples"},{"type":"type","title":"DateTime.t/0","doc":"","ref":"DateTime.html#t:t/0"},{"type":"function","title":"DateTime.to_date/1","doc":"Converts a `DateTime` into a `Date`.\n\nBecause `Date` does not hold time nor time zone information,\ndata will be lost during the conversion.","ref":"DateTime.html#to_date/1"},{"type":"function","title":"Examples - DateTime.to_date/1","doc":"iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_date(dt)\n    ~D[2000-02-29]","ref":"DateTime.html#to_date/1-examples"},{"type":"function","title":"DateTime.to_gregorian_seconds/1","doc":"Converts a `DateTime` struct to a number of gregorian seconds and microseconds.","ref":"DateTime.html#to_gregorian_seconds/1"},{"type":"function","title":"Examples - DateTime.to_gregorian_seconds/1","doc":"iex> dt = %DateTime{year: 0000, month: 1, day: 1, zone_abbr: \"UTC\",\n    ...>                hour: 0, minute: 0, second: 1, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {1, 0}\n\n    iex> dt = %DateTime{year: 2020, month: 5, day: 1, zone_abbr: \"UTC\",\n    ...>                hour: 0, minute: 26, second: 31, microsecond: {5000, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {63_755_511_991, 5000}\n\n    iex> dt = %DateTime{year: 2020, month: 5, day: 1, zone_abbr: \"CET\",\n    ...>                hour: 1, minute: 26, second: 31, microsecond: {5000, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {63_755_511_991, 5000}","ref":"DateTime.html#to_gregorian_seconds/1-examples"},{"type":"function","title":"DateTime.to_iso8601/3","doc":"Converts the given datetime to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601) format.\n\nBy default, `DateTime.to_iso8601/2` returns datetimes formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting datetimes which are in the ISO calendar,\nattempting to convert datetimes from other calendars will raise.\nYou can also optionally specify an offset for the formatted string.\n\nWARNING: the ISO 8601 datetime format does not contain the time zone nor\nits abbreviation, which means information is lost when converting to such\nformat.","ref":"DateTime.html#to_iso8601/3"},{"type":"function","title":"Examples - DateTime.to_iso8601/3","doc":"iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07+01:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07Z\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended)\n    \"2000-02-29T23:00:07-04:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :basic)\n    \"20000229T230007-0400\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended, 3600)\n    \"2000-03-01T04:00:07+01:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended, 0)\n    \"2000-03-01T03:00:07+00:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 3, day: 01, zone_abbr: \"UTC\",\n    ...>                hour: 03, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_iso8601(dt, :extended, 0)\n    \"2000-03-01T03:00:07Z\"\n\n    iex> {:ok, dt, offset} = DateTime.from_iso8601(\"2000-03-01T03:00:07Z\")\n    iex> \"2000-03-01T03:00:07Z\" = DateTime.to_iso8601(dt, :extended, offset)","ref":"DateTime.html#to_iso8601/3-examples"},{"type":"function","title":"DateTime.to_naive/1","doc":"Converts the given `datetime` into a `NaiveDateTime`.\n\nBecause `NaiveDateTime` does not hold time zone information,\nany time zone related data will be lost during the conversion.","ref":"DateTime.html#to_naive/1"},{"type":"function","title":"Examples - DateTime.to_naive/1","doc":"iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_naive(dt)\n    ~N[2000-02-29 23:00:07.0]","ref":"DateTime.html#to_naive/1-examples"},{"type":"function","title":"DateTime.to_string/1","doc":"Converts the given `datetime` to a string according to its calendar.","ref":"DateTime.html#to_string/1"},{"type":"function","title":"Examples - DateTime.to_string/1","doc":"iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07+01:00 CET Europe/Warsaw\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07Z\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07-04:00 AMT America/Manaus\"\n\n    iex> dt = %DateTime{year: -100, month: 12, day: 19, zone_abbr: \"CET\",\n    ...>                hour: 3, minute: 20, second: 31, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Stockholm\"}\n    iex> DateTime.to_string(dt)\n    \"-0100-12-19 03:20:31+01:00 CET Europe/Stockholm\"","ref":"DateTime.html#to_string/1-examples"},{"type":"function","title":"DateTime.to_time/1","doc":"Converts a `DateTime` into `Time`.\n\nBecause `Time` does not hold date nor time zone information,\ndata will be lost during the conversion.","ref":"DateTime.html#to_time/1"},{"type":"function","title":"Examples - DateTime.to_time/1","doc":"iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_time(dt)\n    ~T[23:00:07.0]","ref":"DateTime.html#to_time/1-examples"},{"type":"function","title":"DateTime.to_unix/2","doc":"Converts the given `datetime` to Unix time.\n\nThe `datetime` is expected to be using the ISO calendar\nwith a year greater than or equal to 0.\n\nIt will return the integer with the given unit,\naccording to `System.convert_time_unit/3`.","ref":"DateTime.html#to_unix/2"},{"type":"function","title":"Examples - DateTime.to_unix/2","doc":"iex> 1_464_096_368 |> DateTime.from_unix!() |> DateTime.to_unix()\n    1464096368\n\n    iex> dt = %DateTime{calendar: Calendar.ISO, day: 20, hour: 18, microsecond: {273806, 6},\n    ...>                minute: 58, month: 11, second: 19, time_zone: \"America/Montevideo\",\n    ...>                utc_offset: -10800, std_offset: 3600, year: 2014, zone_abbr: \"UYST\"}\n    iex> DateTime.to_unix(dt)\n    1416517099\n\n    iex> flamel = %DateTime{calendar: Calendar.ISO, day: 22, hour: 8, microsecond: {527771, 6},\n    ...>                minute: 2, month: 3, second: 25, std_offset: 0, time_zone: \"Etc/UTC\",\n    ...>                utc_offset: 0, year: 1418, zone_abbr: \"UTC\"}\n    iex> DateTime.to_unix(flamel)\n    -17412508655","ref":"DateTime.html#to_unix/2-examples"},{"type":"function","title":"DateTime.truncate/2","doc":"Returns the given datetime with the microsecond field truncated to the given\nprecision (`:microsecond`, `:millisecond` or `:second`).\n\nThe given datetime is returned unchanged if it already has lower precision than\nthe given precision.","ref":"DateTime.html#truncate/2"},{"type":"function","title":"Examples - DateTime.truncate/2","doc":"iex> dt1 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt1, :microsecond)\n    #DateTime<2017-11-07 11:45:18.123456+01:00 CET Europe/Paris>\n\n    iex> dt2 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt2, :millisecond)\n    #DateTime<2017-11-07 11:45:18.123+01:00 CET Europe/Paris>\n\n    iex> dt3 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt3, :second)\n    #DateTime<2017-11-07 11:45:18+01:00 CET Europe/Paris>","ref":"DateTime.html#truncate/2-examples"},{"type":"function","title":"DateTime.utc_now/1","doc":"Returns the current datetime in UTC.\n\nIf you want the current time in Unix seconds,\nuse `System.os_time/1` instead.\n\nYou can also pass a time unit to automatically\ntruncate the resulting datetime. This is available\nsince v1.15.0.\n\nThe default unit if none gets passed is `:native`,\nwhich results on a default resolution of microseconds.","ref":"DateTime.html#utc_now/1"},{"type":"function","title":"Examples - DateTime.utc_now/1","doc":"iex> datetime = DateTime.utc_now()\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> datetime = DateTime.utc_now(:second)\n    iex> datetime.microsecond\n    {0, 0}","ref":"DateTime.html#utc_now/1-examples"},{"type":"function","title":"DateTime.utc_now/2","doc":"Returns the current datetime in UTC, supporting\na specific calendar and precision.\n\nIf you want the current time in Unix seconds,\nuse `System.os_time/1` instead.","ref":"DateTime.html#utc_now/2"},{"type":"function","title":"Examples - DateTime.utc_now/2","doc":"iex> datetime = DateTime.utc_now(:microsecond, Calendar.ISO)\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> datetime = DateTime.utc_now(:second, Calendar.ISO)\n    iex> datetime.microsecond\n    {0, 0}","ref":"DateTime.html#utc_now/2-examples"},{"type":"module","title":"Duration","doc":"Struct and functions for handling durations.\n\nA `Duration` struct represents a collection of time scale units,\nallowing for manipulation and calculation of durations.\n\nDate and time scale units are represented as integers, allowing for\nboth positive and negative values.\n\nMicroseconds are represented using a tuple `{microsecond, precision}`.\nThis ensures compatibility with other calendar types implementing time,\nsuch as `Time`, `DateTime`, and `NaiveDateTime`.","ref":"Duration.html"},{"type":"module","title":"Shifting - Duration","doc":"The most common use of durations in Elixir's standard library is to\n\"shift\" the calendar types.\n\n    iex> Date.shift(~D[2016-01-03], month: 2)\n    ~D[2016-03-03]\n\nIn the example above, `Date.shift/2` automatically converts the units\ninto a `Duration` struct, although one can also be given directly:\n\n    iex> Date.shift(~D[2016-01-03], Duration.new!(month: 2))\n    ~D[2016-03-03]\n\nIt is important to note that shifting is not an arithmetic operation.\nFor example, adding `date + 1 month + 1 month` does not yield the same\nresult as `date + 2 months`. Let's see an example:\n\n    iex> ~D[2016-01-31] |> Date.shift(month: 1) |> Date.shift(month: 1)\n    ~D[2016-03-29]\n\n    iex> ~D[2016-01-31] |> Date.shift(month: 2)\n    ~D[2016-03-31]\n\nAs you can see above, the results differ, which explains why operations\nwith durations are called \"shift\" rather than \"add\". This happens because,\nonce we add one month to `2016-01-31`, we get `2016-02-29`. Then adding\none extra month gives us `2016-03-29` instead of `2016-03-31`.\n\nIn particular, when applying durations to `Calendar.ISO` types:\n\n  * larger units (such as years and months) are applied before\n    smaller ones (such as weeks, hours, days, and so on)\n\n  * units are collapsed into months (`:year` and `:month`),\n    seconds (`:week`, `:day`, `:hour`, `:minute`, `:second`)\n    and microseconds (`:microsecond`) before they are applied\n\n  * 1 year is equivalent to 12 months, 1 week is equivalent to 7 days.\n    Therefore, 4 weeks _are not_ equivalent to 1 month\n\n  * in case of non-existing dates, the results are rounded down to the\n    nearest valid date\n\nAs the `shift/2` functions are calendar aware, they are guaranteed to return\nvalid date/times, considering leap years as well as DST in applicable time zones.","ref":"Duration.html#module-shifting"},{"type":"module","title":"Intervals - Duration","doc":"Durations in Elixir can be combined with stream operations to build intervals.\nFor example, to retrieve the next three Wednesdays starting from 17th April, 2024:\n\n    iex> ~D[2024-04-17] |> Stream.iterate(&Date.shift(&1, week: 1)) |> Enum.take(3)\n    [~D[2024-04-17], ~D[2024-04-24], ~D[2024-05-01]]\n\nHowever, once again, it is important to remember that shifting a duration is not\narithmetic, so you may want to use the functions in this module depending on what\nyou to achieve. Compare the results of both examples below:\n\n    # Adding one month after the other\n    iex> date = ~D[2016-01-31]\n    iex> duration = Duration.new!(month: 1)\n    iex> stream = Stream.iterate(date, fn prev_date -> Date.shift(prev_date, duration) end)\n    iex> Enum.take(stream, 3)\n    [~D[2016-01-31], ~D[2016-02-29], ~D[2016-03-29]]\n\n    # Multiplying durations by an index\n    iex> date = ~D[2016-01-31]\n    iex> duration = Duration.new!(month: 1)\n    iex> stream = Stream.from_index(fn i -> Date.shift(date, Duration.multiply(duration, i)) end)\n    iex> Enum.take(stream, 3)\n    [~D[2016-01-31], ~D[2016-02-29], ~D[2016-03-31]]\n\nThe second example consistently points to the last day of the month,\nas it performs operations on the duration, rather than shifting date\nafter date.","ref":"Duration.html#module-intervals"},{"type":"function","title":"Duration.add/2","doc":"Adds units of given durations `d1` and `d2`.\n\nRespects the the highest microsecond precision of the two.","ref":"Duration.html#add/2"},{"type":"function","title":"Examples - Duration.add/2","doc":"iex> Duration.add(Duration.new!(week: 2, day: 1), Duration.new!(day: 2))\n    %Duration{week: 2, day: 3}\n    iex> Duration.add(Duration.new!(microsecond: {400, 3}), Duration.new!(microsecond: {600, 6}))\n    %Duration{microsecond: {1000, 6}}","ref":"Duration.html#add/2-examples"},{"type":"type","title":"Duration.duration/0","doc":"The duration type specifies a `%Duration{}` struct or a keyword list of valid duration unit pairs.","ref":"Duration.html#t:duration/0"},{"type":"function","title":"Duration.from_iso8601/1","doc":"Parses an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) formatted duration string to a `Duration` struct.\n\nDuration strings, as well as individual units, may be prefixed with plus/minus signs so that:\n\n- `-PT6H3M` parses as `%Duration{hour: -6, minute: -3}`\n- `-PT6H-3M` parses as `%Duration{hour: -6, minute: 3}`\n- `+PT6H3M` parses as `%Duration{hour: 6, minute: 3}`\n- `+PT6H-3M` parses as `%Duration{hour: 6, minute: -3}`\n\nDuration designators must be provided in order of magnitude: `P[n]Y[n]M[n]W[n]DT[n]H[n]M[n]S`.\n\nOnly seconds may be specified with a decimal fraction, using either a comma or a full stop: `P1DT4,5S`.","ref":"Duration.html#from_iso8601/1"},{"type":"function","title":"Examples - Duration.from_iso8601/1","doc":"iex> Duration.from_iso8601(\"P1Y2M3DT4H5M6S\")\n    {:ok, %Duration{year: 1, month: 2, day: 3, hour: 4, minute: 5, second: 6}}\n    iex> Duration.from_iso8601(\"P3Y-2MT3H\")\n    {:ok, %Duration{year: 3, month: -2, hour: 3}}\n    iex> Duration.from_iso8601(\"-PT10H-30M\")\n    {:ok, %Duration{hour: -10, minute: 30}}\n    iex> Duration.from_iso8601(\"PT4.650S\")\n    {:ok, %Duration{second: 4, microsecond: {650000, 3}}}","ref":"Duration.html#from_iso8601/1-examples"},{"type":"function","title":"Duration.from_iso8601!/1","doc":"Same as `from_iso8601/1` but raises an `ArgumentError`.","ref":"Duration.html#from_iso8601!/1"},{"type":"function","title":"Examples - Duration.from_iso8601!/1","doc":"iex> Duration.from_iso8601!(\"P1Y2M3DT4H5M6S\")\n    %Duration{year: 1, month: 2, day: 3, hour: 4, minute: 5, second: 6}\n    iex> Duration.from_iso8601!(\"P10D\")\n    %Duration{day: 10}","ref":"Duration.html#from_iso8601!/1-examples"},{"type":"function","title":"Duration.multiply/2","doc":"Multiplies `duration` units by given `integer`.","ref":"Duration.html#multiply/2"},{"type":"function","title":"Examples - Duration.multiply/2","doc":"iex> Duration.multiply(Duration.new!(day: 1, minute: 15, second: -10), 3)\n    %Duration{day: 3, minute: 45, second: -30}\n    iex> Duration.multiply(Duration.new!(microsecond: {200, 4}), 3)\n    %Duration{microsecond: {600, 4}}","ref":"Duration.html#multiply/2-examples"},{"type":"function","title":"Duration.negate/1","doc":"Negates `duration` units.","ref":"Duration.html#negate/1"},{"type":"function","title":"Examples - Duration.negate/1","doc":"iex> Duration.negate(Duration.new!(day: 1, minute: 15, second: -10))\n    %Duration{day: -1, minute: -15, second: 10}\n    iex> Duration.negate(Duration.new!(microsecond: {500000, 4}))\n    %Duration{microsecond: {-500000, 4}}","ref":"Duration.html#negate/1-examples"},{"type":"function","title":"Duration.new!/1","doc":"Creates a new `Duration` struct from given `unit_pairs`.\n\nRaises an `ArgumentError` when called with invalid unit pairs.","ref":"Duration.html#new!/1"},{"type":"function","title":"Examples - Duration.new!/1","doc":"iex> Duration.new!(year: 1, week: 3, hour: 4, second: 1)\n    %Duration{year: 1, week: 3, hour: 4, second: 1}\n    iex> Duration.new!(second: 1, microsecond: {1000, 6})\n    %Duration{second: 1, microsecond: {1000, 6}}\n    iex> Duration.new!(month: 2)\n    %Duration{month: 2}","ref":"Duration.html#new!/1-examples"},{"type":"function","title":"Duration.subtract/2","doc":"Subtracts units of given durations `d1` and `d2`.\n\nRespects the the highest microsecond precision of the two.","ref":"Duration.html#subtract/2"},{"type":"function","title":"Examples - Duration.subtract/2","doc":"iex> Duration.subtract(Duration.new!(week: 2, day: 1), Duration.new!(day: 2))\n    %Duration{week: 2, day: -1}\n    iex> Duration.subtract(Duration.new!(microsecond: {400, 6}), Duration.new!(microsecond: {600, 3}))\n    %Duration{microsecond: {-200, 6}}","ref":"Duration.html#subtract/2-examples"},{"type":"type","title":"Duration.t/0","doc":"The duration struct type.","ref":"Duration.html#t:t/0"},{"type":"function","title":"Duration.to_iso8601/1","doc":"Converts the given `duration` to an [ISO 8601-2:2019](https://en.wikipedia.org/wiki/ISO_8601) formatted string.\n\nNote this function implements the *extension* of ISO 8601:2019. This extensions allows weeks to\nappear between months and days: `P3M3W3D`, making it fully compatible with any `Duration` struct.","ref":"Duration.html#to_iso8601/1"},{"type":"function","title":"Examples - Duration.to_iso8601/1","doc":"iex> Duration.to_iso8601(Duration.new!(year: 3))\n    \"P3Y\"\n    iex> Duration.to_iso8601(Duration.new!(day: 40, hour: 12, minute: 42, second: 12))\n    \"P40DT12H42M12S\"\n    iex> Duration.to_iso8601(Duration.new!(second: 30))\n    \"PT30S\"\n\n    iex> Duration.to_iso8601(Duration.new!([]))\n    \"PT0S\"\n\n    iex> Duration.to_iso8601(Duration.new!(second: 1, microsecond: {2_200, 3}))\n    \"PT1.002S\"\n    iex> Duration.to_iso8601(Duration.new!(second: 1, microsecond: {-1_200_000, 4}))\n    \"PT-0.2000S\"","ref":"Duration.html#to_iso8601/1-examples"},{"type":"type","title":"Duration.unit_pair/0","doc":"The unit pair type specifies a pair of a valid duration unit key and value.","ref":"Duration.html#t:unit_pair/0"},{"type":"behaviour","title":"Exception","doc":"Functions for dealing with throw/catch/exit and exceptions.\n\nThis module also defines the behaviour required by custom\nexceptions. To define your own, see `defexception/1`.","ref":"Exception.html"},{"type":"behaviour","title":"Formatting functions - Exception","doc":"Several functions in this module help format exceptions.\nSome of these functions expect the stacktrace as argument.\nThe stacktrace is typically available inside catch and\nrescue by using the `__STACKTRACE__/0` variable.\n\nDo not rely on the particular format returned by the\nfunctions in this module. They may be changed in future releases\nin order to better suit Elixir's tool chain. In other words,\nby using the functions in this module it is guaranteed you will\nformat exceptions as in the current Elixir version being used.","ref":"Exception.html#module-formatting-functions"},{"type":"type","title":"Exception.arity_or_args/0","doc":"","ref":"Exception.html#t:arity_or_args/0"},{"type":"callback","title":"Exception.blame/2","doc":"Called from `Exception.blame/3` to augment the exception struct.\n\nCan be used to collect additional information about the exception\nor do some additional expensive computation.","ref":"Exception.html#c:blame/2"},{"type":"function","title":"Exception.blame/3","doc":"Attaches information to exceptions for extra debugging.\n\nThis operation is potentially expensive, as it reads data\nfrom the file system, parses beam files, evaluates code and\nso on.\n\nIf the exception module implements the optional `c:blame/2`\ncallback, it will be invoked to perform the computation.","ref":"Exception.html#blame/3"},{"type":"function","title":"Exception.blame_mfa/3","doc":"Blames the invocation of the given module, function and arguments.\n\nThis function will retrieve the available clauses from bytecode\nand evaluate them against the given arguments. The clauses are\nreturned as a list of `{args, guards}` pairs where each argument\nand each top-level condition in a guard separated by `and`/`or`\nis wrapped in a tuple with blame metadata.\n\nThis function returns either `{:ok, definition, clauses}` or `:error`.\nWhere `definition` is `:def`, `:defp`, `:defmacro` or `:defmacrop`.","ref":"Exception.html#blame_mfa/3"},{"type":"callback","title":"Exception.exception/1","doc":"Receives the arguments given to `raise/2` and returns the exception struct.\n\nThe default implementation accepts either a set of keyword arguments\nthat is merged into the struct or a string to be used as the exception's message.","ref":"Exception.html#c:exception/1"},{"type":"function","title":"Exception.format/3","doc":"Normalizes and formats throw/errors/exits and stacktraces.\n\nIt relies on `format_banner/3` and `format_stacktrace/1`\nto generate the final format.\n\nIf `kind` is `{:EXIT, pid}`, it does not generate a stacktrace,\nas such exits are retrieved as messages without stacktraces.","ref":"Exception.html#format/3"},{"type":"function","title":"Exception.format_banner/3","doc":"Normalizes and formats any throw/error/exit.\n\nThe message is formatted and displayed in the same\nformat as used by Elixir's CLI.\n\nThe third argument is the stacktrace which is used to enrich\na normalized error with more information. It is only used when\nthe kind is an error.","ref":"Exception.html#format_banner/3"},{"type":"function","title":"Exception.format_exit/1","doc":"Formats an exit. It returns a string.\n\nOften there are errors/exceptions inside exits. Exits are often\nwrapped by the caller and provide stacktraces too. This function\nformats exits in a way to nicely show the exit reason, caller\nand stacktrace.","ref":"Exception.html#format_exit/1"},{"type":"function","title":"Exception.format_fa/2","doc":"Receives an anonymous function and arity and formats it as\nshown in stacktraces. The arity may also be a list of arguments.","ref":"Exception.html#format_fa/2"},{"type":"function","title":"Examples - Exception.format_fa/2","doc":"Exception.format_fa(fn -> nil end, 1)\n    #=> \"#Function<...>/1\"","ref":"Exception.html#format_fa/2-examples"},{"type":"function","title":"Exception.format_file_line/3","doc":"Formats the given `file` and `line` as shown in stacktraces.\n\nIf any of the values are `nil`, they are omitted.","ref":"Exception.html#format_file_line/3"},{"type":"function","title":"Examples - Exception.format_file_line/3","doc":"iex> Exception.format_file_line(\"foo\", 1)\n    \"foo:1:\"\n\n    iex> Exception.format_file_line(\"foo\", nil)\n    \"foo:\"\n\n    iex> Exception.format_file_line(nil, nil)\n    \"\"","ref":"Exception.html#format_file_line/3-examples"},{"type":"function","title":"Exception.format_file_line_column/4","doc":"Formats the given `file`, `line`, and `column` as shown in stacktraces.\n\nIf any of the values are `nil`, they are omitted.","ref":"Exception.html#format_file_line_column/4"},{"type":"function","title":"Examples - Exception.format_file_line_column/4","doc":"iex> Exception.format_file_line_column(\"foo\", 1, 2)\n    \"foo:1:2:\"\n\n    iex> Exception.format_file_line_column(\"foo\", 1, nil)\n    \"foo:1:\"\n\n    iex> Exception.format_file_line_column(\"foo\", nil, nil)\n    \"foo:\"\n\n    iex> Exception.format_file_line_column(\"foo\", nil, 2)\n    \"foo:\"\n\n    iex> Exception.format_file_line_column(nil, nil, nil)\n    \"\"","ref":"Exception.html#format_file_line_column/4-examples"},{"type":"function","title":"Exception.format_mfa/3","doc":"Receives a module, fun and arity and formats it\nas shown in stacktraces. The arity may also be a list\nof arguments.","ref":"Exception.html#format_mfa/3"},{"type":"function","title":"Examples - Exception.format_mfa/3","doc":"iex> Exception.format_mfa(Foo, :bar, 1)\n    \"Foo.bar/1\"\n\n    iex> Exception.format_mfa(Foo, :bar, [])\n    \"Foo.bar()\"\n\n    iex> Exception.format_mfa(nil, :bar, [])\n    \"nil.bar()\"\n\nAnonymous functions are reported as -func/arity-anonfn-count-,\nwhere func is the name of the enclosing function. Convert to\n\"anonymous fn in func/arity\"","ref":"Exception.html#format_mfa/3-examples"},{"type":"function","title":"Exception.format_stacktrace/1","doc":"Formats the stacktrace.\n\nA stacktrace must be given as an argument. If not, the stacktrace\nis retrieved from `Process.info/2`.","ref":"Exception.html#format_stacktrace/1"},{"type":"function","title":"Exception.format_stacktrace_entry/1","doc":"Receives a stacktrace entry and formats it into a string.","ref":"Exception.html#format_stacktrace_entry/1"},{"type":"type","title":"Exception.kind/0","doc":"The kind handled by formatting functions","ref":"Exception.html#t:kind/0"},{"type":"type","title":"Exception.location/0","doc":"","ref":"Exception.html#t:location/0"},{"type":"function","title":"Exception.message/1","doc":"Gets the message for an `exception`.","ref":"Exception.html#message/1"},{"type":"callback","title":"Exception.message/1","doc":"Receives the exception struct and must return its message.\n\nMost commonly exceptions have a message field which by default is accessed\nby this function. However, if an exception does not have a message field,\nthis function must be explicitly implemented.","ref":"Exception.html#c:message/1"},{"type":"type","title":"Exception.non_error_kind/0","doc":"","ref":"Exception.html#t:non_error_kind/0"},{"type":"function","title":"Exception.normalize/3","doc":"Normalizes an exception, converting Erlang exceptions\nto Elixir exceptions.\n\nIt takes the `kind` spilled by `catch` as an argument and\nnormalizes only `:error`, returning the untouched payload\nfor others.\n\nThe third argument is the stacktrace which is used to enrich\na normalized error with more information. It is only used when\nthe kind is an error.","ref":"Exception.html#normalize/3"},{"type":"type","title":"Exception.stacktrace/0","doc":"","ref":"Exception.html#t:stacktrace/0"},{"type":"type","title":"Exception.stacktrace_entry/0","doc":"","ref":"Exception.html#t:stacktrace_entry/0"},{"type":"type","title":"Exception.t/0","doc":"The exception type","ref":"Exception.html#t:t/0"},{"type":"module","title":"Float","doc":"Functions for working with floating-point numbers.\n\nFor mathematical operations on top of floating-points,\nsee Erlang's [`:math`](`:math`) module.","ref":"Float.html"},{"type":"module","title":"Kernel functions - Float","doc":"There are functions related to floating-point numbers on the `Kernel` module\ntoo. Here is a list of them:\n\n  * `Kernel.round/1`: rounds a number to the nearest integer.\n  * `Kernel.trunc/1`: returns the integer part of a number.","ref":"Float.html#module-kernel-functions"},{"type":"module","title":"Known issues - Float","doc":"There are some very well known problems with floating-point numbers\nand arithmetic due to the fact most decimal fractions cannot be\nrepresented by a floating-point binary and most operations are not exact,\nbut operate on approximations. Those issues are not specific\nto Elixir, they are a property of floating point representation itself.\n\nFor example, the numbers 0.1 and 0.01 are two of them, what means the result\nof squaring 0.1 does not give 0.01 neither the closest representable. Here is\nwhat happens in this case:\n\n  * The closest representable number to 0.1 is 0.1000000014\n  * The closest representable number to 0.01 is 0.0099999997\n  * Doing 0.1 * 0.1 should return 0.01, but because 0.1 is actually 0.1000000014,\n    the result is 0.010000000000000002, and because this is not the closest\n    representable number to 0.01, you'll get the wrong result for this operation\n\nThere are also other known problems like flooring or rounding numbers. See\n`round/2` and `floor/2` for more details about them.\n\nTo learn more about floating-point arithmetic visit:\n\n  * [0.30000000000000004.com](http://0.30000000000000004.com/)\n  * [What Every Programmer Should Know About Floating-Point Arithmetic](https://floating-point-gui.de/)","ref":"Float.html#module-known-issues"},{"type":"function","title":"Float.ceil/2","doc":"Rounds a float to the smallest float greater than or equal to `number`.\n\n`ceil/2` also accepts a precision to round a floating-point value down\nto an arbitrary number of fractional digits (between 0 and 15).\n\nThe operation is performed on the binary floating point, without a\nconversion to decimal.\n\nThe behavior of `ceil/2` for floats can be surprising. For example:\n\n    iex> Float.ceil(-12.52, 2)\n    -12.51\n\nOne may have expected it to ceil to -12.52. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as -12.51999999,\nwhich explains the behavior above.\n\nThis function always returns floats. `Kernel.trunc/1` may be used instead to\ntruncate the result to an integer afterwards.","ref":"Float.html#ceil/2"},{"type":"function","title":"Examples - Float.ceil/2","doc":"iex> Float.ceil(34.25)\n    35.0\n    iex> Float.ceil(-56.5)\n    -56.0\n    iex> Float.ceil(34.251, 2)\n    34.26\n    iex> Float.ceil(-0.01)\n    -0.0","ref":"Float.html#ceil/2-examples"},{"type":"function","title":"Float.floor/2","doc":"Rounds a float to the largest float less than or equal to `number`.\n\n`floor/2` also accepts a precision to round a floating-point value down\nto an arbitrary number of fractional digits (between 0 and 15).\nThe operation is performed on the binary floating point, without a\nconversion to decimal.\n\nThis function always returns a float. `Kernel.trunc/1` may be used instead to\ntruncate the result to an integer afterwards.","ref":"Float.html#floor/2"},{"type":"function","title":"Known issues - Float.floor/2","doc":"The behavior of `floor/2` for floats can be surprising. For example:\n\n    iex> Float.floor(12.52, 2)\n    12.51\n\nOne may have expected it to floor to 12.52. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as 12.51999999,\nwhich explains the behavior above.","ref":"Float.html#floor/2-known-issues"},{"type":"function","title":"Examples - Float.floor/2","doc":"iex> Float.floor(34.25)\n    34.0\n    iex> Float.floor(-56.5)\n    -57.0\n    iex> Float.floor(34.259, 2)\n    34.25","ref":"Float.html#floor/2-examples"},{"type":"function","title":"Float.max_finite/0","doc":"Returns the maximum finite value for a float.","ref":"Float.html#max_finite/0"},{"type":"function","title":"Examples - Float.max_finite/0","doc":"iex> Float.max_finite()\n    1.7976931348623157e308","ref":"Float.html#max_finite/0-examples"},{"type":"function","title":"Float.min_finite/0","doc":"Returns the minimum finite value for a float.","ref":"Float.html#min_finite/0"},{"type":"function","title":"Examples - Float.min_finite/0","doc":"iex> Float.min_finite()\n    -1.7976931348623157e308","ref":"Float.html#min_finite/0-examples"},{"type":"function","title":"Float.parse/1","doc":"Parses a binary into a float.\n\nIf successful, returns a tuple in the form of `{float, remainder_of_binary}`;\nwhen the binary cannot be coerced into a valid float, the atom `:error` is\nreturned.\n\nIf the size of float exceeds the maximum size of `1.7976931348623157e+308`,\n`:error` is returned even though the textual representation itself might be\nwell formed.\n\nIf you want to convert a string-formatted float directly to a float,\n`String.to_float/1` can be used instead.","ref":"Float.html#parse/1"},{"type":"function","title":"Examples - Float.parse/1","doc":"iex> Float.parse(\"34\")\n    {34.0, \"\"}\n    iex> Float.parse(\"34.25\")\n    {34.25, \"\"}\n    iex> Float.parse(\"56.5xyz\")\n    {56.5, \"xyz\"}\n\n    iex> Float.parse(\"pi\")\n    :error\n    iex> Float.parse(\"1.7976931348623159e+308\")\n    :error","ref":"Float.html#parse/1-examples"},{"type":"function","title":"Float.pow/2","doc":"Computes `base` raised to power of `exponent`.\n\n`base` must be a float and `exponent` can be any number.\nHowever, if a negative base and a fractional exponent\nare given, it raises `ArithmeticError`.\n\nIt always returns a float. See `Integer.pow/2` for\nexponentiation that returns integers.","ref":"Float.html#pow/2"},{"type":"function","title":"Examples - Float.pow/2","doc":"iex> Float.pow(2.0, 0)\n    1.0\n    iex> Float.pow(2.0, 1)\n    2.0\n    iex> Float.pow(2.0, 10)\n    1024.0\n    iex> Float.pow(2.0, -1)\n    0.5\n    iex> Float.pow(2.0, -3)\n    0.125\n\n    iex> Float.pow(3.0, 1.5)\n    5.196152422706632\n\n    iex> Float.pow(-2.0, 3)\n    -8.0\n    iex> Float.pow(-2.0, 4)\n    16.0\n\n    iex> Float.pow(-1.0, 0.5)\n    ** (ArithmeticError) bad argument in arithmetic expression","ref":"Float.html#pow/2-examples"},{"type":"type","title":"Float.precision_range/0","doc":"","ref":"Float.html#t:precision_range/0"},{"type":"function","title":"Float.ratio/1","doc":"Returns a pair of integers whose ratio is exactly equal\nto the original float and with a positive denominator.","ref":"Float.html#ratio/1"},{"type":"function","title":"Examples - Float.ratio/1","doc":"iex> Float.ratio(0.0)\n    {0, 1}\n    iex> Float.ratio(3.14)\n    {7070651414971679, 2251799813685248}\n    iex> Float.ratio(-3.14)\n    {-7070651414971679, 2251799813685248}\n    iex> Float.ratio(1.5)\n    {3, 2}\n    iex> Float.ratio(-1.5)\n    {-3, 2}\n    iex> Float.ratio(16.0)\n    {16, 1}\n    iex> Float.ratio(-16.0)\n    {-16, 1}","ref":"Float.html#ratio/1-examples"},{"type":"function","title":"Float.round/2","doc":"Rounds a floating-point value to an arbitrary number of fractional\ndigits (between 0 and 15).\n\nThe rounding direction always ties to half up. The operation is\nperformed on the binary floating point, without a conversion to decimal.\n\nThis function only accepts floats and always returns a float. Use\n`Kernel.round/1` if you want a function that accepts both floats\nand integers and always returns an integer.","ref":"Float.html#round/2"},{"type":"function","title":"Known issues - Float.round/2","doc":"The behavior of `round/2` for floats can be surprising. For example:\n\n    iex> Float.round(5.5675, 3)\n    5.567\n\nOne may have expected it to round to the half up 5.568. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as 5.567499999,\nwhich explains the behavior above. If you want exact rounding for decimals,\nyou must use a decimal library. The behavior above is also in accordance\nto reference implementations, such as \"Correctly Rounded Binary-Decimal and\nDecimal-Binary Conversions\" by David M. Gay.","ref":"Float.html#round/2-known-issues"},{"type":"function","title":"Examples - Float.round/2","doc":"iex> Float.round(12.5)\n    13.0\n    iex> Float.round(5.5674, 3)\n    5.567\n    iex> Float.round(5.5675, 3)\n    5.567\n    iex> Float.round(-5.5674, 3)\n    -5.567\n    iex> Float.round(-5.5675)\n    -6.0\n    iex> Float.round(12.341444444444441, 15)\n    12.341444444444441\n    iex> Float.round(-0.01)\n    -0.0","ref":"Float.html#round/2-examples"},{"type":"function","title":"Float.to_charlist/1","doc":"Returns a charlist which corresponds to the shortest text representation\nof the given float.\n\nThe underlying algorithm changes depending on the Erlang/OTP version:\n\n  * For OTP >= 24, it uses the algorithm presented in \"Ryū: fast\n    float-to-string conversion\" in Proceedings of the SIGPLAN '2018\n    Conference on Programming Language Design and Implementation.\n\n  * For OTP < 24, it uses the algorithm presented in \"Printing Floating-Point\n    Numbers Quickly and Accurately\" in Proceedings of the SIGPLAN '1996\n    Conference on Programming Language Design and Implementation.\n\nFor a configurable representation, use `:erlang.float_to_list/2`.","ref":"Float.html#to_charlist/1"},{"type":"function","title":"Examples - Float.to_charlist/1","doc":"iex> Float.to_charlist(7.0)\n    ~c\"7.0\"","ref":"Float.html#to_charlist/1-examples"},{"type":"function","title":"Float.to_string/1","doc":"Returns a binary which corresponds to the shortest text representation\nof the given float.\n\nThe underlying algorithm changes depending on the Erlang/OTP version:\n\n  * For OTP >= 24, it uses the algorithm presented in \"Ryū: fast\n    float-to-string conversion\" in Proceedings of the SIGPLAN '2018\n    Conference on Programming Language Design and Implementation.\n\n  * For OTP < 24, it uses the algorithm presented in \"Printing Floating-Point\n    Numbers Quickly and Accurately\" in Proceedings of the SIGPLAN '1996\n    Conference on Programming Language Design and Implementation.\n\nFor a configurable representation, use `:erlang.float_to_binary/2`.","ref":"Float.html#to_string/1"},{"type":"function","title":"Examples - Float.to_string/1","doc":"iex> Float.to_string(7.0)\n    \"7.0\"","ref":"Float.html#to_string/1-examples"},{"type":"module","title":"Function","doc":"A set of functions for working with functions.\n\nAnonymous functions are typically created by using `fn`:\n\n    iex> add = fn a, b -> a + b end\n    iex> add.(1, 2)\n    3\n\nAnonymous functions can also have multiple clauses. All clauses\nshould expect the same number of arguments:\n\n    iex> negate = fn\n    ...>   true -> false\n    ...>   false -> true\n    ...> end\n    iex> negate.(false)\n    true","ref":"Function.html"},{"type":"module","title":"The capture operator - Function","doc":"It is also possible to capture public module functions and pass them\naround as if they were anonymous functions by using the capture\noperator `&/1`:\n\n    iex> add = &Kernel.+/2\n    iex> add.(1, 2)\n    3\n\n    iex> length = &String.length/1\n    iex> length.(\"hello\")\n    5\n\nTo capture a definition within the current module, you can skip the\nmodule prefix, such as `&my_fun/2`. In those cases, the captured\nfunction can be public (`def`) or private (`defp`).\n\nThe capture operator can also be used to create anonymous functions\nthat expect at least one argument:\n\n    iex> add = &(&1 + &2)\n    iex> add.(1, 2)\n    3\n\nIn such cases, using the capture operator is no different than using `fn`.","ref":"Function.html#module-the-capture-operator"},{"type":"module","title":"Internal and external functions - Function","doc":"We say that functions that point to definitions residing in modules, such\nas `&String.length/1`, are **external** functions. All other functions are\n**local** and they are always bound to the file or module that defined them.\n\nBesides the functions in this module to work with functions, `Kernel` also\nhas an `apply/2` function that invokes a function with a dynamic number of\narguments, as well as `is_function/1` and `is_function/2`, to check\nrespectively if a given value is a function or a function of a given arity.","ref":"Function.html#module-internal-and-external-functions"},{"type":"function","title":"Function.capture/3","doc":"Captures the given function.\n\nInlined by the compiler.","ref":"Function.html#capture/3"},{"type":"function","title":"Examples - Function.capture/3","doc":"iex> Function.capture(String, :length, 1)\n    &String.length/1","ref":"Function.html#capture/3-examples"},{"type":"function","title":"Function.identity/1","doc":"Returns its input `value`. This function can be passed as an anonymous function\nto transformation functions.","ref":"Function.html#identity/1"},{"type":"function","title":"Examples - Function.identity/1","doc":"iex> Function.identity(\"Hello world!\")\n    \"Hello world!\"\n\n    iex> ~c\"abcdaabccc\" |> Enum.sort() |> Enum.chunk_by(&Function.identity/1)\n    [~c\"aaa\", ~c\"bb\", ~c\"cccc\", ~c\"d\"]\n\n    iex> Enum.group_by(~c\"abracadabra\", &Function.identity/1)\n    %{97 => ~c\"aaaaa\", 98 => ~c\"bb\", 99 => ~c\"c\", 100 => ~c\"d\", 114 => ~c\"rr\"}\n\n    iex> Enum.map([1, 2, 3, 4], &Function.identity/1)\n    [1, 2, 3, 4]","ref":"Function.html#identity/1-examples"},{"type":"function","title":"Function.info/1","doc":"Returns a keyword list with information about a function.\n\nThe returned keys (with the corresponding possible values) for\nall types of functions (local and external) are the following:\n\n  * `:type` - `:local` (for anonymous functions) or `:external` (for\n    named functions).\n\n  * `:module` - an atom which is the module where the function is defined when\n  anonymous or the module which the function refers to when it's a named function.\n\n  * `:arity` - (integer) the number of arguments the function is to be called with.\n\n  * `:name` - (atom) the name of the function.\n\n  * `:env` - a list of the environment or free variables. For named\n    functions, the returned list is always empty.\n\nWhen `fun` is an anonymous function (that is, the type is `:local`), the following\nadditional keys are returned:\n\n  * `:pid` - PID of the process that originally created the function.\n\n  * `:index` - (integer) an index into the module function table.\n\n  * `:new_index` - (integer) an index into the module function table.\n\n  * `:new_uniq` - (binary) a unique value for this function. It's\n    calculated from the compiled code for the entire module.\n\n  * `:uniq` - (integer) a unique value for this function. This integer is\n    calculated from the compiled code for the entire module.\n\n**Note**: this function must be used only for debugging purposes.\n\nInlined by the compiler.","ref":"Function.html#info/1"},{"type":"function","title":"Examples - Function.info/1","doc":"iex> fun = fn x -> x end\n    iex> info = Function.info(fun)\n    iex> Keyword.get(info, :arity)\n    1\n    iex> Keyword.get(info, :type)\n    :local\n\n    iex> fun = &String.length/1\n    iex> info = Function.info(fun)\n    iex> Keyword.get(info, :type)\n    :external\n    iex> Keyword.get(info, :name)\n    :length","ref":"Function.html#info/1-examples"},{"type":"function","title":"Function.info/2","doc":"Returns a specific information about the function.\n\nThe returned information is a two-element tuple in the shape of\n`{info, value}`.\n\nFor any function, the information asked for can be any of the atoms\n`:module`, `:name`, `:arity`, `:env`, or `:type`.\n\nFor anonymous functions, there is also information about any of the\natoms `:index`, `:new_index`, `:new_uniq`, `:uniq`, and `:pid`.\nFor a named function, the value of any of these items is always the\natom `:undefined`.\n\nFor more information on each of the possible returned values, see\n`info/1`.\n\nInlined by the compiler.","ref":"Function.html#info/2"},{"type":"function","title":"Examples - Function.info/2","doc":"iex> f = fn x -> x end\n    iex> Function.info(f, :arity)\n    {:arity, 1}\n    iex> Function.info(f, :type)\n    {:type, :local}\n\n    iex> fun = &String.length/1\n    iex> Function.info(fun, :name)\n    {:name, :length}\n    iex> Function.info(fun, :pid)\n    {:pid, :undefined}","ref":"Function.html#info/2-examples"},{"type":"type","title":"Function.information/0","doc":"","ref":"Function.html#t:information/0"},{"type":"module","title":"Integer","doc":"Functions for working with integers.\n\nSome functions that work on integers are found in `Kernel`:\n\n  * `Kernel.abs/1`\n  * `Kernel.div/2`\n  * `Kernel.max/2`\n  * `Kernel.min/2`\n  * `Kernel.rem/2`","ref":"Integer.html"},{"type":"function","title":"Integer.digits/2","doc":"Returns the ordered digits for the given `integer`.\n\nAn optional `base` value may be provided representing the radix for the returned\ndigits. This one must be an integer >= 2.","ref":"Integer.html#digits/2"},{"type":"function","title":"Examples - Integer.digits/2","doc":"iex> Integer.digits(123)\n    [1, 2, 3]\n\n    iex> Integer.digits(170, 2)\n    [1, 0, 1, 0, 1, 0, 1, 0]\n\n    iex> Integer.digits(-170, 2)\n    [-1, 0, -1, 0, -1, 0, -1, 0]","ref":"Integer.html#digits/2-examples"},{"type":"function","title":"Integer.extended_gcd/2","doc":"Returns the extended greatest common divisor of the two given integers.\n\nThis function uses the extended Euclidean algorithm to return a three-element tuple with the `gcd`\nand the coefficients `m` and `n` of Bézout's identity such that:\n\n    gcd(a, b) = m*a + n*b\n\nBy convention, `extended_gcd(0, 0)` returns `{0, 0, 0}`.","ref":"Integer.html#extended_gcd/2"},{"type":"function","title":"Examples - Integer.extended_gcd/2","doc":"iex> Integer.extended_gcd(240, 46)\n    {2, -9, 47}\n    iex> Integer.extended_gcd(46, 240)\n    {2, 47, -9}\n    iex> Integer.extended_gcd(-46, 240)\n    {2, -47, -9}\n    iex> Integer.extended_gcd(-46, -240)\n    {2, -47, 9}\n\n    iex> Integer.extended_gcd(14, 21)\n    {7, -1, 1}\n\n    iex> Integer.extended_gcd(10, 0)\n    {10, 1, 0}\n    iex> Integer.extended_gcd(0, 10)\n    {10, 0, 1}\n    iex> Integer.extended_gcd(0, 0)\n    {0, 0, 0}","ref":"Integer.html#extended_gcd/2-examples"},{"type":"function","title":"Integer.floor_div/2","doc":"Performs a floored integer division.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\nThis function performs a *floored* integer division, which means that\nthe result will always be rounded towards negative infinity.\n\nIf you want to perform truncated integer division (rounding towards zero),\nuse `Kernel.div/2` instead.","ref":"Integer.html#floor_div/2"},{"type":"function","title":"Examples - Integer.floor_div/2","doc":"iex> Integer.floor_div(5, 2)\n    2\n    iex> Integer.floor_div(6, -4)\n    -2\n    iex> Integer.floor_div(-99, 2)\n    -50","ref":"Integer.html#floor_div/2-examples"},{"type":"function","title":"Integer.gcd/2","doc":"Returns the greatest common divisor of the two given integers.\n\nThe greatest common divisor (GCD) of `integer1` and `integer2` is the largest positive\ninteger that divides both `integer1` and `integer2` without leaving a remainder.\n\nBy convention, `gcd(0, 0)` returns `0`.","ref":"Integer.html#gcd/2"},{"type":"function","title":"Examples - Integer.gcd/2","doc":"iex> Integer.gcd(2, 3)\n    1\n\n    iex> Integer.gcd(8, 12)\n    4\n\n    iex> Integer.gcd(8, -12)\n    4\n\n    iex> Integer.gcd(10, 0)\n    10\n\n    iex> Integer.gcd(7, 7)\n    7\n\n    iex> Integer.gcd(0, 0)\n    0","ref":"Integer.html#gcd/2-examples"},{"type":"macro","title":"Integer.is_even/1","doc":"Determines if an `integer` is even.\n\nReturns `true` if the given `integer` is an even number,\notherwise it returns `false`.\n\nAllowed in guard clauses.","ref":"Integer.html#is_even/1"},{"type":"macro","title":"Examples - Integer.is_even/1","doc":"iex> Integer.is_even(10)\n    true\n\n    iex> Integer.is_even(5)\n    false\n\n    iex> Integer.is_even(-10)\n    true\n\n    iex> Integer.is_even(0)\n    true","ref":"Integer.html#is_even/1-examples"},{"type":"macro","title":"Integer.is_odd/1","doc":"Determines if `integer` is odd.\n\nReturns `true` if the given `integer` is an odd number,\notherwise it returns `false`.\n\nAllowed in guard clauses.","ref":"Integer.html#is_odd/1"},{"type":"macro","title":"Examples - Integer.is_odd/1","doc":"iex> Integer.is_odd(5)\n    true\n\n    iex> Integer.is_odd(6)\n    false\n\n    iex> Integer.is_odd(-5)\n    true\n\n    iex> Integer.is_odd(0)\n    false","ref":"Integer.html#is_odd/1-examples"},{"type":"function","title":"Integer.mod/2","doc":"Computes the modulo remainder of an integer division.\n\nThis function performs a [floored division](`floor_div/2`), which means that\nthe result will always have the sign of the `divisor`.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.","ref":"Integer.html#mod/2"},{"type":"function","title":"Examples - Integer.mod/2","doc":"iex> Integer.mod(5, 2)\n    1\n    iex> Integer.mod(6, -4)\n    -2","ref":"Integer.html#mod/2-examples"},{"type":"function","title":"Integer.parse/2","doc":"Parses a text representation of an integer.\n\nAn optional `base` to the corresponding integer can be provided.\nIf `base` is not given, 10 will be used.\n\nIf successful, returns a tuple in the form of `{integer, remainder_of_binary}`.\nOtherwise `:error`.\n\nRaises an error if `base` is less than 2 or more than 36.\n\nIf you want to convert a string-formatted integer directly to an integer,\n`String.to_integer/1` or `String.to_integer/2` can be used instead.","ref":"Integer.html#parse/2"},{"type":"function","title":"Examples - Integer.parse/2","doc":"iex> Integer.parse(\"34\")\n    {34, \"\"}\n\n    iex> Integer.parse(\"34.5\")\n    {34, \".5\"}\n\n    iex> Integer.parse(\"three\")\n    :error\n\n    iex> Integer.parse(\"34\", 10)\n    {34, \"\"}\n\n    iex> Integer.parse(\"f4\", 16)\n    {244, \"\"}\n\n    iex> Integer.parse(\"Awww++\", 36)\n    {509216, \"++\"}\n\n    iex> Integer.parse(\"fab\", 10)\n    :error\n\n    iex> Integer.parse(\"a2\", 38)\n    ** (ArgumentError) invalid base 38","ref":"Integer.html#parse/2-examples"},{"type":"function","title":"Integer.pow/2","doc":"Computes `base` raised to power of `exponent`.\n\nBoth `base` and `exponent` must be integers.\nThe exponent must be zero or positive.\n\nSee `Float.pow/2` for exponentiation of negative\nexponents as well as floats.","ref":"Integer.html#pow/2"},{"type":"function","title":"Examples - Integer.pow/2","doc":"iex> Integer.pow(2, 0)\n    1\n    iex> Integer.pow(2, 1)\n    2\n    iex> Integer.pow(2, 10)\n    1024\n    iex> Integer.pow(2, 11)\n    2048\n    iex> Integer.pow(2, 64)\n    0x10000000000000000\n\n    iex> Integer.pow(3, 4)\n    81\n    iex> Integer.pow(4, 3)\n    64\n\n    iex> Integer.pow(-2, 3)\n    -8\n    iex> Integer.pow(-2, 4)\n    16\n\n    iex> Integer.pow(2, -2)\n    ** (ArithmeticError) bad argument in arithmetic expression","ref":"Integer.html#pow/2-examples"},{"type":"function","title":"Integer.to_charlist/2","doc":"Returns a charlist which corresponds to the text representation\nof `integer` in the given `base`.\n\n`base` can be an integer between 2 and 36. If no `base` is given,\nit defaults to `10`.\n\nInlined by the compiler.","ref":"Integer.html#to_charlist/2"},{"type":"function","title":"Examples - Integer.to_charlist/2","doc":"iex> Integer.to_charlist(123)\n    ~c\"123\"\n\n    iex> Integer.to_charlist(+456)\n    ~c\"456\"\n\n    iex> Integer.to_charlist(-789)\n    ~c\"-789\"\n\n    iex> Integer.to_charlist(0123)\n    ~c\"123\"\n\n    iex> Integer.to_charlist(100, 16)\n    ~c\"64\"\n\n    iex> Integer.to_charlist(-100, 16)\n    ~c\"-64\"\n\n    iex> Integer.to_charlist(882_681_651, 36)\n    ~c\"ELIXIR\"","ref":"Integer.html#to_charlist/2-examples"},{"type":"function","title":"Integer.to_string/2","doc":"Returns a binary which corresponds to the text representation\nof `integer` in the given `base`.\n\n`base` can be an integer between 2 and 36. If no `base` is given,\nit defaults to `10`.\n\nInlined by the compiler.","ref":"Integer.html#to_string/2"},{"type":"function","title":"Examples - Integer.to_string/2","doc":"iex> Integer.to_string(123)\n    \"123\"\n\n    iex> Integer.to_string(+456)\n    \"456\"\n\n    iex> Integer.to_string(-789)\n    \"-789\"\n\n    iex> Integer.to_string(0123)\n    \"123\"\n\n    iex> Integer.to_string(100, 16)\n    \"64\"\n\n    iex> Integer.to_string(-100, 16)\n    \"-64\"\n\n    iex> Integer.to_string(882_681_651, 36)\n    \"ELIXIR\"","ref":"Integer.html#to_string/2-examples"},{"type":"function","title":"Integer.undigits/2","doc":"Returns the integer represented by the ordered `digits`.\n\nAn optional `base` value may be provided representing the radix for the `digits`.\nBase has to be an integer greater than or equal to `2`.","ref":"Integer.html#undigits/2"},{"type":"function","title":"Examples - Integer.undigits/2","doc":"iex> Integer.undigits([1, 2, 3])\n    123\n\n    iex> Integer.undigits([1, 4], 16)\n    20\n\n    iex> Integer.undigits([])\n    0","ref":"Integer.html#undigits/2-examples"},{"type":"behaviour","title":"Module","doc":"Provides functions to deal with modules during compilation time.\n\nIt allows a developer to dynamically add, delete and register\nattributes, attach documentation and so forth.\n\nAfter a module is compiled, using many of the functions in\nthis module will raise errors, since it is out of their scope\nto inspect runtime data. Most of the runtime data can be inspected\nvia the [`__info__/1`](`c:Module.__info__/1`) function attached to\neach compiled module.","ref":"Module.html"},{"type":"behaviour","title":"Module attributes - Module","doc":"Each module can be decorated with one or more attributes. The following ones\nare currently defined by Elixir:\n\n### `@after_compile`\n\nA hook that will be invoked right after the current module is compiled.\nAccepts a module or a `{module, function_name}`. See the \"Compile callbacks\"\nsection below.\n\n### `@after_verify` (since v1.14.0)\n\nA hook that will be invoked right after the current module is verified for\nundefined functions, deprecations, etc. Accepts a module or a `{module, function_name}`.\nSee the \"Compile callbacks\" section below.\n\n### `@before_compile`\n\nA hook that will be invoked before the module is compiled.\nAccepts a module or a `{module, function_or_macro_name}` tuple.\nSee the \"Compile callbacks\" section below.\n\n### `@behaviour`\n\nNote the British spelling!\n\nBehaviours can be referenced by modules to ensure they implement\nrequired specific function signatures defined by `@callback`.\n\nFor example, you could specify a `URI.Parser` behaviour as follows:\n\n    defmodule URI.Parser do\n      @doc \"Defines a default port\"\n      @callback default_port() :: integer\n\n      @doc \"Parses the given URL\"\n      @callback parse(uri_info :: URI.t()) :: URI.t()\n    end\n\nAnd then a module may use it as:\n\n    defmodule URI.HTTP do\n      @behaviour URI.Parser\n      def default_port(), do: 80\n      def parse(info), do: info\n    end\n\nIf the behaviour changes or `URI.HTTP` does not implement\none of the callbacks, a warning will be raised.\n\nFor detailed documentation, see the\n[behaviour typespec documentation](typespecs.md#behaviours).\n\n### `@impl` (since v1.5.0)\n\nTo aid in the correct implementation of behaviours, you may optionally declare\n`@impl` for implemented callbacks of a behaviour. This makes callbacks\nexplicit and can help you to catch errors in your code. The compiler will warn\nin these cases:\n\n  * if you mark a function with `@impl` when that function is not a callback.\n\n  * if you don't mark a function with `@impl` when other functions are marked\n    with `@impl`. If you mark one function with `@impl`, you must mark all\n    other callbacks for that behaviour as `@impl`.\n\n`@impl` works on a per-context basis. If you generate a function through a macro\nand mark it with `@impl`, that won't affect the module where that function is\ngenerated in.\n\n`@impl` also helps with maintainability by making it clear to other developers\nthat the function is implementing a callback.\n\nUsing `@impl`, the example above can be rewritten as:\n\n    defmodule URI.HTTP do\n      @behaviour URI.Parser\n\n      @impl true\n      def default_port(), do: 80\n\n      @impl true\n      def parse(info), do: info\n    end\n\nYou may pass either `false`, `true`, or a specific behaviour to `@impl`.\n\n    defmodule Foo do\n      @behaviour Bar\n      @behaviour Baz\n\n      # Will warn if neither Bar nor Baz specify a callback named bar/0.\n      @impl true\n      def bar(), do: :ok\n\n      # Will warn if Baz does not specify a callback named baz/0.\n      @impl Baz\n      def baz(), do: :ok\n    end\n\nThe code is now more readable, as it is now clear which functions are\npart of your API and which ones are callback implementations. To reinforce this\nidea, `@impl true` automatically marks the function as `@doc false`, disabling\ndocumentation unless `@doc` is explicitly set.\n\n### `@compile`\n\nDefines options for module compilation. This is used to configure\nboth Elixir and Erlang compilers, as any other compilation pass\nadded by external tools. For example:\n\n    defmodule MyModule do\n      @compile {:inline, my_fun: 1}\n\n      def my_fun(arg) do\n        to_string(arg)\n      end\n    end\n\nMultiple uses of `@compile` will accumulate instead of overriding\nprevious ones. See the \"Compile options\" section below.\n\n### `@deprecated` (since v1.6.0)\n\nProvides the deprecation reason for a function. For example:\n\n    defmodule Keyword do\n      @deprecated \"Use Kernel.length/1 instead\"\n      def size(keyword) do\n        length(keyword)\n      end\n    end\n\nThe Mix compiler automatically looks for calls to deprecated modules\nand emit warnings during compilation.\n\nUsing the `@deprecated` attribute will also be reflected in the\ndocumentation of the given function and macro. You can choose between\nthe `@deprecated` attribute and the documentation metadata to provide\nhard-deprecations (with warnings) and soft-deprecations (without warnings):\n\nThis is a soft-deprecation as it simply annotates the documentation\nas deprecated:\n\n    @doc deprecated: \"Use Kernel.length/1 instead\"\n    def size(keyword)\n\nThis is a hard-deprecation as it emits warnings and annotates the\ndocumentation as deprecated:\n\n    @deprecated \"Use Kernel.length/1 instead\"\n    def size(keyword)\n\nCurrently `@deprecated` only supports functions and macros. However\nyou can use the `:deprecated` key in the annotation metadata to\nannotate the docs of modules, types and callbacks too.\n\nWe recommend using this feature with care, especially library authors.\nDeprecating code always pushes the burden towards library users. We\nalso recommend for deprecated functionality to be maintained for long\nperiods of time, even after deprecation, giving developers plenty of\ntime to update (except for cases where keeping the deprecated API is\nundesired, such as in the presence of security issues).\n\n### `@doc` and `@typedoc`\n\nProvides documentation for the entity that follows the attribute.\n`@doc` is to be used with a function, macro, callback, or\nmacrocallback, while `@typedoc` with a type (public or opaque).\n\nAccepts one of these:\n\n  * a string (often a heredoc)\n  * `false`, which will make the entity invisible to documentation-extraction\n    tools like [`ExDoc`](https://hexdocs.pm/ex_doc/)\n  * a keyword list, since Elixir 1.7.0\n\nFor example:\n\n    defmodule MyModule do\n      @typedoc \"This type\"\n      @typedoc since: \"1.1.0\"\n      @type t :: term\n\n      @doc \"Hello world\"\n      @doc since: \"1.1.0\"\n      def hello do\n        \"world\"\n      end\n\n      @doc \"\"\"\n      Sums `a` to `b`.\n      \"\"\"\n      def sum(a, b) do\n        a + b\n      end\n    end\n\nAs can be seen in the example above, since Elixir 1.7.0 `@doc` and `@typedoc`\nalso accept a keyword list that serves as a way to provide arbitrary metadata\nabout the entity. Tools like [`ExDoc`](https://hexdocs.pm/ex_doc/) and\n`IEx` may use this information to display annotations. A common use\ncase is the `:since` key, which may be used to annotate in which version the\nfunction was introduced.\n\nAs illustrated in the example, it is possible to use these attributes\nmore than once before an entity. However, the compiler will warn if\nused twice with binaries as that replaces the documentation text from\nthe preceding use. Multiple uses with keyword lists will merge the\nlists into one.\n\nNote that since the compiler also defines some additional metadata,\nthere are a few reserved keys that will be ignored and warned if used.\nCurrently these are: `:opaque` and `:defaults`.\n\nOnce this module is compiled, this information becomes available via\nthe `Code.fetch_docs/1` function.\n\n### `@dialyzer`\n\nDefines warnings to request or suppress when using `:dialyzer`.\n\nAccepts an atom, a tuple, or a list of atoms and tuples. For example:\n\n    defmodule MyModule do\n      @dialyzer {:nowarn_function, [my_fun: 1]}\n\n      def my_fun(arg) do\n        M.not_a_function(arg)\n      end\n    end\n\nFor the list of supported warnings, see [`:dialyzer` module](`:dialyzer`).\n\nMultiple uses of `@dialyzer` will accumulate instead of overriding\nprevious ones.\n\n### `@external_resource`\n\nSpecifies an external resource for the current module.\n\nSometimes a module embeds information from an external file. This\nattribute allows the module to annotate which external resources\nhave been used.\n\nTools may use this information to ensure the module is recompiled\nin case any of the external resources change, see for example:\n[`mix compile.elixir`](https://hexdocs.pm/mix/Mix.Tasks.Compile.Elixir.html).\n\nThe specified file path provided is interpreted as relative to\nthe folder containing the project's `mix.exs`, which is the\ncurrent working directory, not the file where `@external_resource`\nis declared.\n\nIf the external resource does not exist, the module still has\na dependency on it, causing the module to be recompiled as soon\nas the file is added.\n\n### `@file`\n\nChanges the filename used in stacktraces for the function or macro that\nfollows the attribute, such as:\n\n    defmodule MyModule do\n      @doc \"Hello world\"\n      @file \"hello.ex\"\n      def hello do\n        \"world\"\n      end\n    end\n\nNote that this is only valid for exceptions/diagnostics that come from the\ndefinition inner scope (which includes its patterns and guards). For example:\n\n    defmodule MyModule do # <---- module definition\n      @file \"hello.ex\"\n      defp unused(a) do # <---- function definition\n        \"world\" # <---- function scope\n      end\n\n      @file \"bye.ex\"\n      def unused(_), do: true\n    end\n\nIf you run this code with the second \"unused\" definition commented, you will\nsee that `hello.ex` is used as the stacktrace when reporting warnings, but if\nyou uncomment it you'll see that the error will not mention `bye.ex`, because\nit's a module-level error rather than an expression-level error.\n\n### `@moduledoc`\n\nProvides documentation for the current module.\n\n    defmodule MyModule do\n      @moduledoc \"\"\"\n      A very useful module.\n      \"\"\"\n      @moduledoc authors: [\"Alice\", \"Bob\"]\n    end\n\nAccepts a string (often a heredoc) or `false` where `@moduledoc false`\nwill make the module invisible to documentation extraction tools like\n[`ExDoc`](https://hexdocs.pm/ex_doc/).\n\nSimilarly to `@doc` also accepts a keyword list to provide metadata\nabout the module. For more details, see the documentation of `@doc`\nabove.\n\nOnce this module is compiled, this information becomes available via\nthe `Code.fetch_docs/1` function.\n\n### `@nifs` (since v1.16.0)\n\nA list of functions and their arities which will be overridden\nby a native implementation (NIF).\n\n    defmodule MyLibrary.MyModule do\n      @nifs [foo: 1, bar: 2]\n\n      def foo(arg1), do: :erlang.nif_error(:not_loaded)\n      def bar(arg1, arg2), do: :erlang.nif_error(:not_loaded)\n    end\n\nSee the Erlang documentation for more information:\nhttps://www.erlang.org/doc/man/erl_nif\n\n### `@on_definition`\n\nA hook that will be invoked when each function or macro in the current\nmodule is defined. Useful when annotating functions.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take 6 arguments:\n\n  * the module environment\n  * the kind of the function/macro: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n  * the function/macro name\n  * the list of quoted arguments\n  * the list of quoted guards\n  * the quoted function body\n\nIf the function/macro being defined has multiple clauses, the hook will\nbe called for each clause.\n\nUnlike other hooks, `@on_definition` will only invoke functions and\nnever macros. This is to avoid `@on_definition` callbacks from\nredefining functions that have just been defined in favor of more\nexplicit approaches.\n\nWhen just a module is provided, the function is assumed to be\n`__on_definition__/6`.\n\n#### Example\n\n    defmodule Hooks do\n      def on_def(_env, kind, name, args, guards, body) do\n        IO.puts(\"Defining #{kind} named #{name} with args:\")\n        IO.inspect(args)\n        IO.puts(\"and guards\")\n        IO.inspect(guards)\n        IO.puts(\"and body\")\n        IO.puts(Macro.to_string(body))\n      end\n    end\n\n    defmodule MyModule do\n      @on_definition {Hooks, :on_def}\n\n      def hello(arg) when is_binary(arg) or is_list(arg) do\n        \"Hello\" <> to_string(arg)\n      end\n\n      def hello(_) do\n        :ok\n      end\n    end\n\n### `@on_load`\n\nA hook that will be invoked whenever the module is loaded.\n\nAccepts the function name (as an atom) of a function in the current module.\nThe function must have an arity of 0 (no arguments). If the function does\nnot return `:ok`, the loading of the module will be aborted.\nFor example:\n\n    defmodule MyModule do\n      @on_load :load_check\n\n      def load_check do\n        if some_condition() do\n          :ok\n        else\n          :abort\n        end\n      end\n\n      def some_condition do\n        false\n      end\n    end\n\n### `@vsn`\n\nSpecify the module version. Accepts any valid Elixir value, for example:\n\n    defmodule MyModule do\n      @vsn \"1.0\"\n    end","ref":"Module.html#module-module-attributes"},{"type":"behaviour","title":"Struct attributes - Module","doc":"* `@derive` - derives an implementation for the given protocol for the\n    struct defined in the current module\n\n  * `@enforce_keys` - ensures the given keys are always set when building\n    the struct defined in the current module\n\nSee `defstruct/1` for more information on building and using structs.","ref":"Module.html#module-struct-attributes"},{"type":"behaviour","title":"Typespec attributes - Module","doc":"The following attributes are part of typespecs and are also built-in in\nElixir:\n\n  * `@type` - defines a type to be used in `@spec`\n  * `@typep` - defines a private type to be used in `@spec`\n  * `@opaque` - defines an opaque type to be used in `@spec`\n  * `@spec` - provides a specification for a function\n  * `@callback` - provides a specification for a behaviour callback\n  * `@macrocallback` - provides a specification for a macro behaviour callback\n  * `@optional_callbacks` - specifies which behaviour callbacks and macro\n    behaviour callbacks are optional\n  * `@impl` - declares an implementation of a callback function or macro\n\nFor detailed documentation, see the [typespec documentation](typespecs.md).","ref":"Module.html#module-typespec-attributes"},{"type":"behaviour","title":"Custom attributes - Module","doc":"In addition to the built-in attributes outlined above, custom attributes may\nalso be added. Custom attributes are expressed using the `@/1` operator followed\nby a valid variable name. The value given to the custom attribute must be a valid\nElixir value:\n\n    defmodule MyModule do\n      @custom_attr [some: \"stuff\"]\n    end\n\nFor more advanced options available when defining custom attributes, see\n`register_attribute/3`.","ref":"Module.html#module-custom-attributes"},{"type":"behaviour","title":"Compile callbacks - Module","doc":"There are three compilation callbacks, invoked in this order:\n`@before_compile`, `@after_compile`, and `@after_verify`.\nThey are described next.\n\n### `@before_compile`\n\nA hook that will be invoked before the module is compiled. This is\noften used to change how the current module is being compiled.\n\nAccepts a module or a `{module, function_or_macro_name}` tuple. The\nfunction/macro must take one argument: the module environment. If\nit's a macro, its returned value will be injected at the end of the\nmodule definition before the compilation starts.\n\nWhen just a module is provided, the function/macro is assumed to be\n`__before_compile__/1`.\n\nCallbacks will run in the order they are registered. Any overridable\ndefinition will be made concrete before the first callback runs.\nA definition may be made overridable again in another before compile\ncallback and it will be made concrete one last time after all callbacks\nrun.\n\n*Note*: the callback function/macro must be placed in a separate module\n(because when the callback is invoked, the current module does not yet exist).\n\n#### Example\n\n    defmodule A do\n      defmacro __before_compile__(_env) do\n        quote do\n          def hello, do: \"world\"\n        end\n      end\n    end\n\n    defmodule B do\n      @before_compile A\n    end\n\n    B.hello()\n    #=> \"world\"\n\n### `@after_compile`\n\nA hook that will be invoked right after the current module is compiled.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take two arguments: the module environment and its bytecode.\nWhen just a module is provided, the function is assumed to be\n`__after_compile__/2`.\n\nCallbacks will run in the order they are registered.\n\n`Module` functions expecting not yet compiled modules (such as `definitions_in/1`)\nare still available at the time `@after_compile` is invoked.\n\n#### Example\n\n    defmodule MyModule do\n      @after_compile __MODULE__\n\n      def __after_compile__(env, _bytecode) do\n        IO.inspect(env)\n      end\n    end\n\n### `@after_verify`\n\nA hook that will be invoked right after the current module is verified for\nundefined functions, deprecations, etc. A module is always verified after\nit is compiled. In Mix projects, a module is also verified when any of its\nruntime dependencies change. Therefore this is useful to perform verification\nof the current module while avoiding compile-time dependencies. Given the\ncallback is invoked under different scenarios, Elixir provides no guarantees\nof when in the compilation cycle nor in which process the callback runs.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take one argument: the module name. When just a module is provided,\nthe function is assumed to be `__after_verify__/1`.\n\nCallbacks will run in the order they are registered.\n\n`Module` functions expecting not yet compiled modules are no longer available\nat the time `@after_verify` is invoked.\n\n#### Example\n\n    defmodule MyModule do\n      @after_verify __MODULE__\n\n      def __after_verify__(module) do\n        IO.inspect(module)\n        :ok\n      end\n    end","ref":"Module.html#module-compile-callbacks"},{"type":"behaviour","title":"Compile options - Module","doc":"The `@compile` attribute accepts different options that are used by both\nElixir and Erlang compilers. Some of the common use cases are documented\nbelow:\n\n  * `@compile :debug_info` - includes `:debug_info` regardless of the\n    corresponding setting in `Code.get_compiler_option/1`\n\n  * `@compile {:debug_info, false}` - disables `:debug_info` regardless\n    of the corresponding setting in `Code.get_compiler_option/1`. Note\n    disabling `:debug_info` is not recommended as it removes the ability\n    of the Elixir compiler and other tools to static analyse the code.\n    If you want to remove the `:debug_info` while deploying, tools like\n    `mix release` already do such by default.\n\n  * `@compile {:inline, some_fun: 2, other_fun: 3}` - inlines the given\n    name/arity pairs. Inlining is applied locally, calls from another\n    module are not affected by this option\n\n  * `@compile {:autoload, false}` - disables automatic loading of\n    modules after compilation. Instead, the module will be loaded after\n    it is dispatched to\n\n  * `@compile {:no_warn_undefined, Mod}` or\n    `@compile {:no_warn_undefined, {Mod, fun, arity}}` - does not warn if\n    the given module or the given `Mod.fun/arity` are not defined","ref":"Module.html#module-compile-options"},{"type":"callback","title":"Module.__info__/1","doc":"Provides runtime information about functions, macros, and other information\ndefined by the module.\n\nEach module gets an `__info__/1` function when it's compiled. The function\ntakes one of the following items:\n\n  * `:attributes` - a keyword list with all persisted attributes\n\n  * `:compile` - a list with compiler metadata\n\n  * `:functions` - a keyword list of public functions and their arities\n\n  * `:macros` - a keyword list of public macros and their arities\n\n  * `:md5` - the MD5 of the module\n\n  * `:module` - the module atom name\n\n  * `:struct` - (since v1.14.0) if the module defines a struct and if so each field in order","ref":"Module.html#c:__info__/1"},{"type":"function","title":"Module.attributes_in/1","doc":"Returns all module attributes names defined in `module`.\n\nThis function can only be used on modules that have not yet been compiled.","ref":"Module.html#attributes_in/1"},{"type":"function","title":"Examples - Module.attributes_in/1","doc":"defmodule Example do\n      @foo 1\n      Module.register_attribute(__MODULE__, :bar, accumulate: true)\n\n      :foo in Module.attributes_in(__MODULE__)\n      #=> true\n\n      :bar in Module.attributes_in(__MODULE__)\n      #=> true\n    end","ref":"Module.html#attributes_in/1-examples"},{"type":"function","title":"Module.concat/1","doc":"Concatenates a list of aliases and returns a new alias.\n\nIt handles binaries and atoms.","ref":"Module.html#concat/1"},{"type":"function","title":"Examples - Module.concat/1","doc":"iex> Module.concat([Foo, Bar])\n    Foo.Bar\n\n    iex> Module.concat([Foo, \"Bar\"])\n    Foo.Bar","ref":"Module.html#concat/1-examples"},{"type":"function","title":"Module.concat/2","doc":"Concatenates two aliases and returns a new alias.\n\nIt handles binaries and atoms.","ref":"Module.html#concat/2"},{"type":"function","title":"Examples - Module.concat/2","doc":"iex> Module.concat(Foo, Bar)\n    Foo.Bar\n\n    iex> Module.concat(Foo, \"Bar\")\n    Foo.Bar","ref":"Module.html#concat/2-examples"},{"type":"function","title":"Module.create/3","doc":"Creates a module with the given name and defined by\nthe given quoted expressions.\n\nThe line where the module is defined and its file **must**\nbe passed as options.\n\nIt returns a tuple of shape `{:module, module, binary, term}`\nwhere `module` is the module name, `binary` is the module\nbytecode and `term` is the result of the last expression in\n`quoted`.\n\nSimilar to `Kernel.defmodule/2`, the binary will only be\nwritten to disk as a `.beam` file if `Module.create/3` is\ninvoked in a file that is currently being compiled.","ref":"Module.html#create/3"},{"type":"function","title":"Examples - Module.create/3","doc":"contents =\n      quote do\n        def world, do: true\n      end\n\n    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n\n    Hello.world()\n    #=> true","ref":"Module.html#create/3-examples"},{"type":"function","title":"Differences from `defmodule` - Module.create/3","doc":"`Module.create/3` works similarly to `Kernel.defmodule/2`\nand return the same results. While one could also use\n`Kernel.defmodule/2` to define modules dynamically, this function\nis preferred when the module body is given by a quoted\nexpression.\n\nAnother important distinction is that `Module.create/3`\nallows you to control the environment variables used\nwhen defining the module, while `Kernel.defmodule/2`\nautomatically uses the environment it is invoked at.","ref":"Module.html#create/3-differences-from-defmodule"},{"type":"type","title":"Module.def_kind/0","doc":"","ref":"Module.html#t:def_kind/0"},{"type":"function","title":"Module.defines?/2","doc":"Checks if the module defines the given function or macro.\n\nUse `defines?/3` to assert for a specific type.\n\nThis function can only be used on modules that have not yet been compiled.\nUse `Kernel.function_exported?/3` and `Kernel.macro_exported?/3` to check for\npublic functions and macros respectively in compiled modules.\n\nNote that `defines?` returns `false` for functions and macros that have\nbeen defined but then marked as overridable and no other implementation\nhas been provided. You can check the overridable status by calling\n`overridable?/2`.","ref":"Module.html#defines?/2"},{"type":"function","title":"Examples - Module.defines?/2","doc":"defmodule Example do\n      Module.defines?(__MODULE__, {:version, 0}) #=> false\n      def version, do: 1\n      Module.defines?(__MODULE__, {:version, 0}) #=> true\n    end","ref":"Module.html#defines?/2-examples"},{"type":"function","title":"Module.defines?/3","doc":"Checks if the module defines a function or macro of the\ngiven `kind`.\n\n`kind` can be any of `:def`, `:defp`, `:defmacro`, or `:defmacrop`.\n\nThis function can only be used on modules that have not yet been compiled.\nUse `Kernel.function_exported?/3` and `Kernel.macro_exported?/3` to check for\npublic functions and macros respectively in compiled modules.","ref":"Module.html#defines?/3"},{"type":"function","title":"Examples - Module.defines?/3","doc":"defmodule Example do\n      Module.defines?(__MODULE__, {:version, 0}, :def) #=> false\n      def version, do: 1\n      Module.defines?(__MODULE__, {:version, 0}, :def) #=> true\n    end","ref":"Module.html#defines?/3-examples"},{"type":"function","title":"Module.defines_type?/2","doc":"Checks if the current module defines the given type (private, opaque or not).\n\nThis function is only available for modules being compiled.","ref":"Module.html#defines_type?/2"},{"type":"type","title":"Module.definition/0","doc":"","ref":"Module.html#t:definition/0"},{"type":"function","title":"Module.definitions_in/1","doc":"Returns all functions and macros defined in `module`.\n\nIt returns a list with all defined functions and macros, public and private,\nin the shape of `[{name, arity}, ...]`.\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get the public functions and macros in\ncompiled modules.","ref":"Module.html#definitions_in/1"},{"type":"function","title":"Examples - Module.definitions_in/1","doc":"defmodule Example do\n      def version, do: 1\n      defmacrop test(arg), do: arg\n      Module.definitions_in(__MODULE__) #=> [{:version, 0}, {:test, 1}]\n    end","ref":"Module.html#definitions_in/1-examples"},{"type":"function","title":"Module.definitions_in/2","doc":"Returns all functions defined in `module`, according\nto its kind.\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get the public functions and macros in\ncompiled modules.","ref":"Module.html#definitions_in/2"},{"type":"function","title":"Examples - Module.definitions_in/2","doc":"defmodule Example do\n      def version, do: 1\n      Module.definitions_in(__MODULE__, :def)  #=> [{:version, 0}]\n      Module.definitions_in(__MODULE__, :defp) #=> []\n    end","ref":"Module.html#definitions_in/2-examples"},{"type":"function","title":"Module.delete_attribute/2","doc":"Deletes the entry (or entries) for the given module attribute.\n\nIt returns the deleted attribute value. If the attribute has not\nbeen set nor configured to accumulate, it returns `nil`.\n\nIf the attribute is set to accumulate, then this function always\nreturns a list. Deleting the attribute removes existing entries\nbut the attribute will still accumulate.","ref":"Module.html#delete_attribute/2"},{"type":"function","title":"Examples - Module.delete_attribute/2","doc":"defmodule MyModule do\n      Module.put_attribute(__MODULE__, :custom_threshold_for_lib, 10)\n      Module.delete_attribute(__MODULE__, :custom_threshold_for_lib)\n    end","ref":"Module.html#delete_attribute/2-examples"},{"type":"function","title":"Module.delete_definition/2","doc":"Deletes a definition from a module.\n\nIt returns `true` if the definition exists and it was removed,\notherwise it returns `false`.","ref":"Module.html#delete_definition/2"},{"type":"function","title":"Module.eval_quoted/4","doc":"Evaluates the quoted contents in the given module's context.\n\nA list of environment options can also be given as argument.\nSee `Code.eval_string/3` for more information.\n\nRaises an error if the module was already compiled.","ref":"Module.html#eval_quoted/4"},{"type":"function","title":"Examples - Module.eval_quoted/4","doc":"defmodule Foo do\n      contents =\n        quote do\n          def sum(a, b), do: a + b\n        end\n\n      Module.eval_quoted(__MODULE__, contents)\n    end\n\n    Foo.sum(1, 2)\n    #=> 3\n\nFor convenience, you can pass any `Macro.Env` struct, such\nas  `__ENV__/0`, as the first argument or as options. Both\nthe module and all options will be automatically extracted\nfrom the environment:\n\n    defmodule Foo do\n      contents =\n        quote do\n          def sum(a, b), do: a + b\n        end\n\n      Module.eval_quoted(__ENV__, contents)\n    end\n\n    Foo.sum(1, 2)\n    #=> 3\n\nNote that if you pass a `Macro.Env` struct as first argument\nwhile also passing `opts`, they will be merged with `opts`\nhaving precedence.","ref":"Module.html#eval_quoted/4-examples"},{"type":"function","title":"Module.get_attribute/3","doc":"Gets the given attribute from a module.\n\nIf the attribute was marked with `accumulate` with\n`Module.register_attribute/3`, a list is always returned.\n`nil` is returned if the attribute has not been marked with\n`accumulate` and has not been set to any value.\n\nThe `@` macro compiles to a call to this function. For example,\nthe following code:\n\n    @foo\n\nExpands to something akin to:\n\n    Module.get_attribute(__MODULE__, :foo)\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get all persisted attributes, or\n`Code.fetch_docs/1` to retrieve all documentation related attributes in\ncompiled modules.","ref":"Module.html#get_attribute/3"},{"type":"function","title":"Examples - Module.get_attribute/3","doc":"defmodule Foo do\n      Module.put_attribute(__MODULE__, :value, 1)\n      Module.get_attribute(__MODULE__, :value) #=> 1\n\n      Module.get_attribute(__MODULE__, :value, :default) #=> 1\n      Module.get_attribute(__MODULE__, :not_found, :default) #=> :default\n\n      Module.register_attribute(__MODULE__, :value, accumulate: true)\n      Module.put_attribute(__MODULE__, :value, 1)\n      Module.get_attribute(__MODULE__, :value) #=> [1]\n    end","ref":"Module.html#get_attribute/3-examples"},{"type":"function","title":"Module.get_definition/3","doc":"Returns the definition for the given name-arity pair.\n\nIt returns a tuple with the `version`, the `kind`,\nthe definition `metadata`, and a list with each clause.\nEach clause is a four-element tuple with metadata,\nthe arguments, the guards, and the clause AST.\n\nThe clauses are returned in the Elixir AST but a subset\nthat has already been expanded and normalized. This makes\nit useful for analyzing code but it cannot be reinjected\ninto the module as it will have lost some of its original\ncontext. Given this AST representation is mostly internal,\nit is versioned and it may change at any time. Therefore,\n**use this API with caution**.","ref":"Module.html#get_definition/3"},{"type":"function","title":"Options - Module.get_definition/3","doc":"* `:skip_clauses` (since v1.14.0) - returns `[]` instead\n    of returning the clauses. This is useful when there is\n    only an interest in fetching the kind and the metadata","ref":"Module.html#get_definition/3-options"},{"type":"function","title":"Module.get_last_attribute/3","doc":"Gets the last set value of a given attribute from a module.\n\nIf the attribute was marked with `accumulate` with\n`Module.register_attribute/3`, the previous value to have been set will be\nreturned. If the attribute does not accumulate, this call is the same as\ncalling `Module.get_attribute/3`.\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get all persisted attributes, or\n`Code.fetch_docs/1` to retrieve all documentation related attributes in\ncompiled modules.","ref":"Module.html#get_last_attribute/3"},{"type":"function","title":"Examples - Module.get_last_attribute/3","doc":"defmodule Foo do\n      Module.put_attribute(__MODULE__, :value, 1)\n      Module.get_last_attribute(__MODULE__, :value) #=> 1\n\n      Module.get_last_attribute(__MODULE__, :not_found, :default) #=> :default\n\n      Module.register_attribute(__MODULE__, :acc, accumulate: true)\n      Module.put_attribute(__MODULE__, :acc, 1)\n      Module.get_last_attribute(__MODULE__, :acc) #=> 1\n      Module.put_attribute(__MODULE__, :acc, 2)\n      Module.get_last_attribute(__MODULE__, :acc) #=> 2\n    end","ref":"Module.html#get_last_attribute/3-examples"},{"type":"function","title":"Module.has_attribute?/2","doc":"Checks if the given attribute has been defined.\n\nAn attribute is defined if it has been registered with `register_attribute/3`\nor assigned a value. If an attribute has been deleted with `delete_attribute/2`\nit is no longer considered defined.\n\nThis function can only be used on modules that have not yet been compiled.","ref":"Module.html#has_attribute?/2"},{"type":"function","title":"Examples - Module.has_attribute?/2","doc":"defmodule MyModule do\n      @value 1\n      Module.register_attribute(__MODULE__, :other_value)\n      Module.put_attribute(__MODULE__, :another_value, 1)\n\n      Module.has_attribute?(__MODULE__, :value) #=> true\n      Module.has_attribute?(__MODULE__, :other_value) #=> true\n      Module.has_attribute?(__MODULE__, :another_value) #=> true\n\n      Module.has_attribute?(__MODULE__, :undefined) #=> false\n\n      Module.delete_attribute(__MODULE__, :value)\n      Module.has_attribute?(__MODULE__, :value) #=> false\n    end","ref":"Module.html#has_attribute?/2-examples"},{"type":"function","title":"Module.make_overridable/2","doc":"Makes the given functions in `module` overridable.\n\nAn overridable function is lazily defined, allowing a\ndeveloper to customize it. See `Kernel.defoverridable/1` for\nmore information and documentation.\n\nOnce a function or a macro is marked as overridable, it will\nno longer be listed under `definitions_in/1` or return true\nwhen given to `defines?/2` until another implementation is\ngiven.","ref":"Module.html#make_overridable/2"},{"type":"function","title":"Module.open?/1","doc":"Checks if a module is open.\n\nA module is \"open\" if it is currently being defined and its attributes and\nfunctions can be modified.","ref":"Module.html#open?/1"},{"type":"function","title":"Module.overridable?/2","doc":"Returns `true` if `tuple` in `module` was marked as overridable\nat some point.\n\nNote `overridable?/2` returns `true` even if the definition was\nalready overridden. You can use `defines?/2` to see if a definition\nexists or one is pending.","ref":"Module.html#overridable?/2"},{"type":"function","title":"Module.overridables_in/1","doc":"Returns all overridable definitions in `module`.\n\nNote a definition is included even if it was was already overridden.\nYou can use `defines?/2` to see if a definition exists or one is pending.\n\nThis function can only be used on modules that have not yet been compiled.","ref":"Module.html#overridables_in/1"},{"type":"function","title":"Examples - Module.overridables_in/1","doc":"defmodule Example do\n      def foo, do: 1\n      def bar, do: 2\n\n      defoverridable foo: 0, bar: 0\n      def foo, do: 3\n\n      [bar: 0, foo: 0] = Module.overridables_in(__MODULE__) |> Enum.sort()\n    end","ref":"Module.html#overridables_in/1-examples"},{"type":"function","title":"Module.put_attribute/3","doc":"Puts a module attribute with `key` and `value` in the given `module`.","ref":"Module.html#put_attribute/3"},{"type":"function","title":"Examples - Module.put_attribute/3","doc":"defmodule MyModule do\n      Module.put_attribute(__MODULE__, :custom_threshold_for_lib, 10)\n    end","ref":"Module.html#put_attribute/3-examples"},{"type":"function","title":"Module.register_attribute/3","doc":"Registers an attribute.\n\nBy registering an attribute, a developer is able to customize\nhow Elixir will store and accumulate the attribute values.","ref":"Module.html#register_attribute/3"},{"type":"function","title":"Options - Module.register_attribute/3","doc":"When registering an attribute, two options can be given:\n\n  * `:accumulate` - several calls to the same attribute will\n    accumulate instead of overriding the previous one. New attributes\n    are always added to the top of the accumulated list.\n\n  * `:persist` - the attribute will be persisted in the Erlang\n    Abstract Format. Useful when interfacing with Erlang libraries.\n\nBy default, both options are `false`. Once an attribute has been\nset to accumulate or persist, the behaviour cannot be reverted.","ref":"Module.html#register_attribute/3-options"},{"type":"function","title":"Examples - Module.register_attribute/3","doc":"defmodule MyModule do\n      Module.register_attribute(__MODULE__, :custom_threshold_for_lib, accumulate: true)\n\n      @custom_threshold_for_lib 10\n      @custom_threshold_for_lib 20\n      @custom_threshold_for_lib #=> [20, 10]\n    end","ref":"Module.html#register_attribute/3-examples"},{"type":"function","title":"Module.reserved_attributes/0","doc":"Returns information about module attributes used by Elixir.\n\nSee the \"Module attributes\" section in the module documentation for more\ninformation on each attribute.","ref":"Module.html#reserved_attributes/0"},{"type":"function","title":"Examples - Module.reserved_attributes/0","doc":"iex> map = Module.reserved_attributes()\n    iex> Map.has_key?(map, :moduledoc)\n    true\n    iex> Map.has_key?(map, :doc)\n    true","ref":"Module.html#reserved_attributes/0-examples"},{"type":"function","title":"Module.safe_concat/1","doc":"Concatenates a list of aliases and returns a new alias only if the alias\nwas already referenced.\n\nIf the alias was not referenced yet, fails with `ArgumentError`.\nIt handles binaries and atoms.","ref":"Module.html#safe_concat/1"},{"type":"function","title":"Examples - Module.safe_concat/1","doc":"iex> Module.safe_concat([List, Chars])\n    List.Chars","ref":"Module.html#safe_concat/1-examples"},{"type":"function","title":"Module.safe_concat/2","doc":"Concatenates two aliases and returns a new alias only if the alias was\nalready referenced.\n\nIf the alias was not referenced yet, fails with `ArgumentError`.\nIt handles binaries and atoms.","ref":"Module.html#safe_concat/2"},{"type":"function","title":"Examples - Module.safe_concat/2","doc":"iex> Module.safe_concat(List, Chars)\n    List.Chars","ref":"Module.html#safe_concat/2-examples"},{"type":"function","title":"Module.spec_to_callback/2","doc":"Copies the given spec as a callback.\n\nReturns `true` if there is such a spec and it was copied as a callback.\nIf the function associated to the spec has documentation defined prior to\ninvoking this function, the docs are copied too.","ref":"Module.html#spec_to_callback/2"},{"type":"function","title":"Module.split/1","doc":"Splits the given module name into binary parts.\n\n`module` has to be an Elixir module, as `split/1` won't work with Erlang-style\nmodules (for example, `split(:lists)` raises an error).\n\n`split/1` also supports splitting the string representation of Elixir modules\n(that is, the result of calling `Atom.to_string/1` with the module name).","ref":"Module.html#split/1"},{"type":"function","title":"Examples - Module.split/1","doc":"iex> Module.split(Very.Long.Module.Name.And.Even.Longer)\n    [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer\"]\n    iex> Module.split(\"Elixir.String.Chars\")\n    [\"String\", \"Chars\"]","ref":"Module.html#split/1-examples"},{"type":"module","title":"NaiveDateTime","doc":"A NaiveDateTime struct (without a time zone) and functions.\n\nThe NaiveDateTime struct contains the fields year, month, day, hour,\nminute, second, microsecond and calendar. New naive datetimes can be\nbuilt with the `new/2` and `new/8` functions or using the\n`~N` (see `sigil_N/2`) sigil:\n\n    iex> ~N[2000-01-01 23:00:07]\n    ~N[2000-01-01 23:00:07]\n\nThe date and time fields in the struct can be accessed directly:\n\n    iex> naive = ~N[2000-01-01 23:00:07]\n    iex> naive.year\n    2000\n    iex> naive.second\n    7\n\nWe call them \"naive\" because this datetime representation does not\nhave a time zone. This means the datetime may not actually exist in\ncertain areas in the world even though it is valid.\n\nFor example, when daylight saving changes are applied by a region,\nthe clock typically moves forward or backward by one hour. This means\ncertain datetimes never occur or may occur more than once. Since\n`NaiveDateTime` is not validated against a time zone, such errors\nwould go unnoticed.\n\nDevelopers should avoid creating the NaiveDateTime structs directly\nand instead, rely on the functions provided by this module as well\nas the ones in third-party calendar libraries.","ref":"NaiveDateTime.html"},{"type":"module","title":"Comparing naive date times - NaiveDateTime","doc":"Comparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `NaiveDateTime` struct fields. For proper comparison\nbetween naive datetimes, use the `compare/2` function. The existence of the\n`compare/2` function in this module also allows using `Enum.min/2` and\n`Enum.max/2` functions to get the minimum and maximum naive datetime of an\n`Enum`. For example:\n\n    iex> Enum.min([~N[2020-01-01 23:00:07], ~N[2000-01-01 23:00:07]], NaiveDateTime)\n    ~N[2000-01-01 23:00:07]","ref":"NaiveDateTime.html#module-comparing-naive-date-times"},{"type":"module","title":"Using epochs - NaiveDateTime","doc":"The `add/3` and `diff/3` functions can be used for computing date\ntimes or retrieving the number of seconds between instants.\nFor example, if there is an interest in computing the number of\nseconds from the Unix epoch (1970-01-01 00:00:00):\n\n    iex> NaiveDateTime.diff(~N[2010-04-17 14:00:00], ~N[1970-01-01 00:00:00])\n    1271512800\n\n    iex> NaiveDateTime.add(~N[1970-01-01 00:00:00], 1_271_512_800)\n    ~N[2010-04-17 14:00:00]\n\nThose functions are optimized to deal with common epochs, such\nas the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00).","ref":"NaiveDateTime.html#module-using-epochs"},{"type":"function","title":"NaiveDateTime.add/3","doc":"Adds a specified amount of time to a `NaiveDateTime`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.","ref":"NaiveDateTime.html#add/3"},{"type":"function","title":"Examples - NaiveDateTime.add/3","doc":"It uses seconds by default:\n\n    # adds seconds by default\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2)\n    ~N[2014-10-02 00:29:12]\n\n    # accepts negative offsets\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], -2)\n    ~N[2014-10-02 00:29:08]\n\nIt can also work with subsecond precisions:\n\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2_000, :millisecond)\n    ~N[2014-10-02 00:29:12.000]\n\nAs well as days/hours/minutes:\n\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 2, :day)\n    ~N[2015-03-02 00:29:10]\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 36, :hour)\n    ~N[2015-03-01 12:29:10]\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 60, :minute)\n    ~N[2015-02-28 01:29:10]\n\nThis operation merges the precision of the naive date time with the given unit:\n\n    iex> result = NaiveDateTime.add(~N[2014-10-02 00:29:10], 21, :millisecond)\n    ~N[2014-10-02 00:29:10.021]\n    iex> result.microsecond\n    {21000, 3}\n\nOperations on top of gregorian seconds or the Unix epoch are optimized:\n\n    # from Gregorian seconds\n    iex> NaiveDateTime.add(~N[0000-01-01 00:00:00], 63_579_428_950)\n    ~N[2014-10-02 00:29:10]\n\nPassing a `DateTime` automatically converts it to `NaiveDateTime`,\ndiscarding the time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.add(dt, 21, :second)\n    ~N[2000-02-29 23:00:28]\n\nTo shift a naive datetime by a `Duration` and according to its underlying calendar, use `NaiveDateTime.shift/2`.","ref":"NaiveDateTime.html#add/3-examples"},{"type":"function","title":"NaiveDateTime.after?/2","doc":"Returns `true` if the first `NaiveDateTime` is strictly later than the second.","ref":"NaiveDateTime.html#after?/2"},{"type":"function","title":"Examples - NaiveDateTime.after?/2","doc":"iex> NaiveDateTime.after?(~N[2022-02-02 11:00:00], ~N[2021-01-01 11:00:00])\n    true\n    iex> NaiveDateTime.after?(~N[2021-01-01 11:00:00], ~N[2021-01-01 11:00:00])\n    false\n    iex> NaiveDateTime.after?(~N[2021-01-01 11:00:00], ~N[2022-02-02 11:00:00])\n    false","ref":"NaiveDateTime.html#after?/2-examples"},{"type":"function","title":"NaiveDateTime.before?/2","doc":"Returns `true` if the first `NaiveDateTime` is strictly earlier than the second.","ref":"NaiveDateTime.html#before?/2"},{"type":"function","title":"Examples - NaiveDateTime.before?/2","doc":"iex> NaiveDateTime.before?(~N[2021-01-01 11:00:00], ~N[2022-02-02 11:00:00])\n    true\n    iex> NaiveDateTime.before?(~N[2021-01-01 11:00:00], ~N[2021-01-01 11:00:00])\n    false\n    iex> NaiveDateTime.before?(~N[2022-02-02 11:00:00], ~N[2021-01-01 11:00:00])\n    false","ref":"NaiveDateTime.html#before?/2-examples"},{"type":"function","title":"NaiveDateTime.beginning_of_day/1","doc":"Calculates a `NaiveDateTime` that is the first moment for the given `NaiveDateTime`.\n\nTo calculate the beginning of day of a `DateTime`, call this function, then convert back to a `DateTime`:\n\n    datetime\n    |> NaiveDateTime.beginning_of_day()\n    |> DateTime.from_naive(datetime.time_zone)\n\nNote that the beginning of the day may not exist or be ambiguous\nin a given timezone, so you must handle those cases accordingly.","ref":"NaiveDateTime.html#beginning_of_day/1"},{"type":"function","title":"Examples - NaiveDateTime.beginning_of_day/1","doc":"iex> NaiveDateTime.beginning_of_day(~N[2000-01-01 23:00:07.123456])\n    ~N[2000-01-01 00:00:00.000000]","ref":"NaiveDateTime.html#beginning_of_day/1-examples"},{"type":"function","title":"NaiveDateTime.compare/2","doc":"Compares two `NaiveDateTime` structs.\n\nReturns `:gt` if first is later than the second\nand `:lt` for vice versa. If the two NaiveDateTime\nare equal `:eq` is returned.","ref":"NaiveDateTime.html#compare/2"},{"type":"function","title":"Examples - NaiveDateTime.compare/2","doc":"iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15], ~N[2016-04-28 16:19:25])\n    :lt\n    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15.1], ~N[2016-04-16 13:30:15.01])\n    :gt\n\nThis function can also be used to compare a DateTime without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.compare(dt, ~N[2000-02-29 23:00:07])\n    :eq\n    iex> NaiveDateTime.compare(dt, ~N[2000-01-29 23:00:07])\n    :gt\n    iex> NaiveDateTime.compare(dt, ~N[2000-03-29 23:00:07])\n    :lt","ref":"NaiveDateTime.html#compare/2-examples"},{"type":"function","title":"NaiveDateTime.convert/2","doc":"Converts the given `naive_datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an `{:error, :incompatible_calendars}` tuple\nis returned.","ref":"NaiveDateTime.html#convert/2"},{"type":"function","title":"Examples - NaiveDateTime.convert/2","doc":"Imagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> NaiveDateTime.convert(~N[2000-01-01 13:30:15], Calendar.Holocene)\n    {:ok, %NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,\n                         hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}","ref":"NaiveDateTime.html#convert/2-examples"},{"type":"function","title":"NaiveDateTime.convert!/2","doc":"Converts the given `naive_datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an ArgumentError is raised.","ref":"NaiveDateTime.html#convert!/2"},{"type":"function","title":"Examples - NaiveDateTime.convert!/2","doc":"Imagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> NaiveDateTime.convert!(~N[2000-01-01 13:30:15], Calendar.Holocene)\n    %NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,\n                   hour: 13, minute: 30, second: 15, microsecond: {0, 0}}","ref":"NaiveDateTime.html#convert!/2-examples"},{"type":"function","title":"NaiveDateTime.diff/3","doc":"Subtracts `naive_datetime2` from `naive_datetime1`.\n\nThe answer can be returned in any `:day`, `:hour`, `:minute`, or any `unit`\navailable from `t:System.time_unit/0`. The unit is measured according to\n`Calendar.ISO` and defaults to `:second`.\n\nFractional results are not supported and are truncated.","ref":"NaiveDateTime.html#diff/3"},{"type":"function","title":"Examples - NaiveDateTime.diff/3","doc":"iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10])\n    2\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10], :microsecond)\n    2_000_000\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021])\n    0\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021], :millisecond)\n    21\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10], ~N[2014-10-02 00:29:12])\n    -2\n    iex> NaiveDateTime.diff(~N[-0001-10-02 00:29:10], ~N[-0001-10-02 00:29:12])\n    -2\n\nIt can also compute the difference in days, hours, or minutes:\n\n    iex> NaiveDateTime.diff(~N[2014-10-10 00:29:10], ~N[2014-10-02 00:29:10], :day)\n    8\n    iex> NaiveDateTime.diff(~N[2014-10-02 12:29:10], ~N[2014-10-02 00:29:10], :hour)\n    12\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:39:10], ~N[2014-10-02 00:29:10], :minute)\n    10\n\nBut it also rounds incomplete days to zero:\n\n    iex> NaiveDateTime.diff(~N[2014-10-10 00:29:09], ~N[2014-10-02 00:29:10], :day)\n    7","ref":"NaiveDateTime.html#diff/3-examples"},{"type":"function","title":"NaiveDateTime.end_of_day/1","doc":"Calculates a `NaiveDateTime` that is the last moment for the given `NaiveDateTime`.\n\nTo calculate the end of day of a `DateTime`, call this function, then convert back to a `DateTime`:\n\n    datetime\n    |> NaiveDateTime.end_of_day()\n    |> DateTime.from_naive(datetime.time_zone)\n\nNote that the end of the day may not exist or be ambiguous\nin a given timezone, so you must handle those cases accordingly.","ref":"NaiveDateTime.html#end_of_day/1"},{"type":"function","title":"Examples - NaiveDateTime.end_of_day/1","doc":"iex> NaiveDateTime.end_of_day(~N[2000-01-01 23:00:07.123456])\n    ~N[2000-01-01 23:59:59.999999]","ref":"NaiveDateTime.html#end_of_day/1-examples"},{"type":"function","title":"NaiveDateTime.from_erl/3","doc":"Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n\nAttempting to convert an invalid ISO calendar date will produce an error tuple.","ref":"NaiveDateTime.html#from_erl/3"},{"type":"function","title":"Examples - NaiveDateTime.from_erl/3","doc":"iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}})\n    {:ok, ~N[2000-01-01 13:30:15]}\n    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n    {:ok, ~N[2000-01-01 13:30:15.005]}\n    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n    {:error, :invalid_date}\n    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n    {:error, :invalid_date}","ref":"NaiveDateTime.html#from_erl/3-examples"},{"type":"function","title":"NaiveDateTime.from_erl!/3","doc":"Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n\nRaises if the datetime is invalid.\nAttempting to convert an invalid ISO calendar date will produce an error tuple.","ref":"NaiveDateTime.html#from_erl!/3"},{"type":"function","title":"Examples - NaiveDateTime.from_erl!/3","doc":"iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}})\n    ~N[2000-01-01 13:30:15]\n    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n    ~N[2000-01-01 13:30:15.005]\n    iex> NaiveDateTime.from_erl!({{2000, 13, 1}, {13, 30, 15}})\n    ** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive datetime, reason: :invalid_date","ref":"NaiveDateTime.html#from_erl!/3-examples"},{"type":"function","title":"NaiveDateTime.from_gregorian_seconds/3","doc":"Converts a number of gregorian seconds to a `NaiveDateTime` struct.","ref":"NaiveDateTime.html#from_gregorian_seconds/3"},{"type":"function","title":"Examples - NaiveDateTime.from_gregorian_seconds/3","doc":"iex> NaiveDateTime.from_gregorian_seconds(1)\n    ~N[0000-01-01 00:00:01]\n    iex> NaiveDateTime.from_gregorian_seconds(63_755_511_991, {5000, 3})\n    ~N[2020-05-01 00:26:31.005]\n    iex> NaiveDateTime.from_gregorian_seconds(-1)\n    ~N[-0001-12-31 23:59:59]","ref":"NaiveDateTime.html#from_gregorian_seconds/3-examples"},{"type":"function","title":"NaiveDateTime.from_iso8601/2","doc":"Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nTime zone offset may be included in the string but they will be\nsimply discarded as such information is not included in naive date\ntimes.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\nNote leap seconds are not supported by the built-in Calendar.ISO.","ref":"NaiveDateTime.html#from_iso8601/2"},{"type":"function","title":"Examples - NaiveDateTime.from_iso8601/2","doc":"iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0\")\n    {:ok, ~N[2015-01-23 23:50:07.0]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07,0123456\")\n    {:ok, ~N[2015-01-23 23:50:07.012345]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0123456\")\n    {:ok, ~N[2015-01-23 23:50:07.012345]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123Z\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23P23:50:07\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015:01:23 23-50-07\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:61\")\n    {:error, :invalid_time}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-32 23:50:07\")\n    {:error, :invalid_date}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+00:00\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-02:30\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-24:00\")\n    {:error, :invalid_format}","ref":"NaiveDateTime.html#from_iso8601/2-examples"},{"type":"function","title":"NaiveDateTime.from_iso8601!/2","doc":"Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.","ref":"NaiveDateTime.html#from_iso8601!/2"},{"type":"function","title":"Examples - NaiveDateTime.from_iso8601!/2","doc":"iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07.123Z\")\n    ~N[2015-01-23 23:50:07.123]\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07,123Z\")\n    ~N[2015-01-23 23:50:07.123]\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23P23:50:07\")\n    ** (ArgumentError) cannot parse \"2015-01-23P23:50:07\" as naive datetime, reason: :invalid_format","ref":"NaiveDateTime.html#from_iso8601!/2-examples"},{"type":"function","title":"NaiveDateTime.local_now/1","doc":"Returns the \"local time\" for the machine the Elixir program is running on.\n\nWARNING: This function can cause insidious bugs. It depends on the time zone\nconfiguration at run time. This can changed and be set to a time zone that has\ndaylight saving jumps (spring forward or fall back).\n\nThis function can be used to display what the time is right now for the time\nzone configuration that the machine happens to have. An example would be a\ndesktop program displaying a clock to the user. For any other uses it is\nprobably a bad idea to use this function.\n\nFor most cases, use `DateTime.now/2` or `DateTime.utc_now/1` instead.\n\nDoes not include fractional seconds.","ref":"NaiveDateTime.html#local_now/1"},{"type":"function","title":"Examples - NaiveDateTime.local_now/1","doc":"iex> naive_datetime = NaiveDateTime.local_now()\n    iex> naive_datetime.year >= 2019\n    true","ref":"NaiveDateTime.html#local_now/1-examples"},{"type":"function","title":"NaiveDateTime.new/2","doc":"Builds a naive datetime from date and time structs.","ref":"NaiveDateTime.html#new/2"},{"type":"function","title":"Examples - NaiveDateTime.new/2","doc":"iex> NaiveDateTime.new(~D[2010-01-13], ~T[23:00:07.005])\n    {:ok, ~N[2010-01-13 23:00:07.005]}","ref":"NaiveDateTime.html#new/2-examples"},{"type":"function","title":"NaiveDateTime.new/8","doc":"Builds a new ISO naive datetime.\n\nExpects all values to be integers. Returns `{:ok, naive_datetime}`\nif each entry fits its appropriate range, returns `{:error, reason}`\notherwise.","ref":"NaiveDateTime.html#new/8"},{"type":"function","title":"Examples - NaiveDateTime.new/8","doc":"iex> NaiveDateTime.new(2000, 1, 1, 0, 0, 0)\n    {:ok, ~N[2000-01-01 00:00:00]}\n    iex> NaiveDateTime.new(2000, 13, 1, 0, 0, 0)\n    {:error, :invalid_date}\n    iex> NaiveDateTime.new(2000, 2, 29, 0, 0, 0)\n    {:ok, ~N[2000-02-29 00:00:00]}\n    iex> NaiveDateTime.new(2000, 2, 30, 0, 0, 0)\n    {:error, :invalid_date}\n    iex> NaiveDateTime.new(2001, 2, 29, 0, 0, 0)\n    {:error, :invalid_date}\n\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1})\n    {:ok, ~N[2000-01-01 23:59:59.0]}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 999_999)\n    {:ok, ~N[2000-01-01 23:59:59.999999]}\n    iex> NaiveDateTime.new(2000, 1, 1, 24, 59, 59, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 60, 59, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 60, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 1_000_000)\n    {:error, :invalid_time}\n\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)\n    {:ok, ~N[2000-01-01 23:59:59.0]}","ref":"NaiveDateTime.html#new/8-examples"},{"type":"function","title":"NaiveDateTime.new!/2","doc":"Builds a naive datetime from date and time structs.","ref":"NaiveDateTime.html#new!/2"},{"type":"function","title":"Examples - NaiveDateTime.new!/2","doc":"iex> NaiveDateTime.new!(~D[2010-01-13], ~T[23:00:07.005])\n    ~N[2010-01-13 23:00:07.005]","ref":"NaiveDateTime.html#new!/2-examples"},{"type":"function","title":"NaiveDateTime.new!/8","doc":"Builds a new ISO naive datetime.\n\nExpects all values to be integers. Returns `naive_datetime`\nif each entry fits its appropriate range, raises if\ntime or date is invalid.","ref":"NaiveDateTime.html#new!/8"},{"type":"function","title":"Examples - NaiveDateTime.new!/8","doc":"iex> NaiveDateTime.new!(2000, 1, 1, 0, 0, 0)\n    ~N[2000-01-01 00:00:00]\n    iex> NaiveDateTime.new!(2000, 2, 29, 0, 0, 0)\n    ~N[2000-02-29 00:00:00]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1})\n    ~N[2000-01-01 23:59:59.0]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, 999_999)\n    ~N[2000-01-01 23:59:59.999999]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)\n    ~N[2000-01-01 23:59:59.0]\n    iex> NaiveDateTime.new!(2000, 1, 1, 24, 59, 59, 999_999)\n    ** (ArgumentError) cannot build naive datetime, reason: :invalid_time","ref":"NaiveDateTime.html#new!/8-examples"},{"type":"function","title":"NaiveDateTime.shift/2","doc":"Shifts given `naive_datetime` by `duration` according to its calendar.\n\nAllowed units are: `:year`, `:month`, `:week`, `:day`, `:hour`, `:minute`, `:second`, `:microsecond`.\n\nWhen using the default ISO calendar, durations are collapsed and\napplied in the order of months, then seconds and microseconds:\n\n* when shifting by 1 year and 2 months the date is actually shifted by 14 months\n* weeks, days and smaller units are collapsed into seconds and microseconds\n\nWhen shifting by month, days are rounded down to the nearest valid date.","ref":"NaiveDateTime.html#shift/2"},{"type":"function","title":"Examples - NaiveDateTime.shift/2","doc":"iex> NaiveDateTime.shift(~N[2016-01-31 00:00:00], month: 1)\n    ~N[2016-02-29 00:00:00]\n    iex> NaiveDateTime.shift(~N[2016-01-31 00:00:00], year: 4, day: 1)\n    ~N[2020-02-01 00:00:00]\n    iex> NaiveDateTime.shift(~N[2016-01-31 00:00:00], year: -2, day: 1)\n    ~N[2014-02-01 00:00:00]\n    iex> NaiveDateTime.shift(~N[2016-01-31 00:00:00], second: 45)\n    ~N[2016-01-31 00:00:45]\n    iex> NaiveDateTime.shift(~N[2016-01-31 00:00:00], microsecond: {100, 6})\n    ~N[2016-01-31 00:00:00.000100]\n\n    # leap years\n    iex> NaiveDateTime.shift(~N[2024-02-29 00:00:00], year: 1)\n    ~N[2025-02-28 00:00:00]\n    iex> NaiveDateTime.shift(~N[2024-02-29 00:00:00], year: 4)\n    ~N[2028-02-29 00:00:00]\n\n    # rounding down\n    iex> NaiveDateTime.shift(~N[2015-01-31 00:00:00], month: 1)\n    ~N[2015-02-28 00:00:00]","ref":"NaiveDateTime.html#shift/2-examples"},{"type":"type","title":"NaiveDateTime.t/0","doc":"","ref":"NaiveDateTime.html#t:t/0"},{"type":"function","title":"NaiveDateTime.to_date/1","doc":"Converts a `NaiveDateTime` into a `Date`.\n\nBecause `Date` does not hold time information,\ndata will be lost during the conversion.","ref":"NaiveDateTime.html#to_date/1"},{"type":"function","title":"Examples - NaiveDateTime.to_date/1","doc":"iex> NaiveDateTime.to_date(~N[2002-01-13 23:00:07])\n    ~D[2002-01-13]","ref":"NaiveDateTime.html#to_date/1-examples"},{"type":"function","title":"NaiveDateTime.to_erl/1","doc":"Converts a `NaiveDateTime` struct to an Erlang datetime tuple.\n\nOnly supports converting naive datetimes which are in the ISO calendar,\nattempting to convert naive datetimes from other calendars will raise.\n\nWARNING: Loss of precision may occur, as Erlang time tuples only store\nhour/minute/second.","ref":"NaiveDateTime.html#to_erl/1"},{"type":"function","title":"Examples - NaiveDateTime.to_erl/1","doc":"iex> NaiveDateTime.to_erl(~N[2000-01-01 13:30:15])\n    {{2000, 1, 1}, {13, 30, 15}}\n\nThis function can also be used to convert a DateTime to an Erlang\ndatetime tuple without the time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_erl(dt)\n    {{2000, 2, 29}, {23, 00, 07}}","ref":"NaiveDateTime.html#to_erl/1-examples"},{"type":"function","title":"NaiveDateTime.to_gregorian_seconds/1","doc":"Converts a `NaiveDateTime` struct to a number of gregorian seconds and microseconds.","ref":"NaiveDateTime.html#to_gregorian_seconds/1"},{"type":"function","title":"Examples - NaiveDateTime.to_gregorian_seconds/1","doc":"iex> NaiveDateTime.to_gregorian_seconds(~N[0000-01-01 00:00:01])\n    {1, 0}\n    iex> NaiveDateTime.to_gregorian_seconds(~N[2020-05-01 00:26:31.005])\n    {63_755_511_991, 5000}","ref":"NaiveDateTime.html#to_gregorian_seconds/1-examples"},{"type":"function","title":"NaiveDateTime.to_iso8601/2","doc":"Converts the given naive datetime to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `NaiveDateTime.to_iso8601/2` returns naive datetimes formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting naive datetimes which are in the ISO calendar,\nattempting to convert naive datetimes from other calendars will raise.","ref":"NaiveDateTime.html#to_iso8601/2"},{"type":"function","title":"Examples - NaiveDateTime.to_iso8601/2","doc":"iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13])\n    \"2000-02-28T23:00:13\"\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001])\n    \"2000-02-28T23:00:13.001\"\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001], :basic)\n    \"20000228T230013.001\"\n\nThis function can also be used to convert a DateTime to ISO 8601 without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07\"","ref":"NaiveDateTime.html#to_iso8601/2-examples"},{"type":"function","title":"NaiveDateTime.to_string/1","doc":"Converts the given naive datetime to a string according to its calendar.","ref":"NaiveDateTime.html#to_string/1"},{"type":"function","title":"Examples - NaiveDateTime.to_string/1","doc":"iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13])\n    \"2000-02-28 23:00:13\"\n    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13.001])\n    \"2000-02-28 23:00:13.001\"\n    iex> NaiveDateTime.to_string(~N[-0100-12-15 03:20:31])\n    \"-0100-12-15 03:20:31\"\n\nThis function can also be used to convert a DateTime to a string without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_string(dt)\n    \"2000-02-29 23:00:07\"","ref":"NaiveDateTime.html#to_string/1-examples"},{"type":"function","title":"NaiveDateTime.to_time/1","doc":"Converts a `NaiveDateTime` into `Time`.\n\nBecause `Time` does not hold date information,\ndata will be lost during the conversion.","ref":"NaiveDateTime.html#to_time/1"},{"type":"function","title":"Examples - NaiveDateTime.to_time/1","doc":"iex> NaiveDateTime.to_time(~N[2002-01-13 23:00:07])\n    ~T[23:00:07]","ref":"NaiveDateTime.html#to_time/1-examples"},{"type":"function","title":"NaiveDateTime.truncate/2","doc":"Returns the given naive datetime with the microsecond field truncated to the\ngiven precision (`:microsecond`, `:millisecond` or `:second`).\n\nThe given naive datetime is returned unchanged if it already has lower precision\nthan the given precision.","ref":"NaiveDateTime.html#truncate/2"},{"type":"function","title":"Examples - NaiveDateTime.truncate/2","doc":"iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :microsecond)\n    ~N[2017-11-06 00:23:51.123456]\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :millisecond)\n    ~N[2017-11-06 00:23:51.123]\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :second)\n    ~N[2017-11-06 00:23:51]","ref":"NaiveDateTime.html#truncate/2-examples"},{"type":"function","title":"NaiveDateTime.utc_now/1","doc":"Returns the current naive datetime in UTC.\n\nPrefer using `DateTime.utc_now/0` when possible as, opposite\nto `NaiveDateTime`, it will keep the time zone information.\n\nYou can also provide a time unit to automatically truncate\nthe naive datetime. This is available since v1.15.0.","ref":"NaiveDateTime.html#utc_now/1"},{"type":"function","title":"Examples - NaiveDateTime.utc_now/1","doc":"iex> naive_datetime = NaiveDateTime.utc_now()\n    iex> naive_datetime.year >= 2016\n    true\n\n    iex> naive_datetime = NaiveDateTime.utc_now(:second)\n    iex> naive_datetime.microsecond\n    {0, 0}","ref":"NaiveDateTime.html#utc_now/1-examples"},{"type":"function","title":"NaiveDateTime.utc_now/2","doc":"Returns the current naive datetime in UTC, supporting a specific\ncalendar and precision.\n\nPrefer using `DateTime.utc_now/2` when possible as, opposite\nto `NaiveDateTime`, it will keep the time zone information.","ref":"NaiveDateTime.html#utc_now/2"},{"type":"function","title":"Examples - NaiveDateTime.utc_now/2","doc":"iex> naive_datetime = NaiveDateTime.utc_now(:second, Calendar.ISO)\n    iex> naive_datetime.year >= 2016\n    true\n\n    iex> naive_datetime = NaiveDateTime.utc_now(:second, Calendar.ISO)\n    iex> naive_datetime.microsecond\n    {0, 0}","ref":"NaiveDateTime.html#utc_now/2-examples"},{"type":"module","title":"Record","doc":"Module to work with, define, and import records.\n\nRecords are simply tuples where the first element is an atom:\n\n    iex> Record.is_record({User, \"john\", 27})\n    true\n\nThis module provides conveniences for working with records at\ncompilation time, where compile-time field names are used to\nmanipulate the tuples, providing fast operations on top of\nthe tuples' compact structure.\n\nIn Elixir, records are used mostly in two situations:\n\n  1. to work with short, internal data\n  2. to interface with Erlang records\n\nThe macros `defrecord/3` and `defrecordp/3` can be used to create records\nwhile `extract/2` and `extract_all/1` can be used to extract records from\nErlang files.","ref":"Record.html"},{"type":"module","title":"Types - Record","doc":"Types can be defined for tuples with the `record/2` macro (only available in\ntypespecs). This macro will expand to a tuple as seen in the example below:\n\n    defmodule MyModule do\n      require Record\n      Record.defrecord(:user, name: \"john\", age: 25)\n\n      @type user :: record(:user, name: String.t(), age: integer)\n      # expands to: \"@type user :: {:user, String.t(), integer}\"\n    end","ref":"Record.html#module-types"},{"type":"module","title":"Reflection - Record","doc":"A list of all records in a module, if any, can be retrieved by reading the\n`@__records__` module attribute. It returns a list of maps with the record\nkind, name, tag, and fields. The attribute is only available inside the\nmodule definition.","ref":"Record.html#module-reflection"},{"type":"macro","title":"Record.defrecord/3","doc":"Defines a set of macros to create, access, and pattern match\non a record.\n\nThe name of the generated macros will be `name` (which has to be an\natom). `tag` is also an atom and is used as the \"tag\" for the record (i.e.,\nthe first element of the record tuple); by default (if `nil`), it's the same\nas `name`. `kv` is a keyword list of `name: default_value` fields for the\nnew record.\n\nThe following macros are generated:\n\n  * `name/0` to create a new record with default values for all fields\n  * `name/1` to create a new record with the given fields and values,\n    to get the zero-based index of the given field in a record or to\n    convert the given record to a keyword list\n  * `name/2` to update an existing record with the given fields and values\n    or to access a given field in a given record\n\nAll these macros are public macros (as defined by `defmacro`).\n\nSee the \"Examples\" section for examples on how to use these macros.","ref":"Record.html#defrecord/3"},{"type":"macro","title":"Examples - Record.defrecord/3","doc":"defmodule User do\n      require Record\n      Record.defrecord(:user, name: \"meg\", age: \"25\")\n    end\n\nIn the example above, a set of macros named `user` but with different\narities will be defined to manipulate the underlying record.\n\n    # Import the module to make the user macros locally available\n    import User\n\n    # To create records\n    record = user()        #=> {:user, \"meg\", 25}\n    record = user(age: 26) #=> {:user, \"meg\", 26}\n\n    # To get a field from the record\n    user(record, :name) #=> \"meg\"\n\n    # To update the record\n    user(record, age: 26) #=> {:user, \"meg\", 26}\n\n    # To get the zero-based index of the field in record tuple\n    # (index 0 is occupied by the record \"tag\")\n    user(:name) #=> 1\n\n    # Convert a record to a keyword list\n    user(record) #=> [name: \"meg\", age: 26]\n\nThe generated macros can also be used in order to pattern match on records and\nto bind variables during the match:\n\n    record = user() #=> {:user, \"meg\", 25}\n\n    user(name: name) = record\n    name #=> \"meg\"\n\nBy default, Elixir uses the record name as the first element of the tuple (the \"tag\").\nHowever, a different tag can be specified when defining a record,\nas in the following example, in which we use `Customer` as the second argument of `defrecord/3`:\n\n    defmodule User do\n      require Record\n      Record.defrecord(:user, Customer, name: nil)\n    end\n\n    require User\n    User.user() #=> {Customer, nil}","ref":"Record.html#defrecord/3-examples"},{"type":"macro","title":"Defining extracted records with anonymous functions in the values - Record.defrecord/3","doc":"If a record defines an anonymous function in the default values, an\n`ArgumentError` will be raised. This can happen unintentionally when defining\na record after extracting it from an Erlang library that uses anonymous\nfunctions for defaults.\n\n    Record.defrecord(:my_rec, Record.extract(...))\n    ** (ArgumentError) invalid value for record field fun_field,\n        cannot escape #Function<12.90072148/2 in :erl_eval.expr/5>.\n\nTo work around this error, redefine the field with your own &M.f/a function,\nlike so:\n\n    defmodule MyRec do\n      require Record\n      Record.defrecord(:my_rec, Record.extract(...) |> Keyword.merge(fun_field: &__MODULE__.foo/2))\n      def foo(bar, baz), do: IO.inspect({bar, baz})\n    end","ref":"Record.html#defrecord/3-defining-extracted-records-with-anonymous-functions-in-the-values"},{"type":"macro","title":"Record.defrecordp/3","doc":"Same as `defrecord/3` but generates private macros.","ref":"Record.html#defrecordp/3"},{"type":"function","title":"Record.extract/2","doc":"Extracts record information from an Erlang file.\n\nReturns a quoted expression containing the fields as a list\nof tuples.\n\n`name`, which is the name of the extracted record, is expected to be an atom\n*at compile time*.","ref":"Record.html#extract/2"},{"type":"function","title":"Options - Record.extract/2","doc":"This function requires one of the following options, which are exclusive to each\nother (i.e., only one of them can be used in the same call):\n\n  * `:from` - (binary representing a path to a file) path to the Erlang file\n    that contains the record definition to extract; with this option, this\n    function uses the same path lookup used by the `-include` attribute used in\n    Erlang modules.\n\n  * `:from_lib` - (binary representing a path to a file) path to the Erlang\n    file that contains the record definition to extract; with this option,\n    this function uses the same path lookup used by the `-include_lib`\n    attribute used in Erlang modules.\n\nIt additionally accepts the following optional, non-exclusive options:\n\n  * `:includes` - (a list of directories as binaries) if the record being\n    extracted depends on relative includes, this option allows developers\n    to specify the directory where those relative includes exist.\n\n  * `:macros` - (keyword list of macro names and values) if the record\n    being extracted depends on the values of macros, this option allows\n    the value of those macros to be set.\n\nThese options are expected to be literals (including the binary values) at\ncompile time.","ref":"Record.html#extract/2-options"},{"type":"function","title":"Examples - Record.extract/2","doc":"iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n    [\n      size: :undefined,\n      type: :undefined,\n      access: :undefined,\n      atime: :undefined,\n      mtime: :undefined,\n      ctime: :undefined,\n      mode: :undefined,\n      links: :undefined,\n      major_device: :undefined,\n      minor_device: :undefined,\n      inode: :undefined,\n      uid: :undefined,\n      gid: :undefined\n    ]","ref":"Record.html#extract/2-examples"},{"type":"function","title":"Record.extract_all/1","doc":"Extracts all records information from an Erlang file.\n\nReturns a keyword list of `{record_name, fields}` tuples where `record_name`\nis the name of an extracted record and `fields` is a list of `{field, value}`\ntuples representing the fields for that record.","ref":"Record.html#extract_all/1"},{"type":"function","title":"Options - Record.extract_all/1","doc":"Accepts the same options as listed for `Record.extract/2`.","ref":"Record.html#extract_all/1-options"},{"type":"macro","title":"Record.is_record/1","doc":"Checks if the given `data` is a record.\n\nThis is implemented as a macro so it can be used in guard clauses.","ref":"Record.html#is_record/1"},{"type":"macro","title":"Examples - Record.is_record/1","doc":"Record.is_record({User, \"john\", 27})\n    #=> true\n\n    Record.is_record({})\n    #=> false","ref":"Record.html#is_record/1-examples"},{"type":"macro","title":"Record.is_record/2","doc":"Checks if the given `data` is a record of kind `kind`.\n\nThis is implemented as a macro so it can be used in guard clauses.","ref":"Record.html#is_record/2"},{"type":"macro","title":"Examples - Record.is_record/2","doc":"iex> record = {User, \"john\", 27}\n    iex> Record.is_record(record, User)\n    true","ref":"Record.html#is_record/2-examples"},{"type":"module","title":"Regex","doc":"Provides regular expressions for Elixir.\n\nRegex is based on PCRE (Perl Compatible Regular Expressions) and\nbuilt on top of Erlang's `:re` module. More information can be found\nin the [`:re` module documentation](`:re`).\n\nRegular expressions in Elixir can be created using the sigils\n`~r` (see `sigil_r/2`):\n\n    # A simple regular expression that matches foo anywhere in the string\n    ~r/foo/\n\n    # A regular expression with case insensitive and Unicode options\n    ~r/foo/iu\n\nRegular expressions created via sigils are pre-compiled and stored\nin the `.beam` file. Note that this may be a problem if you are precompiling\nElixir, see the \"Precompilation\" section for more information.\n\nA Regex is represented internally as the `Regex` struct. Therefore,\n`%Regex{}` can be used whenever there is a need to match on them.\nKeep in mind that all of the structs fields are private. There is\nalso not guarantee two regular expressions from the same source are\nequal, for example:\n\n    ~r/(? .)(? .)/ == ~r/(? .)(? .)/\n\nmay return `true` or `false` depending on your machine, endianness,\navailable optimizations and others. You can, however, retrieve the source\nof a compiled regular expression by accessing the `source` field, and then\ncompare those directly:\n\n    ~r/(? .)(? .)/.source == ~r/(? .)(? .)/.source","ref":"Regex.html"},{"type":"module","title":"Escapes - Regex","doc":"Escape sequences are split into two categories.","ref":"Regex.html#module-escapes"},{"type":"module","title":"Non-printing characters - Regex","doc":"* `\\a` - Alarm, that is, the BEL character (hex 07)\n  * `\\e` - Escape (hex 1B)\n  * `\\f` - Form feed (hex 0C)\n  * `\\n` - Line feed (hex 0A)\n  * `\\r` - Carriage return (hex 0D)\n  * `\\t` - Tab (hex 09)\n  * `\\xhh` - Character with hex code hh\n  * `\\x{hhh..}` - Character with hex code hhh..\n\n`\\u` and `\\U` are not supported. Other escape sequences, such as `\\ddd`\nfor octals, are supported but discouraged.","ref":"Regex.html#module-non-printing-characters"},{"type":"module","title":"Generic character types - Regex","doc":"* `\\d` - Any decimal digit\n  * `\\D` - Any character that is not a decimal digit\n  * `\\h` - Any horizontal whitespace character\n  * `\\H` - Any character that is not a horizontal whitespace character\n  * `\\s` - Any whitespace character\n  * `\\S` - Any character that is not a whitespace character\n  * `\\v` - Any vertical whitespace character\n  * `\\V` - Any character that is not a vertical whitespace character\n  * `\\w` - Any \"word\" character\n  * `\\W` - Any \"non-word\" character","ref":"Regex.html#module-generic-character-types"},{"type":"module","title":"Modifiers - Regex","doc":"The modifiers available when creating a Regex are:\n\n  * `:unicode` (u) - enables Unicode specific patterns like `\\p` and causes\n    character classes like `\\w`, `\\W`, `\\s`, and the like to also match on Unicode\n    (see examples below in \"Character classes\"). It expects valid Unicode\n    strings to be given on match\n\n  * `:caseless` (i) - adds case insensitivity\n\n  * `:dotall` (s) - causes dot to match newlines and also set newline to\n    anycrlf; the new line setting can be overridden by setting `(*CR)` or\n    `(*LF)` or `(*CRLF)` or `(*ANY)` according to `:re` documentation\n\n  * `:multiline` (m) - causes `^` and `$` to mark the beginning and end of\n    each line; use `\\A` and `\\z` to match the end or beginning of the string\n\n  * `:extended` (x) - whitespace characters are ignored except when escaped\n    or within `[..]`, and allow `#` to delimit comments\n\n  * `:firstline` (f) - forces the unanchored pattern to match before or at the\n    first newline, though the matched text may continue over the newline\n\n  * `:ungreedy` (U) - inverts the \"greediness\" of the regexp\n    (the previous `r` option is deprecated in favor of `U`)\n\nThe options not available are:\n\n  * `:anchored` - not available, use `^` or `\\A` instead\n  * `:dollar_endonly` - not available, use `\\z` instead\n  * `:no_auto_capture` - not available, use `?:` instead\n  * `:newline` - not available, use `(*CR)` or `(*LF)` or `(*CRLF)` or\n    `(*ANYCRLF)` or `(*ANY)` at the beginning of the regexp according to the\n    `:re` documentation","ref":"Regex.html#module-modifiers"},{"type":"module","title":"Captures - Regex","doc":"Many functions in this module handle what to capture in a regex\nmatch via the `:capture` option. The supported values are:\n\n  * `:all` - all captured subpatterns including the complete matching string\n    (this is the default)\n\n  * `:first` - only the first captured subpattern, which is always the\n    complete matching part of the string; all explicitly captured subpatterns\n    are discarded\n\n  * `:all_but_first` - all but the first matching subpattern, i.e. all\n    explicitly captured subpatterns, but not the complete matching part of\n    the string\n\n  * `:none` - does not return matching subpatterns at all\n\n  * `:all_names` - captures all named subpattern matches in the Regex as a list\n    ordered **alphabetically** by the names of the subpatterns\n\n  * `list(binary | atom)` - a list of named captures to capture","ref":"Regex.html#module-captures"},{"type":"module","title":"Character classes - Regex","doc":"Regex supports several built in named character classes. These are used by\nenclosing the class name in `[: :]` inside a group. For example:\n\n    iex> String.match?(\"123\", ~r/^[[:alnum:]]+$/)\n    true\n    iex> String.match?(\"123 456\", ~r/^[[:alnum:][:blank:]]+$/)\n    true\n\nThe supported class names are:\n\n  * alnum - Letters and digits\n  * alpha - Letters\n  * blank - Space or tab only\n  * cntrl - Control characters\n  * digit - Decimal digits (same as \\\\d)\n  * graph - Printing characters, excluding space\n  * lower - Lowercase letters\n  * print - Printing characters, including space\n  * punct - Printing characters, excluding letters, digits, and space\n  * space - Whitespace (the same as \\s from PCRE 8.34)\n  * upper - Uppercase letters\n  * word  - \"Word\" characters (same as \\w)\n  * xdigit - Hexadecimal digits\n\nThere is another character class, `ascii`, that erroneously matches\nLatin-1 characters instead of the 0-127 range specified by POSIX. This\ncannot be fixed without altering the behavior of other classes, so we\nrecommend matching the range with `[\\\\0-\\x7f]` instead.\n\nNote the behavior of those classes may change according to the Unicode\nand other modifiers:\n\n    iex> String.match?(\"josé\", ~r/^[[:lower:]]+$/)\n    false\n    iex> String.match?(\"josé\", ~r/^[[:lower:]]+$/u)\n    true\n    iex> Regex.replace(~r/\\s/, \"Unicode\\u00A0spaces\", \"-\")\n    \"Unicode spaces\"\n    iex> Regex.replace(~r/\\s/u, \"Unicode\\u00A0spaces\", \"-\")\n    \"Unicode-spaces\"","ref":"Regex.html#module-character-classes"},{"type":"module","title":"Precompilation - Regex","doc":"Regular expressions built with sigil are precompiled and stored in `.beam`\nfiles. Precompiled regexes will be checked in runtime and may work slower\nbetween operating systems and OTP releases. This is rarely a problem, as most Elixir code\nshared during development is compiled on the target (such as dependencies,\narchives, and escripts) and, when running in production, the code must either\nbe compiled on the target (via `mix compile` or similar) or released on the\nhost (via `mix releases` or similar) with a matching OTP, operating system\nand architecture as the target.\n\nIf you know you are running on a different system than the current one and\nyou are doing multiple matches with the regex, you can manually invoke\n`Regex.recompile/1` or `Regex.recompile!/1` to perform a runtime version\ncheck and recompile the regex if necessary.","ref":"Regex.html#module-precompilation"},{"type":"function","title":"Regex.compile/2","doc":"Compiles the regular expression.\n\nThe given options can either be a binary with the characters\nrepresenting the same regex options given to the\n`~r` (see `sigil_r/2`) sigil, or a list of options, as\nexpected by the Erlang's [`:re`](`:re`) module.\n\nIt returns `{:ok, regex}` in case of success,\n`{:error, reason}` otherwise.","ref":"Regex.html#compile/2"},{"type":"function","title":"Examples - Regex.compile/2","doc":"iex> Regex.compile(\"foo\")\n    {:ok, ~r/foo/}\n\n    iex> Regex.compile(\"*foo\")\n    {:error, {~c\"nothing to repeat\", 0}}\n\n    iex> Regex.compile(\"foo\", \"i\")\n    {:ok, ~r/foo/i}\n\n    iex> Regex.compile(\"foo\", [:caseless])\n    {:ok, Regex.compile!(\"foo\", [:caseless])}","ref":"Regex.html#compile/2-examples"},{"type":"function","title":"Regex.compile!/2","doc":"Compiles the regular expression and raises `Regex.CompileError` in case of errors.","ref":"Regex.html#compile!/2"},{"type":"function","title":"Regex.escape/1","doc":"Escapes a string to be literally matched in a regex.","ref":"Regex.html#escape/1"},{"type":"function","title":"Examples - Regex.escape/1","doc":"iex> Regex.escape(\".\")\n    \"\\\\.\"\n\n    iex> Regex.escape(\"\\\\what if\")\n    \"\\\\\\\\what\\\\ if\"","ref":"Regex.html#escape/1-examples"},{"type":"function","title":"Regex.match?/2","doc":"Returns a boolean indicating whether there was a match or not.","ref":"Regex.html#match?/2"},{"type":"function","title":"Examples - Regex.match?/2","doc":"iex> Regex.match?(~r/foo/, \"foo\")\n    true\n\n    iex> Regex.match?(~r/foo/, \"bar\")\n    false\n\nElixir also provides text-based match operator `=~/2` and function `String.match?/2` as\nan alternative to test strings against regular expressions and\nstrings.","ref":"Regex.html#match?/2-examples"},{"type":"function","title":"Regex.named_captures/3","doc":"Returns the given captures as a map or `nil` if no captures are found.","ref":"Regex.html#named_captures/3"},{"type":"function","title":"Options - Regex.named_captures/3","doc":"* `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.","ref":"Regex.html#named_captures/3-options"},{"type":"function","title":"Examples - Regex.named_captures/3","doc":"iex> Regex.named_captures(~r/c(? d)/, \"abcd\")\n    %{\"foo\" => \"d\"}\n\n    iex> Regex.named_captures(~r/a(? b)c(? d)/, \"abcd\")\n    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n\n    iex> Regex.named_captures(~r/a(? b)c(? d)/, \"efgh\")\n    nil","ref":"Regex.html#named_captures/3-examples"},{"type":"function","title":"Regex.names/1","doc":"Returns a list of names in the regex.","ref":"Regex.html#names/1"},{"type":"function","title":"Examples - Regex.names/1","doc":"iex> Regex.names(~r/(? bar)/)\n    [\"foo\"]","ref":"Regex.html#names/1-examples"},{"type":"function","title":"Regex.opts/1","doc":"Returns the regex options.\n\nSee the documentation of `Regex.compile/2` for more information.","ref":"Regex.html#opts/1"},{"type":"function","title":"Examples - Regex.opts/1","doc":"iex> Regex.opts(~r/foo/m)\n    [:multiline]\n\n    iex> Regex.opts(Regex.compile!(\"foo\", [:caseless]))\n    [:caseless]","ref":"Regex.html#opts/1-examples"},{"type":"function","title":"Regex.re_pattern/1","doc":"Returns the underlying `re_pattern` in the regular expression.","ref":"Regex.html#re_pattern/1"},{"type":"function","title":"Regex.recompile/1","doc":"Recompiles the existing regular expression if necessary.\n\nThis checks the version stored in the regular expression\nand recompiles the regex in case of version mismatch.","ref":"Regex.html#recompile/1"},{"type":"function","title":"Regex.recompile!/1","doc":"Recompiles the existing regular expression and raises `Regex.CompileError` in case of errors.","ref":"Regex.html#recompile!/1"},{"type":"function","title":"Regex.replace/4","doc":"Receives a regex, a binary and a replacement, returns a new\nbinary where all matches are replaced by the replacement.\n\nThe replacement can be either a string or a function that returns a string.\nThe resulting string is used as a replacement for every match.\n\nWhen the replacement is a string, it allows specific captures of the match\nusing brackets at the regex expression and accessing them in the replacement\nvia `\\N` or `\\g{N}`, where `N` is the number of the capture. In case `\\0` is\nused, the whole match is inserted. Note that in regexes the backslash needs\nto be escaped, hence in practice you'll need to use `\\\\N` and `\\\\g{N}`.\n\nWhen the replacement is a function, it allows specific captures too.\nThe function may have arity N where each argument maps to a capture,\nwith the first argument being the whole match. If the function expects more\narguments than captures found, the remaining arguments will receive `\"\"`.","ref":"Regex.html#replace/4"},{"type":"function","title":"Options - Regex.replace/4","doc":"* `:global` - when `false`, replaces only the first occurrence\n    (defaults to `true`)","ref":"Regex.html#replace/4-options"},{"type":"function","title":"Examples - Regex.replace/4","doc":"iex> Regex.replace(~r/d/, \"abc\", \"d\")\n    \"abc\"\n\n    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n    \"adc\"\n\n    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n    \"a[b]c\"\n\n    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n    \"[b][d]\"\n\n    iex> Regex.replace(~r/\\.(\\d)$/, \"500.5\", \".\\\\g{1}0\")\n    \"500.50\"\n\n    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n    \"[b][d]\"\n\n    iex> Regex.replace(~r/(\\w+)@(\\w+).(\\w+)/, \"abc@def.com\", fn _full, _c1, _c2, c3 -> \"TLD: #{c3}\" end)\n    \"TLD: com\"\n\n    iex> Regex.replace(~r/a/, \"abcadc\", \"A\", global: false)\n    \"Abcadc\"","ref":"Regex.html#replace/4-examples"},{"type":"function","title":"Regex.run/3","doc":"Runs the regular expression against the given string until the first match.\nIt returns a list with all captures or `nil` if no match occurred.","ref":"Regex.html#run/3"},{"type":"function","title":"Options - Regex.run/3","doc":"* `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n  * `:capture` - what to capture in the result. See the [\"Captures\" section](#module-captures)\n    to see the possible capture values.\n  * `:offset` - (since v1.12.0) specifies the starting offset to match in the given string.\n    Defaults to zero.","ref":"Regex.html#run/3-options"},{"type":"function","title":"Examples - Regex.run/3","doc":"iex> Regex.run(~r/c(d)/, \"abcd\")\n    [\"cd\", \"d\"]\n\n    iex> Regex.run(~r/e/, \"abcd\")\n    nil\n\n    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n    [{2, 2}, {3, 1}]\n\n    iex> Regex.run(~r/c(d)/, \"abcd\", capture: :first)\n    [\"cd\"]\n\n    iex> Regex.run(~r/c(? d)/, \"abcd\", capture: [\"foo\", \"bar\"])\n    [\"d\", \"\"]","ref":"Regex.html#run/3-examples"},{"type":"function","title":"Regex.scan/3","doc":"Same as `run/3` but returns all non-overlapping matches of the regular expression.\n\nA list of lists is returned, where each entry in the primary list represents a\nmatch and each entry in the secondary list represents the captured contents.","ref":"Regex.html#scan/3"},{"type":"function","title":"Options - Regex.scan/3","doc":"* `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n  * `:capture` - what to capture in the result. See the [\"Captures\" section](#module-captures)\n    to see the possible capture values.\n  * `:offset` - (since v1.12.0) specifies the starting offset to match in the given string.\n    Defaults to zero.","ref":"Regex.html#scan/3-options"},{"type":"function","title":"Examples - Regex.scan/3","doc":"iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n\n    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n    [[\"cd\"], [\"ce\"]]\n\n    iex> Regex.scan(~r/e/, \"abcd\")\n    []\n\n    iex> Regex.scan(~r/ab|bc|cd/, \"abcd\")\n    [[\"ab\"], [\"cd\"]]\n\n    iex> Regex.scan(~r/ab|bc|cd/, \"abbccd\")\n    [[\"ab\"], [\"bc\"], [\"cd\"]]\n\n    iex> Regex.scan(~r/\\p{Sc}/u, \"$, £, and €\")\n    [[\"$\"], [\"£\"], [\"€\"]]\n\n    iex> Regex.scan(~r/=+/, \"=ü†ƒ8===\", return: :index)\n    [[{0, 1}], [{9, 3}]]\n\n    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\", capture: :first)\n    [[\"cd\"], [\"ce\"]]","ref":"Regex.html#scan/3-examples"},{"type":"function","title":"Regex.source/1","doc":"Returns the regex source as a binary.","ref":"Regex.html#source/1"},{"type":"function","title":"Examples - Regex.source/1","doc":"iex> Regex.source(~r/foo/)\n    \"foo\"","ref":"Regex.html#source/1-examples"},{"type":"function","title":"Regex.split/3","doc":"Splits the given target based on the given pattern and in the given number of\nparts.","ref":"Regex.html#split/3"},{"type":"function","title":"Options - Regex.split/3","doc":"* `:parts` - when specified, splits the string into the given number of\n    parts. If not specified, `:parts` defaults to `:infinity`, which will\n    split the string into the maximum number of parts possible based on the\n    given pattern.\n\n  * `:trim` - when `true`, removes empty strings (`\"\"`) from the result.\n    Defaults to `false`.\n\n  * `:on` - specifies which captures to split the string on, and in what\n    order. Defaults to `:first` which means captures inside the regex do not\n    affect the splitting process. See the [\"Captures\" section](#module-captures)\n    to see the possible capture values.\n\n  * `:include_captures` - when `true`, includes in the result the matches of\n    the regular expression. The matches are not counted towards the maximum\n    number of parts if combined with the `:parts` option. Defaults to `false`.","ref":"Regex.html#split/3-options"},{"type":"function","title":"Examples - Regex.split/3","doc":"iex> Regex.split(~r{-}, \"a-b-c\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> Regex.split(~r{-}, \"a-b-c\", parts: 2)\n    [\"a\", \"b-c\"]\n\n    iex> Regex.split(~r{-}, \"abc\")\n    [\"abc\"]\n\n    iex> Regex.split(~r{}, \"abc\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> Regex.split(~r{a(? b)c}, \"abc\")\n    [\"\", \"\"]\n\n    iex> Regex.split(~r{a(? b)c}, \"abc\", on: [:second])\n    [\"a\", \"c\"]\n\n    iex> Regex.split(~r{(x)}, \"Elixir\", include_captures: true)\n    [\"Eli\", \"x\", \"ir\"]\n\n    iex> Regex.split(~r{a(? b)c}, \"abc\", on: [:second], include_captures: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> Regex.split(~r{-}, \"-a-b--c\", trim: true)\n    [\"a\", \"b\", \"c\"]","ref":"Regex.html#split/3-examples"},{"type":"type","title":"Regex.t/0","doc":"","ref":"Regex.html#t:t/0"},{"type":"function","title":"Regex.version/0","doc":"Returns the version of the underlying Regex engine.","ref":"Regex.html#version/0"},{"type":"module","title":"String","doc":"Strings in Elixir are UTF-8 encoded binaries.\n\nStrings in Elixir are a sequence of Unicode characters,\ntypically written between double quoted strings, such\nas `\"hello\"` and `\"héllò\"`.\n\nIn case a string must have a double-quote in itself,\nthe double quotes must be escaped with a backslash,\nfor example: `\"this is a string with \\\"double quotes\\\"\"`.\n\nYou can concatenate two strings with the `<>/2` operator:\n\n    iex> \"hello\" <> \" \" <> \"world\"\n    \"hello world\"\n\nThe functions in this module act according to\n[The Unicode Standard, Version 15.1.0](http://www.unicode.org/versions/Unicode15.1.0/).","ref":"String.html"},{"type":"module","title":"Interpolation - String","doc":"Strings in Elixir also support interpolation. This allows\nyou to place some value in the middle of a string by using\nthe `#{}` syntax:\n\n    iex> name = \"joe\"\n    iex> \"hello #{name}\"\n    \"hello joe\"\n\nAny Elixir expression is valid inside the interpolation.\nIf a string is given, the string is interpolated as is.\nIf any other value is given, Elixir will attempt to convert\nit to a string using the `String.Chars` protocol. This\nallows, for example, to output an integer from the interpolation:\n\n    iex> \"2 + 2 = #{2 + 2}\"\n    \"2 + 2 = 4\"\n\nIn case the value you want to interpolate cannot be\nconverted to a string, because it doesn't have a human\ntextual representation, a protocol error will be raised.","ref":"String.html#module-interpolation"},{"type":"module","title":"Escape characters - String","doc":"Besides allowing double-quotes to be escaped with a backslash,\nstrings also support the following escape characters:\n\n  * `\\0` - Null byte\n  * `\\a` - Bell\n  * `\\b` - Backspace\n  * `\\t` - Horizontal tab\n  * `\\n` - Line feed (New lines)\n  * `\\v` - Vertical tab\n  * `\\f` - Form feed\n  * `\\r` - Carriage return\n  * `\\e` - Command Escape\n  * `\\s` - Space\n  * `\\#` - Returns the `#` character itself, skipping interpolation\n  * `\\\\` - Single backslash\n  * `\\xNN` - A byte represented by the hexadecimal `NN`\n  * `\\uNNNN` - A Unicode code point represented by `NNNN`\n  * `\\u{NNNNNN}` - A Unicode code point represented by `NNNNNN`\n\nNote it is generally not advised to use `\\xNN` in Elixir\nstrings, as introducing an invalid byte sequence would\nmake the string invalid. If you have to introduce a\ncharacter by its hexadecimal representation, it is best\nto work with Unicode code points, such as `\\uNNNN`. In fact,\nunderstanding Unicode code points can be essential when doing\nlow-level manipulations of string, so let's explore them in\ndetail next.","ref":"String.html#module-escape-characters"},{"type":"module","title":"Unicode and code points - String","doc":"In order to facilitate meaningful communication between computers\nacross multiple languages, a standard is required so that the ones\nand zeros on one machine mean the same thing when they are transmitted\nto another. The Unicode Standard acts as an official registry of\nvirtually all the characters we know: this includes characters from\nclassical and historical texts, emoji, and formatting and control\ncharacters as well.\n\nUnicode organizes all of the characters in its repertoire into code\ncharts, and each character is given a unique numerical index. This\nnumerical index is known as a Code Point.\n\nIn Elixir you can use a `?` in front of a character literal to reveal\nits code point:\n\n    iex> ?a\n    97\n    iex> ?ł\n    322\n\nNote that most Unicode code charts will refer to a code point by its\nhexadecimal (hex) representation, e.g. `97` translates to `0061` in hex,\nand we can represent any Unicode character in an Elixir string by\nusing the `\\u` escape character followed by its code point number:\n\n    iex> \"\\u0061\" === \"a\"\n    true\n    iex> 0x0061 = 97 = ?a\n    97\n\nThe hex representation will also help you look up information about a\ncode point, e.g. [https://codepoints.net/U+0061](https://codepoints.net/U+0061)\nhas a data sheet all about the lower case `a`, a.k.a. code point 97.\nRemember you can get the hex presentation of a number by calling\n`Integer.to_string/2`:\n\n    iex> Integer.to_string(?a, 16)\n    \"61\"","ref":"String.html#module-unicode-and-code-points"},{"type":"module","title":"UTF-8 encoded and encodings - String","doc":"Now that we understand what the Unicode standard is and what code points\nare, we can finally talk about encodings. Whereas the code point is **what**\nwe store, an encoding deals with **how** we store it: encoding is an\nimplementation. In other words, we need a mechanism to convert the code\npoint numbers into bytes so they can be stored in memory, written to disk, and such.\n\nElixir uses UTF-8 to encode its strings, which means that code points are\nencoded as a series of 8-bit bytes. UTF-8 is a **variable width** character\nencoding that uses one to four bytes to store each code point. It is capable\nof encoding all valid Unicode code points. Let's see an example:\n\n    iex> string = \"héllo\"\n    \"héllo\"\n    iex> String.length(string)\n    5\n    iex> byte_size(string)\n    6\n\nAlthough the string above has 5 characters, it uses 6 bytes, as two bytes\nare used to represent the character `é`.","ref":"String.html#module-utf-8-encoded-and-encodings"},{"type":"module","title":"Grapheme clusters - String","doc":"This module also works with the concept of grapheme cluster\n(from now on referenced as graphemes). Graphemes can consist\nof multiple code points that may be perceived as a single character\nby readers. For example, \"é\" can be represented either as a single\n\"e with acute\" code point, as seen above in the string `\"héllo\"`,\nor as the letter \"e\" followed by a \"combining acute accent\"\n(two code points):\n\n    iex> string = \"\\u0065\\u0301\"\n    \"é\"\n    iex> byte_size(string)\n    3\n    iex> String.length(string)\n    1\n    iex> String.codepoints(string)\n    [\"e\", \"́\"]\n    iex> String.graphemes(string)\n    [\"é\"]\n\nAlthough it looks visually the same as before, the example above\nis made of two characters, it is perceived by users as one.\n\nGraphemes can also be two characters that are interpreted as one\nby some languages. For example, some languages may consider \"ch\"\nas a single character. However, since this information depends on\nthe locale, it is not taken into account by this module.\n\nIn general, the functions in this module rely on the Unicode\nStandard, but do not contain any of the locale specific behavior.\nMore information about graphemes can be found in the [Unicode\nStandard Annex #29](https://www.unicode.org/reports/tr29/).\n\nFor converting a binary to a different encoding and for Unicode\nnormalization mechanisms, see Erlang's `:unicode` module.","ref":"String.html#module-grapheme-clusters"},{"type":"module","title":"String and binary operations - String","doc":"To act according to the Unicode Standard, many functions\nin this module run in linear time, as they need to traverse\nthe whole string considering the proper Unicode code points.\n\nFor example, `String.length/1` will take longer as\nthe input grows. On the other hand, `Kernel.byte_size/1` always runs\nin constant time (i.e. regardless of the input size).\n\nThis means often there are performance costs in using the\nfunctions in this module, compared to the more low-level\noperations that work directly with binaries:\n\n  * `Kernel.binary_part/3` - retrieves part of the binary\n  * `Kernel.bit_size/1` and `Kernel.byte_size/1` - size related functions\n  * `Kernel.is_bitstring/1` and `Kernel.is_binary/1` - type-check function\n  * Plus a number of functions for working with binaries (bytes)\n    in the [`:binary` module](`:binary`)\n\nA `utf8` modifier is also available inside the binary syntax `<<>>`.\nIt can be used to match code points out of a binary/string:\n\n    iex> < > = \"é\"\n    iex> eacute\n    233\n\nSee the [*Patterns and Guards* guide](patterns-and-guards.md) and the documentation for\n[`<<>>`](`<<>>/1`) for more information on binary pattern matching.\n\nYou can also fully convert a string into a list of integer code points,\nknown as \"charlists\" in Elixir, by calling `String.to_charlist/1`:\n\n    iex> String.to_charlist(\"héllo\")\n    [104, 233, 108, 108, 111]\n\nIf you would rather see the underlying bytes of a string, instead of\nits codepoints, a common trick is to concatenate the null byte `<<0>>`\nto it:\n\n    iex> \"héllo\" <> <<0>>\n    <<104, 195, 169, 108, 108, 111, 0>>\n\nAlternatively, you can view a string's binary representation by\npassing an option to `IO.inspect/2`:\n\n    IO.inspect(\"héllo\", binaries: :as_binaries)\n    #=> <<104, 195, 169, 108, 108, 111>>","ref":"String.html#module-string-and-binary-operations"},{"type":"module","title":"Self-synchronization - String","doc":"The UTF-8 encoding is self-synchronizing. This means that\nif malformed data (i.e., data that is not possible according\nto the definition of the encoding) is encountered, only one\ncode point needs to be rejected.\n\nThis module relies on this behavior to ignore such invalid\ncharacters. For example, `length/1` will return\na correct result even if an invalid code point is fed into it.\n\nIn other words, this module expects invalid data to be detected\nelsewhere, usually when retrieving data from the external source.\nFor example, a driver that reads strings from a database will be\nresponsible to check the validity of the encoding. `String.chunk/2`\ncan be used for breaking a string into valid and invalid parts.","ref":"String.html#module-self-synchronization"},{"type":"module","title":"Compile binary patterns - String","doc":"Many functions in this module work with patterns. For example,\n`String.split/3` can split a string into multiple strings given\na pattern. This pattern can be a string, a list of strings or\na compiled pattern:\n\n    iex> String.split(\"foo bar\", \" \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo bar!\", [\" \", \"!\"])\n    [\"foo\", \"bar\", \"\"]\n\n    iex> pattern = :binary.compile_pattern([\" \", \"!\"])\n    iex> String.split(\"foo bar!\", pattern)\n    [\"foo\", \"bar\", \"\"]\n\nThe compiled pattern is useful when the same match will\nbe done over and over again. Note though that the compiled\npattern cannot be stored in a module attribute as the pattern\nis generated at runtime and does not survive compile time.","ref":"String.html#module-compile-binary-patterns"},{"type":"function","title":"String.at/2","doc":"Returns the grapheme at the `position` of the given UTF-8 `string`.\nIf `position` is greater than `string` length, then it returns `nil`.","ref":"String.html#at/2"},{"type":"function","title":"Examples - String.at/2","doc":"iex> String.at(\"elixir\", 0)\n    \"e\"\n\n    iex> String.at(\"elixir\", 1)\n    \"l\"\n\n    iex> String.at(\"elixir\", 10)\n    nil\n\n    iex> String.at(\"elixir\", -1)\n    \"r\"\n\n    iex> String.at(\"elixir\", -10)\n    nil","ref":"String.html#at/2-examples"},{"type":"function","title":"String.bag_distance/2","doc":"Computes the bag distance between two strings.\n\nReturns a float value between 0 and 1 representing the bag\ndistance between `string1` and `string2`.\n\nThe bag distance is meant to be an efficient approximation\nof the distance between two strings to quickly rule out strings\nthat are largely different.\n\nThe algorithm is outlined in the \"String Matching with Metric\nTrees Using an Approximate Distance\" paper by Ilaria Bartolini,\nPaolo Ciaccia, and Marco Patella.","ref":"String.html#bag_distance/2"},{"type":"function","title":"Examples - String.bag_distance/2","doc":"iex> String.bag_distance(\"abc\", \"\")\n    0.0\n    iex> String.bag_distance(\"abcd\", \"a\")\n    0.25\n    iex> String.bag_distance(\"abcd\", \"ab\")\n    0.5\n    iex> String.bag_distance(\"abcd\", \"abc\")\n    0.75\n    iex> String.bag_distance(\"abcd\", \"abcd\")\n    1.0","ref":"String.html#bag_distance/2-examples"},{"type":"function","title":"String.byte_slice/3","doc":"Returns a substring starting at (or after) `start_bytes` and of at most\nthe given `size_bytes`.\n\nThis function works on bytes and then adjusts the string to eliminate\ntruncated codepoints. This is useful when you have a string and you need\nto guarantee it does not exceed a certain amount of bytes.\n\nIf the offset is greater than the number of bytes in the string, then it\nreturns `\"\"`. Similar to `String.slice/2`, a negative `start_bytes`\nwill be adjusted to the end of the string (but in bytes).\n\nThis function does not guarantee the string won't have invalid codepoints,\nit only guarantees to remove truncated codepoints immediately at the beginning\nor the end of the slice.","ref":"String.html#byte_slice/3"},{"type":"function","title":"Examples - String.byte_slice/3","doc":"Consider the string \"héllo\". Let's see its representation:\n\n    iex> inspect(\"héllo\", binaries: :as_binaries)\n    \"<<104, 195, 169, 108, 108, 111>>\"\n\nAlthough the string has 5 characters, it is made of 6 bytes. Now imagine\nwe want to get only the first two bytes. To do so, let's use `binary_slice/3`,\nwhich is unaware of codepoints:\n\n    iex> binary_slice(\"héllo\", 0, 2)\n    <<104, 195>>\n\nAs you can see, this operation is unsafe and returns an invalid string.\nThat's because we cut the string in the middle of the bytes representing\n\"é\". On the other hand, we could use `String.slice/3`:\n\n    iex> String.slice(\"héllo\", 0, 2)\n    \"hé\"\n\nWhile the above is correct, it has 3 bytes. If you have a requirement where\nyou need *at most* 2 bytes, the result would also be invalid. In such scenarios,\nyou can use this function, which will slice the given bytes, but clean up\nthe truncated codepoints:\n\n    iex> String.byte_slice(\"héllo\", 0, 2)\n    \"h\"\n\nTruncated codepoints at the beginning are also cleaned up:\n\n    iex> String.byte_slice(\"héllo\", 2, 3)\n    \"llo\"\n\nNote that, if you want to work on raw bytes, then you must use `binary_slice/3`\ninstead.","ref":"String.html#byte_slice/3-examples"},{"type":"function","title":"String.capitalize/2","doc":"Converts the first character in the given string to\nuppercase and the remainder to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode\nconsiders all non-conditional transformations outlined in the Unicode standard.\n`:ascii` capitalizes only the letters A to Z. `:greek` includes the context\nsensitive mappings found in Greek. `:turkic` properly handles the letter `i`\nwith the dotless variant.\n\nAlso see `upcase/2` and `capitalize/2` for other conversions. If you want\na variation of this function that does not lowercase the rest of string,\nsee Erlang's `:string.titlecase/1`.","ref":"String.html#capitalize/2"},{"type":"function","title":"Examples - String.capitalize/2","doc":"iex> String.capitalize(\"abcd\")\n    \"Abcd\"\n    iex> String.capitalize(\"ABCD\")\n    \"Abcd\"\n\n    iex> String.capitalize(\"ﬁn\")\n    \"Fin\"\n    iex> String.capitalize(\"olá\")\n    \"Olá\"","ref":"String.html#capitalize/2-examples"},{"type":"function","title":"String.chunk/2","doc":"Splits the string into chunks of characters that share a common trait.\n\nThe trait can be one of two options:\n\n  * `:valid` - the string is split into chunks of valid and invalid\n    character sequences\n\n  * `:printable` - the string is split into chunks of printable and\n    non-printable character sequences\n\nReturns a list of binaries each of which contains only one kind of\ncharacters.\n\nIf the given string is empty, an empty list is returned.","ref":"String.html#chunk/2"},{"type":"function","title":"Examples - String.chunk/2","doc":"iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n    [\"abc\\0\"]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0xFFFF::utf16>>, :valid)\n    [\"abc\\0\", <<0xFFFF::utf16>>]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0FFFF::utf8>>, :printable)\n    [\"abc\", <<0, 0x0FFFF::utf8>>]","ref":"String.html#chunk/2-examples"},{"type":"type","title":"String.codepoint/0","doc":"A single Unicode code point encoded in UTF-8. It may be one or more bytes.","ref":"String.html#t:codepoint/0"},{"type":"function","title":"String.codepoints/1","doc":"Returns a list of code points encoded as strings.\n\nTo retrieve code points in their natural integer\nrepresentation, see `to_charlist/1`. For details about\ncode points and graphemes, see the `String` module\ndocumentation.","ref":"String.html#codepoints/1"},{"type":"function","title":"Examples - String.codepoints/1","doc":"iex> String.codepoints(\"olá\")\n    [\"o\", \"l\", \"á\"]\n\n    iex> String.codepoints(\"оптими зации\")\n    [\"о\", \"п\", \"т\", \"и\", \"м\", \"и\", \" \", \"з\", \"а\", \"ц\", \"и\", \"и\"]\n\n    iex> String.codepoints(\"ἅἪῼ\")\n    [\"ἅ\", \"Ἢ\", \"ῼ\"]\n\n    iex> String.codepoints(\"\\u00e9\")\n    [\"é\"]\n\n    iex> String.codepoints(\"\\u0065\\u0301\")\n    [\"e\", \"́\"]","ref":"String.html#codepoints/1-examples"},{"type":"function","title":"String.contains?/2","doc":"Searches if `string` contains any of the given `contents`.\n\n`contents` can be either a string, a list of strings,\nor a compiled pattern. If `contents` is a list, this\nfunction will search if any of the strings in `contents`\nare part of `string`.\n\n> #### Searching for a string in a list {: .tip}\n>\n> If you want to check if `string` is listed in `contents`,\n> where `contents` is a list, use `Enum.member?(contents, string)`\n> instead.","ref":"String.html#contains?/2"},{"type":"function","title":"Examples - String.contains?/2","doc":"iex> String.contains?(\"elixir of life\", \"of\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"life\", \"death\"])\n    true\n    iex> String.contains?(\"elixir of life\", [\"death\", \"mercury\"])\n    false\n\nThe argument can also be a compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\"life\", \"death\"])\n    iex> String.contains?(\"elixir of life\", pattern)\n    true\n\nAn empty string will always match:\n\n    iex> String.contains?(\"elixir of life\", \"\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.contains?(\"elixir of life\", [])\n    false\n\n    iex> String.contains?(\"\", [])\n    false\n\nBe aware that this function can match within or across grapheme boundaries.\nFor example, take the grapheme \"é\" which is made of the characters\n\"e\" and the acute accent. The following returns `true`:\n\n    iex> String.contains?(String.normalize(\"é\", :nfd), \"e\")\n    true\n\nHowever, if \"é\" is represented by the single character \"e with acute\"\naccent, then it will return `false`:\n\n    iex> String.contains?(String.normalize(\"é\", :nfc), \"e\")\n    false","ref":"String.html#contains?/2-examples"},{"type":"function","title":"String.downcase/2","doc":"Converts all characters in the given string to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nlowercases only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\nAlso see `upcase/2` and `capitalize/2` for other conversions.","ref":"String.html#downcase/2"},{"type":"function","title":"Examples - String.downcase/2","doc":"iex> String.downcase(\"ABCD\")\n    \"abcd\"\n\n    iex> String.downcase(\"AB 123 XPTO\")\n    \"ab 123 xpto\"\n\n    iex> String.downcase(\"OLÁ\")\n    \"olá\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.downcase(\"OLÁ\", :ascii)\n    \"olÁ\"\n\nThe `:greek` mode properly handles the context sensitive sigma in Greek:\n\n    iex> String.downcase(\"ΣΣ\")\n    \"σσ\"\n\n    iex> String.downcase(\"ΣΣ\", :greek)\n    \"σς\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.downcase(\"Iİ\")\n    \"ii̇\"\n\n    iex> String.downcase(\"Iİ\", :turkic)\n    \"ıi\"","ref":"String.html#downcase/2-examples"},{"type":"function","title":"String.duplicate/2","doc":"Returns a string `subject` repeated `n` times.\n\nInlined by the compiler.","ref":"String.html#duplicate/2"},{"type":"function","title":"Examples - String.duplicate/2","doc":"iex> String.duplicate(\"abc\", 0)\n    \"\"\n\n    iex> String.duplicate(\"abc\", 1)\n    \"abc\"\n\n    iex> String.duplicate(\"abc\", 2)\n    \"abcabc\"","ref":"String.html#duplicate/2-examples"},{"type":"function","title":"String.ends_with?/2","doc":"Returns `true` if `string` ends with any of the suffixes given.\n\n`suffixes` can be either a single suffix or a list of suffixes.","ref":"String.html#ends_with?/2"},{"type":"function","title":"Examples - String.ends_with?/2","doc":"iex> String.ends_with?(\"language\", \"age\")\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"age\"])\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"elixir\"])\n    false\n\nAn empty suffix will always match:\n\n    iex> String.ends_with?(\"language\", \"\")\n    true\n    iex> String.ends_with?(\"language\", [\"\", \"other\"])\n    true","ref":"String.html#ends_with?/2-examples"},{"type":"function","title":"String.equivalent?/2","doc":"Returns `true` if `string1` is canonically equivalent to `string2`.\n\nIt performs Normalization Form Canonical Decomposition (NFD) on the\nstrings before comparing them. This function is equivalent to:\n\n    String.normalize(string1, :nfd) == String.normalize(string2, :nfd)\n\nIf you plan to compare multiple strings, multiple times in a row, you\nmay normalize them upfront and compare them directly to avoid multiple\nnormalization passes.","ref":"String.html#equivalent?/2"},{"type":"function","title":"Examples - String.equivalent?/2","doc":"iex> String.equivalent?(\"abc\", \"abc\")\n    true\n\n    iex> String.equivalent?(\"man\\u0303ana\", \"mañana\")\n    true\n\n    iex> String.equivalent?(\"abc\", \"ABC\")\n    false\n\n    iex> String.equivalent?(\"nø\", \"nó\")\n    false","ref":"String.html#equivalent?/2-examples"},{"type":"function","title":"String.first/1","doc":"Returns the first grapheme from a UTF-8 string,\n`nil` if the string is empty.","ref":"String.html#first/1"},{"type":"function","title":"Examples - String.first/1","doc":"iex> String.first(\"elixir\")\n    \"e\"\n\n    iex> String.first(\"եոգլի\")\n    \"ե\"\n\n    iex> String.first(\"\")\n    nil","ref":"String.html#first/1-examples"},{"type":"type","title":"String.grapheme/0","doc":"Multiple code points that may be perceived as a single character by readers","ref":"String.html#t:grapheme/0"},{"type":"function","title":"String.graphemes/1","doc":"Returns Unicode graphemes in the string as per Extended Grapheme\nCluster algorithm.\n\nThe algorithm is outlined in the [Unicode Standard Annex #29,\nUnicode Text Segmentation](https://www.unicode.org/reports/tr29/).\n\nFor details about code points and graphemes, see the `String` module documentation.","ref":"String.html#graphemes/1"},{"type":"function","title":"Examples - String.graphemes/1","doc":"iex> String.graphemes(\"Ńaïve\")\n    [\"Ń\", \"a\", \"ï\", \"v\", \"e\"]\n\n    iex> String.graphemes(\"\\u00e9\")\n    [\"é\"]\n\n    iex> String.graphemes(\"\\u0065\\u0301\")\n    [\"é\"]","ref":"String.html#graphemes/1-examples"},{"type":"function","title":"String.jaro_distance/2","doc":"Computes the Jaro distance (similarity) between two strings.\n\nReturns a float value between `0.0` (equates to no similarity) and `1.0`\n(is an exact match) representing [Jaro](https://en.wikipedia.org/wiki/Jaro-Winkler_distance)\ndistance between `string1` and `string2`.\n\nThe Jaro distance metric is designed and best suited for short\nstrings such as person names. Elixir itself uses this function\nto provide the \"did you mean?\" functionality. For instance, when you\nare calling a function in a module and you have a typo in the\nfunction name, we attempt to suggest the most similar function\nname available, if any, based on the `jaro_distance/2` score.","ref":"String.html#jaro_distance/2"},{"type":"function","title":"Examples - String.jaro_distance/2","doc":"iex> String.jaro_distance(\"Dwayne\", \"Duane\")\n    0.8222222222222223\n    iex> String.jaro_distance(\"even\", \"odd\")\n    0.0\n    iex> String.jaro_distance(\"same\", \"same\")\n    1.0","ref":"String.html#jaro_distance/2-examples"},{"type":"function","title":"String.last/1","doc":"Returns the last grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\nIt traverses the whole string to find its last grapheme.","ref":"String.html#last/1"},{"type":"function","title":"Examples - String.last/1","doc":"iex> String.last(\"\")\n    nil\n\n    iex> String.last(\"elixir\")\n    \"r\"\n\n    iex> String.last(\"եոգլի\")\n    \"ի\"","ref":"String.html#last/1-examples"},{"type":"function","title":"String.length/1","doc":"Returns the number of Unicode graphemes in a UTF-8 string.","ref":"String.html#length/1"},{"type":"function","title":"Examples - String.length/1","doc":"iex> String.length(\"elixir\")\n    6\n\n    iex> String.length(\"եոգլի\")\n    5","ref":"String.html#length/1-examples"},{"type":"function","title":"String.match?/2","doc":"Checks if `string` matches the given regular expression.","ref":"String.html#match?/2"},{"type":"function","title":"Examples - String.match?/2","doc":"iex> String.match?(\"foo\", ~r/foo/)\n    true\n\n    iex> String.match?(\"bar\", ~r/foo/)\n    false\n\nElixir also provides text-based match operator `=~/2` and function `Regex.match?/2` as\nalternatives to test strings against regular expressions.","ref":"String.html#match?/2-examples"},{"type":"function","title":"String.myers_difference/2","doc":"Returns a keyword list that represents an edit script.\n\nCheck `List.myers_difference/2` for more information.","ref":"String.html#myers_difference/2"},{"type":"function","title":"Examples - String.myers_difference/2","doc":"iex> string1 = \"fox hops over the dog\"\n    iex> string2 = \"fox jumps over the lazy cat\"\n    iex> String.myers_difference(string1, string2)\n    [eq: \"fox \", del: \"ho\", ins: \"jum\", eq: \"ps over the \", del: \"dog\", ins: \"lazy cat\"]","ref":"String.html#myers_difference/2-examples"},{"type":"function","title":"String.next_codepoint/1","doc":"Returns the next code point in a string.\n\nThe result is a tuple with the code point and the\nremainder of the string or `nil` in case\nthe string reached its end.\n\nAs with other functions in the `String` module, `next_codepoint/1`\nworks with binaries that are invalid UTF-8. If the string starts\nwith a sequence of bytes that is not valid in UTF-8 encoding, the\nfirst element of the returned tuple is a binary with the first byte.","ref":"String.html#next_codepoint/1"},{"type":"function","title":"Examples - String.next_codepoint/1","doc":"iex> String.next_codepoint(\"olá\")\n    {\"o\", \"lá\"}\n\n    iex> invalid = \"\\x80\\x80OK\" # first two bytes are invalid in UTF-8\n    iex> {_, rest} = String.next_codepoint(invalid)\n    {<<128>>, <<128, 79, 75>>}\n    iex> String.next_codepoint(rest)\n    {<<128>>, \"OK\"}","ref":"String.html#next_codepoint/1-examples"},{"type":"function","title":"Comparison with binary pattern matching - String.next_codepoint/1","doc":"Binary pattern matching provides a similar way to decompose\na string:\n\n    iex> < > = \"Elixir\"\n    \"Elixir\"\n    iex> codepoint\n    69\n    iex> rest\n    \"lixir\"\n\nthough not entirely equivalent because `codepoint` comes as\nan integer, and the pattern won't match invalid UTF-8.\n\nBinary pattern matching, however, is simpler and more efficient,\nso pick the option that better suits your use case.","ref":"String.html#next_codepoint/1-comparison-with-binary-pattern-matching"},{"type":"function","title":"String.next_grapheme/1","doc":"Returns the next grapheme in a string.\n\nThe result is a tuple with the grapheme and the\nremainder of the string or `nil` in case\nthe String reached its end.","ref":"String.html#next_grapheme/1"},{"type":"function","title":"Examples - String.next_grapheme/1","doc":"iex> String.next_grapheme(\"olá\")\n    {\"o\", \"lá\"}\n\n    iex> String.next_grapheme(\"\")\n    nil","ref":"String.html#next_grapheme/1-examples"},{"type":"function","title":"String.next_grapheme_size/1","doc":"Returns the size (in bytes) of the next grapheme.\n\nThe result is a tuple with the next grapheme size in bytes and\nthe remainder of the string or `nil` in case the string\nreached its end.","ref":"String.html#next_grapheme_size/1"},{"type":"function","title":"Examples - String.next_grapheme_size/1","doc":"iex> String.next_grapheme_size(\"olá\")\n    {1, \"lá\"}\n\n    iex> String.next_grapheme_size(\"\")\n    nil","ref":"String.html#next_grapheme_size/1-examples"},{"type":"function","title":"String.normalize/2","doc":"Converts all characters in `string` to Unicode normalization\nform identified by `form`.\n\nInvalid Unicode codepoints are skipped and the remaining of\nthe string is converted. If you want the algorithm to stop\nand return on invalid codepoint, use `:unicode.characters_to_nfd_binary/1`,\n`:unicode.characters_to_nfc_binary/1`, `:unicode.characters_to_nfkd_binary/1`,\nand `:unicode.characters_to_nfkc_binary/1` instead.\n\nNormalization forms `:nfkc` and `:nfkd` should not be blindly applied\nto arbitrary text. Because they erase many formatting distinctions,\nthey will prevent round-trip conversion to and from many legacy\ncharacter sets.","ref":"String.html#normalize/2"},{"type":"function","title":"Forms - String.normalize/2","doc":"The supported forms are:\n\n  * `:nfd` - Normalization Form Canonical Decomposition.\n    Characters are decomposed by canonical equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfc` - Normalization Form Canonical Composition.\n    Characters are decomposed and then recomposed by canonical equivalence.\n\n  * `:nfkd` - Normalization Form Compatibility Decomposition.\n    Characters are decomposed by compatibility equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfkc` - Normalization Form Compatibility Composition.\n    Characters are decomposed and then recomposed by compatibility equivalence.","ref":"String.html#normalize/2-forms"},{"type":"function","title":"Examples - String.normalize/2","doc":"iex> String.normalize(\"yêṩ\", :nfd)\n    \"yêṩ\"\n\n    iex> String.normalize(\"leña\", :nfc)\n    \"leña\"\n\n    iex> String.normalize(\"ﬁ\", :nfkd)\n    \"fi\"\n\n    iex> String.normalize(\"fi\", :nfkc)\n    \"fi\"","ref":"String.html#normalize/2-examples"},{"type":"function","title":"String.pad_leading/3","doc":"Returns a new string padded with a leading filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.","ref":"String.html#pad_leading/3"},{"type":"function","title":"Examples - String.pad_leading/3","doc":"iex> String.pad_leading(\"abc\", 5)\n    \"  abc\"\n\n    iex> String.pad_leading(\"abc\", 4, \"12\")\n    \"1abc\"\n\n    iex> String.pad_leading(\"abc\", 6, \"12\")\n    \"121abc\"\n\n    iex> String.pad_leading(\"abc\", 5, [\"1\", \"23\"])\n    \"123abc\"","ref":"String.html#pad_leading/3-examples"},{"type":"function","title":"String.pad_trailing/3","doc":"Returns a new string padded with a trailing filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.","ref":"String.html#pad_trailing/3"},{"type":"function","title":"Examples - String.pad_trailing/3","doc":"iex> String.pad_trailing(\"abc\", 5)\n    \"abc  \"\n\n    iex> String.pad_trailing(\"abc\", 4, \"12\")\n    \"abc1\"\n\n    iex> String.pad_trailing(\"abc\", 6, \"12\")\n    \"abc121\"\n\n    iex> String.pad_trailing(\"abc\", 5, [\"1\", \"23\"])\n    \"abc123\"","ref":"String.html#pad_trailing/3-examples"},{"type":"type","title":"String.pattern/0","doc":"Pattern used in functions like `replace/4` and `split/3`.\n\nIt must be one of:\n\n  * a string\n  * an empty list\n  * a list containing non-empty strings\n  * a compiled search pattern created by `:binary.compile_pattern/1`","ref":"String.html#t:pattern/0"},{"type":"function","title":"String.printable?/2","doc":"Checks if a string contains only printable characters up to `character_limit`.\n\nTakes an optional `character_limit` as a second argument. If `character_limit` is `0`, this\nfunction will return `true`.","ref":"String.html#printable?/2"},{"type":"function","title":"Examples - String.printable?/2","doc":"iex> String.printable?(\"abc\")\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>)\n    false\n\n    iex> String.printable?(\"abc\" <> <<0>>, 2)\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>, 0)\n    true","ref":"String.html#printable?/2-examples"},{"type":"function","title":"String.replace/4","doc":"Returns a new string created by replacing occurrences of `pattern` in\n`subject` with `replacement`.\n\nThe `subject` is always a string.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe `replacement` may be a string or a function that receives the matched\npattern and must return the replacement as a string or iodata.\n\nBy default it replaces all occurrences but this behavior can be controlled\nthrough the `:global` option; see the \"Options\" section below.","ref":"String.html#replace/4"},{"type":"function","title":"Options - String.replace/4","doc":"* `:global` - (boolean) if `true`, all occurrences of `pattern` are replaced\n    with `replacement`, otherwise only the first occurrence is\n    replaced. Defaults to `true`","ref":"String.html#replace/4-options"},{"type":"function","title":"Examples - String.replace/4","doc":"iex> String.replace(\"a,b,c\", \",\", \"-\")\n    \"a-b-c\"\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n    \"a-b,c\"\n\nThe pattern may also be a list of strings and the replacement may also\nbe a function that receives the matches:\n\n    iex> String.replace(\"a,b,c\", [\"a\", \"c\"], fn < > -> < > end)\n    \"b,b,d\"\n\nWhen the pattern is a regular expression, one can give `\\N` or\n`\\g{N}` in the `replacement` string to access a specific capture in the\nregular expression:\n\n    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\g{1}\")\n    \"a,bb,cc\"\n\nNote that we had to escape the backslash escape character (i.e., we used `\\\\N`\ninstead of just `\\N` to escape the backslash; same thing for `\\\\g{N}`). By\ngiving `\\0`, one can inject the whole match in the replacement string.\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern(\",\")\n    iex> String.replace(\"a,b,c\", pattern, \"[]\")\n    \"a[]b[]c\"\n\nWhen an empty string is provided as a `pattern`, the function will treat it as\nan implicit empty string between each grapheme and the string will be\ninterspersed. If an empty string is provided as `replacement` the `subject`\nwill be returned:\n\n    iex> String.replace(\"ELIXIR\", \"\", \".\")\n    \".E.L.I.X.I.R.\"\n\n    iex> String.replace(\"ELIXIR\", \"\", \"\")\n    \"ELIXIR\"\n\nBe aware that this function can replace within or across grapheme boundaries.\nFor example, take the grapheme \"é\" which is made of the characters\n\"e\" and the acute accent. The following will replace only the letter \"e\",\nmoving the accent to the letter \"o\":\n\n    iex> String.replace(String.normalize(\"é\", :nfd), \"e\", \"o\")\n    \"ó\"\n\nHowever, if \"é\" is represented by the single character \"e with acute\"\naccent, then it won't be replaced at all:\n\n    iex> String.replace(String.normalize(\"é\", :nfc), \"e\", \"o\")\n    \"é\"","ref":"String.html#replace/4-examples"},{"type":"function","title":"String.replace_invalid/2","doc":"Returns a new string created by replacing all invalid bytes with `replacement` (`\"�\"` by default).","ref":"String.html#replace_invalid/2"},{"type":"function","title":"Examples - String.replace_invalid/2","doc":"iex> String.replace_invalid(\"asd\" <> <<0xFF::8>>)\n    \"asd�\"\n\n    iex> String.replace_invalid(\"nem rán bề bề\")\n    \"nem rán bề bề\"\n\n    iex> String.replace_invalid(\"nem rán b\" <> <<225, 187>> <> \" bề\")\n    \"nem rán b� bề\"\n\n    iex> String.replace_invalid(\"nem rán b\" <> <<225, 187>> <> \" bề\", \"ERROR!\")\n    \"nem rán bERROR! bề\"","ref":"String.html#replace_invalid/2-examples"},{"type":"function","title":"String.replace_leading/3","doc":"Replaces all leading occurrences of `match` by `replacement` of `match` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe beginning of `string`, and it's impossible to replace \"multiple\"\noccurrences of `\"\"`.","ref":"String.html#replace_leading/3"},{"type":"function","title":"Examples - String.replace_leading/3","doc":"iex> String.replace_leading(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"\")\n    \"world\"\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"ola \")\n    \"ola ola world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.","ref":"String.html#replace_leading/3-examples"},{"type":"function","title":"String.replace_prefix/3","doc":"Replaces prefix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just prepended to `string`.","ref":"String.html#replace_prefix/3"},{"type":"function","title":"Examples - String.replace_prefix/3","doc":"iex> String.replace_prefix(\"world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"\")\n    \"hello world\"\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"ola \")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"ola \")\n    \"ola hello world\"\n\n    iex> String.replace_prefix(\"world\", \"\", \"hello \")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.","ref":"String.html#replace_prefix/3-examples"},{"type":"function","title":"String.replace_suffix/3","doc":"Replaces suffix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just appended to `string`.","ref":"String.html#replace_suffix/3"},{"type":"function","title":"Examples - String.replace_suffix/3","doc":"iex> String.replace_suffix(\"hello\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \"\")\n    \"hello world\"\n\n    iex> String.replace_suffix(\"hello\", \" world\", \" mundo\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \" mundo\")\n    \"hello world mundo\"\n\n    iex> String.replace_suffix(\"hello\", \"\", \" world\")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.","ref":"String.html#replace_suffix/3-examples"},{"type":"function","title":"String.replace_trailing/3","doc":"Replaces all trailing occurrences of `match` by `replacement` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe end of `string`, and it's impossible to replace \"multiple\" occurrences of\n`\"\"`.","ref":"String.html#replace_trailing/3"},{"type":"function","title":"Examples - String.replace_trailing/3","doc":"iex> String.replace_trailing(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \"\")\n    \"hello\"\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \" mundo\")\n    \"hello mundo mundo\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.","ref":"String.html#replace_trailing/3-examples"},{"type":"function","title":"String.reverse/1","doc":"Reverses the graphemes in given string.","ref":"String.html#reverse/1"},{"type":"function","title":"Examples - String.reverse/1","doc":"iex> String.reverse(\"abcd\")\n    \"dcba\"\n\n    iex> String.reverse(\"hello world\")\n    \"dlrow olleh\"\n\n    iex> String.reverse(\"hello ∂og\")\n    \"go∂ olleh\"\n\nKeep in mind reversing the same string twice does\nnot necessarily yield the original string:\n\n    iex> \"̀e\"\n    \"̀e\"\n    iex> String.reverse(\"̀e\")\n    \"è\"\n    iex> String.reverse(String.reverse(\"̀e\"))\n    \"è\"\n\nIn the first example the accent is before the vowel, so\nit is considered two graphemes. However, when you reverse\nit once, you have the vowel followed by the accent, which\nbecomes one grapheme. Reversing it again will keep it as\none single grapheme.","ref":"String.html#reverse/1-examples"},{"type":"function","title":"String.slice/2","doc":"Returns a substring from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nThis function works on Unicode graphemes. For example, slicing the first\nthree characters of the string \"héllo\" will return \"hél\", which internally\nis represented by more than three bytes. Use `String.byte_slice/3` if you\nwant to slice by a given number of bytes, while respecting the codepoint\nboundaries. If you want to work on raw bytes, check `Kernel.binary_part/3`\nor `Kernel.binary_slice/3` instead.\n\nIf the start of the range is not a valid offset for the given\nstring or if the range is in reverse order, returns `\"\"`.\n\nIf the start or end of the range is negative, the whole string\nis traversed first in order to convert the negative indices into\npositive ones.","ref":"String.html#slice/2"},{"type":"function","title":"Examples - String.slice/2","doc":"iex> String.slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> String.slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -100..100)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> String.slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole string as is:\n\n    iex> String.slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the string:\n\n    iex> String.slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> String.slice(\"elixir\", 10..3//1)\n    \"\"\n    iex> String.slice(\"a\", 1..1500)\n    \"\"","ref":"String.html#slice/2-examples"},{"type":"function","title":"String.slice/3","doc":"Returns a substring starting at the offset `start`, and of the given `length`.\n\nThis function works on Unicode graphemes. For example, slicing the first\nthree characters of the string \"héllo\" will return \"hél\", which internally\nis represented by more than three bytes. Use `String.byte_slice/3` if you\nwant to slice by a given number of bytes, while respecting the codepoint\nboundaries. If you want to work on raw bytes, check `Kernel.binary_part/3`\nor `Kernel.binary_slice/3` instead.\n\nIf the offset is greater than string length, then it returns `\"\"`.","ref":"String.html#slice/3"},{"type":"function","title":"Examples - String.slice/3","doc":"iex> String.slice(\"elixir\", 1, 3)\n    \"lix\"\n\n    iex> String.slice(\"elixir\", 1, 10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", 10, 3)\n    \"\"\n\nIf the start position is negative, it is normalized\nagainst the string length and clamped to 0:\n\n    iex> String.slice(\"elixir\", -4, 4)\n    \"ixir\"\n\n    iex> String.slice(\"elixir\", -10, 3)\n    \"eli\"\n\nIf start is more than the string length, an empty\nstring is returned:\n\n    iex> String.slice(\"elixir\", 10, 1500)\n    \"\"","ref":"String.html#slice/3-examples"},{"type":"function","title":"String.split/1","doc":"Divides a string into substrings at each Unicode whitespace\noccurrence with leading and trailing whitespace ignored. Groups\nof whitespace are treated as a single occurrence. Divisions do\nnot occur on non-breaking whitespace.","ref":"String.html#split/1"},{"type":"function","title":"Examples - String.split/1","doc":"iex> String.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\" foo   bar \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"no\\u00a0break\")\n    [\"no\\u00a0break\"]","ref":"String.html#split/1-examples"},{"type":"function","title":"String.split/3","doc":"Divides a string into parts based on a pattern.\n\nReturns a list of these parts.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe string is split into as many parts as possible by\ndefault, but can be controlled via the `:parts` option.\n\nEmpty strings are only removed from the result if the\n`:trim` option is set to `true`.\n\nWhen the pattern used is a regular expression, the string is\nsplit using `Regex.split/3`.\n\nIf the pattern cannot be found, a list containing the original\nstring will be returned.","ref":"String.html#split/3"},{"type":"function","title":"Options - String.split/3","doc":"* `:parts` (positive integer or `:infinity`) - the string\n    is split into at most as many parts as this option specifies.\n    If `:infinity`, the string will be split into all possible\n    parts. Defaults to `:infinity`.\n\n  * `:trim` (boolean) - if `true`, empty strings are removed from\n    the resulting list.\n\nThis function also accepts all options accepted by `Regex.split/3`\nif `pattern` is a regular expression.","ref":"String.html#split/3-options"},{"type":"function","title":"Examples - String.split/3","doc":"Splitting with a string pattern:\n\n    iex> String.split(\"a,b,c\", \",\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", \",\", parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", \" \", trim: true)\n    [\"a\", \"b\", \"c\"]\n\nA list of patterns:\n\n    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n    [\"1\", \"2\", \"3\", \"4\"]\n\nA regular expression:\n\n    iex> String.split(\"a,b,c\", ~r{,})\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", ~r{b}, include_captures: true)\n    [\"a\", \"b\", \"c\"]\n\nA compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.split(\"1,2 3,4\", pattern)\n    [\"1\", \"2\", \"3\", \"4\"]\n\nSplitting on empty string returns graphemes:\n\n    iex> String.split(\"abc\", \"\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> String.split(\"abc\", \"\", trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", \"\", parts: 1)\n    [\"abc\"]\n\n    iex> String.split(\"abc\", \"\", parts: 3)\n    [\"\", \"a\", \"bc\"]\n\nSplitting on an non-existing pattern returns the original string:\n\n    iex> String.split(\"abc\", \",\")\n    [\"abc\"]\n\nBe aware that this function can split within or across grapheme boundaries.\nFor example, take the grapheme \"é\" which is made of the characters\n\"e\" and the acute accent. The following will split the string into two parts:\n\n    iex> String.split(String.normalize(\"é\", :nfd), \"e\")\n    [\"\", \"́\"]\n\nHowever, if \"é\" is represented by the single character \"e with acute\"\naccent, then it will split the string into just one part:\n\n    iex> String.split(String.normalize(\"é\", :nfc), \"e\")\n    [\"é\"]","ref":"String.html#split/3-examples"},{"type":"function","title":"String.split_at/2","doc":"Splits a string into two at the specified offset. When the offset given is\nnegative, location is counted from the end of the string.\n\nThe offset is capped to the length of the string. Returns a tuple with\ntwo elements.\n\nNote: keep in mind this function splits on graphemes and for such it\nhas to linearly traverse the string. If you want to split a string or\na binary based on the number of bytes, use `Kernel.binary_part/3`\ninstead.","ref":"String.html#split_at/2"},{"type":"function","title":"Examples - String.split_at/2","doc":"iex> String.split_at(\"sweetelixir\", 5)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"sweetelixir\", -6)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"abc\", 0)\n    {\"\", \"abc\"}\n\n    iex> String.split_at(\"abc\", 1000)\n    {\"abc\", \"\"}\n\n    iex> String.split_at(\"abc\", -1000)\n    {\"\", \"abc\"}","ref":"String.html#split_at/2-examples"},{"type":"function","title":"String.splitter/3","doc":"Returns an enumerable that splits a string on demand.\n\nThis is in contrast to `split/3` which splits the\nentire string upfront.\n\nThis function does not support regular expressions\nby design. When using regular expressions, it is often\nmore efficient to have the regular expressions traverse\nthe string at once than in parts, like this function does.","ref":"String.html#splitter/3"},{"type":"function","title":"Options - String.splitter/3","doc":"* :trim - when `true`, does not emit empty patterns","ref":"String.html#splitter/3-options"},{"type":"function","title":"Examples - String.splitter/3","doc":"iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", [\" \", \",\"]) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]\n\n    iex> String.splitter(\"abcd\", \"\") |> Enum.take(10)\n    [\"\", \"a\", \"b\", \"c\", \"d\", \"\"]\n\n    iex> String.splitter(\"abcd\", \"\", trim: true) |> Enum.take(10)\n    [\"a\", \"b\", \"c\", \"d\"]\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", pattern) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]","ref":"String.html#splitter/3-examples"},{"type":"function","title":"String.starts_with?/2","doc":"Returns `true` if `string` starts with any of the prefixes given.\n\n`prefix` can be either a string, a list of strings, or a compiled\npattern.","ref":"String.html#starts_with?/2"},{"type":"function","title":"Examples - String.starts_with?/2","doc":"iex> String.starts_with?(\"elixir\", \"eli\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"elixir\"])\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"ruby\"])\n    false\n\nAn empty string will always match:\n\n    iex> String.starts_with?(\"elixir\", \"\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.starts_with?(\"elixir\", [])\n    false\n\n    iex> String.starts_with?(\"\", [])\n    false","ref":"String.html#starts_with?/2-examples"},{"type":"type","title":"String.t/0","doc":"A UTF-8 encoded binary.\n\nThe types `String.t()` and `binary()` are equivalent to analysis tools.\nAlthough, for those reading the documentation, `String.t()` implies\nit is a UTF-8 encoded binary.","ref":"String.html#t:t/0"},{"type":"function","title":"String.to_atom/1","doc":"Converts a string to an existing atom or creates a new one.\n\nWarning: this function creates atoms dynamically and atoms are\nnot garbage-collected. Therefore, `string` should not be an\nuntrusted value, such as input received from a socket or during\na web request. Consider using `to_existing_atom/1` instead.\n\nBy default, the maximum number of atoms is `1_048_576`. This limit\ncan be raised or lowered using the VM option `+t`.\n\nThe maximum atom size is of 255 Unicode code points.\n\nInlined by the compiler.","ref":"String.html#to_atom/1"},{"type":"function","title":"Examples - String.to_atom/1","doc":"iex> String.to_atom(\"my_atom\")\n    :my_atom","ref":"String.html#to_atom/1-examples"},{"type":"function","title":"String.to_charlist/1","doc":"Converts a string into a charlist.\n\nSpecifically, this function takes a UTF-8 encoded binary and returns a list of its integer\ncode points. It is similar to `codepoints/1` except that the latter returns a list of code points as\nstrings.\n\nIn case you need to work with bytes, take a look at the\n[`:binary` module](`:binary`).","ref":"String.html#to_charlist/1"},{"type":"function","title":"Examples - String.to_charlist/1","doc":"iex> String.to_charlist(\"foo\")\n    ~c\"foo\"","ref":"String.html#to_charlist/1-examples"},{"type":"function","title":"String.to_existing_atom/1","doc":"Converts a string to an existing atom or raises if\nthe atom does not exist.\n\nThe maximum atom size is of 255 Unicode code points.\nRaises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `String.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.\n>\n> To create a module name itself from a string safely,\n> it is recommended to use `Module.safe_concat/1`.","ref":"String.html#to_existing_atom/1"},{"type":"function","title":"Examples - String.to_existing_atom/1","doc":"iex> _ = :my_atom\n    iex> String.to_existing_atom(\"my_atom\")\n    :my_atom","ref":"String.html#to_existing_atom/1-examples"},{"type":"function","title":"String.to_float/1","doc":"Returns a float whose text representation is `string`.\n\n`string` must be the string representation of a float including a decimal point.\nIn order to parse a string without decimal point as a float then `Float.parse/1`\nshould be used. Otherwise, an `ArgumentError` will be raised.\n\nInlined by the compiler.","ref":"String.html#to_float/1"},{"type":"function","title":"Examples - String.to_float/1","doc":"iex> String.to_float(\"2.2017764e+0\")\n    2.2017764\n\n    iex> String.to_float(\"3.0\")\n    3.0\n\n    String.to_float(\"3\")\n    ** (ArgumentError) argument error","ref":"String.html#to_float/1-examples"},{"type":"function","title":"String.to_integer/1","doc":"Returns an integer whose text representation is `string`.\n\n`string` must be the string representation of an integer.\nOtherwise, an `ArgumentError` will be raised. If you want\nto parse a string that may contain an ill-formatted integer,\nuse `Integer.parse/1`.\n\nInlined by the compiler.","ref":"String.html#to_integer/1"},{"type":"function","title":"Examples - String.to_integer/1","doc":"iex> String.to_integer(\"123\")\n    123\n\nPassing a string that does not represent an integer leads to an error:\n\n    String.to_integer(\"invalid data\")\n    ** (ArgumentError) argument error","ref":"String.html#to_integer/1-examples"},{"type":"function","title":"String.to_integer/2","doc":"Returns an integer whose text representation is `string` in base `base`.\n\nInlined by the compiler.","ref":"String.html#to_integer/2"},{"type":"function","title":"Examples - String.to_integer/2","doc":"iex> String.to_integer(\"3FF\", 16)\n    1023","ref":"String.html#to_integer/2-examples"},{"type":"function","title":"String.trim/1","doc":"Returns a string where all leading and trailing Unicode whitespaces\nhave been removed.","ref":"String.html#trim/1"},{"type":"function","title":"Examples - String.trim/1","doc":"iex> String.trim(\"\\n  abc\\n  \")\n    \"abc\"","ref":"String.html#trim/1-examples"},{"type":"function","title":"String.trim/2","doc":"Returns a string where all leading and trailing `to_trim` characters have been\nremoved.","ref":"String.html#trim/2"},{"type":"function","title":"Examples - String.trim/2","doc":"iex> String.trim(\"a  abc  a\", \"a\")\n    \"  abc  \"","ref":"String.html#trim/2-examples"},{"type":"function","title":"String.trim_leading/1","doc":"Returns a string where all leading Unicode whitespaces\nhave been removed.","ref":"String.html#trim_leading/1"},{"type":"function","title":"Examples - String.trim_leading/1","doc":"iex> String.trim_leading(\"\\n  abc   \")\n    \"abc   \"","ref":"String.html#trim_leading/1-examples"},{"type":"function","title":"String.trim_leading/2","doc":"Returns a string where all leading `to_trim` characters have been removed.","ref":"String.html#trim_leading/2"},{"type":"function","title":"Examples - String.trim_leading/2","doc":"iex> String.trim_leading(\"__ abc _\", \"_\")\n    \" abc _\"\n\n    iex> String.trim_leading(\"1 abc\", \"11\")\n    \"1 abc\"","ref":"String.html#trim_leading/2-examples"},{"type":"function","title":"String.trim_trailing/1","doc":"Returns a string where all trailing Unicode whitespaces\nhas been removed.","ref":"String.html#trim_trailing/1"},{"type":"function","title":"Examples - String.trim_trailing/1","doc":"iex> String.trim_trailing(\"   abc\\n  \")\n    \"   abc\"","ref":"String.html#trim_trailing/1-examples"},{"type":"function","title":"String.trim_trailing/2","doc":"Returns a string where all trailing `to_trim` characters have been removed.","ref":"String.html#trim_trailing/2"},{"type":"function","title":"Examples - String.trim_trailing/2","doc":"iex> String.trim_trailing(\"_ abc __\", \"_\")\n    \"_ abc \"\n\n    iex> String.trim_trailing(\"abc 1\", \"11\")\n    \"abc 1\"","ref":"String.html#trim_trailing/2-examples"},{"type":"function","title":"String.upcase/2","doc":"Converts all characters in the given string to uppercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nuppercases only the letters a to z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.","ref":"String.html#upcase/2"},{"type":"function","title":"Examples - String.upcase/2","doc":"iex> String.upcase(\"abcd\")\n    \"ABCD\"\n\n    iex> String.upcase(\"ab 123 xpto\")\n    \"AB 123 XPTO\"\n\n    iex> String.upcase(\"olá\")\n    \"OLÁ\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.upcase(\"olá\", :ascii)\n    \"OLá\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.upcase(\"ıi\")\n    \"II\"\n\n    iex> String.upcase(\"ıi\", :turkic)\n    \"Iİ\"\n\nAlso see `downcase/2` and `capitalize/2` for other conversions.","ref":"String.html#upcase/2-examples"},{"type":"function","title":"String.valid?/2","doc":"Checks whether `string` contains only valid characters.\n\n`algorithm` may be `:default` or `:fast_ascii`. Both algorithms are equivalent\nfrom a validation perspective (they will always produce the same output), but\n`:fast_ascii` can yield significant performance benefits in specific scenarios.\n\nIf all of the following conditions are true, you may want to experiment with\nthe `:fast_ascii` algorithm to see if it yields performance benefits in your\nspecific scenario:\n\n* You are running Erlang/OTP 26 or newer on a 64 bit platform\n* You expect most of your strings to be longer than ~64 bytes\n* You expect most of your strings to contain mostly ASCII codepoints\n\nNote that the `:fast_ascii` algorithm does not affect correctness, you can\nexpect the output of `String.valid?/2` to be the same regardless of algorithm.\nThe only difference to be expected is one of performance, which can be\nexpected to improve roughly linearly in string length compared to the\n`:default` algorithm.","ref":"String.html#valid?/2"},{"type":"function","title":"Examples - String.valid?/2","doc":"iex> String.valid?(\"a\")\n    true\n\n    iex> String.valid?(\"ø\")\n    true\n\n    iex> String.valid?(<<0xFFFF::16>>)\n    false\n\n    iex> String.valid?(<<0xEF, 0xB7, 0x90>>)\n    true\n\n    iex> String.valid?(\"asd\" <> <<0xFFFF::16>>)\n    false\n\n    iex> String.valid?(\"a\", :fast_ascii)\n    true\n\n    iex> String.valid?(4)\n    ** (FunctionClauseError) no function clause matching in String.valid?/2","ref":"String.html#valid?/2-examples"},{"type":"module","title":"Time","doc":"A Time struct and functions.\n\nThe Time struct contains the fields hour, minute, second and microseconds.\nNew times can be built with the `new/4` function or using the\n`~T` (see `sigil_T/2`) sigil:\n\n    iex> ~T[23:00:07.001]\n    ~T[23:00:07.001]\n\nBoth `new/4` and sigil return a struct where the time fields can\nbe accessed directly:\n\n    iex> time = ~T[23:00:07.001]\n    iex> time.hour\n    23\n    iex> time.microsecond\n    {1000, 3}\n\nThe functions on this module work with the `Time` struct as well\nas any struct that contains the same fields as the `Time` struct,\nsuch as `NaiveDateTime` and `DateTime`. Such functions expect\n`t:Calendar.time/0` in their typespecs (instead of `t:t/0`).\n\nDevelopers should avoid creating the Time structs directly\nand instead rely on the functions provided by this module as well\nas the ones in third-party calendar libraries.","ref":"Time.html"},{"type":"module","title":"Comparing times - Time","doc":"Comparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `Time` struct fields. For proper comparison between\ntimes, use the `compare/2` function. The existence of the `compare/2`\nfunction in this module also allows using `Enum.min/2` and `Enum.max/2`\nfunctions to get the minimum and maximum time of an `Enum`. For example:\n\n    iex> Enum.min([~T[23:00:07.001], ~T[10:00:07.001]], Time)\n    ~T[10:00:07.001]","ref":"Time.html#module-comparing-times"},{"type":"function","title":"Time.add/3","doc":"Adds the `amount_to_add` of `unit`s to the given `time`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\nNote the result value represents the time of day, meaning that it is cyclic,\nfor instance, it will never go over 24 hours for the ISO calendar.","ref":"Time.html#add/3"},{"type":"function","title":"Examples - Time.add/3","doc":"iex> Time.add(~T[10:00:00], 27000)\n    ~T[17:30:00]\n    iex> Time.add(~T[11:00:00.005], 2400)\n    ~T[11:40:00.005]\n    iex> Time.add(~T[00:00:00.000], 86_399_999, :millisecond)\n    ~T[23:59:59.999]\n\nNegative values are allowed:\n\n    iex> Time.add(~T[23:00:00], -60)\n    ~T[22:59:00]\n\nNote that the time is cyclic:\n\n    iex> Time.add(~T[17:10:05], 86400)\n    ~T[17:10:05]\n\nHours and minutes are also supported:\n\n    iex> Time.add(~T[17:10:05], 2, :hour)\n    ~T[19:10:05]\n    iex> Time.add(~T[17:10:05], 30, :minute)\n    ~T[17:40:05]\n\nThis operation merges the precision of the time with the given unit:\n\n    iex> result = Time.add(~T[00:29:10], 21, :millisecond)\n    ~T[00:29:10.021]\n    iex> result.microsecond\n    {21000, 3}\n\nTo shift a time by a `Duration` and according to its underlying calendar, use `Time.shift/2`.","ref":"Time.html#add/3-examples"},{"type":"function","title":"Time.after?/2","doc":"Returns `true` if the first time is strictly later than the second.","ref":"Time.html#after?/2"},{"type":"function","title":"Examples - Time.after?/2","doc":"iex> Time.after?(~T[16:04:28], ~T[16:04:16])\n    true\n    iex> Time.after?(~T[16:04:16], ~T[16:04:16])\n    false\n    iex> Time.after?(~T[16:04:16.001], ~T[16:04:16.01])\n    false","ref":"Time.html#after?/2-examples"},{"type":"function","title":"Time.before?/2","doc":"Returns `true` if the first time is strictly earlier than the second.","ref":"Time.html#before?/2"},{"type":"function","title":"Examples - Time.before?/2","doc":"iex> Time.before?(~T[16:04:16], ~T[16:04:28])\n    true\n    iex> Time.before?(~T[16:04:16], ~T[16:04:16])\n    false\n    iex> Time.before?(~T[16:04:16.01], ~T[16:04:16.001])\n    false","ref":"Time.html#before?/2-examples"},{"type":"function","title":"Time.compare/2","doc":"Compares two time structs.\n\nReturns `:gt` if first time is later than the second\nand `:lt` for vice versa. If the two times are equal\n`:eq` is returned.","ref":"Time.html#compare/2"},{"type":"function","title":"Examples - Time.compare/2","doc":"iex> Time.compare(~T[16:04:16], ~T[16:04:28])\n    :lt\n    iex> Time.compare(~T[16:04:16], ~T[16:04:16])\n    :eq\n    iex> Time.compare(~T[16:04:16.01], ~T[16:04:16.001])\n    :gt\n\nThis function can also be used to compare across more\ncomplex calendar types by considering only the time fields:\n\n    iex> Time.compare(~N[1900-01-01 16:04:16], ~N[2015-01-01 16:04:16])\n    :eq\n    iex> Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])\n    :lt\n    iex> Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 16:04:16.001])\n    :gt","ref":"Time.html#compare/2-examples"},{"type":"function","title":"Time.convert/2","doc":"Converts given `time` to a different calendar.\n\nReturns `{:ok, time}` if the conversion was successful,\nor `{:error, reason}` if it was not, for some reason.","ref":"Time.html#convert/2"},{"type":"function","title":"Examples - Time.convert/2","doc":"Imagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert(~T[13:30:15], Calendar.Holocene)\n    {:ok, %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}","ref":"Time.html#convert/2-examples"},{"type":"function","title":"Time.convert!/2","doc":"Similar to `Time.convert/2`, but raises an `ArgumentError`\nif the conversion between the two calendars is not possible.","ref":"Time.html#convert!/2"},{"type":"function","title":"Examples - Time.convert!/2","doc":"Imagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert!(~T[13:30:15], Calendar.Holocene)\n    %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}","ref":"Time.html#convert!/2-examples"},{"type":"function","title":"Time.diff/3","doc":"Returns the difference between two times, considering only the hour, minute,\nsecond and microsecond.\n\nAs with the `compare/2` function both `Time` structs and other structures\ncontaining time can be used. If for instance a `NaiveDateTime` or `DateTime`\nis passed, only the hour, minute, second, and microsecond is considered. Any\nadditional information about a date or time zone is ignored when calculating\nthe difference.\n\nThe answer can be returned in any `:hour`, `:minute`, `:second` or any\nsubsecond `unit` available from `t:System.time_unit/0`. If the first time\nvalue is earlier than the second, a negative number is returned.\n\nThe unit is measured according to `Calendar.ISO` and defaults to `:second`.\nFractional results are not supported and are truncated.","ref":"Time.html#diff/3"},{"type":"function","title":"Examples - Time.diff/3","doc":"iex> Time.diff(~T[00:29:12], ~T[00:29:10])\n    2\n\n    # When passing a `NaiveDateTime` the date part is ignored.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~T[00:29:10])\n    2\n\n    # Two `NaiveDateTime` structs could have big differences in the date\n    # but only the time part is considered.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~N[1900-02-03 00:29:10])\n    2\n\n    iex> Time.diff(~T[00:29:12], ~T[00:29:10], :microsecond)\n    2_000_000\n    iex> Time.diff(~T[00:29:10], ~T[00:29:12], :microsecond)\n    -2_000_000\n\n    iex> Time.diff(~T[02:29:10], ~T[00:29:10], :hour)\n    2\n    iex> Time.diff(~T[02:29:10], ~T[00:29:11], :hour)\n    1","ref":"Time.html#diff/3-examples"},{"type":"function","title":"Time.from_erl/3","doc":"Converts an Erlang time tuple to a `Time` struct.","ref":"Time.html#from_erl/3"},{"type":"function","title":"Examples - Time.from_erl/3","doc":"iex> Time.from_erl({23, 30, 15}, {5000, 3})\n    {:ok, ~T[23:30:15.005]}\n    iex> Time.from_erl({24, 30, 15})\n    {:error, :invalid_time}","ref":"Time.html#from_erl/3-examples"},{"type":"function","title":"Time.from_erl!/3","doc":"Converts an Erlang time tuple to a `Time` struct.","ref":"Time.html#from_erl!/3"},{"type":"function","title":"Examples - Time.from_erl!/3","doc":"iex> Time.from_erl!({23, 30, 15})\n    ~T[23:30:15]\n    iex> Time.from_erl!({23, 30, 15}, {5000, 3})\n    ~T[23:30:15.005]\n    iex> Time.from_erl!({24, 30, 15})\n    ** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time","ref":"Time.html#from_erl!/3-examples"},{"type":"function","title":"Time.from_iso8601/2","doc":"Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nTime zone offset may be included in the string but they will be\nsimply discarded as such information is not included in times.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.","ref":"Time.html#from_iso8601/2"},{"type":"function","title":"Examples - Time.from_iso8601/2","doc":"iex> Time.from_iso8601(\"23:50:07\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"T23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n\n    iex> Time.from_iso8601(\"23:50:07,0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.123Z\")\n    {:ok, ~T[23:50:07.123]}\n\n    iex> Time.from_iso8601(\"2015:01:23 23-50-07\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07A\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07.\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:61\")\n    {:error, :invalid_time}","ref":"Time.html#from_iso8601/2-examples"},{"type":"function","title":"Time.from_iso8601!/2","doc":"Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.","ref":"Time.html#from_iso8601!/2"},{"type":"function","title":"Examples - Time.from_iso8601!/2","doc":"iex> Time.from_iso8601!(\"23:50:07,123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"23:50:07.123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"2015:01:23 23-50-07\")\n    ** (ArgumentError) cannot parse \"2015:01:23 23-50-07\" as time, reason: :invalid_format","ref":"Time.html#from_iso8601!/2-examples"},{"type":"function","title":"Time.from_seconds_after_midnight/3","doc":"Converts a number of seconds after midnight to a `Time` struct.","ref":"Time.html#from_seconds_after_midnight/3"},{"type":"function","title":"Examples - Time.from_seconds_after_midnight/3","doc":"iex> Time.from_seconds_after_midnight(10_000)\n    ~T[02:46:40]\n    iex> Time.from_seconds_after_midnight(30_000, {5000, 3})\n    ~T[08:20:00.005]\n    iex> Time.from_seconds_after_midnight(-1)\n    ~T[23:59:59]\n    iex> Time.from_seconds_after_midnight(100_000)\n    ~T[03:46:40]","ref":"Time.html#from_seconds_after_midnight/3-examples"},{"type":"function","title":"Time.new/5","doc":"Builds a new time.\n\nExpects all values to be integers. Returns `{:ok, time}` if each\nentry fits its appropriate range, returns `{:error, reason}` otherwise.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.","ref":"Time.html#new/5"},{"type":"function","title":"Examples - Time.new/5","doc":"iex> Time.new(0, 0, 0, 0)\n    {:ok, ~T[00:00:00.000000]}\n    iex> Time.new(23, 59, 59, 999_999)\n    {:ok, ~T[23:59:59.999999]}\n\n    iex> Time.new(24, 59, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 60, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 60, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 59, 1_000_000)\n    {:error, :invalid_time}\n\n    # Invalid precision\n    Time.new(23, 59, 59, {999_999, 10})\n    {:error, :invalid_time}","ref":"Time.html#new/5-examples"},{"type":"function","title":"Time.new!/5","doc":"Builds a new time.\n\nExpects all values to be integers. Returns `time` if each\nentry fits its appropriate range, raises if the time is invalid.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.","ref":"Time.html#new!/5"},{"type":"function","title":"Examples - Time.new!/5","doc":"iex> Time.new!(0, 0, 0, 0)\n    ~T[00:00:00.000000]\n    iex> Time.new!(23, 59, 59, 999_999)\n    ~T[23:59:59.999999]\n    iex> Time.new!(24, 59, 59, 999_999)\n    ** (ArgumentError) cannot build time, reason: :invalid_time","ref":"Time.html#new!/5-examples"},{"type":"function","title":"Time.shift/2","doc":"Shifts given `time` by `duration` according to its calendar.\n\nAvailable duration units are: `:hour`, `:minute`, `:second`, `:microsecond`.\n\nWhen using the default ISO calendar, durations are collapsed to seconds and\nmicroseconds before they are applied.\n\nRaises an `ArgumentError` when called with date scale units.","ref":"Time.html#shift/2"},{"type":"function","title":"Examples - Time.shift/2","doc":"iex> Time.shift(~T[01:00:15], hour: 12)\n    ~T[13:00:15]\n    iex> Time.shift(~T[01:35:00], hour: 6, minute: -15)\n    ~T[07:20:00]\n    iex> Time.shift(~T[01:15:00], second: 125)\n    ~T[01:17:05]\n    iex> Time.shift(~T[01:00:15], microsecond: {100, 6})\n    ~T[01:00:15.000100]\n    iex> Time.shift(~T[01:15:00], Duration.new!(second: 65))\n    ~T[01:16:05]","ref":"Time.html#shift/2-examples"},{"type":"type","title":"Time.t/0","doc":"","ref":"Time.html#t:t/0"},{"type":"function","title":"Time.to_erl/1","doc":"Converts given `time` to an Erlang time tuple.\n\nWARNING: Loss of precision may occur, as Erlang time tuples\nonly contain hours/minutes/seconds.","ref":"Time.html#to_erl/1"},{"type":"function","title":"Examples - Time.to_erl/1","doc":"iex> Time.to_erl(~T[23:30:15.999])\n    {23, 30, 15}\n\n    iex> Time.to_erl(~N[2010-04-17 23:30:15.999])\n    {23, 30, 15}","ref":"Time.html#to_erl/1-examples"},{"type":"function","title":"Time.to_iso8601/2","doc":"Converts the given time to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `Time.to_iso8601/2` returns times formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through\npassing the `:basic` option.","ref":"Time.html#to_iso8601/2"},{"type":"function","title":"Examples - Time.to_iso8601/2","doc":"iex> Time.to_iso8601(~T[23:00:13])\n    \"23:00:13\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001])\n    \"23:00:13.001\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001], :basic)\n    \"230013.001\"\n\n    iex> Time.to_iso8601(~N[2010-04-17 23:00:13])\n    \"23:00:13\"","ref":"Time.html#to_iso8601/2-examples"},{"type":"function","title":"Time.to_seconds_after_midnight/1","doc":"Converts a `Time` struct to a number of seconds after midnight.\n\nThe returned value is a two-element tuple with the number of seconds and microseconds.","ref":"Time.html#to_seconds_after_midnight/1"},{"type":"function","title":"Examples - Time.to_seconds_after_midnight/1","doc":"iex> Time.to_seconds_after_midnight(~T[23:30:15])\n    {84615, 0}\n    iex> Time.to_seconds_after_midnight(~N[2010-04-17 23:30:15.999])\n    {84615, 999000}","ref":"Time.html#to_seconds_after_midnight/1-examples"},{"type":"function","title":"Time.to_string/1","doc":"Converts the given `time` to a string.","ref":"Time.html#to_string/1"},{"type":"function","title":"Examples - Time.to_string/1","doc":"iex> Time.to_string(~T[23:00:00])\n    \"23:00:00\"\n    iex> Time.to_string(~T[23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~T[23:00:00.123456])\n    \"23:00:00.123456\"\n\n    iex> Time.to_string(~N[2015-01-01 23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~N[2015-01-01 23:00:00.123456])\n    \"23:00:00.123456\"","ref":"Time.html#to_string/1-examples"},{"type":"function","title":"Time.truncate/2","doc":"Returns the given time with the microsecond field truncated to the given\nprecision (`:microsecond`, `millisecond` or `:second`).\n\nThe given time is returned unchanged if it already has lower precision than\nthe given precision.","ref":"Time.html#truncate/2"},{"type":"function","title":"Examples - Time.truncate/2","doc":"iex> Time.truncate(~T[01:01:01.123456], :microsecond)\n    ~T[01:01:01.123456]\n\n    iex> Time.truncate(~T[01:01:01.123456], :millisecond)\n    ~T[01:01:01.123]\n\n    iex> Time.truncate(~T[01:01:01.123456], :second)\n    ~T[01:01:01]","ref":"Time.html#truncate/2-examples"},{"type":"function","title":"Time.utc_now/1","doc":"Returns the current time in UTC.","ref":"Time.html#utc_now/1"},{"type":"function","title":"Examples - Time.utc_now/1","doc":"iex> time = Time.utc_now()\n    iex> time.hour >= 0\n    true","ref":"Time.html#utc_now/1-examples"},{"type":"module","title":"Tuple","doc":"Functions for working with tuples.\n\nPlease note the following functions for tuples are found in `Kernel`:\n\n  * `elem/2` - accesses a tuple by index\n  * `put_elem/3` - inserts a value into a tuple by index\n  * `tuple_size/1` - gets the number of elements in a tuple\n\nTuples are intended as fixed-size containers for multiple elements.\nTo manipulate a collection of elements, use a list instead. `Enum`\nfunctions do not work on tuples.\n\nTuples are denoted with curly braces:\n\n    iex> {}\n    {}\n    iex> {1, :two, \"three\"}\n    {1, :two, \"three\"}\n\nA tuple may contain elements of different types, which are stored\ncontiguously in memory. Accessing any element takes constant time,\nbut modifying a tuple, which produces a shallow copy, takes linear time.\nTuples are good for reading data while lists are better for traversals.\n\nTuples are typically used either when a function has multiple return values\nor for error handling. `File.read/1` returns `{:ok, contents}` if reading\nthe given file is successful, or else `{:error, reason}` such as when\nthe file does not exist.\n\nThe functions in this module that add and remove elements from tuples are\nrarely used in practice, as they typically imply tuples are being used as\ncollections. To append to a tuple, it is preferable to extract the elements\nfrom the old tuple with pattern matching, and then create a new tuple:\n\n    tuple = {:ok, :example}\n\n    # Avoid\n    result = Tuple.insert_at(tuple, 2, %{})\n\n    # Prefer\n    {:ok, atom} = tuple\n    result = {:ok, atom, %{}}","ref":"Tuple.html"},{"type":"function","title":"Tuple.append/2","doc":"Inserts an element at the end of a tuple.\n\nReturns a new tuple with the element appended at the end, and contains\nthe elements in `tuple` followed by `value` as the last element.\n\nInlined by the compiler.","ref":"Tuple.html#append/2"},{"type":"function","title":"Examples - Tuple.append/2","doc":"iex> tuple = {:foo, :bar}\n    iex> Tuple.append(tuple, :baz)\n    {:foo, :bar, :baz}","ref":"Tuple.html#append/2-examples"},{"type":"function","title":"Tuple.delete_at/2","doc":"Removes an element from a tuple.\n\nDeletes the element at the given `index` from `tuple`.\nRaises an `ArgumentError` if `index` is negative or greater than\nor equal to the length of `tuple`. Index is zero-based.\n\nInlined by the compiler.","ref":"Tuple.html#delete_at/2"},{"type":"function","title":"Examples - Tuple.delete_at/2","doc":"iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.delete_at(tuple, 0)\n    {:bar, :baz}","ref":"Tuple.html#delete_at/2-examples"},{"type":"function","title":"Tuple.duplicate/2","doc":"Creates a new tuple.\n\nCreates a tuple of `size` containing the\ngiven `data` at every position.\n\nInlined by the compiler.","ref":"Tuple.html#duplicate/2"},{"type":"function","title":"Examples - Tuple.duplicate/2","doc":"iex> Tuple.duplicate(:hello, 3)\n    {:hello, :hello, :hello}","ref":"Tuple.html#duplicate/2-examples"},{"type":"function","title":"Tuple.insert_at/3","doc":"Inserts an element into a tuple.\n\nInserts `value` into `tuple` at the given `index`.\nRaises an `ArgumentError` if `index` is negative or greater than the\nlength of `tuple`. Index is zero-based.\n\nInlined by the compiler.","ref":"Tuple.html#insert_at/3"},{"type":"function","title":"Examples - Tuple.insert_at/3","doc":"iex> tuple = {:bar, :baz}\n    iex> Tuple.insert_at(tuple, 0, :foo)\n    {:foo, :bar, :baz}\n    iex> Tuple.insert_at(tuple, 2, :bong)\n    {:bar, :baz, :bong}","ref":"Tuple.html#insert_at/3-examples"},{"type":"function","title":"Tuple.product/1","doc":"Computes a product of tuple elements.","ref":"Tuple.html#product/1"},{"type":"function","title":"Examples - Tuple.product/1","doc":"iex> Tuple.product({255, 255})\n    65025\n    iex> Tuple.product({255, 1.0})\n    255.0\n    iex> Tuple.product({})\n    1","ref":"Tuple.html#product/1-examples"},{"type":"function","title":"Tuple.sum/1","doc":"Computes a sum of tuple elements.","ref":"Tuple.html#sum/1"},{"type":"function","title":"Examples - Tuple.sum/1","doc":"iex> Tuple.sum({255, 255})\n    510\n    iex> Tuple.sum({255, 0.0})\n    255.0\n    iex> Tuple.sum({})\n    0","ref":"Tuple.html#sum/1-examples"},{"type":"function","title":"Tuple.to_list/1","doc":"Converts a tuple to a list.\n\nReturns a new list with all the tuple elements.\n\nInlined by the compiler.","ref":"Tuple.html#to_list/1"},{"type":"function","title":"Examples - Tuple.to_list/1","doc":"iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.to_list(tuple)\n    [:foo, :bar, :baz]","ref":"Tuple.html#to_list/1-examples"},{"type":"module","title":"URI","doc":"Utilities for working with URIs.\n\nThis module provides functions for working with URIs (for example, parsing\nURIs or encoding query strings). The functions in this module are implemented\naccording to [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nAdditionally, the Erlang [`:uri_string` module](`:uri_string`) provides certain functionalities,\nsuch as RFC 3986 compliant URI normalization.","ref":"URI.html"},{"type":"function","title":"URI.__struct__/0","doc":"The URI struct.\n\nThe fields are defined to match the following URI representation\n(with field names between brackets):\n\n    [scheme]://[userinfo]@[host]:[port][path]?[query]#[fragment]\n\n\nNote the `authority` field is deprecated. `parse/1` will still\npopulate it for backwards compatibility but you should generally\navoid setting or getting it.","ref":"URI.html#__struct__/0"},{"type":"function","title":"URI.append_path/2","doc":"Appends `path` to the given `uri`.\n\nPath must start with `/` and cannot contain additional URL components like\nfragments or query strings. This function further assumes the path is valid and\nit does not contain a query string or fragment parts.","ref":"URI.html#append_path/2"},{"type":"function","title":"Examples - URI.append_path/2","doc":"iex> URI.append_path(URI.parse(\"http://example.com/foo/?x=1\"), \"/my-path\") |> URI.to_string()\n    \"http://example.com/foo/my-path?x=1\"\n\n    iex> URI.append_path(URI.parse(\"http://example.com\"), \"my-path\")\n    ** (ArgumentError) path must start with \"/\", got: \"my-path\"","ref":"URI.html#append_path/2-examples"},{"type":"function","title":"URI.append_query/2","doc":"Appends `query` to the given `uri`.\n\nThe given `query` is not automatically encoded, use `encode/2` or `encode_www_form/1`.","ref":"URI.html#append_query/2"},{"type":"function","title":"Examples - URI.append_query/2","doc":"iex> URI.append_query(URI.parse(\"http://example.com/\"), \"x=1\") |> URI.to_string()\n    \"http://example.com/?x=1\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"y=2\") |> URI.to_string()\n    \"http://example.com/?x=1&y=2\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"x=2\") |> URI.to_string()\n    \"http://example.com/?x=1&x=2\"","ref":"URI.html#append_query/2-examples"},{"type":"opaque","title":"URI.authority/0","doc":"","ref":"URI.html#t:authority/0"},{"type":"function","title":"URI.char_reserved?/1","doc":"Checks if `character` is a reserved one in a URI.\n\nAs specified in [RFC 3986, section 2.2](https://tools.ietf.org/html/rfc3986#section-2.2),\nthe following characters are reserved: `:`, `/`, `?`, `#`, `[`, `]`, `@`, `!`, `$`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `;`, `=`","ref":"URI.html#char_reserved?/1"},{"type":"function","title":"Examples - URI.char_reserved?/1","doc":"iex> URI.char_reserved?(?+)\n    true","ref":"URI.html#char_reserved?/1-examples"},{"type":"function","title":"URI.char_unescaped?/1","doc":"Checks if `character` is allowed unescaped in a URI.\n\nThis is the default used by `URI.encode/2` where both\n[reserved](`char_reserved?/1`) and [unreserved characters](`char_unreserved?/1`)\nare kept unescaped.","ref":"URI.html#char_unescaped?/1"},{"type":"function","title":"Examples - URI.char_unescaped?/1","doc":"iex> URI.char_unescaped?(?{)\n    false","ref":"URI.html#char_unescaped?/1-examples"},{"type":"function","title":"URI.char_unreserved?/1","doc":"Checks if `character` is an unreserved one in a URI.\n\nAs specified in [RFC 3986, section 2.3](https://tools.ietf.org/html/rfc3986#section-2.3),\nthe following characters are unreserved:\n\n  * Alphanumeric characters: `A-Z`, `a-z`, `0-9`\n  * `~`, `_`, `-`, `.`","ref":"URI.html#char_unreserved?/1"},{"type":"function","title":"Examples - URI.char_unreserved?/1","doc":"iex> URI.char_unreserved?(?_)\n    true","ref":"URI.html#char_unreserved?/1-examples"},{"type":"function","title":"URI.decode/1","doc":"Percent-unescapes a URI.","ref":"URI.html#decode/1"},{"type":"function","title":"Examples - URI.decode/1","doc":"iex> URI.decode(\"https%3A%2F%2Felixir-lang.org\")\n    \"https://elixir-lang.org\"","ref":"URI.html#decode/1-examples"},{"type":"function","title":"URI.decode_query/3","doc":"Decodes `query` into a map.\n\nGiven a query string in the form of `key1=value1&key2=value2...`, this\nfunction inserts each key-value pair in the query string as one entry in the\ngiven `map`. Keys and values in the resulting map will be binaries. Keys and\nvalues will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.\n\nUse `query_decoder/1` if you want to iterate over each value manually.","ref":"URI.html#decode_query/3"},{"type":"function","title":"Examples - URI.decode_query/3","doc":"iex> URI.decode_query(\"foo=1&bar=2\")\n    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{\"starting\" => \"map\"})\n    %{\"percent\" => \"oh yes!\", \"starting\" => \"map\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{}, :rfc3986)\n    %{\"percent\" => \"oh+yes!\"}","ref":"URI.html#decode_query/3-examples"},{"type":"function","title":"URI.decode_www_form/1","doc":"Decodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.","ref":"URI.html#decode_www_form/1"},{"type":"function","title":"Examples - URI.decode_www_form/1","doc":"iex> URI.decode_www_form(\"%3Call+in%2F\")\n    \"<all in/\"","ref":"URI.html#decode_www_form/1-examples"},{"type":"function","title":"URI.default_port/1","doc":"Returns the default port for a given `scheme`.\n\nIf the scheme is unknown to the `URI` module, this function returns\n`nil`. The default port for any scheme can be configured globally\nvia `default_port/2`.","ref":"URI.html#default_port/1"},{"type":"function","title":"Examples - URI.default_port/1","doc":"iex> URI.default_port(\"ftp\")\n    21\n\n    iex> URI.default_port(\"ponzi\")\n    nil","ref":"URI.html#default_port/1-examples"},{"type":"function","title":"URI.default_port/2","doc":"Registers the default `port` for the given `scheme`.\n\nAfter this function is called, `port` will be returned by\n`default_port/1` for the given scheme `scheme`. Note that this function\nchanges the default port for the given `scheme` *globally*, meaning for\nevery application.\n\nIt is recommended for this function to be invoked in your\napplication's start callback in case you want to register\nnew URIs.","ref":"URI.html#default_port/2"},{"type":"function","title":"URI.encode/2","doc":"Percent-encodes all characters that require escaping in `string`.\n\nBy default, this function is meant to escape the whole URI, and\ntherefore it will only escape characters which are foreign in\nall parts of a URI. Reserved characters (such as `:` and `/`)\nor unreserved (such as letters and numbers) are not escaped.\n\nBecause different components of a URI require different escaping\nrules, this function also accepts a `predicate` function as an optional\nargument. If passed, this function will be called with each byte\nin `string` as its argument and should return a truthy value (anything other\nthan `false` or `nil`) if the given byte should be left as is, or\nreturn a falsy value (`false` or `nil`) if the character should be\nescaped. Defaults to `URI.char_unescaped?/1`.\n\nSee `encode_www_form/1` if you are interested in escaping reserved\ncharacters too.","ref":"URI.html#encode/2"},{"type":"function","title":"Examples - URI.encode/2","doc":"iex> URI.encode(\"ftp://s-ite.tld/?value=put it+й\")\n    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n\n    iex> URI.encode(\"a string\", &(&1 != ?i))\n    \"a str%69ng\"","ref":"URI.html#encode/2-examples"},{"type":"function","title":"URI.encode_query/2","doc":"Encodes `enumerable` into a query string using `encoding`.\n\nTakes an enumerable that enumerates as a list of two-element\ntuples (for instance, a map or a keyword list) and returns a string\nin the form of `key1=value1&key2=value2...`.\n\nKeys and values can be any term that implements the `String.Chars`\nprotocol with the exception of lists, which are explicitly forbidden.\n\nYou can specify one of the following `encoding` strategies:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are URL encoded as\n    per `encode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It encodes \" \" as \"+\".\n\n  * `:rfc3986` - (since v1.12.0) the same as `:www_form` except it encodes\n    \" \" as \"%20\" according [RFC 3986](https://tools.ietf.org/html/rfc3986).\n    This is the best option if you are encoding in a non-browser situation,\n    since encoding spaces as \"+\" can be ambiguous to URI parsers. This can\n    inadvertently lead to spaces being interpreted as literal plus signs.\n\nEncoding defaults to `:www_form` for backward compatibility.","ref":"URI.html#encode_query/2"},{"type":"function","title":"Examples - URI.encode_query/2","doc":"iex> query = %{\"foo\" => 1, \"bar\" => 2}\n    iex> URI.encode_query(query)\n    \"bar=2&foo=1\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query)\n    \"key=value+with+spaces\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query, :rfc3986)\n    \"key=value%20with%20spaces\"\n\n    iex> URI.encode_query(%{key: [:a, :list]})\n    ** (ArgumentError) encode_query/2 values cannot be lists, got: [:a, :list]","ref":"URI.html#encode_query/2-examples"},{"type":"function","title":"URI.encode_www_form/1","doc":"Encodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.","ref":"URI.html#encode_www_form/1"},{"type":"function","title":"Example - URI.encode_www_form/1","doc":"iex> URI.encode_www_form(\"put: it+й\")\n    \"put%3A+it%2B%D0%B9\"","ref":"URI.html#encode_www_form/1-example"},{"type":"function","title":"URI.merge/2","doc":"Merges two URIs.\n\nThis function merges two URIs as per\n[RFC 3986, section 5.2](https://tools.ietf.org/html/rfc3986#section-5.2).","ref":"URI.html#merge/2"},{"type":"function","title":"Examples - URI.merge/2","doc":"iex> URI.merge(URI.parse(\"http://google.com\"), \"/query\") |> to_string()\n    \"http://google.com/query\"\n\n    iex> URI.merge(\"http://example.com\", \"http://google.com\") |> to_string()\n    \"http://google.com\"","ref":"URI.html#merge/2-examples"},{"type":"function","title":"URI.new/1","doc":"Creates a new URI struct from a URI or a string.\n\nIf a `%URI{}` struct is given, it returns `{:ok, uri}`. If a string is\ngiven, it will parse and validate it. If the string is valid, it returns\n`{:ok, uri}`, otherwise it returns `{:error, part}` with the invalid part\nof the URI. For parsing URIs without further validation, see `parse/1`.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\n`nil` or not.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.","ref":"URI.html#new/1"},{"type":"function","title":"Examples - URI.new/1","doc":"iex> URI.new(\"https://elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//[fe80::]/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"fe80::\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"https:?query\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: nil,\n      port: 443,\n      query: \"query\",\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/invalid_greater_than_in_path/>\")\n    {:error, \">\"}\n\nGiving an existing URI simply returns it wrapped in a tuple:\n\n    iex> {:ok, uri} = URI.new(\"https://elixir-lang.org/\")\n    iex> URI.new(uri)\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}","ref":"URI.html#new/1-examples"},{"type":"function","title":"URI.new!/1","doc":"Similar to `new/1` but raises `URI.Error` if an invalid string is given.","ref":"URI.html#new!/1"},{"type":"function","title":"Examples - URI.new!/1","doc":"iex> URI.new!(\"https://elixir-lang.org/\")\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.new!(\"/invalid_greater_than_in_path/>\")\n    ** (URI.Error) cannot parse due to reason invalid_uri: \">\"\n\nGiving an existing URI simply returns it:\n\n    iex> uri = URI.new!(\"https://elixir-lang.org/\")\n    iex> URI.new!(uri)\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }","ref":"URI.html#new!/1-examples"},{"type":"function","title":"URI.parse/1","doc":"Parses a URI into its components, without further validation.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\nnil or not. Furthermore, this function expects both absolute and\nrelative URIs to be well-formed and does not perform any validation.\nSee the \"Examples\" section below. Use `new/1` if you want to validate\nthe URI fields after parsing.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.\n\nIf a `%URI{}` struct is given to this function, this function returns it\nunmodified.\n\n> #### `:authority` field {: .info}\n>\n> This function sets the field `:authority` for backwards-compatibility reasons\n> but it is deprecated.","ref":"URI.html#parse/1"},{"type":"function","title":"Examples - URI.parse/1","doc":"iex> URI.parse(\"https://elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"//elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"/foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nIn contrast to `URI.new/1`, this function will parse poorly-formed\nURIs, for example:\n\n    iex> URI.parse(\"/invalid_greater_than_in_path/>\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/invalid_greater_than_in_path/>\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nAnother example is a URI with brackets in query strings. It is accepted\nby `parse/1`, it is commonly accepted by browsers, but it will be refused\nby `new/1`:\n\n    iex> URI.parse(\"/?foo[bar]=baz\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/\",\n      port: nil,\n      query: \"foo[bar]=baz\",\n      scheme: nil,\n      userinfo: nil\n    }","ref":"URI.html#parse/1-examples"},{"type":"function","title":"URI.query_decoder/2","doc":"Returns a stream of two-element tuples representing key-value pairs in the\ngiven `query`.\n\nKey and value in each tuple will be binaries and will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.","ref":"URI.html#query_decoder/2"},{"type":"function","title":"Examples - URI.query_decoder/2","doc":"iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.to_list()\n    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\") |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water please\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\", :rfc3986) |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water+please\"}]","ref":"URI.html#query_decoder/2-examples"},{"type":"type","title":"URI.t/0","doc":"","ref":"URI.html#t:t/0"},{"type":"function","title":"URI.to_string/1","doc":"Returns the string representation of the given [URI struct](`t:t/0`).","ref":"URI.html#to_string/1"},{"type":"function","title":"Examples - URI.to_string/1","doc":"iex> uri = URI.parse(\"http://google.com\")\n    iex> URI.to_string(uri)\n    \"http://google.com\"\n\n    iex> uri = URI.parse(\"foo://bar.baz\")\n    iex> URI.to_string(uri)\n    \"foo://bar.baz\"","ref":"URI.html#to_string/1-examples"},{"type":"module","title":"Version","doc":"Functions for parsing and matching versions against requirements.\n\nA version is a string in a specific format or a `Version`\ngenerated after parsing via `Version.parse/1`.\n\nAlthough Elixir projects are not required to follow SemVer,\nthey must follow the format outlined on [SemVer 2.0 schema](https://semver.org/).","ref":"Version.html"},{"type":"module","title":"Versions - Version","doc":"In a nutshell, a version is represented by three numbers:\n\n    MAJOR.MINOR.PATCH\n\nPre-releases are supported by optionally appending a hyphen and a series of\nperiod-separated identifiers immediately following the patch version.\nIdentifiers consist of only ASCII alphanumeric characters and hyphens (`[0-9A-Za-z-]`):\n\n    \"1.0.0-alpha.3\"\n\nBuild information can be added by appending a plus sign and a series of\ndot-separated identifiers immediately following the patch or pre-release version.\nIdentifiers consist of only ASCII alphanumeric characters and hyphens (`[0-9A-Za-z-]`):\n\n    \"1.0.0-alpha.3+20130417140000.amd64\"","ref":"Version.html#module-versions"},{"type":"module","title":"Requirements - Version","doc":"Requirements allow you to specify which versions of a given\ndependency you are willing to work against. Requirements support the common\ncomparison operators such as `>`, `>=`, `<`, `<=`, and `==` that work as one\nwould expect, and additionally the special operator `~>` described in detail\nfurther below.\n\n    # Only version 2.0.0\n    \"== 2.0.0\"\n\n    # Anything later than 2.0.0\n    \"> 2.0.0\"\n\nRequirements also support `and` and `or` for complex conditions:\n\n    # 2.0.0 and later until 2.1.0\n    \">= 2.0.0 and < 2.1.0\"\n\nSince the example above is such a common requirement, it can\nbe expressed as:\n\n    \"~> 2.0.0\"\n\n`~>` will never include pre-release versions of its upper bound,\nregardless of the usage of the `:allow_pre` option, or whether the operand\nis a pre-release version. It can also be used to set an upper bound on only the major\nversion part. See the table below for `~>` requirements and\ntheir corresponding translations.\n\n`~>`           | Translation\n:------------- | :---------------------\n`~> 2.0.0`     | `>= 2.0.0 and < 2.1.0`\n`~> 2.1.2`     | `>= 2.1.2 and < 2.2.0`\n`~> 2.1.3-dev` | `>= 2.1.3-dev and < 2.2.0`\n`~> 2.0`       | `>= 2.0.0 and < 3.0.0`\n`~> 2.1`       | `>= 2.1.0 and < 3.0.0`\n\nThe requirement operand after the `~>` is allowed to omit the patch version,\nallowing us to express `~> 2.1` or `~> 2.1-dev`, something that wouldn't be allowed\nwhen using the common comparison operators.\n\nWhen the `:allow_pre` option is set `false` in `Version.match?/3`, the requirement\nwill not match a pre-release version unless the operand is a pre-release version.\nThe default is to always allow pre-releases but note that in\nHex `:allow_pre` is set to `false`. See the table below for examples.\n\nRequirement    | Version     | `:allow_pre`      | Matches\n:------------- | :---------- | :---------------- | :------\n`~> 2.0`       | `2.1.0`     | `true` or `false` | `true`\n`~> 2.0`       | `3.0.0`     | `true` or `false` | `false`\n`~> 2.0.0`     | `2.0.5`     | `true` or `false` | `true`\n`~> 2.0.0`     | `2.1.0`     | `true` or `false` | `false`\n`~> 2.1.2`     | `2.1.6-dev` | `true`            | `true`\n`~> 2.1.2`     | `2.1.6-dev` | `false`           | `false`\n`~> 2.1-dev`   | `2.2.0-dev` | `true` or `false` | `true`\n`~> 2.1.2-dev` | `2.1.6-dev` | `true` or `false` | `true`\n`>= 2.1.0`     | `2.2.0-dev` | `true`            | `true`\n`>= 2.1.0`     | `2.2.0-dev` | `false`           | `false`\n`>= 2.1.0-dev` | `2.2.6-dev` | `true` or `false` | `true`","ref":"Version.html#module-requirements"},{"type":"function","title":"Version.__struct__/0","doc":"The Version struct.\n\nIt contains the fields `:major`, `:minor`, `:patch`, `:pre`, and\n`:build` according to SemVer 2.0, where `:pre` is a list.\n\nYou can read those fields but you should not create a new `Version`\ndirectly via the struct syntax. Instead use the functions in this\nmodule.","ref":"Version.html#__struct__/0"},{"type":"type","title":"Version.build/0","doc":"","ref":"Version.html#t:build/0"},{"type":"function","title":"Version.compare/2","doc":"Compares two versions.\n\nReturns `:gt` if the first version is greater than the second one, and `:lt`\nfor vice versa. If the two versions are equal, `:eq` is returned.\n\nPre-releases are strictly less than their corresponding release versions.\n\nPatch segments are compared lexicographically if they are alphanumeric, and\nnumerically otherwise.\n\nBuild segments are ignored: if two versions differ only in their build segment\nthey are considered to be equal.\n\nRaises a `Version.InvalidVersionError` exception if any of the two given\nversions are not parsable. If given an already parsed version this function\nwon't raise.","ref":"Version.html#compare/2"},{"type":"function","title":"Examples - Version.compare/2","doc":"iex> Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n    :gt\n\n    iex> Version.compare(\"1.0.0-beta\", \"1.0.0-rc1\")\n    :lt\n\n    iex> Version.compare(\"1.0.0-10\", \"1.0.0-2\")\n    :gt\n\n    iex> Version.compare(\"2.0.1+build0\", \"2.0.1\")\n    :eq\n\n    iex> Version.compare(\"invalid\", \"2.0.1\")\n    ** (Version.InvalidVersionError) invalid version: \"invalid\"","ref":"Version.html#compare/2-examples"},{"type":"function","title":"Version.compile_requirement/1","doc":"Compiles a requirement to an internal representation that may optimize matching.\n\nThe internal representation is opaque.","ref":"Version.html#compile_requirement/1"},{"type":"type","title":"Version.major/0","doc":"","ref":"Version.html#t:major/0"},{"type":"function","title":"Version.match?/3","doc":"Checks if the given version matches the specification.\n\nReturns `true` if `version` satisfies `requirement`, `false` otherwise.\nRaises a `Version.InvalidRequirementError` exception if `requirement` is not\nparsable, or a `Version.InvalidVersionError` exception if `version` is not parsable.\nIf given an already parsed version and requirement this function won't\nraise.","ref":"Version.html#match?/3"},{"type":"function","title":"Options - Version.match?/3","doc":"* `:allow_pre` (boolean) - when `false`, pre-release versions will not match\n    unless the operand is a pre-release version. Defaults to `true`.\n    For examples, please refer to the table above under the \"Requirements\" section.","ref":"Version.html#match?/3-options"},{"type":"function","title":"Examples - Version.match?/3","doc":"iex> Version.match?(\"2.0.0\", \"> 1.0.0\")\n    true\n\n    iex> Version.match?(\"2.0.0\", \"== 1.0.0\")\n    false\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\")\n    true\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\", allow_pre: false)\n    false\n\n    iex> Version.match?(\"foo\", \"== 1.0.0\")\n    ** (Version.InvalidVersionError) invalid version: \"foo\"\n\n    iex> Version.match?(\"2.0.0\", \"== == 1.0.0\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 1.0.0\"","ref":"Version.html#match?/3-examples"},{"type":"type","title":"Version.minor/0","doc":"","ref":"Version.html#t:minor/0"},{"type":"function","title":"Version.parse/1","doc":"Parses a version string into a `Version` struct.","ref":"Version.html#parse/1"},{"type":"function","title":"Examples - Version.parse/1","doc":"iex> Version.parse(\"2.0.1-alpha1\")\n    {:ok, %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}}\n\n    iex> Version.parse(\"2.0-alpha1\")\n    :error","ref":"Version.html#parse/1-examples"},{"type":"function","title":"Version.parse!/1","doc":"Parses a version string into a `Version`.\n\nIf `string` is an invalid version, a `Version.InvalidVersionError` is raised.","ref":"Version.html#parse!/1"},{"type":"function","title":"Examples - Version.parse!/1","doc":"iex> Version.parse!(\"2.0.1-alpha1\")\n    %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}\n\n    iex> Version.parse!(\"2.0-alpha1\")\n    ** (Version.InvalidVersionError) invalid version: \"2.0-alpha1\"","ref":"Version.html#parse!/1-examples"},{"type":"function","title":"Version.parse_requirement/1","doc":"Parses a version requirement string into a `Version.Requirement` struct.","ref":"Version.html#parse_requirement/1"},{"type":"function","title":"Examples - Version.parse_requirement/1","doc":"iex> {:ok, requirement} = Version.parse_requirement(\"== 2.0.1\")\n    iex> requirement\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement(\"== == 2.0.1\")\n    :error","ref":"Version.html#parse_requirement/1-examples"},{"type":"function","title":"Version.parse_requirement!/1","doc":"Parses a version requirement string into a `Version.Requirement` struct.\n\nIf `string` is an invalid requirement, a `Version.InvalidRequirementError` is raised.\n\n# Examples\n\n    iex> Version.parse_requirement!(\"== 2.0.1\")\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement!(\"== == 2.0.1\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 2.0.1\"","ref":"Version.html#parse_requirement!/1"},{"type":"type","title":"Version.patch/0","doc":"","ref":"Version.html#t:patch/0"},{"type":"type","title":"Version.pre/0","doc":"","ref":"Version.html#t:pre/0"},{"type":"type","title":"Version.requirement/0","doc":"","ref":"Version.html#t:requirement/0"},{"type":"type","title":"Version.t/0","doc":"","ref":"Version.html#t:t/0"},{"type":"function","title":"Version.to_string/1","doc":"Converts the given version to a string.","ref":"Version.html#to_string/1"},{"type":"function","title":"Examples - Version.to_string/1","doc":"iex> Version.to_string(%Version{major: 1, minor: 2, patch: 3})\n    \"1.2.3\"\n    iex> Version.to_string(Version.parse!(\"1.14.0-rc.0+build0\"))\n    \"1.14.0-rc.0+build0\"","ref":"Version.html#to_string/1-examples"},{"type":"type","title":"Version.version/0","doc":"","ref":"Version.html#t:version/0"},{"type":"module","title":"Version.Requirement","doc":"A struct that holds version requirement information.\n\nThe struct fields are private and should not be accessed.\n\nSee the \"Requirements\" section in the `Version` module\nfor more information.","ref":"Version.Requirement.html"},{"type":"opaque","title":"Version.Requirement.t/0","doc":"","ref":"Version.Requirement.html#t:t/0"},{"type":"behaviour","title":"Access","doc":"Key-based access to data structures.\n\nThe `Access` module defines a behaviour for dynamically accessing\nkeys of any type in a data structure via the `data[key]` syntax.\n\n`Access` supports keyword lists (`Keyword`) and maps (`Map`) out\nof the box. Keywords supports only atoms keys, keys for maps can\nbe of any type. Both return `nil` if the key does not exist:\n\n    iex> keywords = [a: 1, b: 2]\n    iex> keywords[:a]\n    1\n    iex> keywords[:c]\n    nil\n\n    iex> map = %{a: 1, b: 2}\n    iex> map[:a]\n    1\n\n    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n    iex> star_ratings[1.5]\n    \"★☆\"\n\nThis syntax is very convenient as it can be nested arbitrarily:\n\n    iex> keywords = [a: 1, b: 2]\n    iex> keywords[:c][:unknown]\n    nil\n\nThis works because accessing anything on a `nil` value, returns\n`nil` itself:\n\n    iex> nil[:a]\n    nil","ref":"Access.html"},{"type":"behaviour","title":"Maps and structs - Access","doc":"While the access syntax is allowed in maps via `map[key]`,\nif your map is made of predefined atom keys, you should prefer\nto access those atom keys with `map.key` instead of `map[key]`,\nas `map.key` will raise if the key is missing (which is not\nsupposed to happen if the keys are predefined) or if `map` is\n`nil`.\n\nSimilarly, since structs are maps and structs have predefined\nkeys, they only allow the `struct.key` syntax and they do not\nallow the `struct[key]` access syntax.\n\nIn other words, the `map[key]` syntax is loose, returning `nil`\nfor missing keys, while the `map.key` syntax is strict, raising\nfor both nil values and missing keys.\n\nTo bridge this gap, Elixir provides the `get_in/1` and `get_in/2`\nfunctions, which are capable of traversing nested data structures,\neven in the presence of `nil`s:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users[\"john\"].age)\n    27\n    iex> get_in(users[\"unknown\"].age)\n    nil\n\nNotice how, even if no user was found, `get_in/1` returned `nil`.\nOutside of `get_in/1`, trying to access the field `.age` on `nil`\nwould raise.\n\nThe `get_in/2` function takes one step further by allowing\ndifferent accessors to be mixed in. For example, given a user\nmap with the `:name` and `:languages` keys, here is how to\naccess the name of all programming languages:\n\n      iex> languages = [\n      ...>   %{name: \"elixir\", type: :functional},\n      ...>   %{name: \"c\", type: :procedural}\n      ...> ]\n      iex> user = %{name: \"john\", languages: languages}\n      iex> get_in(user, [:languages, Access.all(), :name])\n      [\"elixir\", \"c\"]\n\nThis module provides convenience functions for traversing other\nstructures, like tuples and lists. As we will see next, they can\neven be used to update nested data structures.\n\nIf you want to learn more about the dual nature of maps in Elixir,\nas they can be either for structured data or as a key-value store,\nsee the `Map` module.","ref":"Access.html#module-maps-and-structs"},{"type":"behaviour","title":"Updating nested data structures - Access","doc":"The access syntax can also be used with the `Kernel.put_in/2`,\n`Kernel.update_in/2`, `Kernel.get_and_update_in/2`, and `Kernel.pop_in/1`\nmacros to further manipulate values in nested data structures:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users[\"john\"].age, 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nAs shown in the previous section, you can also use the\n`Kernel.put_in/3`, `Kernel.update_in/3`, `Kernel.pop_in/2`, and\n`Kernel.get_and_update_in/3` functions to provide nested\ncustom accessors. For instance, given a user map with the\n`:name` and `:languages` keys, here is how to deeply traverse\nthe map and convert all language names to uppercase:\n\n    iex> languages = [\n    ...>   %{name: \"elixir\", type: :functional},\n    ...>   %{name: \"c\", type: :procedural}\n    ...> ]\n    iex> user = %{name: \"john\", languages: languages}\n    iex> update_in(user, [:languages, Access.all(), :name], &String.upcase/1)\n    %{\n      name: \"john\",\n      languages: [\n        %{name: \"ELIXIR\", type: :functional},\n        %{name: \"C\", type: :procedural}\n      ]\n    }\n\nSee the functions `key/1`, `key!/1`, `elem/1`, and `all/0` for\nsome of the available accessors.","ref":"Access.html#module-updating-nested-data-structures"},{"type":"type","title":"Access.access_fun/2","doc":"","ref":"Access.html#t:access_fun/2"},{"type":"function","title":"Access.all/0","doc":"Returns a function that accesses all the elements in a list.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.","ref":"Access.html#all/0"},{"type":"function","title":"Examples - Access.all/0","doc":"iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.all(), :name])\n    [\"john\", \"mary\"]\n    iex> get_and_update_in(list, [Access.all(), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"john\", \"mary\"], [%{name: \"JOHN\"}, %{name: \"MARY\"}]}\n    iex> pop_in(list, [Access.all(), :name])\n    {[\"john\", \"mary\"], [%{}, %{}]}\n\nHere is an example that traverses the list dropping even\nnumbers and multiplying odd numbers by 2:\n\n    iex> require Integer\n    iex> get_and_update_in([1, 2, 3, 4, 5], [Access.all()], fn num ->\n    ...>   if Integer.is_even(num), do: :pop, else: {num, num * 2}\n    ...> end)\n    {[1, 2, 3, 4, 5], [2, 6, 10]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.all()])\n    ** (RuntimeError) Access.all/0 expected a list, got: %{}","ref":"Access.html#all/0-examples"},{"type":"function","title":"Access.at/1","doc":"Returns a function that accesses the element at `index` (zero based) of a list.\n\nKeep in mind that index lookups in lists take linear time: the larger the list,\nthe longer it will take to access its index. Therefore index-based operations\nare generally avoided in favor of other functions in the `Enum` module.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.","ref":"Access.html#at/1"},{"type":"function","title":"Examples - Access.at/1","doc":"iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.at(1), :name])\n    \"mary\"\n    iex> get_in(list, [Access.at(-1), :name])\n    \"mary\"\n    iex> get_and_update_in(list, [Access.at(0), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", [%{name: \"JOHN\"}, %{name: \"mary\"}]}\n    iex> get_and_update_in(list, [Access.at(-1), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"mary\", [%{name: \"john\"}, %{name: \"MARY\"}]}\n\n`at/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> pop_in(list, [Access.at(0)])\n    {%{name: \"john\"}, [%{name: \"mary\"}]}\n    iex> pop_in(list, [Access.at(0), :name])\n    {\"john\", [%{}, %{name: \"mary\"}]}\n\nWhen the index is out of bounds, `nil` is returned and the update function is never called:\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.at(10), :name])\n    nil\n    iex> get_and_update_in(list, [Access.at(10), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {nil, [%{name: \"john\"}, %{name: \"mary\"}]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.at(1)])\n    ** (RuntimeError) Access.at/1 expected a list, got: %{}","ref":"Access.html#at/1-examples"},{"type":"function","title":"Access.at!/1","doc":"Same as `at/1` except that it raises `Enum.OutOfBoundsError`\nif the given index is out of bounds.","ref":"Access.html#at!/1"},{"type":"function","title":"Examples - Access.at!/1","doc":"iex> get_in([:a, :b, :c], [Access.at!(2)])\n    :c\n    iex> get_in([:a, :b, :c], [Access.at!(3)])\n    ** (Enum.OutOfBoundsError) out of bounds error","ref":"Access.html#at!/1-examples"},{"type":"type","title":"Access.container/0","doc":"","ref":"Access.html#t:container/0"},{"type":"function","title":"Access.elem/1","doc":"Returns a function that accesses the element at the given index in a tuple.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nThe returned function raises if `index` is out of bounds.\n\nNote that popping elements out of tuples is not possible and raises an\nerror.","ref":"Access.html#elem/1"},{"type":"function","title":"Examples - Access.elem/1","doc":"iex> map = %{user: {\"john\", 27}}\n    iex> get_in(map, [:user, Access.elem(0)])\n    \"john\"\n    iex> get_and_update_in(map, [:user, Access.elem(0)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: {\"JOHN\", 27}}}\n    iex> pop_in(map, [:user, Access.elem(0)])\n    ** (RuntimeError) cannot pop data from a tuple\n\nAn error is raised if the accessed structure is not a tuple:\n\n    iex> get_in(%{}, [Access.elem(0)])\n    ** (RuntimeError) Access.elem/1 expected a tuple, got: %{}","ref":"Access.html#elem/1-examples"},{"type":"function","title":"Access.fetch/2","doc":"Fetches the value for the given key in a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns `{:ok, value}` where `value` is the value under `key` if there is such\na key, or `:error` if `key` is not found.","ref":"Access.html#fetch/2"},{"type":"function","title":"Examples - Access.fetch/2","doc":"iex> Access.fetch(%{name: \"meg\", age: 26}, :name)\n    {:ok, \"meg\"}\n\n    iex> Access.fetch([ordered: true, on_timeout: :exit], :timeout)\n    :error","ref":"Access.html#fetch/2-examples"},{"type":"callback","title":"Access.fetch/2","doc":"Invoked in order to access the value stored under `key` in the given term `term`.\n\nThis function should return `{:ok, value}` where `value` is the value under\n`key` if the key exists in the term, or `:error` if the key does not exist in\nthe term.\n\nMany of the functions defined in the `Access` module internally call this\nfunction. This function is also used when the square-brackets access syntax\n(`structure[key]`) is used: the `fetch/2` callback implemented by the module\nthat defines the `structure` struct is invoked and if it returns `{:ok,\nvalue}` then `value` is returned, or if it returns `:error` then `nil` is\nreturned.\n\nSee the `Map.fetch/2` and `Keyword.fetch/2` implementations for examples of\nhow to implement this callback.","ref":"Access.html#c:fetch/2"},{"type":"function","title":"Access.fetch!/2","doc":"Same as `fetch/2` but returns the value directly,\nor raises a `KeyError` exception if `key` is not found.","ref":"Access.html#fetch!/2"},{"type":"function","title":"Examples - Access.fetch!/2","doc":"iex> Access.fetch!(%{name: \"meg\", age: 26}, :name)\n    \"meg\"","ref":"Access.html#fetch!/2-examples"},{"type":"function","title":"Access.filter/1","doc":"Returns a function that accesses all elements of a list that match the provided predicate.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.","ref":"Access.html#filter/1"},{"type":"function","title":"Examples - Access.filter/1","doc":"iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> get_in(list, [Access.filter(&(&1.salary > 20)), :name])\n    [\"francine\"]\n    iex> get_and_update_in(list, [Access.filter(&(&1.salary <= 20)), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"john\"], [%{name: \"JOHN\", salary: 10}, %{name: \"francine\", salary: 30}]}\n\n`filter/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> pop_in(list, [Access.filter(&(&1.salary >= 20))])\n    {[%{name: \"francine\", salary: 30}], [%{name: \"john\", salary: 10}]}\n    iex> pop_in(list, [Access.filter(&(&1.salary >= 20)), :name])\n    {[\"francine\"], [%{name: \"john\", salary: 10}, %{salary: 30}]}\n\nWhen no match is found, an empty list is returned and the update function is never called\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> get_in(list, [Access.filter(&(&1.salary >= 50)), :name])\n    []\n    iex> get_and_update_in(list, [Access.filter(&(&1.salary >= 50)), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[], [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]}\n\nAn error is raised if the predicate is not a function or is of the incorrect arity:\n\n    iex> get_in([], [Access.filter(5)])\n    ** (FunctionClauseError) no function clause matching in Access.filter/1\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.filter(fn a -> a == 10 end)])\n    ** (RuntimeError) Access.filter/1 expected a list, got: %{}","ref":"Access.html#filter/1-examples"},{"type":"function","title":"Access.find/1","doc":"Returns a function that accesses the first element of a list that matches the provided predicate.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.","ref":"Access.html#find/1"},{"type":"function","title":"Examples - Access.find/1","doc":"iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> get_in(list, [Access.find(&(&1.salary > 20)), :name])\n    \"francine\"\n    iex>  get_and_update_in(list, [Access.find(&(&1.salary <= 40)), :name], fn prev ->\n    ...> {prev, String.upcase(prev)}\n    ...>  end)\n    {\"john\", [%{name: \"JOHN\", salary: 10}, %{name: \"francine\", salary: 30}]}\n\n`find/1` can also be used to pop the first found element out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> pop_in(list, [Access.find(&(&1.salary <= 40))])\n    {%{name: \"john\", salary: 10}, [%{name: \"francine\", salary: 30}]}\n\nWhen no match is found, nil is returned and the update function is never called\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> get_in(list, [Access.find(&(&1.salary >= 50)), :name])\n    nil\n    iex> get_and_update_in(list, [Access.find(&(&1.salary >= 50)), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {nil, [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]}\n\nAn error is raised if the predicate is not a function or is of the incorrect arity:\n\n    iex> get_in([], [Access.find(5)])\n    ** (FunctionClauseError) no function clause matching in Access.find/1\n\nAn error is raised if the accessed structure is not a list:\n\n    iex>  get_in(%{}, [Access.find(fn a -> a == 10 end)])\n    ** (RuntimeError) Access.find/1 expected a list, got: %{}","ref":"Access.html#find/1-examples"},{"type":"function","title":"Access.get/3","doc":"Gets the value for the given key in a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns the value under `key` if there is such a key, or `default` if `key` is\nnot found.","ref":"Access.html#get/3"},{"type":"function","title":"Examples - Access.get/3","doc":"iex> Access.get(%{name: \"john\"}, :name, \"default name\")\n    \"john\"\n    iex> Access.get(%{name: \"john\"}, :age, 25)\n    25\n\n    iex> Access.get([ordered: true], :timeout)\n    nil","ref":"Access.html#get/3-examples"},{"type":"function","title":"Access.get_and_update/3","doc":"Gets and updates the given key in a `container` (a map, a keyword list,\na struct that implements the `Access` behaviour).\n\nThe `fun` argument receives the value of `key` (or `nil` if `key` is not\npresent in `container`) and must return a two-element tuple `{current_value, new_value}`:\nthe \"get\" value `current_value` (the retrieved value, which can be operated on before\nbeing returned) and the new value to be stored under `key` (`new_value`).\n`fun` may also return `:pop`, which means the current value\nshould be removed from the container and returned.\n\nThe returned value is a two-element tuple with the \"get\" value returned by\n`fun` and a new container with the updated value under `key`.","ref":"Access.html#get_and_update/3"},{"type":"function","title":"Examples - Access.get_and_update/3","doc":"iex> Access.get_and_update([a: 1], :a, fn current_value ->\n    ...>   {current_value, current_value + 1}\n    ...> end)\n    {1, [a: 2]}","ref":"Access.html#get_and_update/3-examples"},{"type":"callback","title":"Access.get_and_update/3","doc":"Invoked in order to access the value under `key` and update it at the same time.\n\nThe implementation of this callback should invoke `fun` with the value under\n`key` in the passed structure `data`, or with `nil` if `key` is not present in it.\nThis function must return either `{current_value, new_value}` or `:pop`.\n\nIf the passed function returns `{current_value, new_value}`,\nthe return value of this callback should be `{current_value, new_data}`, where:\n\n  * `current_value` is the retrieved value (which can be operated on before being returned)\n\n  * `new_value` is the new value to be stored under `key`\n\n  * `new_data` is `data` after updating the value of `key` with `new_value`.\n\nIf the passed function returns `:pop`, the return value of this callback\nmust be `{value, new_data}` where `value` is the value under `key`\n(or `nil` if not present) and `new_data` is `data` without `key`.\n\nSee the implementations of `Map.get_and_update/3` or `Keyword.get_and_update/3`\nfor more examples.","ref":"Access.html#c:get_and_update/3"},{"type":"type","title":"Access.get_and_update_fun/2","doc":"","ref":"Access.html#t:get_and_update_fun/2"},{"type":"type","title":"Access.get_fun/1","doc":"","ref":"Access.html#t:get_fun/1"},{"type":"type","title":"Access.key/0","doc":"","ref":"Access.html#t:key/0"},{"type":"function","title":"Access.key/2","doc":"Returns a function that accesses the given key in a map/struct.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nThe returned function uses the default value if the key does not exist.\nThis can be used to specify defaults and safely traverse missing keys:\n\n    iex> get_in(%{}, [Access.key(:user, %{}), Access.key(:name, \"meg\")])\n    \"meg\"\n\nSuch is also useful when using update functions, allowing us to introduce\nvalues as we traverse the data structure for updates:\n\n    iex> put_in(%{}, [Access.key(:user, %{}), Access.key(:name)], \"Mary\")\n    %{user: %{name: \"Mary\"}}","ref":"Access.html#key/2"},{"type":"function","title":"Examples - Access.key/2","doc":"iex> map = %{user: %{name: \"john\"}}\n    iex> get_in(map, [Access.key(:unknown, %{}), Access.key(:name, \"john\")])\n    \"john\"\n    iex> get_and_update_in(map, [Access.key(:user), Access.key(:name)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: %{name: \"JOHN\"}}}\n    iex> pop_in(map, [Access.key(:user), Access.key(:name)])\n    {\"john\", %{user: %{}}}\n\nAn error is raised if the accessed structure is not a map or a struct:\n\n    iex> get_in([], [Access.key(:foo)])\n    ** (BadMapError) expected a map, got: []","ref":"Access.html#key/2-examples"},{"type":"function","title":"Access.key!/1","doc":"Returns a function that accesses the given key in a map/struct.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nSimilar to `key/2`, but the returned function raises if the key does not exist.","ref":"Access.html#key!/1"},{"type":"function","title":"Examples - Access.key!/1","doc":"iex> map = %{user: %{name: \"john\"}}\n    iex> get_in(map, [Access.key!(:user), Access.key!(:name)])\n    \"john\"\n    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: %{name: \"JOHN\"}}}\n    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n    {\"john\", %{user: %{}}}\n    iex> get_in(map, [Access.key!(:user), Access.key!(:unknown)])\n    ** (KeyError) key :unknown not found in: %{name: \"john\"}\n\nThe examples above could be partially written as:\n\n    iex> map = %{user: %{name: \"john\"}}\n    iex> map.user.name\n    \"john\"\n    iex> get_and_update_in(map.user.name, fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: %{name: \"JOHN\"}}}\n\nHowever, it is not possible to remove fields using the dot notation,\nas it is implied those fields must also be present. In any case,\n`Access.key!/1` is useful when the key is not known in advance\nand must be accessed dynamically.\n\nAn error is raised if the accessed structure is not a map/struct:\n\n    iex> get_in([], [Access.key!(:foo)])\n    ** (RuntimeError) Access.key!/1 expected a map/struct, got: []","ref":"Access.html#key!/1-examples"},{"type":"type","title":"Access.nil_container/0","doc":"","ref":"Access.html#t:nil_container/0"},{"type":"function","title":"Access.pop/2","doc":"Removes the entry with a given key from a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns a tuple containing the value associated with the key and the\nupdated container. `nil` is returned for the value if the key isn't\nin the container.","ref":"Access.html#pop/2"},{"type":"function","title":"Examples - Access.pop/2","doc":"With a map:\n\n    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :name)\n    {\"Elixir\", %{creator: \"Valim\"}}\n\nA keyword list:\n\n    iex> Access.pop([name: \"Elixir\", creator: \"Valim\"], :name)\n    {\"Elixir\", [creator: \"Valim\"]}\n\nAn unknown key:\n\n    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :year)\n    {nil, %{creator: \"Valim\", name: \"Elixir\"}}","ref":"Access.html#pop/2-examples"},{"type":"callback","title":"Access.pop/2","doc":"Invoked to \"pop\" the value under `key` out of the given data structure.\n\nWhen `key` exists in the given structure `data`, the implementation should\nreturn a `{value, new_data}` tuple where `value` is the value that was under\n`key` and `new_data` is `term` without `key`.\n\nWhen `key` is not present in the given structure, a tuple `{value, data}`\nshould be returned, where `value` is implementation-defined.\n\nSee the implementations for `Map.pop/3` or `Keyword.pop/3` for more examples.","ref":"Access.html#c:pop/2"},{"type":"function","title":"Access.slice/1","doc":"Returns a function that accesses all items of a list that are within the provided range.\n\nThe range will be normalized following the same rules from `Enum.slice/2`.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.","ref":"Access.html#slice/1"},{"type":"function","title":"Examples - Access.slice/1","doc":"iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> get_in(list, [Access.slice(1..2), :name])\n    [\"francine\", \"vitor\"]\n    iex> get_and_update_in(list, [Access.slice(1..3//2), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"francine\"], [%{name: \"john\", salary: 10}, %{name: \"FRANCINE\", salary: 30}, %{name: \"vitor\", salary: 25}]}\n\n`slice/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> pop_in(list, [Access.slice(-2..-1)])\n    {[%{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}], [%{name: \"john\", salary: 10}]}\n    iex> pop_in(list, [Access.slice(-2..-1), :name])\n    {[\"francine\", \"vitor\"], [%{name: \"john\", salary: 10}, %{salary: 30}, %{salary: 25}]}\n\nWhen no match is found, an empty list is returned and the update function is never called\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> get_in(list, [Access.slice(5..10//2), :name])\n    []\n    iex> get_and_update_in(list, [Access.slice(5..10//2), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[], [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.slice(2..10//3)])\n    ** (ArgumentError) Access.slice/1 expected a list, got: %{}\n\nAn error is raised if the step of the range is negative:\n\n    iex> get_in([], [Access.slice(2..10//-1)])\n    ** (ArgumentError) Access.slice/1 does not accept ranges with negative steps, got: 2..10//-1","ref":"Access.html#slice/1-examples"},{"type":"type","title":"Access.t/0","doc":"","ref":"Access.html#t:t/0"},{"type":"type","title":"Access.value/0","doc":"","ref":"Access.html#t:value/0"},{"type":"module","title":"Date.Range","doc":"Returns an inclusive range between dates.\n\nRanges must be created with the `Date.range/2` or `Date.range/3` function.\n\nThe following fields are public:\n\n  * `:first` - the initial date on the range\n  * `:last` - the last date on the range\n  * `:step` - (since v1.12.0) the step\n\nThe remaining fields are private and should not be accessed.","ref":"Date.Range.html"},{"type":"type","title":"Date.Range.t/0","doc":"","ref":"Date.Range.html#t:t/0"},{"type":"module","title":"Enum","doc":"Functions for working with collections (known as enumerables).\n\nIn Elixir, an enumerable is any data type that implements the\n`Enumerable` protocol. `List`s (`[1, 2, 3]`), `Map`s (`%{foo: 1, bar: 2}`)\nand `Range`s (`1..3`) are common data types used as enumerables:\n\n    iex> Enum.map([1, 2, 3], fn x -> x * 2 end)\n    [2, 4, 6]\n\n    iex> Enum.sum([1, 2, 3])\n    6\n\n    iex> Enum.map(1..3, fn x -> x * 2 end)\n    [2, 4, 6]\n\n    iex> Enum.sum(1..3)\n    6\n\n    iex> map = %{\"a\" => 1, \"b\" => 2}\n    iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)\n    [{\"a\", 2}, {\"b\", 4}]\n\nMany other enumerables exist in the language, such as `MapSet`s\nand the data type returned by `File.stream!/3` which allows a file to be\ntraversed as if it was an enumerable.\n\nFor a general overview of all functions in the `Enum` module, see\n[the `Enum` cheatsheet](enum-cheat.cheatmd).\n\nThe functions in this module work in linear time. This means that, the\ntime it takes to perform an operation grows at the same rate as the length\nof the enumerable. This is expected on operations such as `Enum.map/2`.\nAfter all, if we want to traverse every element on a list, the longer the\nlist, the more elements we need to traverse, and the longer it will take.\n\nThis linear behavior should also be expected on operations like `count/1`,\n`member?/2`, `at/2` and similar. While Elixir does allow data types to\nprovide performant variants for such operations, you should not expect it\nto always be available, since the `Enum` module is meant to work with a\nlarge variety of data types and not all data types can provide optimized\nbehavior.\n\nFinally, note the functions in the `Enum` module are eager: they will\ntraverse the enumerable as soon as they are invoked. This is particularly\ndangerous when working with infinite enumerables. In such cases, you should\nuse the `Stream` module, which allows you to lazily express computations,\nwithout traversing collections, and work with possibly infinite collections.\nSee the `Stream` module for examples and documentation.","ref":"Enum.html"},{"type":"type","title":"Enum.acc/0","doc":"","ref":"Enum.html#t:acc/0"},{"type":"function","title":"Enum.all?/1","doc":"Returns `true` if all elements in `enumerable` are truthy.\n\nWhen an element has a falsy value (`false` or `nil`) iteration stops immediately\nand `false` is returned. In all other cases `true` is returned.","ref":"Enum.html#all?/1"},{"type":"function","title":"Examples - Enum.all?/1","doc":"iex> Enum.all?([1, 2, 3])\n    true\n\n    iex> Enum.all?([1, nil, 3])\n    false\n\n    iex> Enum.all?([])\n    true","ref":"Enum.html#all?/1-examples"},{"type":"function","title":"Enum.all?/2","doc":"Returns `true` if `fun.(element)` is truthy for all elements in `enumerable`.\n\nIterates over `enumerable` and invokes `fun` on each element. If `fun` ever\nreturns a falsy value (`false` or `nil`), iteration stops immediately and\n`false` is returned. Otherwise, `true` is returned.","ref":"Enum.html#all?/2"},{"type":"function","title":"Examples - Enum.all?/2","doc":"iex> Enum.all?([2, 4, 6], fn x -> rem(x, 2) == 0 end)\n    true\n\n    iex> Enum.all?([2, 3, 4], fn x -> rem(x, 2) == 0 end)\n    false\n\n    iex> Enum.all?([], fn _ -> nil end)\n    true\n\nAs the last example shows, `Enum.all?/2` returns `true` if `enumerable` is\nempty, regardless of `fun`. In an empty enumerable there is no element for\nwhich `fun` returns a falsy value, so the result must be `true`. This is a\nwell-defined logical argument for empty collections.","ref":"Enum.html#all?/2-examples"},{"type":"function","title":"Enum.any?/1","doc":"Returns `true` if at least one element in `enumerable` is truthy.\n\nWhen an element has a truthy value (neither `false` nor `nil`) iteration stops\nimmediately and `true` is returned. In all other cases `false` is returned.","ref":"Enum.html#any?/1"},{"type":"function","title":"Examples - Enum.any?/1","doc":"iex> Enum.any?([false, false, false])\n    false\n\n    iex> Enum.any?([false, true, false])\n    true\n\n    iex> Enum.any?([])\n    false","ref":"Enum.html#any?/1-examples"},{"type":"function","title":"Enum.any?/2","doc":"Returns `true` if `fun.(element)` is truthy for at least one element in `enumerable`.\n\nIterates over the `enumerable` and invokes `fun` on each element. When an invocation\nof `fun` returns a truthy value (neither `false` nor `nil`) iteration stops\nimmediately and `true` is returned. In all other cases `false` is returned.","ref":"Enum.html#any?/2"},{"type":"function","title":"Examples - Enum.any?/2","doc":"iex> Enum.any?([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    false\n\n    iex> Enum.any?([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    true\n\n    iex> Enum.any?([], fn x -> x > 0 end)\n    false","ref":"Enum.html#any?/2-examples"},{"type":"function","title":"Enum.at/3","doc":"Finds the element at the given `index` (zero-based).\n\nReturns `default` if `index` is out of bounds.\n\nA negative `index` can be passed, which means the `enumerable` is\nenumerated once and the `index` is counted from the end (for example,\n`-1` finds the last element).","ref":"Enum.html#at/3"},{"type":"function","title":"Examples - Enum.at/3","doc":"iex> Enum.at([2, 4, 6], 0)\n    2\n\n    iex> Enum.at([2, 4, 6], 2)\n    6\n\n    iex> Enum.at([2, 4, 6], 4)\n    nil\n\n    iex> Enum.at([2, 4, 6], 4, :none)\n    :none","ref":"Enum.html#at/3-examples"},{"type":"function","title":"Enum.chunk_by/2","doc":"Splits enumerable on every element for which `fun` returns a new\nvalue.\n\nReturns a list of lists.","ref":"Enum.html#chunk_by/2"},{"type":"function","title":"Examples - Enum.chunk_by/2","doc":"iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]","ref":"Enum.html#chunk_by/2-examples"},{"type":"function","title":"Enum.chunk_every/2","doc":"Shortcut to `chunk_every(enumerable, count, count)`.","ref":"Enum.html#chunk_every/2"},{"type":"function","title":"Enum.chunk_every/4","doc":"Returns list of lists containing `count` elements each, where\neach new chunk starts `step` elements into the `enumerable`.\n\n`step` is optional and, if not passed, defaults to `count`, i.e.\nchunks do not overlap. Chunking will stop as soon as the collection\nends or when we emit an incomplete chunk.\n\nIf the last chunk does not have `count` elements to fill the chunk,\nelements are taken from `leftover` to fill in the chunk. If `leftover`\ndoes not have enough elements to fill the chunk, then a partial chunk\nis returned with less than `count` elements.\n\nIf `:discard` is given in `leftover`, the last chunk is discarded\nunless it has exactly `count` elements.","ref":"Enum.html#chunk_every/4"},{"type":"function","title":"Examples - Enum.chunk_every/4","doc":"iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)\n    [[1, 2], [3, 4], [5, 6]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard)\n    [[1, 2, 3], [3, 4, 5]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7])\n    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 3, 3, [])\n    [[1, 2, 3], [4]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 10)\n    [[1, 2, 3, 4]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5], 2, 3, [])\n    [[1, 2], [4, 5]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0]))\n    [[1, 2, 3], [4, 0, 0]]","ref":"Enum.html#chunk_every/4-examples"},{"type":"function","title":"Enum.chunk_while/4","doc":"Chunks the `enumerable` with fine grained control when every chunk is emitted.\n\n`chunk_fun` receives the current element and the accumulator and must return:\n\n  * `{:cont, chunk, acc}` to emit a chunk and continue with the accumulator\n  * `{:cont, acc}` to not emit any chunk and continue with the accumulator\n  * `{:halt, acc}` to halt chunking over the `enumerable`.\n\n`after_fun` is invoked with the final accumulator when iteration is\nfinished (or `halt`ed) to handle any trailing elements that were returned\nas part of an accumulator, but were not emitted as a chunk by `chunk_fun`.\nIt must return:\n\n  * `{:cont, chunk, acc}` to emit a chunk. The chunk will be appended to the\n    list of already emitted chunks.\n  * `{:cont, acc}` to not emit a chunk\n\nThe `acc` in `after_fun` is required in order to mirror the tuple format\nfrom `chunk_fun` but it will be discarded since the traversal is complete.\n\nReturns a list of emitted chunks.","ref":"Enum.html#chunk_while/4"},{"type":"function","title":"Examples - Enum.chunk_while/4","doc":"iex> chunk_fun = fn element, acc ->\n    ...>   if rem(element, 2) == 0 do\n    ...>     {:cont, Enum.reverse([element | acc]), []}\n    ...>   else\n    ...>     {:cont, [element | acc]}\n    ...>   end\n    ...> end\n    iex> after_fun = fn\n    ...>   [] -> {:cont, []}\n    ...>   acc -> {:cont, Enum.reverse(acc), []}\n    ...> end\n    iex> Enum.chunk_while(1..10, [], chunk_fun, after_fun)\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n    iex> Enum.chunk_while([1, 2, 3, 5, 7], [], chunk_fun, after_fun)\n    [[1, 2], [3, 5, 7]]","ref":"Enum.html#chunk_while/4-examples"},{"type":"function","title":"Enum.concat/1","doc":"Given an enumerable of enumerables, concatenates the `enumerables` into\na single list.","ref":"Enum.html#concat/1"},{"type":"function","title":"Examples - Enum.concat/1","doc":"iex> Enum.concat([1..3, 4..6, 7..9])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n    [1, [2], 3, 4, 5, 6]","ref":"Enum.html#concat/1-examples"},{"type":"function","title":"Enum.concat/2","doc":"Concatenates the enumerable on the `right` with the enumerable on the\n`left`.\n\nThis function produces the same result as the `++/2` operator\nfor lists.","ref":"Enum.html#concat/2"},{"type":"function","title":"Examples - Enum.concat/2","doc":"iex> Enum.concat(1..3, 4..6)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n    [1, 2, 3, 4, 5, 6]","ref":"Enum.html#concat/2-examples"},{"type":"function","title":"Enum.count/1","doc":"Returns the size of the `enumerable`.","ref":"Enum.html#count/1"},{"type":"function","title":"Examples - Enum.count/1","doc":"iex> Enum.count([1, 2, 3])\n    3","ref":"Enum.html#count/1-examples"},{"type":"function","title":"Enum.count/2","doc":"Returns the count of elements in the `enumerable` for which `fun` returns\na truthy value.","ref":"Enum.html#count/2"},{"type":"function","title":"Examples - Enum.count/2","doc":"iex> Enum.count([1, 2, 3, 4, 5], fn x -> rem(x, 2) == 0 end)\n    2","ref":"Enum.html#count/2-examples"},{"type":"function","title":"Enum.count_until/2","doc":"Counts the enumerable stopping at `limit`.\n\nThis is useful for checking certain properties of the count of an enumerable\nwithout having to actually count the entire enumerable. For example, if you\nwanted to check that the count was exactly, at least, or more than a value.\n\nIf the enumerable implements `c:Enumerable.count/1`, the enumerable is\nnot traversed and we return the lower of the two numbers. To force\nenumeration, use `count_until/3` with `fn _ -> true end` as the second\nargument.","ref":"Enum.html#count_until/2"},{"type":"function","title":"Examples - Enum.count_until/2","doc":"iex> Enum.count_until(1..20, 5)\n    5\n    iex> Enum.count_until(1..20, 50)\n    20\n    iex> Enum.count_until(1..10, 10) == 10 # At least 10\n    true\n    iex> Enum.count_until(1..11, 10 + 1) > 10 # More than 10\n    true\n    iex> Enum.count_until(1..5, 10) < 10 # Less than 10\n    true\n    iex> Enum.count_until(1..10, 10 + 1) == 10 # Exactly ten\n    true","ref":"Enum.html#count_until/2-examples"},{"type":"function","title":"Enum.count_until/3","doc":"Counts the elements in the enumerable for which `fun` returns a truthy value, stopping at `limit`.\n\nSee `count/2` and `count_until/2` for more information.","ref":"Enum.html#count_until/3"},{"type":"function","title":"Examples - Enum.count_until/3","doc":"iex> Enum.count_until(1..20, fn x -> rem(x, 2) == 0 end, 7)\n    7\n    iex> Enum.count_until(1..20, fn x -> rem(x, 2) == 0 end, 11)\n    10","ref":"Enum.html#count_until/3-examples"},{"type":"function","title":"Enum.dedup/1","doc":"Enumerates the `enumerable`, returning a list where all consecutive\nduplicate elements are collapsed to a single element.\n\nElements are compared using `===/2`.\n\nIf you want to remove all duplicate elements, regardless of order,\nsee `uniq/1`.","ref":"Enum.html#dedup/1"},{"type":"function","title":"Examples - Enum.dedup/1","doc":"iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n    [1, 2, 3, 2, 1]\n\n    iex> Enum.dedup([1, 1, 2, 2.0, :three, :three])\n    [1, 2, 2.0, :three]","ref":"Enum.html#dedup/1-examples"},{"type":"function","title":"Enum.dedup_by/2","doc":"Enumerates the `enumerable`, returning a list where all consecutive\nduplicate elements are collapsed to a single element.\n\nThe function `fun` maps every element to a term which is used to\ndetermine if two elements are duplicates.","ref":"Enum.html#dedup_by/2"},{"type":"function","title":"Examples - Enum.dedup_by/2","doc":"iex> Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -> x end)\n    [{1, :a}, {2, :b}, {1, :a}]\n\n    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n    [5, 1, 3, 2]","ref":"Enum.html#dedup_by/2-examples"},{"type":"type","title":"Enum.default/0","doc":"","ref":"Enum.html#t:default/0"},{"type":"function","title":"Enum.drop/2","doc":"Drops the `amount` of elements from the `enumerable`.\n\nIf a negative `amount` is given, the `amount` of last values will be dropped.\nThe `enumerable` will be enumerated once to retrieve the proper index and\nthe remaining calculation is performed from the end.","ref":"Enum.html#drop/2"},{"type":"function","title":"Examples - Enum.drop/2","doc":"iex> Enum.drop([1, 2, 3], 2)\n    [3]\n\n    iex> Enum.drop([1, 2, 3], 10)\n    []\n\n    iex> Enum.drop([1, 2, 3], 0)\n    [1, 2, 3]\n\n    iex> Enum.drop([1, 2, 3], -1)\n    [1, 2]","ref":"Enum.html#drop/2-examples"},{"type":"function","title":"Enum.drop_every/2","doc":"Returns a list of every `nth` element in the `enumerable` dropped,\nstarting with the first element.\n\nThe first element is always dropped, unless `nth` is 0.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.","ref":"Enum.html#drop_every/2"},{"type":"function","title":"Examples - Enum.drop_every/2","doc":"iex> Enum.drop_every(1..10, 2)\n    [2, 4, 6, 8, 10]\n\n    iex> Enum.drop_every(1..10, 0)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    iex> Enum.drop_every([1, 2, 3], 1)\n    []","ref":"Enum.html#drop_every/2-examples"},{"type":"function","title":"Enum.drop_while/2","doc":"Drops elements at the beginning of the `enumerable` while `fun` returns a\ntruthy value.","ref":"Enum.html#drop_while/2"},{"type":"function","title":"Examples - Enum.drop_while/2","doc":"iex> Enum.drop_while([1, 2, 3, 2, 1], fn x -> x < 3 end)\n    [3, 2, 1]","ref":"Enum.html#drop_while/2-examples"},{"type":"function","title":"Enum.each/2","doc":"Invokes the given `fun` for each element in the `enumerable`.\n\nReturns `:ok`.","ref":"Enum.html#each/2"},{"type":"function","title":"Examples - Enum.each/2","doc":"Enum.each([\"some\", \"example\"], fn x -> IO.puts(x) end)\n    \"some\"\n    \"example\"\n    #=> :ok","ref":"Enum.html#each/2-examples"},{"type":"type","title":"Enum.element/0","doc":"","ref":"Enum.html#t:element/0"},{"type":"function","title":"Enum.empty?/1","doc":"Determines if the `enumerable` is empty.\n\nReturns `true` if `enumerable` is empty, otherwise `false`.","ref":"Enum.html#empty?/1"},{"type":"function","title":"Examples - Enum.empty?/1","doc":"iex> Enum.empty?([])\n    true\n\n    iex> Enum.empty?([1, 2, 3])\n    false","ref":"Enum.html#empty?/1-examples"},{"type":"function","title":"Enum.fetch/2","doc":"Finds the element at the given `index` (zero-based).\n\nReturns `{:ok, element}` if found, otherwise `:error`.\n\nA negative `index` can be passed, which means the `enumerable` is\nenumerated once and the `index` is counted from the end (for example,\n`-1` fetches the last element).","ref":"Enum.html#fetch/2"},{"type":"function","title":"Examples - Enum.fetch/2","doc":"iex> Enum.fetch([2, 4, 6], 0)\n    {:ok, 2}\n\n    iex> Enum.fetch([2, 4, 6], -3)\n    {:ok, 2}\n\n    iex> Enum.fetch([2, 4, 6], 2)\n    {:ok, 6}\n\n    iex> Enum.fetch([2, 4, 6], 4)\n    :error","ref":"Enum.html#fetch/2-examples"},{"type":"function","title":"Enum.fetch!/2","doc":"Finds the element at the given `index` (zero-based).\n\nRaises `OutOfBoundsError` if the given `index` is outside the range of\nthe `enumerable`.","ref":"Enum.html#fetch!/2"},{"type":"function","title":"Examples - Enum.fetch!/2","doc":"iex> Enum.fetch!([2, 4, 6], 0)\n    2\n\n    iex> Enum.fetch!([2, 4, 6], 2)\n    6\n\n    iex> Enum.fetch!([2, 4, 6], 4)\n    ** (Enum.OutOfBoundsError) out of bounds error","ref":"Enum.html#fetch!/2-examples"},{"type":"function","title":"Enum.filter/2","doc":"Filters the `enumerable`, i.e. returns only those elements\nfor which `fun` returns a truthy value.\n\nSee also `reject/2` which discards all elements where the\nfunction returns a truthy value.","ref":"Enum.html#filter/2"},{"type":"function","title":"Examples - Enum.filter/2","doc":"iex> Enum.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    [2]\n    iex> Enum.filter([\"apple\", \"pear\", \"banana\"], fn fruit -> String.contains?(fruit, \"a\") end)\n    [\"apple\", \"pear\", \"banana\"]\n    iex> Enum.filter([4, 21, 24, 904], fn seconds -> seconds > 1000 end)\n    []\n\nKeep in mind that `filter` is not capable of filtering and\ntransforming an element at the same time. If you would like\nto do so, consider using `flat_map/2`. For example, if you\nwant to convert all strings that represent an integer and\ndiscard the invalid one in one pass:\n\n    strings = [\"1234\", \"abc\", \"12ab\"]\n\n    Enum.flat_map(strings, fn string ->\n      case Integer.parse(string) do\n        # transform to integer\n        {int, _rest} -> [int]\n        # skip the value\n        :error -> []\n      end\n    end)","ref":"Enum.html#filter/2-examples"},{"type":"function","title":"Enum.find/3","doc":"Returns the first element for which `fun` returns a truthy value.\nIf no such element is found, returns `default`.","ref":"Enum.html#find/3"},{"type":"function","title":"Examples - Enum.find/3","doc":"iex> Enum.find([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    3\n\n    iex> Enum.find([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n    iex> Enum.find([2, 4, 6], 0, fn x -> rem(x, 2) == 1 end)\n    0","ref":"Enum.html#find/3-examples"},{"type":"function","title":"Enum.find_index/2","doc":"Similar to `find/3`, but returns the index (zero-based)\nof the element instead of the element itself.","ref":"Enum.html#find_index/2"},{"type":"function","title":"Examples - Enum.find_index/2","doc":"iex> Enum.find_index([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n\n    iex> Enum.find_index([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    1","ref":"Enum.html#find_index/2-examples"},{"type":"function","title":"Enum.find_value/3","doc":"Similar to `find/3`, but returns the value of the function\ninvocation instead of the element itself.\n\nThe return value is considered to be found when the result is truthy\n(neither `nil` nor `false`).","ref":"Enum.html#find_value/3"},{"type":"function","title":"Examples - Enum.find_value/3","doc":"iex> Enum.find_value([2, 3, 4], fn x ->\n    ...>   if x > 2, do: x * x\n    ...> end)\n    9\n\n    iex> Enum.find_value([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n\n    iex> Enum.find_value([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    true\n\n    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n    \"no bools!\"","ref":"Enum.html#find_value/3-examples"},{"type":"function","title":"Enum.flat_map/2","doc":"Maps the given `fun` over `enumerable` and flattens the result.\n\nThis function returns a new enumerable built by appending the result of invoking `fun`\non each element of `enumerable` together; conceptually, this is similar to a\ncombination of `map/2` and `concat/1`.","ref":"Enum.html#flat_map/2"},{"type":"function","title":"Examples - Enum.flat_map/2","doc":"iex> Enum.flat_map([:a, :b, :c], fn x -> [x, x] end)\n    [:a, :a, :b, :b, :c, :c]\n\n    iex> Enum.flat_map([{1, 3}, {4, 6}], fn {x, y} -> x..y end)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> Enum.flat_map([:a, :b, :c], fn x -> [[x]] end)\n    [[:a], [:b], [:c]]","ref":"Enum.html#flat_map/2-examples"},{"type":"function","title":"Enum.flat_map_reduce/3","doc":"Maps and reduces an `enumerable`, flattening the given results (only one level deep).\n\nIt expects an accumulator and a function that receives each enumerable\nelement, and must return a tuple containing a new enumerable (often a list)\nwith the new accumulator or a tuple with `:halt` as first element and\nthe accumulator as second.","ref":"Enum.html#flat_map_reduce/3"},{"type":"function","title":"Examples - Enum.flat_map_reduce/3","doc":"iex> enumerable = 1..100\n    iex> n = 3\n    iex> Enum.flat_map_reduce(enumerable, 0, fn x, acc ->\n    ...>   if acc   end)\n    {[1, 2, 3], 3}\n\n    iex> Enum.flat_map_reduce(1..5, 0, fn x, acc -> {[[x]], acc + x} end)\n    {[[1], [2], [3], [4], [5]], 15}","ref":"Enum.html#flat_map_reduce/3-examples"},{"type":"function","title":"Enum.frequencies/1","doc":"Returns a map with keys as unique elements of `enumerable` and values\nas the count of every element.","ref":"Enum.html#frequencies/1"},{"type":"function","title":"Examples - Enum.frequencies/1","doc":"iex> Enum.frequencies(~w{ant buffalo ant ant buffalo dingo})\n    %{\"ant\" => 3, \"buffalo\" => 2, \"dingo\" => 1}","ref":"Enum.html#frequencies/1-examples"},{"type":"function","title":"Enum.frequencies_by/2","doc":"Returns a map with keys as unique elements given by `key_fun` and values\nas the count of every element.","ref":"Enum.html#frequencies_by/2"},{"type":"function","title":"Examples - Enum.frequencies_by/2","doc":"iex> Enum.frequencies_by(~w{aa aA bb cc}, &String.downcase/1)\n    %{\"aa\" => 2, \"bb\" => 1, \"cc\" => 1}\n\n    iex> Enum.frequencies_by(~w{aaa aA bbb cc c}, &String.length/1)\n    %{3 => 2, 2 => 2, 1 => 1}","ref":"Enum.html#frequencies_by/2-examples"},{"type":"function","title":"Enum.group_by/3","doc":"Splits the `enumerable` into groups based on `key_fun`.\n\nThe result is a map where each key is given by `key_fun`\nand each value is a list of elements given by `value_fun`.\nThe order of elements within each list is preserved from the `enumerable`.\nHowever, like all maps, the resulting map is unordered.","ref":"Enum.html#group_by/3"},{"type":"function","title":"Examples - Enum.group_by/3","doc":"iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n    %{3 => [\"ant\", \"cat\"], 5 => [\"dingo\"], 7 => [\"buffalo\"]}\n\n    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1, &String.first/1)\n    %{3 => [\"a\", \"c\"], 5 => [\"d\"], 7 => [\"b\"]}\n\nThe key can be any Elixir value. For example, you may use a tuple\nto group by multiple keys:\n\n    iex> collection = [\n    ...>   %{id: 1, lang: \"Elixir\", seq: 1},\n    ...>   %{id: 1, lang: \"Java\", seq: 1},\n    ...>   %{id: 1, lang: \"Ruby\", seq: 2},\n    ...>   %{id: 2, lang: \"Python\", seq: 1},\n    ...>   %{id: 2, lang: \"C#\", seq: 2},\n    ...>   %{id: 2, lang: \"Haskell\", seq: 2},\n    ...> ]\n    iex> Enum.group_by(collection, &{&1.id, &1.seq})\n    %{\n      {1, 1} => [%{id: 1, lang: \"Elixir\", seq: 1}, %{id: 1, lang: \"Java\", seq: 1}],\n      {1, 2} => [%{id: 1, lang: \"Ruby\", seq: 2}],\n      {2, 1} => [%{id: 2, lang: \"Python\", seq: 1}],\n      {2, 2} => [%{id: 2, lang: \"C#\", seq: 2}, %{id: 2, lang: \"Haskell\", seq: 2}]\n    }\n    iex> Enum.group_by(collection, &{&1.id, &1.seq}, &{&1.id, &1.lang})\n    %{\n      {1, 1} => [{1, \"Elixir\"}, {1, \"Java\"}],\n      {1, 2} => [{1, \"Ruby\"}],\n      {2, 1} => [{2, \"Python\"}],\n      {2, 2} => [{2, \"C#\"}, {2, \"Haskell\"}]\n    }","ref":"Enum.html#group_by/3-examples"},{"type":"type","title":"Enum.index/0","doc":"Zero-based index. It can also be a negative integer.","ref":"Enum.html#t:index/0"},{"type":"function","title":"Enum.intersperse/2","doc":"Intersperses `separator` between each element of the enumeration.","ref":"Enum.html#intersperse/2"},{"type":"function","title":"Examples - Enum.intersperse/2","doc":"iex> Enum.intersperse([1, 2, 3], 0)\n    [1, 0, 2, 0, 3]\n\n    iex> Enum.intersperse([1], 0)\n    [1]\n\n    iex> Enum.intersperse([], 0)\n    []","ref":"Enum.html#intersperse/2-examples"},{"type":"function","title":"Enum.into/2","doc":"Inserts the given `enumerable` into a `collectable`.\n\nNote that passing a non-empty list as the `collectable` is deprecated.\nIf you're collecting into a non-empty keyword list, consider using\n`Keyword.merge(collectable, Enum.to_list(enumerable))`. If you're collecting\ninto a non-empty list, consider something like `Enum.to_list(enumerable) ++ collectable`.","ref":"Enum.html#into/2"},{"type":"function","title":"Examples - Enum.into/2","doc":"iex> Enum.into([1, 2], [])\n    [1, 2]\n\n    iex> Enum.into([a: 1, b: 2], %{})\n    %{a: 1, b: 2}\n\n    iex> Enum.into(%{a: 1}, %{b: 2})\n    %{a: 1, b: 2}\n\n    iex> Enum.into([a: 1, a: 2], %{})\n    %{a: 2}\n\n    iex> Enum.into([a: 2], %{a: 1, b: 3})\n    %{a: 2, b: 3}","ref":"Enum.html#into/2-examples"},{"type":"function","title":"Enum.into/3","doc":"Inserts the given `enumerable` into a `collectable` according to the\ntransformation function.","ref":"Enum.html#into/3"},{"type":"function","title":"Examples - Enum.into/3","doc":"iex> Enum.into([1, 2, 3], [], fn x -> x * 3 end)\n    [3, 6, 9]\n\n    iex> Enum.into(%{a: 1, b: 2}, %{c: 3}, fn {k, v} -> {k, v * 2} end)\n    %{a: 2, b: 4, c: 3}","ref":"Enum.html#into/3-examples"},{"type":"function","title":"Enum.join/2","doc":"Joins the given `enumerable` into a string using `joiner` as a\nseparator.\n\nIf `joiner` is not passed at all, it defaults to an empty string.\n\nAll elements in the `enumerable` must be convertible to a string\nor be a binary, otherwise an error is raised.","ref":"Enum.html#join/2"},{"type":"function","title":"Examples - Enum.join/2","doc":"iex> Enum.join([1, 2, 3])\n    \"123\"\n\n    iex> Enum.join([1, 2, 3], \" = \")\n    \"1 = 2 = 3\"\n\n    iex> Enum.join([[\"a\", \"b\"], [\"c\", \"d\", \"e\", [\"f\", \"g\"]], \"h\", \"i\"], \" \")\n    \"ab cdefg h i\"","ref":"Enum.html#join/2-examples"},{"type":"function","title":"Enum.map/2","doc":"Returns a list where each element is the result of invoking\n`fun` on each corresponding element of `enumerable`.\n\nFor maps, the function expects a key-value tuple.","ref":"Enum.html#map/2"},{"type":"function","title":"Examples - Enum.map/2","doc":"iex> Enum.map([1, 2, 3], fn x -> x * 2 end)\n    [2, 4, 6]\n\n    iex> Enum.map([a: 1, b: 2], fn {k, v} -> {k, -v} end)\n    [a: -1, b: -2]","ref":"Enum.html#map/2-examples"},{"type":"function","title":"Enum.map_every/3","doc":"Returns a list of results of invoking `fun` on every `nth`\nelement of `enumerable`, starting with the first element.\n\nThe first element is always passed to the given function, unless `nth` is `0`.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.\n\nIf `nth` is `0`, then `enumerable` is directly converted to a list,\nwithout `fun` being ever applied.","ref":"Enum.html#map_every/3"},{"type":"function","title":"Examples - Enum.map_every/3","doc":"iex> Enum.map_every(1..10, 2, fn x -> x + 1000 end)\n    [1001, 2, 1003, 4, 1005, 6, 1007, 8, 1009, 10]\n\n    iex> Enum.map_every(1..10, 3, fn x -> x + 1000 end)\n    [1001, 2, 3, 1004, 5, 6, 1007, 8, 9, 1010]\n\n    iex> Enum.map_every(1..5, 0, fn x -> x + 1000 end)\n    [1, 2, 3, 4, 5]\n\n    iex> Enum.map_every([1, 2, 3], 1, fn x -> x + 1000 end)\n    [1001, 1002, 1003]","ref":"Enum.html#map_every/3-examples"},{"type":"function","title":"Enum.map_intersperse/3","doc":"Maps and intersperses the given enumerable in one pass.","ref":"Enum.html#map_intersperse/3"},{"type":"function","title":"Examples - Enum.map_intersperse/3","doc":"iex> Enum.map_intersperse([1, 2, 3], :a, &(&1 * 2))\n    [2, :a, 4, :a, 6]","ref":"Enum.html#map_intersperse/3-examples"},{"type":"function","title":"Enum.map_join/3","doc":"Maps and joins the given `enumerable` in one pass.\n\nIf `joiner` is not passed at all, it defaults to an empty string.\n\nAll elements returned from invoking the `mapper` must be convertible to\na string, otherwise an error is raised.","ref":"Enum.html#map_join/3"},{"type":"function","title":"Examples - Enum.map_join/3","doc":"iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n    \"246\"\n\n    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n    \"2 = 4 = 6\"","ref":"Enum.html#map_join/3-examples"},{"type":"function","title":"Enum.map_reduce/3","doc":"Invokes the given function to each element in the `enumerable` to reduce\nit to a single element, while keeping an accumulator.\n\nReturns a tuple where the first element is the mapped enumerable and\nthe second one is the final accumulator.\n\nThe function, `fun`, receives two arguments: the first one is the\nelement, and the second one is the accumulator. `fun` must return\na tuple with two elements in the form of `{result, accumulator}`.\n\nFor maps, the first tuple element must be a `{key, value}` tuple.","ref":"Enum.html#map_reduce/3"},{"type":"function","title":"Examples - Enum.map_reduce/3","doc":"iex> Enum.map_reduce([1, 2, 3], 0, fn x, acc -> {x * 2, x + acc} end)\n    {[2, 4, 6], 6}","ref":"Enum.html#map_reduce/3-examples"},{"type":"function","title":"Enum.max/3","doc":"Returns the maximal element in the `enumerable` according\nto Erlang's term ordering.\n\nBy default, the comparison is done with the `>=` sorter function.\nIf multiple elements are considered maximal, the first one that\nwas found is returned. If you want the last element considered\nmaximal to be returned, the sorter function should not return true\nfor equal elements.\n\nIf the enumerable is empty, the provided `empty_fallback` is called.\nThe default `empty_fallback` raises `Enum.EmptyError`.","ref":"Enum.html#max/3"},{"type":"function","title":"Examples - Enum.max/3","doc":"iex> Enum.max([1, 2, 3])\n    3\n\nThe fact this function uses Erlang's term ordering means that the comparison\nis structural and not semantic. For example:\n\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]])\n    ~D[2017-03-31]\n\nIn the example above, `max/2` returned March 31st instead of April 1st\nbecause the structural comparison compares the day before the year.\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-04-01]\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.max([], &>=/2, fn -> 0 end)\n    0","ref":"Enum.html#max/3-examples"},{"type":"function","title":"Enum.max_by/4","doc":"Returns the maximal element in the `enumerable` as calculated\nby the given `fun`.\n\nBy default, the comparison is done with the `>=` sorter function.\nIf multiple elements are considered maximal, the first one that\nwas found is returned. If you want the last element considered\nmaximal to be returned, the sorter function should not return true\nfor equal elements.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.","ref":"Enum.html#max_by/4"},{"type":"function","title":"Examples - Enum.max_by/4","doc":"iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn x -> String.length(x) end)\n    \"aaa\"\n\n    iex> Enum.max_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String.length/1)\n    \"aaa\"\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.max_by(users, &(&1.birthday), Date)\n    %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.max_by([], &String.length/1, fn -> nil end)\n    nil","ref":"Enum.html#max_by/4-examples"},{"type":"function","title":"Enum.member?/2","doc":"Checks if `element` exists within the `enumerable`.\n\nMembership is tested with the match (`===/2`) operator.","ref":"Enum.html#member?/2"},{"type":"function","title":"Examples - Enum.member?/2","doc":"iex> Enum.member?(1..10, 5)\n    true\n    iex> Enum.member?(1..10, 5.0)\n    false\n\n    iex> Enum.member?([1.0, 2.0, 3.0], 2)\n    false\n    iex> Enum.member?([1.0, 2.0, 3.0], 2.000)\n    true\n\n    iex> Enum.member?([:a, :b, :c], :d)\n    false\n\n\nWhen called outside guards, the [`in`](`in/2`) and [`not in`](`in/2`)\noperators work by using this function.","ref":"Enum.html#member?/2-examples"},{"type":"function","title":"Enum.min/3","doc":"Returns the minimal element in the `enumerable` according\nto Erlang's term ordering.\n\nBy default, the comparison is done with the `<=` sorter function.\nIf multiple elements are considered minimal, the first one that\nwas found is returned. If you want the last element considered\nminimal to be returned, the sorter function should not return true\nfor equal elements.\n\nIf the enumerable is empty, the provided `empty_fallback` is called.\nThe default `empty_fallback` raises `Enum.EmptyError`.","ref":"Enum.html#min/3"},{"type":"function","title":"Examples - Enum.min/3","doc":"iex> Enum.min([1, 2, 3])\n    1\n\nThe fact this function uses Erlang's term ordering means that the comparison\nis structural and not semantic. For example:\n\n    iex> Enum.min([~D[2017-03-31], ~D[2017-04-01]])\n    ~D[2017-04-01]\n\nIn the example above, `min/2` returned April 1st instead of March 31st\nbecause the structural comparison compares the day before the year.\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-03-31]\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min([], fn -> 0 end)\n    0","ref":"Enum.html#min/3-examples"},{"type":"function","title":"Enum.min_by/4","doc":"Returns the minimal element in the `enumerable` as calculated\nby the given `fun`.\n\nBy default, the comparison is done with the `<=` sorter function.\nIf multiple elements are considered minimal, the first one that\nwas found is returned. If you want the last element considered\nminimal to be returned, the sorter function should not return true\nfor equal elements.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.","ref":"Enum.html#min_by/4"},{"type":"function","title":"Examples - Enum.min_by/4","doc":"iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn x -> String.length(x) end)\n    \"a\"\n\n    iex> Enum.min_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String.length/1)\n    \"a\"\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.min_by(users, &(&1.birthday), Date)\n    %{name: \"Lovelace\", birthday: ~D[1815-12-10]}\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min_by([], &String.length/1, fn -> nil end)\n    nil","ref":"Enum.html#min_by/4-examples"},{"type":"function","title":"Enum.min_max/2","doc":"Returns a tuple with the minimal and the maximal elements in the\nenumerable according to Erlang's term ordering.\n\nIf multiple elements are considered maximal or minimal, the first one\nthat was found is returned.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.","ref":"Enum.html#min_max/2"},{"type":"function","title":"Examples - Enum.min_max/2","doc":"iex> Enum.min_max([2, 3, 1])\n    {1, 3}\n\n    iex> Enum.min_max([], fn -> {nil, nil} end)\n    {nil, nil}","ref":"Enum.html#min_max/2-examples"},{"type":"function","title":"Enum.min_max_by/4","doc":"Returns a tuple with the minimal and the maximal elements in the\nenumerable as calculated by the given function.\n\nIf multiple elements are considered maximal or minimal, the first one\nthat was found is returned.","ref":"Enum.html#min_max_by/4"},{"type":"function","title":"Examples - Enum.min_max_by/4","doc":"iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn x -> String.length(x) end)\n    {\"c\", \"aaa\"}\n\n    iex> Enum.min_max_by([\"aaa\", \"a\", \"bb\", \"c\", \"ccc\"], &String.length/1)\n    {\"a\", \"aaa\"}\n\n    iex> Enum.min_max_by([], &String.length/1, fn -> {nil, nil} end)\n    {nil, nil}\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.min_max_by(users, &(&1.birthday), Date)\n    {\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n    }\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min_max_by([], &String.length/1, fn -> nil end)\n    nil","ref":"Enum.html#min_max_by/4-examples"},{"type":"function","title":"Enum.product/1","doc":"Returns the product of all elements.\n\nRaises `ArithmeticError` if `enumerable` contains a non-numeric value.","ref":"Enum.html#product/1"},{"type":"function","title":"Examples - Enum.product/1","doc":"iex> Enum.product([])\n    1\n    iex> Enum.product([2, 3, 4])\n    24\n    iex> Enum.product([2.0, 3.0, 4.0])\n    24.0","ref":"Enum.html#product/1-examples"},{"type":"function","title":"Enum.random/1","doc":"Returns a random element of an `enumerable`.\n\nRaises `Enum.EmptyError` if `enumerable` is empty.\n\nThis function uses Erlang's [`:rand` module](`:rand`) to calculate\nthe random value. Check its documentation for setting a\ndifferent random algorithm or a different seed.\n\nIf a range is passed into the function, this function will pick a\nrandom value between the range limits, without traversing the whole\nrange (thus executing in constant time and constant memory).","ref":"Enum.html#random/1"},{"type":"function","title":"Examples - Enum.random/1","doc":"The examples below use the `:exsss` pseudorandom algorithm since it's\nthe default from Erlang/OTP 22:\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {100, 101, 102})\n    iex> Enum.random([1, 2, 3])\n    2\n    iex> Enum.random([1, 2, 3])\n    1\n    iex> Enum.random(1..1_000)\n    309","ref":"Enum.html#random/1-examples"},{"type":"function","title":"Implementation - Enum.random/1","doc":"The random functions in this module implement reservoir sampling,\nwhich allows them to sample infinite collections. In particular,\nwe implement Algorithm L, as described in by Kim-Hung Li in\n\"Reservoir-Sampling Algorithms of Time Complexity O(n(1+log(N/n)))\".","ref":"Enum.html#random/1-implementation"},{"type":"function","title":"Enum.reduce/2","doc":"Invokes `fun` for each element in the `enumerable` with the\naccumulator.\n\nRaises `Enum.EmptyError` if `enumerable` is empty.\n\nThe first element of the `enumerable` is used as the initial value\nof the accumulator. Then, the function is invoked with the next\nelement and the accumulator. The result returned by the function\nis used as the accumulator for the next iteration, recursively.\nWhen the `enumerable` is done, the last accumulator is returned.\n\nSince the first element of the enumerable is used as the initial\nvalue of the accumulator, `fun` will only be executed `n - 1` times\nwhere `n` is the length of the enumerable. This function won't call\nthe specified function for enumerables that are one-element long.\n\nIf you wish to use another value for the accumulator, use\n`Enum.reduce/3`.","ref":"Enum.html#reduce/2"},{"type":"function","title":"Examples - Enum.reduce/2","doc":"iex> Enum.reduce([1, 2, 3, 4], fn x, acc -> x * acc end)\n    24","ref":"Enum.html#reduce/2-examples"},{"type":"function","title":"Enum.reduce/3","doc":"Invokes `fun` for each element in the `enumerable` with the accumulator.\n\nThe initial value of the accumulator is `acc`. The function is invoked for\neach element in the enumerable with the accumulator. The result returned\nby the function is used as the accumulator for the next iteration.\nThe function returns the last accumulator.","ref":"Enum.html#reduce/3"},{"type":"function","title":"Examples - Enum.reduce/3","doc":"iex> Enum.reduce([1, 2, 3], 0, fn x, acc -> x + acc end)\n    6\n\n    iex> Enum.reduce(%{a: 2, b: 3, c: 4}, 0, fn {_key, val}, acc -> acc + val end)\n    9","ref":"Enum.html#reduce/3-examples"},{"type":"function","title":"Reduce as a building block - Enum.reduce/3","doc":"Reduce (sometimes called `fold`) is a basic building block in functional\nprogramming. Almost all of the functions in the `Enum` module can be\nimplemented on top of reduce. Those functions often rely on other operations,\nsuch as `Enum.reverse/1`, which are optimized by the runtime.\n\nFor example, we could implement `map/2` in terms of `reduce/3` as follows:\n\n    def my_map(enumerable, fun) do\n      enumerable\n      |> Enum.reduce([], fn x, acc -> [fun.(x) | acc] end)\n      |> Enum.reverse()\n    end\n\nIn the example above, `Enum.reduce/3` accumulates the result of each call\nto `fun` into a list in reverse order, which is correctly ordered at the\nend by calling `Enum.reverse/1`.\n\nImplementing functions like `map/2`, `filter/2` and others are a good\nexercise for understanding the power behind `Enum.reduce/3`. When an\noperation cannot be expressed by any of the functions in the `Enum`\nmodule, developers will most likely resort to `reduce/3`.","ref":"Enum.html#reduce/3-reduce-as-a-building-block"},{"type":"function","title":"Enum.reduce_while/3","doc":"Reduces `enumerable` until `fun` returns `{:halt, term}`.\n\nThe return value for `fun` is expected to be\n\n  * `{:cont, acc}` to continue the reduction with `acc` as the new\n    accumulator or\n  * `{:halt, acc}` to halt the reduction\n\nIf `fun` returns `{:halt, acc}` the reduction is halted and the function\nreturns `acc`. Otherwise, if the enumerable is exhausted, the function returns\nthe accumulator of the last `{:cont, acc}`.","ref":"Enum.html#reduce_while/3"},{"type":"function","title":"Examples - Enum.reduce_while/3","doc":"iex> Enum.reduce_while(1..100, 0, fn x, acc ->\n    ...>   if x < 5 do\n    ...>     {:cont, acc + x}\n    ...>   else\n    ...>     {:halt, acc}\n    ...>   end\n    ...> end)\n    10\n    iex> Enum.reduce_while(1..100, 0, fn x, acc ->\n    ...>   if x > 0 do\n    ...>     {:cont, acc + x}\n    ...>   else\n    ...>     {:halt, acc}\n    ...>   end\n    ...> end)\n    5050","ref":"Enum.html#reduce_while/3-examples"},{"type":"function","title":"Enum.reject/2","doc":"Returns a list of elements in `enumerable` excluding those for which the function `fun` returns\na truthy value.\n\nSee also `filter/2`.","ref":"Enum.html#reject/2"},{"type":"function","title":"Examples - Enum.reject/2","doc":"iex> Enum.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    [1, 3]","ref":"Enum.html#reject/2-examples"},{"type":"function","title":"Enum.reverse/1","doc":"Returns a list of elements in `enumerable` in reverse order.","ref":"Enum.html#reverse/1"},{"type":"function","title":"Examples - Enum.reverse/1","doc":"iex> Enum.reverse([1, 2, 3])\n    [3, 2, 1]","ref":"Enum.html#reverse/1-examples"},{"type":"function","title":"Enum.reverse/2","doc":"Reverses the elements in `enumerable`, appends the `tail`, and returns\nit as a list.\n\nThis is an optimization for\n`enumerable |> Enum.reverse() |> Enum.concat(tail)`.","ref":"Enum.html#reverse/2"},{"type":"function","title":"Examples - Enum.reverse/2","doc":"iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n    [3, 2, 1, 4, 5, 6]","ref":"Enum.html#reverse/2-examples"},{"type":"function","title":"Enum.reverse_slice/3","doc":"Reverses the `enumerable` in the range from initial `start_index`\nthrough `count` elements.\n\nIf `count` is greater than the size of the rest of the `enumerable`,\nthen this function will reverse the rest of the enumerable.","ref":"Enum.html#reverse_slice/3"},{"type":"function","title":"Examples - Enum.reverse_slice/3","doc":"iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n    [1, 2, 6, 5, 4, 3]","ref":"Enum.html#reverse_slice/3-examples"},{"type":"function","title":"Enum.scan/2","doc":"Applies the given function to each element in the `enumerable`,\nstoring the result in a list and passing it as the accumulator\nfor the next computation. Uses the first element in the `enumerable`\nas the starting value.","ref":"Enum.html#scan/2"},{"type":"function","title":"Examples - Enum.scan/2","doc":"iex> Enum.scan(1..5, &(&1 + &2))\n    [1, 3, 6, 10, 15]","ref":"Enum.html#scan/2-examples"},{"type":"function","title":"Enum.scan/3","doc":"Applies the given function to each element in the `enumerable`,\nstoring the result in a list and passing it as the accumulator\nfor the next computation. Uses the given `acc` as the starting value.","ref":"Enum.html#scan/3"},{"type":"function","title":"Examples - Enum.scan/3","doc":"iex> Enum.scan(1..5, 0, &(&1 + &2))\n    [1, 3, 6, 10, 15]","ref":"Enum.html#scan/3-examples"},{"type":"function","title":"Enum.shuffle/1","doc":"Returns a list with the elements of `enumerable` shuffled.\n\nThis function uses Erlang's [`:rand` module](`:rand`) to calculate\nthe random value. Check its documentation for setting a\ndifferent random algorithm or a different seed.","ref":"Enum.html#shuffle/1"},{"type":"function","title":"Examples - Enum.shuffle/1","doc":"The examples below use the `:exsss` pseudorandom algorithm since it's\nthe default from Erlang/OTP 22:\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {11, 22, 33})\n    iex> Enum.shuffle([1, 2, 3])\n    [2, 1, 3]\n    iex> Enum.shuffle([1, 2, 3])\n    [2, 3, 1]","ref":"Enum.html#shuffle/1-examples"},{"type":"function","title":"Enum.slice/2","doc":"Returns a subset list of the given `enumerable` by `index_range`.\n\n`index_range` must be a `Range`. Given an `enumerable`, it drops\nelements before `index_range.first` (zero-base), then it takes elements\nuntil element `index_range.last` (inclusively).\n\nIndexes are normalized, meaning that negative indexes will be counted\nfrom the end (for example, `-1` means the last element of the `enumerable`).\n\nIf `index_range.last` is out of bounds, then it is assigned as the index\nof the last element.\n\nIf the normalized `index_range.first` is out of bounds of the given\n`enumerable`, or this one is greater than the normalized `index_range.last`,\nthen `[]` is returned.\n\nIf a step `n` (other than `1`) is used in `index_range`, then it takes\nevery `n`th element from `index_range.first` to `index_range.last`\n(according to the same rules described above).","ref":"Enum.html#slice/2"},{"type":"function","title":"Examples - Enum.slice/2","doc":"iex> Enum.slice([1, 2, 3, 4, 5], 1..3)\n    [2, 3, 4]\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 3..10)\n    [4, 5]\n\n    # Last three elements (negative indexes)\n    iex> Enum.slice([1, 2, 3, 4, 5], -3..-1)\n    [3, 4, 5]\n\nFor ranges where `start > stop`, you need to explicit\nmark them as increasing:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 1..-2//1)\n    [2, 3, 4]\n\nThe step can be any positive number. For example, to\nget every 2 elements of the collection:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 0..-1//2)\n    [1, 3, 5]\n\nTo get every third element of the first ten elements:\n\n    iex> integers = Enum.to_list(1..20)\n    iex> Enum.slice(integers, 0..9//3)\n    [1, 4, 7, 10]\n\nIf the first position is after the end of the enumerable\nor after the last position of the range, it returns an\nempty list:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 6..10)\n    []\n\n    # first is greater than last\n    iex> Enum.slice([1, 2, 3, 4, 5], 6..5//1)\n    []","ref":"Enum.html#slice/2-examples"},{"type":"function","title":"Enum.slice/3","doc":"Returns a subset list of the given `enumerable`, from `start_index` (zero-based)\nwith `amount` number of elements if available.\n\nGiven an `enumerable`, it drops elements right before element `start_index`;\nthen, it takes `amount` of elements, returning as many elements as possible if\nthere are not enough elements.\n\nA negative `start_index` can be passed, which means the `enumerable` is\nenumerated once and the index is counted from the end (for example,\n`-1` starts slicing from the last element).\n\nIt returns `[]` if `amount` is `0` or if `start_index` is out of bounds.","ref":"Enum.html#slice/3"},{"type":"function","title":"Examples - Enum.slice/3","doc":"iex> Enum.slice(1..100, 5, 10)\n    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\n    # amount to take is greater than the number of elements\n    iex> Enum.slice(1..10, 5, 100)\n    [6, 7, 8, 9, 10]\n\n    iex> Enum.slice(1..10, 5, 0)\n    []\n\n    # using a negative start index\n    iex> Enum.slice(1..10, -6, 3)\n    [5, 6, 7]\n    iex> Enum.slice(1..10, -11, 5)\n    [1, 2, 3, 4, 5]\n\n    # out of bound start index\n    iex> Enum.slice(1..10, 10, 5)\n    []","ref":"Enum.html#slice/3-examples"},{"type":"function","title":"Enum.slide/3","doc":"Slides a single or multiple elements given by `range_or_single_index` from `enumerable`\nto `insertion_index`.\n\nThe semantics of the range to be moved match the semantics of `Enum.slice/2`.\nSpecifically, that means:\n\n * Indices are normalized, meaning that negative indexes will be counted from the end\n    (for example, -1 means the last element of the enumerable). This will result in *two*\n    traversals of your enumerable on types like lists that don't provide a constant-time count.\n\n  * If the normalized index range's `last` is out of bounds, the range is truncated to the last element.\n\n  * If the normalized index range's `first` is out of bounds, the selected range for sliding\n    will be empty, so you'll get back your input list.\n\n  * Decreasing ranges (such as `5..0//1`) also select an empty range to be moved,\n    so you'll get back your input list.\n\n  * Ranges with any step but 1 will raise an error.","ref":"Enum.html#slide/3"},{"type":"function","title":"Examples - Enum.slide/3","doc":"# Slide a single element\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 5, 1)\n    [:a, :f, :b, :c, :d, :e, :g]\n\n    # Slide a range of elements backward\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..5, 1)\n    [:a, :d, :e, :f, :b, :c, :g]\n\n    # Slide a range of elements forward\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 1..3, 5)\n    [:a, :e, :f, :b, :c, :d, :g]\n\n    # Slide with negative indices (counting from the end)\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..-1//1, 2)\n    [:a, :b, :d, :e, :f, :g, :c]\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], -4..-2, 1)\n    [:a, :d, :e, :f, :b, :c, :g]\n\n    # Insert at negative indices (counting from the end)\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3, -1)\n    [:a, :b, :c, :e, :f, :g, :d]","ref":"Enum.html#slide/3-examples"},{"type":"function","title":"Enum.sort/1","doc":"Sorts the `enumerable` according to Erlang's term ordering.\n\nThis function uses the merge sort algorithm. Do not use this\nfunction to sort structs, see `sort/2` for more information.","ref":"Enum.html#sort/1"},{"type":"function","title":"Examples - Enum.sort/1","doc":"iex> Enum.sort([3, 2, 1])\n    [1, 2, 3]","ref":"Enum.html#sort/1-examples"},{"type":"function","title":"Enum.sort/2","doc":"Sorts the `enumerable` by the given function.\n\nThis function uses the merge sort algorithm. The given function should compare\ntwo arguments, and return `true` if the first argument precedes or is in the\nsame place as the second one.","ref":"Enum.html#sort/2"},{"type":"function","title":"Examples - Enum.sort/2","doc":"iex> Enum.sort([1, 2, 3], &(&1 >= &2))\n    [3, 2, 1]\n\nThe sorting algorithm will be stable as long as the given function\nreturns `true` for values considered equal:\n\n    iex> Enum.sort([\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) <= byte_size(&2)))\n    [\"of\", \"some\", \"kind\", \"monster\"]\n\nIf the function does not return `true` for equal values, the sorting\nis not stable and the order of equal terms may be shuffled.\nFor example:\n\n    iex> Enum.sort([\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) < byte_size(&2)))\n    [\"of\", \"kind\", \"some\", \"monster\"]","ref":"Enum.html#sort/2-examples"},{"type":"function","title":"Ascending and descending (since v1.10.0) - Enum.sort/2","doc":"`sort/2` allows a developer to pass `:asc` or `:desc` as the sorter, which is a convenience for\n[`&<=/2`](`<=/2`) and [`&>=/2`](`>=/2`) respectively.\n\n    iex> Enum.sort([2, 3, 1], :asc)\n    [1, 2, 3]\n    iex> Enum.sort([2, 3, 1], :desc)\n    [3, 2, 1]","ref":"Enum.html#sort/2-ascending-and-descending-since-v1-10-0"},{"type":"function","title":"Sorting structs - Enum.sort/2","doc":"Do not use `</2`, `<=/2`, `>/2`, `>=/2` and friends when sorting structs.\nThat's because the built-in operators above perform structural comparison\nand not a semantic one. Imagine we sort the following list of dates:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates)\n    [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n\nNote that the returned result is incorrect, because `sort/1` by default uses\n`<=/2`, which will compare their structure. When comparing structures, the\nfields are compared in alphabetical order, which means the dates above will\nbe compared by `day`, `month` and then `year`, which is the opposite of what\nwe want.\n\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, Date)\n    [~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]\n\nTo retrieve all dates in descending order, you can wrap the module in\na tuple with `:asc` or `:desc` as first element:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, {:asc, Date})\n    [~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, {:desc, Date})\n    [~D[2020-03-02], ~D[2019-06-06], ~D[2019-01-01]]","ref":"Enum.html#sort/2-sorting-structs"},{"type":"function","title":"Enum.sort_by/3","doc":"Sorts the mapped results of the `enumerable` according to the provided `sorter`\nfunction.\n\nThis function maps each element of the `enumerable` using the\nprovided `mapper` function. The enumerable is then sorted by\nthe mapped elements using the `sorter`, which defaults to `:asc`\nand sorts the elements ascendingly.\n\n`sort_by/3` differs from `sort/2` in that it only calculates the\ncomparison value for each element in the enumerable once instead of\nonce for each element in each comparison. If the same function is\nbeing called on both elements, it's more efficient to use `sort_by/3`.","ref":"Enum.html#sort_by/3"},{"type":"function","title":"Ascending and descending (since v1.10.0) - Enum.sort_by/3","doc":"`sort_by/3` allows a developer to pass `:asc` or `:desc` as the sorter,\nwhich is a convenience for [`&<=/2`](`<=/2`) and [`&>=/2`](`>=/2`) respectively:\n    iex> Enum.sort_by([2, 3, 1], &(&1), :asc)\n    [1, 2, 3]\n\n    iex> Enum.sort_by([2, 3, 1], &(&1), :desc)\n    [3, 2, 1]","ref":"Enum.html#sort_by/3-ascending-and-descending-since-v1-10-0"},{"type":"function","title":"Examples - Enum.sort_by/3","doc":"Using the default `sorter` of `:asc` :\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1)\n    [\"of\", \"some\", \"kind\", \"monster\"]\n\nSorting by multiple properties - first by size, then by first letter\n(this takes advantage of the fact that tuples are compared element-by-element):\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &{byte_size(&1), String.first(&1)})\n    [\"of\", \"kind\", \"some\", \"monster\"]\n\nSimilar to `sort/2`, you can pass a custom sorter:\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1, :desc)\n    [\"monster\", \"some\", \"kind\", \"of\"]\n\nAs in `sort/2`, avoid using the default sorting function to sort\nstructs, as by default it performs structural comparison instead of\na semantic one. In such cases, you shall pass a sorting function as\nthird element or any module that implements a `compare/2` function.\nFor example, to sort users by their birthday in both ascending and\ndescending order respectively:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.sort_by(users, &(&1.birthday), Date)\n    [\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n      %{name: \"Turing\", birthday: ~D[1912-06-23]},\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n    ]\n    iex> Enum.sort_by(users, &(&1.birthday), {:desc, Date})\n    [\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n      %{name: \"Turing\", birthday: ~D[1912-06-23]},\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]}\n    ]","ref":"Enum.html#sort_by/3-examples"},{"type":"function","title":"Performance characteristics - Enum.sort_by/3","doc":"As detailed in the initial section, `sort_by/3` calculates the comparison\nvalue for each element in the enumerable once instead of once for each\nelement in each comparison. This implies `sort_by/3` must do an initial\npass on the data to compute those values.\n\nHowever, if those values are cheap to compute, for example, you have\nalready extracted the field you want to sort by into a tuple, then those\nextra passes become overhead. In such cases, consider using `List.keysort/3`\ninstead.\n\nLet's see an example. Imagine you have a list of products and you have a\nlist of IDs. You want to keep all products that are in the given IDs and\nreturn their names sorted by their price. You could write it like this:\n\n    for(\n      product <- products,\n      product.id in ids,\n      do: product\n    )\n    |> Enum.sort_by(& &1.price)\n    |> Enum.map(& &1.name)\n\nHowever, you could also write it like this:\n\n    for(\n      product <- products,\n      product.id in ids,\n      do: {product.name, product.price}\n    )\n    |> List.keysort(1)\n    |> Enum.map(&elem(&1, 0))\n\nUsing `List.keysort/3` will be a better choice for performance sensitive\ncode as it avoids additional traversals.","ref":"Enum.html#sort_by/3-performance-characteristics"},{"type":"function","title":"Enum.split/2","doc":"Splits the `enumerable` into two enumerables, leaving `count`\nelements in the first one.\n\nIf `count` is a negative number, it starts counting from the\nback to the beginning of the `enumerable`.\n\nBe aware that a negative `count` implies the `enumerable`\nwill be enumerated twice: once to calculate the position, and\na second time to do the actual splitting.","ref":"Enum.html#split/2"},{"type":"function","title":"Examples - Enum.split/2","doc":"iex> Enum.split([1, 2, 3], 2)\n    {[1, 2], [3]}\n\n    iex> Enum.split([1, 2, 3], 10)\n    {[1, 2, 3], []}\n\n    iex> Enum.split([1, 2, 3], 0)\n    {[], [1, 2, 3]}\n\n    iex> Enum.split([1, 2, 3], -1)\n    {[1, 2], [3]}\n\n    iex> Enum.split([1, 2, 3], -5)\n    {[], [1, 2, 3]}","ref":"Enum.html#split/2-examples"},{"type":"function","title":"Enum.split_while/2","doc":"Splits enumerable in two at the position of the element for which\n`fun` returns a falsy value (`false` or `nil`) for the first time.\n\nIt returns a two-element tuple with two lists of elements.\nThe element that triggered the split is part of the second list.","ref":"Enum.html#split_while/2"},{"type":"function","title":"Examples - Enum.split_while/2","doc":"iex> Enum.split_while([1, 2, 3, 4], fn x -> x < 3 end)\n    {[1, 2], [3, 4]}\n\n    iex> Enum.split_while([1, 2, 3, 4], fn x -> x < 0 end)\n    {[], [1, 2, 3, 4]}\n\n    iex> Enum.split_while([1, 2, 3, 4], fn x -> x > 0 end)\n    {[1, 2, 3, 4], []}","ref":"Enum.html#split_while/2-examples"},{"type":"function","title":"Enum.split_with/2","doc":"Splits the `enumerable` in two lists according to the given function `fun`.\n\nSplits the given `enumerable` in two lists by calling `fun` with each element\nin the `enumerable` as its only argument. Returns a tuple with the first list\ncontaining all the elements in `enumerable` for which applying `fun` returned\na truthy value, and a second list with all the elements for which applying\n`fun` returned a falsy value (`false` or `nil`).\n\nThe elements in both the returned lists are in the same relative order as they\nwere in the original enumerable (if such enumerable was ordered, like a\nlist). See the examples below.","ref":"Enum.html#split_with/2"},{"type":"function","title":"Examples - Enum.split_with/2","doc":"iex> Enum.split_with([5, 4, 3, 2, 1, 0], fn x -> rem(x, 2) == 0 end)\n    {[4, 2, 0], [5, 3, 1]}\n\n    iex> Enum.split_with([a: 1, b: -2, c: 1, d: -3], fn {_k, v} -> v < 0 end)\n    {[b: -2, d: -3], [a: 1, c: 1]}\n\n    iex> Enum.split_with([a: 1, b: -2, c: 1, d: -3], fn {_k, v} -> v > 50 end)\n    {[], [a: 1, b: -2, c: 1, d: -3]}\n\n    iex> Enum.split_with([], fn {_k, v} -> v > 50 end)\n    {[], []}","ref":"Enum.html#split_with/2-examples"},{"type":"function","title":"Enum.sum/1","doc":"Returns the sum of all elements.\n\nRaises `ArithmeticError` if `enumerable` contains a non-numeric value.","ref":"Enum.html#sum/1"},{"type":"function","title":"Examples - Enum.sum/1","doc":"iex> Enum.sum([1, 2, 3])\n    6\n\n    iex> Enum.sum(1..10)\n    55\n\n    iex> Enum.sum(1..10//2)\n    25","ref":"Enum.html#sum/1-examples"},{"type":"type","title":"Enum.t/0","doc":"","ref":"Enum.html#t:t/0"},{"type":"function","title":"Enum.take/2","doc":"Takes an `amount` of elements from the beginning or the end of the `enumerable`.\n\nIf a positive `amount` is given, it takes the `amount` elements from the\nbeginning of the `enumerable`.\n\nIf a negative `amount` is given, the `amount` of elements will be taken from the end.\nThe `enumerable` will be enumerated once to retrieve the proper index and\nthe remaining calculation is performed from the end.\n\nIf amount is `0`, it returns `[]`.","ref":"Enum.html#take/2"},{"type":"function","title":"Examples - Enum.take/2","doc":"iex> Enum.take([1, 2, 3], 2)\n    [1, 2]\n\n    iex> Enum.take([1, 2, 3], 10)\n    [1, 2, 3]\n\n    iex> Enum.take([1, 2, 3], 0)\n    []\n\n    iex> Enum.take([1, 2, 3], -1)\n    [3]","ref":"Enum.html#take/2-examples"},{"type":"function","title":"Enum.take_every/2","doc":"Returns a list of every `nth` element in the `enumerable`,\nstarting with the first element.\n\nThe first element is always included, unless `nth` is 0.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.","ref":"Enum.html#take_every/2"},{"type":"function","title":"Examples - Enum.take_every/2","doc":"iex> Enum.take_every(1..10, 2)\n    [1, 3, 5, 7, 9]\n\n    iex> Enum.take_every(1..10, 0)\n    []\n\n    iex> Enum.take_every([1, 2, 3], 1)\n    [1, 2, 3]","ref":"Enum.html#take_every/2-examples"},{"type":"function","title":"Enum.take_random/2","doc":"Takes `count` random elements from `enumerable`.\n\nNote that this function will traverse the whole `enumerable` to\nget the random sublist.\n\nSee `random/1` for notes on implementation and random seed.","ref":"Enum.html#take_random/2"},{"type":"function","title":"Examples - Enum.take_random/2","doc":"# Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Enum.take_random(1..10, 2)\n    [6, 1]\n    iex> Enum.take_random(?a..?z, 5)\n    ~c\"bkzmt\"","ref":"Enum.html#take_random/2-examples"},{"type":"function","title":"Enum.take_while/2","doc":"Takes the elements from the beginning of the `enumerable` while `fun` returns\na truthy value.","ref":"Enum.html#take_while/2"},{"type":"function","title":"Examples - Enum.take_while/2","doc":"iex> Enum.take_while([1, 2, 3], fn x -> x < 3 end)\n    [1, 2]","ref":"Enum.html#take_while/2-examples"},{"type":"function","title":"Enum.to_list/1","doc":"Converts `enumerable` to a list.","ref":"Enum.html#to_list/1"},{"type":"function","title":"Examples - Enum.to_list/1","doc":"iex> Enum.to_list(1..3)\n    [1, 2, 3]","ref":"Enum.html#to_list/1-examples"},{"type":"function","title":"Enum.uniq/1","doc":"Enumerates the `enumerable`, removing all duplicate elements.","ref":"Enum.html#uniq/1"},{"type":"function","title":"Examples - Enum.uniq/1","doc":"iex> Enum.uniq([1, 2, 3, 3, 2, 1])\n    [1, 2, 3]","ref":"Enum.html#uniq/1-examples"},{"type":"function","title":"Enum.uniq_by/2","doc":"Enumerates the `enumerable`, by removing the elements for which\nfunction `fun` returned duplicate elements.\n\nThe function `fun` maps every element to a term. Two elements are\nconsidered duplicates if the return value of `fun` is equal for\nboth of them.\n\nThe first occurrence of each element is kept.","ref":"Enum.html#uniq_by/2"},{"type":"function","title":"Example - Enum.uniq_by/2","doc":"iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n    [{1, :x}, {2, :y}]\n\n    iex> Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end)\n    [a: {:tea, 2}, c: {:coffee, 1}]","ref":"Enum.html#uniq_by/2-example"},{"type":"function","title":"Enum.unzip/1","doc":"Opposite of `zip/2`. Extracts two-element tuples from the\ngiven `enumerable` and groups them together.\n\nIt takes an `enumerable` with elements being two-element tuples and returns\na tuple with two lists, each of which is formed by the first and\nsecond element of each tuple, respectively.\n\nThis function fails unless `enumerable` is or can be converted into a\nlist of tuples with *exactly* two elements in each tuple.","ref":"Enum.html#unzip/1"},{"type":"function","title":"Examples - Enum.unzip/1","doc":"iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n    {[:a, :b, :c], [1, 2, 3]}","ref":"Enum.html#unzip/1-examples"},{"type":"function","title":"Enum.with_index/2","doc":"Returns the `enumerable` with each element wrapped in a tuple\nalongside its index or according to a given function.\n\nMay receive a function or an integer offset.\n\nIf an `offset` is given, it will index from the given offset instead of from\nzero.\n\nIf a `function` is given, it will index by invoking the function for each\nelement and index (zero-based) of the enumerable.","ref":"Enum.html#with_index/2"},{"type":"function","title":"Examples - Enum.with_index/2","doc":"iex> Enum.with_index([:a, :b, :c])\n    [a: 0, b: 1, c: 2]\n\n    iex> Enum.with_index([:a, :b, :c], 3)\n    [a: 3, b: 4, c: 5]\n\n    iex> Enum.with_index([:a, :b, :c], fn element, index -> {index, element} end)\n    [{0, :a}, {1, :b}, {2, :c}]","ref":"Enum.html#with_index/2-examples"},{"type":"function","title":"Enum.zip/1","doc":"Zips corresponding elements from a finite collection of enumerables\ninto a list of tuples.\n\nThe zipping finishes as soon as any enumerable in the given collection completes.","ref":"Enum.html#zip/1"},{"type":"function","title":"Examples - Enum.zip/1","doc":"iex> Enum.zip([[1, 2, 3], [:a, :b, :c], [\"foo\", \"bar\", \"baz\"]])\n    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]\n\n    iex> Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])\n    [{1, :a}, {2, :b}, {3, :c}]","ref":"Enum.html#zip/1-examples"},{"type":"function","title":"Enum.zip/2","doc":"Zips corresponding elements from two enumerables into a list\nof tuples.\n\nBecause a list of two-element tuples with atoms as the first\ntuple element is a keyword list (`Keyword`), zipping a first list\nof atoms with a second list of any kind creates a keyword list.\n\nThe zipping finishes as soon as either enumerable completes.","ref":"Enum.html#zip/2"},{"type":"function","title":"Examples - Enum.zip/2","doc":"iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n    [{1, :a}, {2, :b}, {3, :c}]\n\n    iex> Enum.zip([:a, :b, :c], [1, 2, 3])\n    [a: 1, b: 2, c: 3]\n\n    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n    [{1, :a}, {2, :b}, {3, :c}]","ref":"Enum.html#zip/2-examples"},{"type":"function","title":"Enum.zip_reduce/3","doc":"Reduces over all of the given enumerables, halting as soon as any enumerable is\nempty.\n\nThe reducer will receive 2 args: a list of elements (one from each enum) and the\naccumulator.\n\nIn practice, the behavior provided by this function can be achieved with:\n\n    Enum.reduce(Stream.zip(enums), acc, reducer)\n\nBut `zip_reduce/3` exists for convenience purposes.","ref":"Enum.html#zip_reduce/3"},{"type":"function","title":"Examples - Enum.zip_reduce/3","doc":"iex> enums = [[1, 1], [2, 2], [3, 3]]\n    ...>  Enum.zip_reduce(enums, [], fn elements, acc ->\n    ...>    [List.to_tuple(elements) | acc]\n    ...> end)\n    [{1, 2, 3}, {1, 2, 3}]\n\n    iex> enums = [[1, 2], [a: 3, b: 4], [5, 6]]\n    ...> Enum.zip_reduce(enums, [], fn elements, acc ->\n    ...>   [List.to_tuple(elements) | acc]\n    ...> end)\n    [{2, {:b, 4}, 6}, {1, {:a, 3}, 5}]","ref":"Enum.html#zip_reduce/3-examples"},{"type":"function","title":"Enum.zip_reduce/4","doc":"Reduces over two enumerables halting as soon as either enumerable is empty.\n\nIn practice, the behavior provided by this function can be achieved with:\n\n    Enum.reduce(Stream.zip(left, right), acc, reducer)\n\nBut `zip_reduce/4` exists for convenience purposes.","ref":"Enum.html#zip_reduce/4"},{"type":"function","title":"Examples - Enum.zip_reduce/4","doc":"iex> Enum.zip_reduce([1, 2], [3, 4], 0, fn x, y, acc -> x + y + acc end)\n    10\n\n    iex> Enum.zip_reduce([1, 2], [3, 4], [], fn x, y, acc -> [x + y | acc] end)\n    [6, 4]","ref":"Enum.html#zip_reduce/4-examples"},{"type":"function","title":"Enum.zip_with/2","doc":"Zips corresponding elements from a finite collection of enumerables\ninto list, transforming them with the `zip_fun` function as it goes.\n\nThe first element from each of the enums in `enumerables` will be put\ninto a list which is then passed to the one-arity `zip_fun` function.\nThen, the second elements from each of the enums are put into a list\nand passed to `zip_fun`, and so on until any one of the enums in\n`enumerables` runs out of elements.\n\nReturns a list with all the results of calling `zip_fun`.","ref":"Enum.html#zip_with/2"},{"type":"function","title":"Examples - Enum.zip_with/2","doc":"iex> Enum.zip_with([[1, 2], [3, 4], [5, 6]], fn [x, y, z] -> x + y + z end)\n    [9, 12]\n\n    iex> Enum.zip_with([[1, 2], [3, 4]], fn [x, y] -> x + y end)\n    [4, 6]","ref":"Enum.html#zip_with/2-examples"},{"type":"function","title":"Enum.zip_with/3","doc":"Zips corresponding elements from two enumerables into a list, transforming them with\nthe `zip_fun` function as it goes.\n\nThe corresponding elements from each collection are passed to the provided two-arity `zip_fun`\nfunction in turn. Returns a list that contains the result of calling `zip_fun` for each pair of\nelements.\n\nThe zipping finishes as soon as either enumerable runs out of elements.","ref":"Enum.html#zip_with/3"},{"type":"function","title":"Zipping Maps - Enum.zip_with/3","doc":"It's important to remember that zipping inherently relies on order.\nIf you zip two lists you get the element at the index from each list in turn.\nIf we zip two maps together it's tempting to think that you will get the given\nkey in the left map and the matching key in the right map, but there is no such\nguarantee because map keys are not ordered! Consider the following:\n\n    left =  %{:a => 1, 1 => 3}\n    right = %{:a => 1, :b => :c}\n    Enum.zip(left, right)\n    # [{{1, 3}, {:a, 1}}, {{:a, 1}, {:b, :c}}]\n\nAs you can see `:a` does not get paired with `:a`. If this is what you want,\nyou should use `Map.merge/3`.","ref":"Enum.html#zip_with/3-zipping-maps"},{"type":"function","title":"Examples - Enum.zip_with/3","doc":"iex> Enum.zip_with([1, 2], [3, 4], fn x, y -> x + y end)\n    [4, 6]\n\n    iex> Enum.zip_with([1, 2], [3, 4, 5, 6], fn x, y -> x + y end)\n    [4, 6]\n\n    iex> Enum.zip_with([1, 2, 5, 6], [3, 4], fn x, y -> x + y end)\n    [4, 6]","ref":"Enum.html#zip_with/3-examples"},{"type":"module","title":"Keyword","doc":"A keyword list is a list that consists exclusively of two-element tuples.\n\nThe first element of these tuples is known as the *key*, and it must be an atom.\nThe second element, known as the *value*, can be any term.\n\nKeywords are mostly used to work with optional values. For a general introduction\nto keywords and how the compare with maps, see our [Keyword and Maps](keywords-and-maps.md)\nguide.","ref":"Keyword.html"},{"type":"module","title":"Examples - Keyword","doc":"For example, the following is a keyword list:\n\n    [{:exit_on_close, true}, {:active, :once}, {:packet_size, 1024}]\n\nElixir provides a special and more concise syntax for keyword lists:\n\n    [exit_on_close: true, active: :once, packet_size: 1024]\n\nThe two syntaxes return the exact same value.\n\nA *key* can be any atom, consisting of Unicode letters, numbers,\nan underscore or the `@` sign. If the *key* should have any other\ncharacters, such as spaces, you can wrap it in quotes:\n\n    iex> [\"exit on close\": true]\n    [\"exit on close\": true]\n\nWrapping an atom in quotes does not make it a string. Keyword list\n*keys* are always atoms. Quotes should only be used when necessary\nor Elixir will issue a warning.","ref":"Keyword.html#module-examples"},{"type":"module","title":"Duplicate keys and ordering - Keyword","doc":"A keyword may have duplicate keys so it is not strictly a key-value\ndata type. However, most of the functions in this module work on a\nkey-value structure and behave similar to the functions you would\nfind in the `Map` module. For example, `Keyword.get/3` will get the first\nentry matching the given key, regardless if duplicate entries exist.\nSimilarly, `Keyword.put/3` and `Keyword.delete/2` ensure all duplicate\nentries for a given key are removed when invoked. Note, however, that\nkeyword list operations need to traverse the whole list in order to find\nkeys, so these operations are slower than their map counterparts.\n\nA handful of functions exist to handle duplicate keys, for example,\n`get_values/2` returns all values for a given key and `delete_first/2`\ndeletes just the first entry of the existing ones.\n\nEven though lists preserve the existing order, the functions in\n`Keyword` do not guarantee any ordering. For example, if you invoke\n`Keyword.put(opts, new_key, new_value)`, there is no guarantee for\nwhere `new_key` will be added to (the front, the end or anywhere else).\n\nGiven ordering is not guaranteed, it is not recommended to pattern\nmatch on keyword lists either. For example, a function such as:\n\n    def my_function([some_key: value, another_key: another_value])\n\nwill match\n\n    my_function([some_key: :foo, another_key: :bar])\n\nbut it won't match\n\n    my_function([another_key: :bar, some_key: :foo])\n\nMost of the functions in this module work in linear time. This means\nthat the time it takes to perform an operation grows at the same\nrate as the length of the list.","ref":"Keyword.html#module-duplicate-keys-and-ordering"},{"type":"module","title":"Call syntax - Keyword","doc":"When keyword lists are passed as the last argument to a function,\nthe square brackets around the keyword list can be omitted. For\nexample, the keyword list syntax:\n\n    String.split(\"1-0\", \"-\", [trim: true, parts: 2])\n\ncan be written without the enclosing brackets whenever it is the last\nargument of a function call:\n\n    String.split(\"1-0\", \"-\", trim: true, parts: 2)\n\nSince tuples, lists and maps are treated similarly to function\narguments in Elixir syntax, this property is also available to them:\n\n    iex> {1, 2, foo: :bar}\n    {1, 2, [{:foo, :bar}]}\n\n    iex> [1, 2, foo: :bar]\n    [1, 2, {:foo, :bar}]\n\n    iex> %{1 => 2, foo: :bar}\n    %{1 => 2, :foo => :bar}","ref":"Keyword.html#module-call-syntax"},{"type":"type","title":"Keyword.default/0","doc":"","ref":"Keyword.html#t:default/0"},{"type":"function","title":"Keyword.delete/2","doc":"Deletes the entries in the keyword list under a specific `key`.\n\nIf the `key` does not exist, it returns the keyword list unchanged.\nUse `delete_first/2` to delete just the first entry in case of\nduplicate keys.","ref":"Keyword.html#delete/2"},{"type":"function","title":"Examples - Keyword.delete/2","doc":"iex> Keyword.delete([a: 1, b: 2], :a)\n    [b: 2]\n    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n    [b: 2]\n    iex> Keyword.delete([b: 2], :a)\n    [b: 2]","ref":"Keyword.html#delete/2-examples"},{"type":"function","title":"Keyword.delete_first/2","doc":"Deletes the first entry in the keyword list under a specific `key`.\n\nIf the `key` does not exist, it returns the keyword list unchanged.","ref":"Keyword.html#delete_first/2"},{"type":"function","title":"Examples - Keyword.delete_first/2","doc":"iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n    [b: 2, a: 3]\n    iex> Keyword.delete_first([b: 2], :a)\n    [b: 2]","ref":"Keyword.html#delete_first/2-examples"},{"type":"function","title":"Keyword.drop/2","doc":"Drops the given `keys` from the keyword list.\n\nRemoves duplicate keys from the new keyword list.","ref":"Keyword.html#drop/2"},{"type":"function","title":"Examples - Keyword.drop/2","doc":"iex> Keyword.drop([a: 1, a: 2], [:a])\n    []\n    iex> Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])\n    [a: 1, c: 3]\n    iex> Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])\n    [a: 1, c: 3, a: 5]","ref":"Keyword.html#drop/2-examples"},{"type":"function","title":"Keyword.equal?/2","doc":"Checks if two keywords are equal.\n\nConsiders two keywords to be equal if they contain\nthe same keys and those keys contain the same values.","ref":"Keyword.html#equal?/2"},{"type":"function","title":"Examples - Keyword.equal?/2","doc":"iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n    true\n    iex> Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])\n    false\n    iex> Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])\n    true\n\nComparison between values is done with `===/3`,\nwhich means integers are not equivalent to floats:\n\n    iex> Keyword.equal?([a: 1.0], [a: 1])\n    false","ref":"Keyword.html#equal?/2-examples"},{"type":"function","title":"Keyword.fetch/2","doc":"Fetches the value for a specific `key` and returns it in a tuple.\n\nIf the `key` does not exist, it returns `:error`.","ref":"Keyword.html#fetch/2"},{"type":"function","title":"Examples - Keyword.fetch/2","doc":"iex> Keyword.fetch([a: 1], :a)\n    {:ok, 1}\n    iex> Keyword.fetch([a: 1], :b)\n    :error","ref":"Keyword.html#fetch/2-examples"},{"type":"function","title":"Keyword.fetch!/2","doc":"Fetches the value for specific `key`.\n\nIf the `key` does not exist, it raises a `KeyError`.","ref":"Keyword.html#fetch!/2"},{"type":"function","title":"Examples - Keyword.fetch!/2","doc":"iex> Keyword.fetch!([a: 1], :a)\n    1\n    iex> Keyword.fetch!([a: 1], :b)\n    ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#fetch!/2-examples"},{"type":"function","title":"Keyword.filter/2","doc":"Returns a keyword list containing only the entries from `keywords`\nfor which the function `fun` returns a truthy value.\n\nSee also `reject/2` which discards all entries where the function\nreturns a truthy value.","ref":"Keyword.html#filter/2"},{"type":"function","title":"Examples - Keyword.filter/2","doc":"iex> Keyword.filter([one: 1, two: 2, three: 3], fn {_key, val} -> rem(val, 2) == 1 end)\n    [one: 1, three: 3]","ref":"Keyword.html#filter/2-examples"},{"type":"function","title":"Keyword.from_keys/2","doc":"Builds a keyword from the given `keys` and the fixed `value`.","ref":"Keyword.html#from_keys/2"},{"type":"function","title":"Examples - Keyword.from_keys/2","doc":"iex> Keyword.from_keys([:foo, :bar, :baz], :atom)\n    [foo: :atom, bar: :atom, baz: :atom]\n    iex> Keyword.from_keys([], :atom)\n    []","ref":"Keyword.html#from_keys/2-examples"},{"type":"function","title":"Keyword.get/3","doc":"Gets the value under the given `key`.\n\nReturns the default value if `key` does not exist\n(`nil` if no default value is provided).\n\nIf duplicate entries exist, it returns the first one.\nUse `get_values/2` to retrieve all entries.","ref":"Keyword.html#get/3"},{"type":"function","title":"Examples - Keyword.get/3","doc":"iex> Keyword.get([], :a)\n    nil\n    iex> Keyword.get([a: 1], :a)\n    1\n    iex> Keyword.get([a: 1], :b)\n    nil\n    iex> Keyword.get([a: 1], :b, 3)\n    3\n\nWith duplicate keys:\n\n    iex> Keyword.get([a: 1, a: 2], :a, 3)\n    1\n    iex> Keyword.get([a: 1, a: 2], :b, 3)\n    3","ref":"Keyword.html#get/3-examples"},{"type":"function","title":"Keyword.get_and_update/3","doc":"Gets the value from `key` and updates it, all in one pass.\n\nThe `fun` argument receives the value of `key` (or `nil` if `key`\nis not present) and must return a two-element tuple: the current value\n(the retrieved value, which can be operated on before being returned)\nand the new value to be stored under `key`. The `fun` may also\nreturn `:pop`, implying the current value shall be removed from the\nkeyword list and returned.\n\nReturns a tuple that contains the current value returned by\n`fun` and a new keyword list with the updated value under `key`.","ref":"Keyword.html#get_and_update/3"},{"type":"function","title":"Examples - Keyword.get_and_update/3","doc":"iex> Keyword.get_and_update([a: 1], :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, [a: \"new value!\"]}\n\n    iex> Keyword.get_and_update([a: 1], :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {nil, [b: \"new value!\", a: 1]}\n\n    iex> Keyword.get_and_update([a: 2], :a, fn number ->\n    ...>   {2 * number, 3 * number}\n    ...> end)\n    {4, [a: 6]}\n\n    iex> Keyword.get_and_update([a: 1], :a, fn _ -> :pop end)\n    {1, []}\n\n    iex> Keyword.get_and_update([a: 1], :b, fn _ -> :pop end)\n    {nil, [a: 1]}","ref":"Keyword.html#get_and_update/3-examples"},{"type":"function","title":"Keyword.get_and_update!/3","doc":"Gets the value under `key` and updates it. Raises if there is no `key`.\n\nThe `fun` argument receives the value under `key` and must return a\ntwo-element tuple: the current value (the retrieved value, which can be\noperated on before being returned) and the new value to be stored under\n`key`.\n\nReturns a tuple that contains the current value returned by\n`fun` and a new keyword list with the updated value under `key`.","ref":"Keyword.html#get_and_update!/3"},{"type":"function","title":"Examples - Keyword.get_and_update!/3","doc":"iex> Keyword.get_and_update!([a: 1], :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, [a: \"new value!\"]}\n\n    iex> Keyword.get_and_update!([a: 1], :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    ** (KeyError) key :b not found in: [a: 1]\n\n    iex> Keyword.get_and_update!([a: 1], :a, fn _ ->\n    ...>   :pop\n    ...> end)\n    {1, []}","ref":"Keyword.html#get_and_update!/3-examples"},{"type":"function","title":"Keyword.get_lazy/3","doc":"Gets the value under the given `key`.\n\nIf `key` does not exist, lazily evaluates `fun` and returns its result.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\nIf duplicate entries exist, it returns the first one.\nUse `get_values/2` to retrieve all entries.","ref":"Keyword.html#get_lazy/3"},{"type":"function","title":"Examples - Keyword.get_lazy/3","doc":"iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.get_lazy(keyword, :a, fun)\n    1\n    iex> Keyword.get_lazy(keyword, :b, fun)\n    13","ref":"Keyword.html#get_lazy/3-examples"},{"type":"function","title":"Keyword.get_values/2","doc":"Gets all values under a specific `key`.","ref":"Keyword.html#get_values/2"},{"type":"function","title":"Examples - Keyword.get_values/2","doc":"iex> Keyword.get_values([], :a)\n    []\n    iex> Keyword.get_values([a: 1], :a)\n    [1]\n    iex> Keyword.get_values([a: 1, a: 2], :a)\n    [1, 2]","ref":"Keyword.html#get_values/2-examples"},{"type":"function","title":"Keyword.has_key?/2","doc":"Returns whether a given `key` exists in the given `keywords`.","ref":"Keyword.html#has_key?/2"},{"type":"function","title":"Examples - Keyword.has_key?/2","doc":"iex> Keyword.has_key?([a: 1], :a)\n    true\n    iex> Keyword.has_key?([a: 1], :b)\n    false","ref":"Keyword.html#has_key?/2-examples"},{"type":"function","title":"Keyword.intersect/3","doc":"Intersects two keyword lists, returning a keyword with the common keys.\n\nBy default, it returns the values of the intersected keys in `keyword2`.\nThe keys are returned in the order found in `keyword1`.","ref":"Keyword.html#intersect/3"},{"type":"function","title":"Examples - Keyword.intersect/3","doc":"iex> Keyword.intersect([a: 1, b: 2], [b: \"b\", c: \"c\"])\n    [b: \"b\"]\n\n    iex> Keyword.intersect([a: 1, b: 2], [b: 2, c: 3], fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 4]","ref":"Keyword.html#intersect/3-examples"},{"type":"type","title":"Keyword.key/0","doc":"","ref":"Keyword.html#t:key/0"},{"type":"function","title":"Keyword.keys/1","doc":"Returns all keys from the keyword list.\n\nKeeps duplicate keys in the resulting list of keys.","ref":"Keyword.html#keys/1"},{"type":"function","title":"Examples - Keyword.keys/1","doc":"iex> Keyword.keys(a: 1, b: 2)\n    [:a, :b]\n\n    iex> Keyword.keys(a: 1, b: 2, a: 3)\n    [:a, :b, :a]\n\n    iex> Keyword.keys([{:a, 1}, {\"b\", 2}, {:c, 3}])\n    ** (ArgumentError) expected a keyword list, but an entry in the list is not a two-element tuple with an atom as its first element, got: {\"b\", 2}","ref":"Keyword.html#keys/1-examples"},{"type":"function","title":"Keyword.keyword?/1","doc":"Returns `true` if `term` is a keyword list, otherwise `false`.\n\nWhen `term` is a list it is traversed to the end.","ref":"Keyword.html#keyword?/1"},{"type":"function","title":"Examples - Keyword.keyword?/1","doc":"iex> Keyword.keyword?([])\n    true\n    iex> Keyword.keyword?(a: 1)\n    true\n    iex> Keyword.keyword?([{Foo, 1}])\n    true\n    iex> Keyword.keyword?([{}])\n    false\n    iex> Keyword.keyword?([:key])\n    false\n    iex> Keyword.keyword?(%{})\n    false","ref":"Keyword.html#keyword?/1-examples"},{"type":"function","title":"Keyword.merge/2","doc":"Merges two keyword lists into one.\n\nAdds all keys, including duplicate keys, given in `keywords2`\nto `keywords1`, overriding any existing ones.\n\nThere are no guarantees about the order of the keys in the returned keyword.","ref":"Keyword.html#merge/2"},{"type":"function","title":"Examples - Keyword.merge/2","doc":"iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n    [b: 2, a: 3, d: 4]\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])\n    [b: 2, a: 3, d: 4, a: 5]\n\n    iex> Keyword.merge([a: 1], [2, 3])\n    ** (ArgumentError) expected a keyword list as the second argument, got: [2, 3]","ref":"Keyword.html#merge/2-examples"},{"type":"function","title":"Keyword.merge/3","doc":"Merges two keyword lists into one.\n\nAdds all keys, including duplicate keys, given in `keywords2`\nto `keywords1`. Invokes the given function to solve conflicts.\n\nIf `keywords2` has duplicate keys, it invokes the given function\nfor each matching pair in `keywords1`.\n\nThere are no guarantees about the order of the keys in the returned keyword.","ref":"Keyword.html#merge/3"},{"type":"function","title":"Examples - Keyword.merge/3","doc":"iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4]\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4, a: 5]\n\n    iex> Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4, a: 8]\n\n    iex> Keyword.merge([a: 1, b: 2], [:a, :b], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    ** (ArgumentError) expected a keyword list as the second argument, got: [:a, :b]","ref":"Keyword.html#merge/3-examples"},{"type":"function","title":"Keyword.new/0","doc":"Returns an empty keyword list, i.e. an empty list.","ref":"Keyword.html#new/0"},{"type":"function","title":"Examples - Keyword.new/0","doc":"iex> Keyword.new()\n    []","ref":"Keyword.html#new/0-examples"},{"type":"function","title":"Keyword.new/1","doc":"Creates a keyword list from an enumerable.\n\nRemoves duplicate entries and the last one prevails.\nUnlike `Enum.into(enumerable, [])`, `Keyword.new(enumerable)`\nguarantees the keys are unique.","ref":"Keyword.html#new/1"},{"type":"function","title":"Examples - Keyword.new/1","doc":"iex> Keyword.new([{:b, 1}, {:a, 2}])\n    [b: 1, a: 2]\n\n    iex> Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])\n    [a: 3]","ref":"Keyword.html#new/1-examples"},{"type":"function","title":"Keyword.new/2","doc":"Creates a keyword list from an enumerable via the transformation function.\n\nRemoves duplicate entries and the last one prevails.\nUnlike `Enum.into(enumerable, [], fun)`,\n`Keyword.new(enumerable, fun)` guarantees the keys are unique.","ref":"Keyword.html#new/2"},{"type":"function","title":"Examples - Keyword.new/2","doc":"iex> Keyword.new([:a, :b], fn x -> {x, x} end)\n    [a: :a, b: :b]","ref":"Keyword.html#new/2-examples"},{"type":"function","title":"Keyword.pop/3","doc":"Returns the first value for `key` and removes all associated entries in the keyword list.\n\nIt returns a tuple where the first element is the first value for `key` and the\nsecond element is a keyword list with all entries associated with `key` removed.\nIf the `key` is not present in the keyword list, it returns `{default, keyword_list}`.\n\nIf you don't want to remove all the entries associated with `key` use `pop_first/3`\ninstead, which will remove only the first entry.","ref":"Keyword.html#pop/3"},{"type":"function","title":"Examples - Keyword.pop/3","doc":"iex> Keyword.pop([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop([a: 1], :b)\n    {nil, [a: 1]}\n    iex> Keyword.pop([a: 1], :b, 3)\n    {3, [a: 1]}\n    iex> Keyword.pop([a: 1, a: 2], :a)\n    {1, []}","ref":"Keyword.html#pop/3-examples"},{"type":"function","title":"Keyword.pop!/2","doc":"Returns the first value for `key` and removes all associated entries in the keyword list,\nraising if `key` is not present.\n\nThis function behaves like `pop/3`, but raises in case the `key` is not present in the\ngiven `keywords`.","ref":"Keyword.html#pop!/2"},{"type":"function","title":"Examples - Keyword.pop!/2","doc":"iex> Keyword.pop!([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop!([a: 1, a: 2], :a)\n    {1, []}\n    iex> Keyword.pop!([a: 1], :b)\n    ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#pop!/2-examples"},{"type":"function","title":"Keyword.pop_first/3","doc":"Returns and removes the first value associated with `key` in the keyword list.\n\nKeeps duplicate keys in the resulting keyword list.","ref":"Keyword.html#pop_first/3"},{"type":"function","title":"Examples - Keyword.pop_first/3","doc":"iex> Keyword.pop_first([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop_first([a: 1], :b)\n    {nil, [a: 1]}\n    iex> Keyword.pop_first([a: 1], :b, 3)\n    {3, [a: 1]}\n    iex> Keyword.pop_first([a: 1, a: 2], :a)\n    {1, [a: 2]}","ref":"Keyword.html#pop_first/3-examples"},{"type":"function","title":"Keyword.pop_lazy/3","doc":"Lazily returns and removes all values associated with `key` in the keyword list.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\nRemoves all duplicate keys. See `pop_first/3` for removing only the first entry.","ref":"Keyword.html#pop_lazy/3"},{"type":"function","title":"Examples - Keyword.pop_lazy/3","doc":"iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.pop_lazy(keyword, :a, fun)\n    {1, []}\n    iex> Keyword.pop_lazy(keyword, :b, fun)\n    {13, [a: 1]}","ref":"Keyword.html#pop_lazy/3-examples"},{"type":"function","title":"Keyword.pop_values/2","doc":"Returns all values for `key` and removes all associated entries in the keyword list.\n\nIt returns a tuple where the first element is a list of values for `key` and the\nsecond element is a keyword list with all entries associated with `key` removed.\nIf the `key` is not present in the keyword list, it returns `{[], keyword_list}`.\n\nIf you don't want to remove all the entries associated with `key` use `pop_first/3`\ninstead, which will remove only the first entry.","ref":"Keyword.html#pop_values/2"},{"type":"function","title":"Examples - Keyword.pop_values/2","doc":"iex> Keyword.pop_values([a: 1], :a)\n    {[1], []}\n    iex> Keyword.pop_values([a: 1], :b)\n    {[], [a: 1]}\n    iex> Keyword.pop_values([a: 1, a: 2], :a)\n    {[1, 2], []}","ref":"Keyword.html#pop_values/2-examples"},{"type":"function","title":"Keyword.put/3","doc":"Puts the given `value` under the specified `key`.\n\nIf a value under `key` already exists, it overrides the value\nand removes all duplicate entries.","ref":"Keyword.html#put/3"},{"type":"function","title":"Examples - Keyword.put/3","doc":"iex> Keyword.put([a: 1], :b, 2)\n    [b: 2, a: 1]\n    iex> Keyword.put([a: 1, b: 2], :a, 3)\n    [a: 3, b: 2]\n    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n    [a: 3, b: 2]","ref":"Keyword.html#put/3-examples"},{"type":"function","title":"Keyword.put_new/3","doc":"Puts the given `value` under `key`, unless the entry `key` already exists.","ref":"Keyword.html#put_new/3"},{"type":"function","title":"Examples - Keyword.put_new/3","doc":"iex> Keyword.put_new([a: 1], :b, 2)\n    [b: 2, a: 1]\n    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n    [a: 1, b: 2]","ref":"Keyword.html#put_new/3-examples"},{"type":"function","title":"Keyword.put_new_lazy/3","doc":"Evaluates `fun` and puts the result under `key`\nin keyword list unless `key` is already present.\n\nThis is useful if the value is very expensive to calculate or\ngenerally difficult to set up and tear down again.","ref":"Keyword.html#put_new_lazy/3"},{"type":"function","title":"Examples - Keyword.put_new_lazy/3","doc":"iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.put_new_lazy(keyword, :a, fun)\n    [a: 1]\n    iex> Keyword.put_new_lazy(keyword, :b, fun)\n    [b: 13, a: 1]","ref":"Keyword.html#put_new_lazy/3-examples"},{"type":"function","title":"Keyword.reject/2","doc":"Returns a keyword list excluding the entries from `keywords`\nfor which the function `fun` returns a truthy value.\n\nSee also `filter/2`.","ref":"Keyword.html#reject/2"},{"type":"function","title":"Examples - Keyword.reject/2","doc":"iex> Keyword.reject([one: 1, two: 2, three: 3], fn {_key, val} -> rem(val, 2) == 1 end)\n    [two: 2]","ref":"Keyword.html#reject/2-examples"},{"type":"function","title":"Keyword.replace/3","doc":"Puts a value under `key` only if the `key` already exists in `keywords`.\n\nIn case a key exists multiple times in the keyword list,\nit removes later occurrences.","ref":"Keyword.html#replace/3"},{"type":"function","title":"Examples - Keyword.replace/3","doc":"iex> Keyword.replace([a: 1, b: 2, a: 4], :a, 3)\n    [a: 3, b: 2]\n\n    iex> Keyword.replace([a: 1], :b, 2)\n    [a: 1]","ref":"Keyword.html#replace/3-examples"},{"type":"function","title":"Keyword.replace!/3","doc":"Puts a value under `key` only if the `key` already exists in `keywords`.\n\nIf `key` is not present in `keywords`, it raises a `KeyError`.","ref":"Keyword.html#replace!/3"},{"type":"function","title":"Examples - Keyword.replace!/3","doc":"iex> Keyword.replace!([a: 1, b: 2, a: 3], :a, :new)\n    [a: :new, b: 2]\n    iex> Keyword.replace!([a: 1, b: 2, c: 3, b: 4], :b, :new)\n    [a: 1, b: :new, c: 3]\n\n    iex> Keyword.replace!([a: 1], :b, 2)\n    ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#replace!/3-examples"},{"type":"function","title":"Keyword.replace_lazy/3","doc":"Replaces the value under `key` using the given function only if\n`key` already exists in `keywords`.\n\nIn comparison to `replace/3`, this can be useful when it's expensive to calculate the value.\n\nIf `key` does not exist, the original keyword list is returned unchanged.","ref":"Keyword.html#replace_lazy/3"},{"type":"function","title":"Examples - Keyword.replace_lazy/3","doc":"iex> Keyword.replace_lazy([a: 1, b: 2], :a, fn v -> v * 4 end)\n    [a: 4, b: 2]\n\n    iex> Keyword.replace_lazy([a: 2, b: 2, a: 1], :a, fn v -> v * 4 end)\n    [a: 8, b: 2]\n\n    iex> Keyword.replace_lazy([a: 1, b: 2], :c, fn v -> v * 4 end)\n    [a: 1, b: 2]","ref":"Keyword.html#replace_lazy/3-examples"},{"type":"function","title":"Keyword.split/2","doc":"Takes all entries corresponding to the given `keys` and extracts them into a\nseparate keyword list.\n\nReturns a tuple with the new list and the old list with removed keys.\n\nIgnores keys for which there are no entries in the keyword list.\n\nEntries with duplicate keys end up in the same keyword list.","ref":"Keyword.html#split/2"},{"type":"function","title":"Examples - Keyword.split/2","doc":"iex> Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])\n    {[a: 1, c: 3], [b: 2]}\n    iex> Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])\n    {[a: 1, c: 3, a: 4], [b: 2]}","ref":"Keyword.html#split/2-examples"},{"type":"function","title":"Keyword.split_with/2","doc":"Splits the `keywords` into two keyword lists according to the given function\n`fun`.\n\nThe provided `fun` receives each `{key, value}` pair in the `keywords` as its only\nargument. Returns a tuple with the first keyword list containing all the\nelements in `keywords` for which applying `fun` returned a truthy value, and\na second keyword list with all the elements for which applying `fun` returned\na falsy value (`false` or `nil`).","ref":"Keyword.html#split_with/2"},{"type":"function","title":"Examples - Keyword.split_with/2","doc":"iex> Keyword.split_with([a: 1, b: 2, c: 3], fn {_k, v} -> rem(v, 2) == 0 end)\n    {[b: 2], [a: 1, c: 3]}\n\n    iex> Keyword.split_with([a: 1, b: 2, c: 3, b: 4], fn {_k, v} -> rem(v, 2) == 0 end)\n    {[b: 2, b: 4], [a: 1, c: 3]}\n\n    iex> Keyword.split_with([a: 1, b: 2, c: 3, b: 4], fn {k, v} -> k in [:a, :c] and rem(v, 2) == 0 end)\n    {[], [a: 1, b: 2, c: 3, b: 4]}\n\n    iex> Keyword.split_with([], fn {_k, v} -> rem(v, 2) == 0 end)\n    {[], []}","ref":"Keyword.html#split_with/2-examples"},{"type":"type","title":"Keyword.t/0","doc":"","ref":"Keyword.html#t:t/0"},{"type":"type","title":"Keyword.t/1","doc":"","ref":"Keyword.html#t:t/1"},{"type":"function","title":"Keyword.take/2","doc":"Takes all entries corresponding to the given `keys` and returns them as a new\nkeyword list.\n\nPreserves duplicate keys in the new keyword list.","ref":"Keyword.html#take/2"},{"type":"function","title":"Examples - Keyword.take/2","doc":"iex> Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])\n    [a: 1, c: 3]\n    iex> Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])\n    [a: 1, c: 3, a: 5]","ref":"Keyword.html#take/2-examples"},{"type":"function","title":"Keyword.to_list/1","doc":"Returns the keyword list itself.","ref":"Keyword.html#to_list/1"},{"type":"function","title":"Examples - Keyword.to_list/1","doc":"iex> Keyword.to_list(a: 1)\n    [a: 1]","ref":"Keyword.html#to_list/1-examples"},{"type":"function","title":"Keyword.update/4","doc":"Updates the value under `key` in `keywords` using the given function.\n\nIf the `key` does not exist, it inserts the given `default` value.\nDoes not pass the `default` value through the update function.\n\nRemoves all duplicate keys and only updates the first one.","ref":"Keyword.html#update/4"},{"type":"function","title":"Examples - Keyword.update/4","doc":"iex> Keyword.update([a: 1], :a, 13, fn existing_value -> existing_value * 2 end)\n    [a: 2]\n\n    iex> Keyword.update([a: 1, a: 2], :a, 13, fn existing_value -> existing_value * 2 end)\n    [a: 2]\n\n    iex> Keyword.update([a: 1], :b, 11, fn existing_value -> existing_value * 2 end)\n    [a: 1, b: 11]","ref":"Keyword.html#update/4-examples"},{"type":"function","title":"Keyword.update!/3","doc":"Updates the value under `key` using the given function.\n\nRaises `KeyError` if the `key` does not exist.\n\nRemoves all duplicate keys and only updates the first one.","ref":"Keyword.html#update!/3"},{"type":"function","title":"Examples - Keyword.update!/3","doc":"iex> Keyword.update!([a: 1, b: 2, a: 3], :a, &(&1 * 2))\n    [a: 2, b: 2]\n    iex> Keyword.update!([a: 1, b: 2, c: 3], :b, &(&1 * 2))\n    [a: 1, b: 4, c: 3]\n\n    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n    ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#update!/3-examples"},{"type":"function","title":"Keyword.validate/2","doc":"Ensures the given `keyword` has only the keys given in `values`.\n\nThe second argument must be a list of atoms, specifying\na given key, or tuples specifying a key and a default value.\n\nIf the keyword list has only the given keys, it returns\n`{:ok, keyword}` with default values applied. Otherwise it\nreturns `{:error, invalid_keys}` with invalid keys.\n\nSee also: `validate!/2`.","ref":"Keyword.html#validate/2"},{"type":"function","title":"Examples - Keyword.validate/2","doc":"iex> {:ok, result} = Keyword.validate([], [one: 1, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 2]\n\n    iex> {:ok, result} = Keyword.validate([two: 3], [one: 1, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 3]\n\nIf atoms are given, they are supported as keys but do not\nprovide a default value:\n\n    iex> {:ok, result} = Keyword.validate([], [:one, two: 2])\n    iex> Enum.sort(result)\n    [two: 2]\n\n    iex> {:ok, result} = Keyword.validate([one: 1], [:one, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 2]\n\nPassing unknown keys returns an error:\n\n    iex> Keyword.validate([three: 3, four: 4], [one: 1, two: 2])\n    {:error, [:four, :three]}\n\nPassing the same key multiple times also errors:\n\n    iex> Keyword.validate([one: 1, two: 2, one: 1], [:one, :two])\n    {:error, [:one]}","ref":"Keyword.html#validate/2-examples"},{"type":"function","title":"Keyword.validate!/2","doc":"Similar to `validate/2` but returns the keyword or raises an error.","ref":"Keyword.html#validate!/2"},{"type":"function","title":"Examples - Keyword.validate!/2","doc":"iex> Keyword.validate!([], [one: 1, two: 2]) |> Enum.sort()\n    [one: 1, two: 2]\n    iex> Keyword.validate!([two: 3], [one: 1, two: 2]) |> Enum.sort()\n    [one: 1, two: 3]\n\nIf atoms are given, they are supported as keys but do not\nprovide a default value:\n\n    iex> Keyword.validate!([], [:one, two: 2]) |> Enum.sort()\n    [two: 2]\n    iex> Keyword.validate!([one: 1], [:one, two: 2]) |> Enum.sort()\n    [one: 1, two: 2]\n\nPassing unknown keys raises an error:\n\n    iex> Keyword.validate!([three: 3], [one: 1, two: 2])\n    ** (ArgumentError) unknown keys [:three] in [three: 3], the allowed keys are: [:one, :two]\n\nPassing the same key multiple times also errors:\n\n    iex> Keyword.validate!([one: 1, two: 2, one: 1], [:one, :two])\n    ** (ArgumentError) duplicate keys [:one] in [one: 1, two: 2, one: 1]","ref":"Keyword.html#validate!/2-examples"},{"type":"type","title":"Keyword.value/0","doc":"","ref":"Keyword.html#t:value/0"},{"type":"function","title":"Keyword.values/1","doc":"Returns all values from the keyword list.\n\nKeeps values from duplicate keys in the resulting list of values.","ref":"Keyword.html#values/1"},{"type":"function","title":"Examples - Keyword.values/1","doc":"iex> Keyword.values(a: 1, b: 2)\n    [1, 2]\n    iex> Keyword.values(a: 1, b: 2, a: 3)\n    [1, 2, 3]","ref":"Keyword.html#values/1-examples"},{"type":"module","title":"List","doc":"Linked lists hold zero, one, or more elements in the chosen order.\n\nLists in Elixir are specified between square brackets:\n\n    iex> [1, \"two\", 3, :four]\n    [1, \"two\", 3, :four]\n\nTwo lists can be concatenated and subtracted using the\n`++/2` and `--/2` operators:\n\n    iex> [1, 2, 3] ++ [4, 5, 6]\n    [1, 2, 3, 4, 5, 6]\n    iex> [1, true, 2, false, 3, true] -- [true, false]\n    [1, 2, 3, true]\n\nAn element can be prepended to a list using `|`:\n\n    iex> new = 0\n    iex> list = [1, 2, 3]\n    iex> [new | list]\n    [0, 1, 2, 3]\n\nLists in Elixir are effectively linked lists, which means\nthey are internally represented in pairs containing the\nhead and the tail of a list:\n\n    iex> [head | tail] = [1, 2, 3]\n    iex> head\n    1\n    iex> tail\n    [2, 3]\n\nSimilarly, we could write the list `[1, 2, 3]` using only\nsuch pairs (called cons cells):\n\n    iex> [1 | [2 | [3 | []]]]\n    [1, 2, 3]\n\nSome lists, called improper lists, do not have an empty list as\nthe second element in the last cons cell:\n\n    iex> [1 | [2 | [3 | 4]]]\n    [1, 2, 3 | 4]\n\nAlthough improper lists are generally avoided, they are used in some\nspecial circumstances like iodata and chardata entities (see the `IO` module).\n\nDue to their cons cell based representation, prepending an element\nto a list is always fast (constant time), while appending becomes\nslower as the list grows in size (linear time):\n\n    iex> list = [1, 2, 3]\n    iex> [0 | list] # fast\n    [0, 1, 2, 3]\n    iex> list ++ [4] # slow\n    [1, 2, 3, 4]\n\nMost of the functions in this module work in linear time. This means that\nthe time it takes to perform an operation grows at the same rate as the\nlength of the list. For example `length/1` and `last/1` will run in linear\ntime because they need to iterate through every element of the list, but\n`first/1` will run in constant time because it only needs the first element.\n\nLists also implement the `Enumerable` protocol, so many functions to work with\nlists are found in the `Enum` module. Additionally, the following functions and\noperators for lists are found in `Kernel`:\n\n  * `++/2`\n  * `--/2`\n  * `hd/1`\n  * `tl/1`\n  * `in/2`\n  * `length/1`","ref":"List.html"},{"type":"module","title":"Charlists - List","doc":"If a list is made of non-negative integers, where each integer represents a\nUnicode code point, the list can also be called a charlist. These integers\nmust:\n\n  * be within the range `0..0x10FFFF` (`0..1_114_111`);\n  * and be out of the range `0xD800..0xDFFF` (`55_296..57_343`), which is\n    reserved in Unicode for UTF-16 surrogate pairs.\n\nElixir uses the [`~c` sigil](`sigil_c/2`) to define charlists:\n\n    iex> ~c\"héllo\"\n    [104, 233, 108, 108, 111]\n\nIn particular, charlists will be printed back by default with the `~c`\nsigil if they contain only printable ASCII characters:\n\n    iex> ~c\"abc\"\n    ~c\"abc\"\n\nEven though the representation changed, the raw data does remain a list of\nintegers, which can be handled as such:\n\n    iex> inspect(~c\"abc\", charlists: :as_list)\n    \"[97, 98, 99]\"\n    iex> Enum.map(~c\"abc\", fn num -> 1000 + num end)\n    [1097, 1098, 1099]\n\nYou can use the `IEx.Helpers.i/1` helper to get a condensed rundown on\ncharlists in IEx when you encounter them, which shows you the type, description\nand also the raw representation in one single summary.\n\nThe rationale behind this behavior is to better support\nErlang libraries which may return text as charlists\ninstead of Elixir strings. In Erlang, charlists are the default\nway of handling strings, while in Elixir it's binaries. One\nexample of such functions is `Application.loaded_applications/0`:\n\n    Application.loaded_applications()\n    #=>  [\n    #=>    {:stdlib, ~c\"ERTS  CXC 138 10\", ~c\"2.6\"},\n    #=>    {:compiler, ~c\"ERTS  CXC 138 10\", ~c\"6.0.1\"},\n    #=>    {:elixir, ~c\"elixir\", ~c\"1.0.0\"},\n    #=>    {:kernel, ~c\"ERTS  CXC 138 10\", ~c\"4.1\"},\n    #=>    {:logger, ~c\"logger\", ~c\"1.0.0\"}\n    #=>  ]\n\nA list can be checked if it is made of only printable ASCII\ncharacters with `ascii_printable?/2`.\n\nImproper lists are never deemed as charlists.","ref":"List.html#module-charlists"},{"type":"function","title":"List.ascii_printable?/2","doc":"Checks if `list` is a charlist made only of printable ASCII characters.\n\nTakes an optional `limit` as a second argument. `ascii_printable?/2` only\nchecks the printability of the list up to the `limit`.\n\nA printable charlist in Elixir contains only the printable characters in the\nstandard seven-bit ASCII character encoding, which are characters ranging from\n32 to 126 in decimal notation, plus the following control characters:\n\n  * `?\\a` - Bell\n  * `?\\b` - Backspace\n  * `?\\t` - Horizontal tab\n  * `?\\n` - Line feed\n  * `?\\v` - Vertical tab\n  * `?\\f` - Form feed\n  * `?\\r` - Carriage return\n  * `?\\e` - Escape\n\nFor more information read the [Character groups](https://en.wikipedia.org/wiki/ASCII#Character_groups)\nsection in the Wikipedia article of the [ASCII](https://en.wikipedia.org/wiki/ASCII) standard.","ref":"List.html#ascii_printable?/2"},{"type":"function","title":"Examples - List.ascii_printable?/2","doc":"iex> List.ascii_printable?(~c\"abc\")\n    true\n\n    iex> List.ascii_printable?(~c\"abc\" ++ [0])\n    false\n\n    iex> List.ascii_printable?(~c\"abc\" ++ [0], 2)\n    true\n\nImproper lists are not printable, even if made only of ASCII characters:\n\n    iex> List.ascii_printable?(~c\"abc\" ++ ?d)\n    false","ref":"List.html#ascii_printable?/2-examples"},{"type":"function","title":"List.delete/2","doc":"Deletes the given `element` from the `list`. Returns a new list without\nthe element.\n\nIf the `element` occurs more than once in the `list`, just\nthe first occurrence is removed.","ref":"List.html#delete/2"},{"type":"function","title":"Examples - List.delete/2","doc":"iex> List.delete([:a, :b, :c], :a)\n    [:b, :c]\n\n    iex> List.delete([:a, :b, :c], :d)\n    [:a, :b, :c]\n\n    iex> List.delete([:a, :b, :b, :c], :b)\n    [:a, :b, :c]\n\n    iex> List.delete([], :b)\n    []","ref":"List.html#delete/2-examples"},{"type":"function","title":"List.delete_at/2","doc":"Produces a new list by removing the value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.","ref":"List.html#delete_at/2"},{"type":"function","title":"Examples - List.delete_at/2","doc":"iex> List.delete_at([1, 2, 3], 0)\n    [2, 3]\n\n    iex> List.delete_at([1, 2, 3], 10)\n    [1, 2, 3]\n\n    iex> List.delete_at([1, 2, 3], -1)\n    [1, 2]","ref":"List.html#delete_at/2-examples"},{"type":"function","title":"List.duplicate/2","doc":"Duplicates the given element `n` times in a list.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty list is returned.","ref":"List.html#duplicate/2"},{"type":"function","title":"Examples - List.duplicate/2","doc":"iex> List.duplicate(\"hello\", 0)\n    []\n\n    iex> List.duplicate(\"hi\", 1)\n    [\"hi\"]\n\n    iex> List.duplicate(\"bye\", 2)\n    [\"bye\", \"bye\"]\n\n    iex> List.duplicate([1, 2], 3)\n    [[1, 2], [1, 2], [1, 2]]","ref":"List.html#duplicate/2-examples"},{"type":"function","title":"List.first/2","doc":"Returns the first element in `list` or `default` if `list` is empty.\n\n`first/2` has been introduced in Elixir v1.12.0, while `first/1` has been available since v1.0.0.","ref":"List.html#first/2"},{"type":"function","title":"Examples - List.first/2","doc":"iex> List.first([])\n    nil\n\n    iex> List.first([], 1)\n    1\n\n    iex> List.first([1])\n    1\n\n    iex> List.first([1, 2, 3])\n    1","ref":"List.html#first/2-examples"},{"type":"function","title":"List.flatten/1","doc":"Flattens the given `list` of nested lists.\n\nEmpty list elements are discarded.","ref":"List.html#flatten/1"},{"type":"function","title":"Examples - List.flatten/1","doc":"iex> List.flatten([1, [[2], 3]])\n    [1, 2, 3]\n\n    iex> List.flatten([[], [[], []]])\n    []","ref":"List.html#flatten/1-examples"},{"type":"function","title":"List.flatten/2","doc":"Flattens the given `list` of nested lists.\nThe list `tail` will be added at the end of\nthe flattened list.\n\nEmpty list elements from `list` are discarded,\nbut not the ones from `tail`.","ref":"List.html#flatten/2"},{"type":"function","title":"Examples - List.flatten/2","doc":"iex> List.flatten([1, [[2], 3]], [4, 5])\n    [1, 2, 3, 4, 5]\n\n    iex> List.flatten([1, [], 2], [3, [], 4])\n    [1, 2, 3, [], 4]","ref":"List.html#flatten/2-examples"},{"type":"function","title":"List.foldl/3","doc":"Folds (reduces) the given list from the left with\na function. Requires an accumulator, which can be any value.","ref":"List.html#foldl/3"},{"type":"function","title":"Examples - List.foldl/3","doc":"iex> List.foldl([5, 5], 10, fn x, acc -> x + acc end)\n    20\n\n    iex> List.foldl([1, 2, 3, 4], 0, fn x, acc -> x - acc end)\n    2\n\n    iex> List.foldl([1, 2, 3], {0, 0}, fn x, {a1, a2} -> {a1 + x, a2 - x} end)\n    {6, -6}","ref":"List.html#foldl/3-examples"},{"type":"function","title":"List.foldr/3","doc":"Folds (reduces) the given list from the right with\na function. Requires an accumulator, which can be any value.","ref":"List.html#foldr/3"},{"type":"function","title":"Examples - List.foldr/3","doc":"iex> List.foldr([1, 2, 3, 4], 0, fn x, acc -> x - acc end)\n    -2\n\n    iex> List.foldr([1, 2, 3, 4], %{sum: 0, product: 1}, fn x, %{sum: a1, product: a2} -> %{sum: a1 + x, product: a2 * x} end)\n    %{product: 24, sum: 10}","ref":"List.html#foldr/3-examples"},{"type":"function","title":"List.improper?/1","doc":"Returns `true` if `list` is an improper list. Otherwise returns `false`.","ref":"List.html#improper?/1"},{"type":"function","title":"Examples - List.improper?/1","doc":"iex> List.improper?([1, 2 | 3])\n    true\n\n    iex> List.improper?([1, 2, 3])\n    false","ref":"List.html#improper?/1-examples"},{"type":"function","title":"List.insert_at/3","doc":"Returns a list with `value` inserted at the specified `index`.\n\nNote that `index` is capped at the list length. Negative indices\nindicate an offset from the end of the `list`.","ref":"List.html#insert_at/3"},{"type":"function","title":"Examples - List.insert_at/3","doc":"iex> List.insert_at([1, 2, 3, 4], 2, 0)\n    [1, 2, 0, 3, 4]\n\n    iex> List.insert_at([1, 2, 3], 10, 0)\n    [1, 2, 3, 0]\n\n    iex> List.insert_at([1, 2, 3], -1, 0)\n    [1, 2, 3, 0]\n\n    iex> List.insert_at([1, 2, 3], -10, 0)\n    [0, 1, 2, 3]","ref":"List.html#insert_at/3-examples"},{"type":"function","title":"List.keydelete/3","doc":"Receives a `list` of tuples and deletes the first tuple\nwhere the element at `position` matches the\ngiven `key`. Returns the new list.","ref":"List.html#keydelete/3"},{"type":"function","title":"Examples - List.keydelete/3","doc":"iex> List.keydelete([a: 1, b: 2], :a, 0)\n    [b: 2]\n\n    iex> List.keydelete([a: 1, b: 2], 2, 1)\n    [a: 1]\n\n    iex> List.keydelete([a: 1, b: 2], :c, 0)\n    [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keydelete([{22, \"SSH\"}, {80, \"HTTP\"}], 80, 0)\n    [{22, \"SSH\"}]","ref":"List.html#keydelete/3-examples"},{"type":"function","title":"List.keyfind/4","doc":"Receives a list of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`.\n\nIf no matching tuple is found, `default` is returned.","ref":"List.html#keyfind/4"},{"type":"function","title":"Examples - List.keyfind/4","doc":"iex> List.keyfind([a: 1, b: 2], :a, 0)\n    {:a, 1}\n\n    iex> List.keyfind([a: 1, b: 2], 2, 1)\n    {:b, 2}\n\n    iex> List.keyfind([a: 1, b: 2], :c, 0)\n    nil\n\nThis function works for any list of tuples:\n\n    iex> List.keyfind([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    {22, \"SSH\"}","ref":"List.html#keyfind/4-examples"},{"type":"function","title":"List.keyfind!/3","doc":"Receives a list of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`.\n\nIf no matching tuple is found, an error is raised.","ref":"List.html#keyfind!/3"},{"type":"function","title":"Examples - List.keyfind!/3","doc":"iex> List.keyfind!([a: 1, b: 2], :a, 0)\n    {:a, 1}\n\n    iex> List.keyfind!([a: 1, b: 2], 2, 1)\n    {:b, 2}\n\n    iex> List.keyfind!([a: 1, b: 2], :c, 0)\n    ** (KeyError) key :c at position 0 not found in: [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keyfind!([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    {22, \"SSH\"}","ref":"List.html#keyfind!/3-examples"},{"type":"function","title":"List.keymember?/3","doc":"Receives a list of tuples and returns `true` if there is\na tuple where the element at `position` in the tuple matches\nthe given `key`.","ref":"List.html#keymember?/3"},{"type":"function","title":"Examples - List.keymember?/3","doc":"iex> List.keymember?([a: 1, b: 2], :a, 0)\n    true\n\n    iex> List.keymember?([a: 1, b: 2], 2, 1)\n    true\n\n    iex> List.keymember?([a: 1, b: 2], :c, 0)\n    false\n\nThis function works for any list of tuples:\n\n    iex> List.keymember?([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    true","ref":"List.html#keymember?/3-examples"},{"type":"function","title":"List.keyreplace/4","doc":"Receives a list of tuples and if the identified element by `key` at `position`\nexists, it is replaced with `new_tuple`.","ref":"List.html#keyreplace/4"},{"type":"function","title":"Examples - List.keyreplace/4","doc":"iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n    [a: 3, b: 2]\n\n    iex> List.keyreplace([a: 1, b: 2], :a, 1, {:a, 3})\n    [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keyreplace([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0, {22, \"Secure Shell\"})\n    [{22, \"Secure Shell\"}, {80, \"HTTP\"}]","ref":"List.html#keyreplace/4-examples"},{"type":"function","title":"List.keysort/3","doc":"Receives a list of tuples and sorts the elements\nat `position` of the tuples.\n\nThe sort is stable.\n\nA `sorter` argument is available since Elixir v1.14.0. Similar to\n`Enum.sort/2`, the sorter can be an anonymous function, the atoms\n`:asc` or `:desc`, or module that implements a compare function.","ref":"List.html#keysort/3"},{"type":"function","title":"Examples - List.keysort/3","doc":"iex> List.keysort([a: 5, b: 1, c: 3], 1)\n    [b: 1, c: 3, a: 5]\n\n    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n    [a: 5, b: 3, c: 1]\n\nTo sort in descending order:\n\n    iex> List.keysort([a: 5, c: 1, b: 3], 0, :desc)\n    [c: 1, b: 3, a: 5]\n\nAs in `Enum.sort/2`, avoid using the default sorting function to sort\nstructs, as by default it performs structural comparison instead of a\nsemantic one. In such cases, you shall pass a sorting function as third\nelement or any module that implements a `compare/2` function. For example,\nif you have tuples with user names and their birthday, and you want to\nsort on their birthday, in both ascending and descending order, you should\ndo:\n\n    iex> users = [\n    ...>   {\"Ellis\", ~D[1943-05-11]},\n    ...>   {\"Lovelace\", ~D[1815-12-10]},\n    ...>   {\"Turing\", ~D[1912-06-23]}\n    ...> ]\n    iex> List.keysort(users, 1, Date)\n    [\n      {\"Lovelace\", ~D[1815-12-10]},\n      {\"Turing\", ~D[1912-06-23]},\n      {\"Ellis\", ~D[1943-05-11]}\n    ]\n    iex> List.keysort(users, 1, {:desc, Date})\n    [\n      {\"Ellis\", ~D[1943-05-11]},\n      {\"Turing\", ~D[1912-06-23]},\n      {\"Lovelace\", ~D[1815-12-10]}\n    ]","ref":"List.html#keysort/3-examples"},{"type":"function","title":"List.keystore/4","doc":"Receives a `list` of tuples and replaces the element\nidentified by `key` at `position` with `new_tuple`.\n\nIf the element does not exist, it is added to the end of the `list`.","ref":"List.html#keystore/4"},{"type":"function","title":"Examples - List.keystore/4","doc":"iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n    [a: 3, b: 2]\n\n    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n    [a: 1, b: 2, c: 3]\n\nThis function works for any list of tuples:\n\n    iex> List.keystore([{22, \"SSH\"}], 80, 0, {80, \"HTTP\"})\n    [{22, \"SSH\"}, {80, \"HTTP\"}]","ref":"List.html#keystore/4-examples"},{"type":"function","title":"List.keytake/3","doc":"Receives a `list` of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`, as well as the `list` without found tuple.\n\nIf such a tuple is not found, `nil` will be returned.","ref":"List.html#keytake/3"},{"type":"function","title":"Examples - List.keytake/3","doc":"iex> List.keytake([a: 1, b: 2], :a, 0)\n    {{:a, 1}, [b: 2]}\n\n    iex> List.keytake([a: 1, b: 2], 2, 1)\n    {{:b, 2}, [a: 1]}\n\n    iex> List.keytake([a: 1, b: 2], :c, 0)\n    nil\n\nThis function works for any list of tuples:\n\n    iex> List.keytake([{22, \"SSH\"}, {80, \"HTTP\"}], 80, 0)\n    {{80, \"HTTP\"}, [{22, \"SSH\"}]}","ref":"List.html#keytake/3-examples"},{"type":"function","title":"List.last/2","doc":"Returns the last element in `list` or `default` if `list` is empty.\n\n`last/2` has been introduced in Elixir v1.12.0, while `last/1` has been available since v1.0.0.","ref":"List.html#last/2"},{"type":"function","title":"Examples - List.last/2","doc":"iex> List.last([])\n    nil\n\n    iex> List.last([], 1)\n    1\n\n    iex> List.last([1])\n    1\n\n    iex> List.last([1, 2, 3])\n    3","ref":"List.html#last/2-examples"},{"type":"function","title":"List.myers_difference/2","doc":"Returns a keyword list that represents an *edit script*.\n\nThe algorithm is outlined in the\n\"An O(ND) Difference Algorithm and Its Variations\" paper by E. Myers.\n\nAn *edit script* is a keyword list. Each key describes the \"editing action\" to\ntake in order to bring `list1` closer to being equal to `list2`; a key can be\n`:eq`, `:ins`, or `:del`. Each value is a sublist of either `list1` or `list2`\nthat should be inserted (if the corresponding key is `:ins`), deleted (if the\ncorresponding key is `:del`), or left alone (if the corresponding key is\n`:eq`) in `list1` in order to be closer to `list2`.\n\nSee `myers_difference/3` if you want to handle nesting in the diff scripts.","ref":"List.html#myers_difference/2"},{"type":"function","title":"Examples - List.myers_difference/2","doc":"iex> List.myers_difference([1, 4, 2, 3], [1, 2, 3, 4])\n    [eq: [1], del: [4], eq: [2, 3], ins: [4]]","ref":"List.html#myers_difference/2-examples"},{"type":"function","title":"List.myers_difference/3","doc":"Returns a keyword list that represents an *edit script* with nested diffs.\n\nThis is an extension of `myers_difference/2` where a `diff_script` function\ncan be given in case it is desired to compute nested differences. The function\nmay return a list with the inner edit script or `nil` in case there is no\nsuch script. The returned inner edit script will be under the `:diff` key.","ref":"List.html#myers_difference/3"},{"type":"function","title":"Examples - List.myers_difference/3","doc":"iex> List.myers_difference([\"a\", \"db\", \"c\"], [\"a\", \"bc\"], &String.myers_difference/2)\n    [eq: [\"a\"], diff: [del: \"d\", eq: \"b\", ins: \"c\"], del: [\"c\"]]","ref":"List.html#myers_difference/3-examples"},{"type":"function","title":"List.pop_at/3","doc":"Returns and removes the value at the specified `index` in the `list`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.","ref":"List.html#pop_at/3"},{"type":"function","title":"Examples - List.pop_at/3","doc":"iex> List.pop_at([1, 2, 3], 0)\n    {1, [2, 3]}\n    iex> List.pop_at([1, 2, 3], 5)\n    {nil, [1, 2, 3]}\n    iex> List.pop_at([1, 2, 3], 5, 10)\n    {10, [1, 2, 3]}\n    iex> List.pop_at([1, 2, 3], -1)\n    {3, [1, 2]}","ref":"List.html#pop_at/3-examples"},{"type":"function","title":"List.replace_at/3","doc":"Returns a list with a replaced value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.","ref":"List.html#replace_at/3"},{"type":"function","title":"Examples - List.replace_at/3","doc":"iex> List.replace_at([1, 2, 3], 0, 0)\n    [0, 2, 3]\n\n    iex> List.replace_at([1, 2, 3], 10, 0)\n    [1, 2, 3]\n\n    iex> List.replace_at([1, 2, 3], -1, 0)\n    [1, 2, 0]\n\n    iex> List.replace_at([1, 2, 3], -10, 0)\n    [1, 2, 3]","ref":"List.html#replace_at/3-examples"},{"type":"function","title":"List.starts_with?/2","doc":"Returns `true` if `list` starts with the given `prefix` list, otherwise returns `false`.\n\nIf `prefix` is an empty list, it returns `true`.","ref":"List.html#starts_with?/2"},{"type":"function","title":"Examples - List.starts_with?/2","doc":"iex> List.starts_with?([1, 2, 3], [1, 2])\n    true\n\n    iex> List.starts_with?([1, 2], [1, 2, 3])\n    false\n\n    iex> List.starts_with?([:alpha], [])\n    true\n\n    iex> List.starts_with?([], [:alpha])\n    false","ref":"List.html#starts_with?/2-examples"},{"type":"function","title":"List.to_atom/1","doc":"Converts a charlist to an atom.\n\nElixir supports conversions from charlists which contain any Unicode\ncode point.\n\nInlined by the compiler.","ref":"List.html#to_atom/1"},{"type":"function","title":"Examples - List.to_atom/1","doc":"iex> List.to_atom(~c\"Elixir\")\n    :Elixir\n\n    iex> List.to_atom(~c\"🌢 Elixir\")\n    :\"🌢 Elixir\"","ref":"List.html#to_atom/1-examples"},{"type":"function","title":"List.to_charlist/1","doc":"Converts a list of integers representing Unicode code points, lists or\nstrings into a charlist.\n\nNote that this function expects a list of integers representing\nUnicode code points. If you have a list of bytes, you must instead use\nthe [`:binary` module](`:binary`).","ref":"List.html#to_charlist/1"},{"type":"function","title":"Examples - List.to_charlist/1","doc":"iex> ~c\"æß\" = List.to_charlist([0x00E6, 0x00DF])\n    [230, 223]\n\n    iex> List.to_charlist([0x0061, \"bc\"])\n    ~c\"abc\"\n\n    iex> List.to_charlist([0x0064, \"ee\", [~c\"p\"]])\n    ~c\"deep\"","ref":"List.html#to_charlist/1-examples"},{"type":"function","title":"List.to_existing_atom/1","doc":"Converts a charlist to an existing atom.\n\nElixir supports conversions from charlists which contain any Unicode\ncode point. Raises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `List.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.","ref":"List.html#to_existing_atom/1"},{"type":"function","title":"Examples - List.to_existing_atom/1","doc":"iex> _ = :my_atom\n    iex> List.to_existing_atom(~c\"my_atom\")\n    :my_atom\n\n    iex> _ = :\"🌢 Elixir\"\n    iex> List.to_existing_atom(~c\"🌢 Elixir\")\n    :\"🌢 Elixir\"","ref":"List.html#to_existing_atom/1-examples"},{"type":"function","title":"List.to_float/1","doc":"Returns the float whose text representation is `charlist`.\n\nInlined by the compiler.","ref":"List.html#to_float/1"},{"type":"function","title":"Examples - List.to_float/1","doc":"iex> List.to_float(~c\"2.2017764e+0\")\n    2.2017764","ref":"List.html#to_float/1-examples"},{"type":"function","title":"List.to_integer/1","doc":"Returns an integer whose text representation is `charlist`.\n\nInlined by the compiler.","ref":"List.html#to_integer/1"},{"type":"function","title":"Examples - List.to_integer/1","doc":"iex> List.to_integer(~c\"123\")\n    123","ref":"List.html#to_integer/1-examples"},{"type":"function","title":"List.to_integer/2","doc":"Returns an integer whose text representation is `charlist` in base `base`.\n\nInlined by the compiler.\n\nThe base needs to be between `2` and `36`.","ref":"List.html#to_integer/2"},{"type":"function","title":"Examples - List.to_integer/2","doc":"iex> List.to_integer(~c\"3FF\", 16)\n    1023","ref":"List.html#to_integer/2-examples"},{"type":"function","title":"List.to_string/1","doc":"Converts a list of integers representing code points, lists or\nstrings into a string.\n\nTo be converted to a string, a list must either be empty or only\ncontain the following elements:\n\n  * strings\n  * integers representing Unicode code points\n  * a list containing one of these three elements\n\nNote that this function expects a list of integers representing\nUnicode code points. If you have a list of bytes, you must instead use\nthe [`:binary` module](`:binary`).","ref":"List.html#to_string/1"},{"type":"function","title":"Examples - List.to_string/1","doc":"iex> List.to_string([0x00E6, 0x00DF])\n    \"æß\"\n\n    iex> List.to_string([0x0061, \"bc\"])\n    \"abc\"\n\n    iex> List.to_string([0x0064, \"ee\", [~c\"p\"]])\n    \"deep\"\n\n    iex> List.to_string([])\n    \"\"","ref":"List.html#to_string/1-examples"},{"type":"function","title":"List.to_tuple/1","doc":"Converts a list to a tuple.\n\nInlined by the compiler.","ref":"List.html#to_tuple/1"},{"type":"function","title":"Examples - List.to_tuple/1","doc":"iex> List.to_tuple([:share, [:elixir, 163]])\n    {:share, [:elixir, 163]}","ref":"List.html#to_tuple/1-examples"},{"type":"function","title":"List.update_at/3","doc":"Returns a list with an updated value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.","ref":"List.html#update_at/3"},{"type":"function","title":"Examples - List.update_at/3","doc":"iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n    [11, 2, 3]\n\n    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n    [1, 2, 3]\n\n    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n    [1, 2, 13]\n\n    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n    [1, 2, 3]","ref":"List.html#update_at/3-examples"},{"type":"function","title":"List.wrap/1","doc":"Wraps `term` in a list if this is not list.\n\nIf `term` is already a list, it returns the list.\nIf `term` is `nil`, it returns an empty list.","ref":"List.html#wrap/1"},{"type":"function","title":"Examples - List.wrap/1","doc":"iex> List.wrap(\"hello\")\n    [\"hello\"]\n\n    iex> List.wrap([1, 2, 3])\n    [1, 2, 3]\n\n    iex> List.wrap(nil)\n    []","ref":"List.html#wrap/1-examples"},{"type":"function","title":"List.zip/1","doc":"Zips corresponding elements from each list in `list_of_lists`.\n\nThe zipping finishes as soon as any list terminates.","ref":"List.html#zip/1"},{"type":"function","title":"Examples - List.zip/1","doc":"iex> List.zip([[1, 2], [3, 4], [5, 6]])\n    [{1, 3, 5}, {2, 4, 6}]\n\n    iex> List.zip([[1, 2], [3], [5, 6]])\n    [{1, 3, 5}]","ref":"List.html#zip/1-examples"},{"type":"module","title":"Map","doc":"Maps are the \"go to\" key-value data structure in Elixir.\n\nMaps can be created with the `%{}` syntax, and key-value pairs can be\nexpressed as `key => value`:\n\n    iex> %{}\n    %{}\n    iex> %{\"one\" => :two, 3 => \"four\"}\n    %{3 => \"four\", \"one\" => :two}\n\nKey-value pairs in a map do not follow any order (that's why the printed map\nin the example above has a different order than the map that was created).\n\nMaps do not impose any restriction on the key type: anything can be a key in a\nmap. As a key-value structure, maps do not allow duplicate keys. Keys are\ncompared using the exact-equality operator (`===/2`). If colliding keys are defined\nin a map literal, the last one prevails.\n\nWhen the key in a key-value pair is an atom, the `key: value` shorthand syntax\ncan be used (as in many other special forms):\n\n    iex> %{a: 1, b: 2}\n    %{a: 1, b: 2}\n\nIf you want to mix the shorthand syntax with `=>`, the shorthand syntax must come\nat the end:\n\n    iex> %{\"hello\" => \"world\", a: 1, b: 2}\n    %{:a => 1, :b => 2, \"hello\" => \"world\"}\n\nKeys in maps can be accessed through some of the functions in this module\n(such as `Map.get/3` or `Map.fetch/2`) or through the `map[]` syntax provided\nby the `Access` module:\n\n    iex> map = %{a: 1, b: 2}\n    iex> Map.fetch(map, :a)\n    {:ok, 1}\n    iex> map[:b]\n    2\n    iex> map[\"non_existing_key\"]\n    nil\n\nTo access atom keys, one may also use the `map.key` notation. Note that `map.key`\nwill raise a `KeyError` if the `map` doesn't contain the key `:key`, compared to\n`map[:key]`, that would return `nil`.\n\n    map = %{foo: \"bar\", baz: \"bong\"}\n    map.foo\n    #=> \"bar\"\n    map.non_existing_key\n    ** (KeyError) key :non_existing_key not found in: %{baz: \"bong\", foo: \"bar\"}\n\n> #### Avoid parentheses {: .warning}\n>\n> Do not add parentheses when accessing fields, such as in `data.key()`.\n> If parentheses are used, Elixir will expect `data` to be an atom representing\n> a module and attempt to call the *function* `key/0` in it.\n\nThe two syntaxes for accessing keys reveal the dual nature of maps. The `map[key]`\nsyntax is used for dynamically created maps that may have any key, of any type.\n`map.key` is used with maps that hold a predetermined set of atoms keys, which are\nexpected to always be present. Structs, defined via `defstruct/1`, are one example\nof such \"static maps\", where the keys can also be checked during compile time.\n\nMaps can be pattern matched on. When a map is on the left-hand side of a\npattern match, it will match if the map on the right-hand side contains the\nkeys on the left-hand side and their values match the ones on the left-hand\nside. This means that an empty map matches every map.\n\n    iex> %{} = %{foo: \"bar\"}\n    %{foo: \"bar\"}\n    iex> %{a: a} = %{:a => 1, \"b\" => 2, [:c, :e, :e] => 3}\n    iex> a\n    1\n\nBut this will raise a `MatchError` exception:\n\n    %{:c => 3} = %{:a => 1, 2 => :b}\n\nVariables can be used as map keys both when writing map literals as well as\nwhen matching:\n\n    iex> n = 1\n    1\n    iex> %{n => :one}\n    %{1 => :one}\n    iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}\n    %{1 => :one, 2 => :two, 3 => :three}\n\nMaps also support a specific update syntax to update the value stored under\n*existing* keys. You can update using the atom keys syntax:\n\n    iex> map = %{one: 1, two: 2}\n    iex> %{map | one: \"one\"}\n    %{one: \"one\", two: 2}\n\nOr any other key:\n\n    iex> other_map = %{\"three\" => 3, \"four\" => 4}\n    iex> %{other_map | \"three\" => \"three\"}\n    %{\"four\" => 4, \"three\" => \"three\"}\n\nWhen a key that does not exist in the map is updated a `KeyError` exception will be raised:\n\n    %{map | three: 3}\n\nThe functions in this module that need to find a specific key work in logarithmic time.\nThis means that the time it takes to find keys grows as the map grows, but it's not\ndirectly proportional to the map size. In comparison to finding an element in a list,\nit performs better because lists have a linear time complexity. Some functions,\nsuch as `keys/1` and `values/1`, run in linear time because they need to get to every\nelement in the map.\n\nMaps also implement the `Enumerable` protocol, so many functions to work with maps\nare found in the `Enum` module. Additionally, the following functions for maps are\nfound in `Kernel`:\n\n  * `map_size/1`","ref":"Map.html"},{"type":"function","title":"Map.delete/2","doc":"Deletes the entry in `map` for a specific `key`.\n\nIf the `key` does not exist, returns `map` unchanged.\n\nInlined by the compiler.","ref":"Map.html#delete/2"},{"type":"function","title":"Examples - Map.delete/2","doc":"iex> Map.delete(%{a: 1, b: 2}, :a)\n    %{b: 2}\n    iex> Map.delete(%{b: 2}, :a)\n    %{b: 2}","ref":"Map.html#delete/2-examples"},{"type":"function","title":"Map.drop/2","doc":"Drops the given `keys` from `map`.\n\nIf `keys` contains keys that are not in `map`, they're simply ignored.","ref":"Map.html#drop/2"},{"type":"function","title":"Examples - Map.drop/2","doc":"iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n    %{a: 1, c: 3}","ref":"Map.html#drop/2-examples"},{"type":"function","title":"Map.equal?/2","doc":"Checks if two maps are equal.\n\nTwo maps are considered to be equal if they contain\nthe same keys and those keys contain the same values.\n\nNote this function exists for completeness so the `Map`\nand `Keyword` modules provide similar APIs. In practice,\ndevelopers often compare maps using `==/2` or `===/2`\ndirectly.","ref":"Map.html#equal?/2"},{"type":"function","title":"Examples - Map.equal?/2","doc":"iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n    true\n    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n    false\n\nComparison between keys and values is done with `===/3`,\nwhich means integers are not equivalent to floats:\n\n    iex> Map.equal?(%{a: 1.0}, %{a: 1})\n    false","ref":"Map.html#equal?/2-examples"},{"type":"function","title":"Map.fetch/2","doc":"Fetches the value for a specific `key` in the given `map`.\n\nIf `map` contains the given `key` then its value is returned in the shape of `{:ok, value}`.\nIf `map` doesn't contain `key`, `:error` is returned.\n\nInlined by the compiler.","ref":"Map.html#fetch/2"},{"type":"function","title":"Examples - Map.fetch/2","doc":"iex> Map.fetch(%{a: 1}, :a)\n    {:ok, 1}\n    iex> Map.fetch(%{a: 1}, :b)\n    :error","ref":"Map.html#fetch/2-examples"},{"type":"function","title":"Map.fetch!/2","doc":"Fetches the value for a specific `key` in the given `map`, erroring out if\n`map` doesn't contain `key`.\n\nIf `map` contains `key`, the corresponding value is returned. If\n`map` doesn't contain `key`, a `KeyError` exception is raised.\n\nInlined by the compiler.","ref":"Map.html#fetch!/2"},{"type":"function","title":"Examples - Map.fetch!/2","doc":"iex> Map.fetch!(%{a: 1}, :a)\n    1","ref":"Map.html#fetch!/2-examples"},{"type":"function","title":"Map.filter/2","doc":"Returns a map containing only those pairs from `map`\nfor which `fun` returns a truthy value.\n\n`fun` receives the key and value of each of the\nelements in the map as a key-value pair.\n\nSee also `reject/2` which discards all elements where the\nfunction returns a truthy value.\n\n> #### Performance considerations {: .tip}\n>\n> If you find yourself doing multiple calls to `Map.filter/2`\n> and `Map.reject/2` in a pipeline, it is likely more efficient\n> to use `Enum.map/2` and `Enum.filter/2` instead and convert to\n> a map at the end using `Map.new/1`.","ref":"Map.html#filter/2"},{"type":"function","title":"Examples - Map.filter/2","doc":"iex> Map.filter(%{one: 1, two: 2, three: 3}, fn {_key, val} -> rem(val, 2) == 1 end)\n    %{one: 1, three: 3}","ref":"Map.html#filter/2-examples"},{"type":"function","title":"Map.from_keys/2","doc":"Builds a map from the given `keys` and the fixed `value`.","ref":"Map.html#from_keys/2"},{"type":"function","title":"Examples - Map.from_keys/2","doc":"iex> Map.from_keys([1, 2, 3], :number)\n    %{1 => :number, 2 => :number, 3 => :number}","ref":"Map.html#from_keys/2-examples"},{"type":"function","title":"Map.from_struct/1","doc":"Converts a `struct` to map.\n\nIt accepts the struct module or a struct itself and\nsimply removes the `__struct__` field from the given struct\nor from a new struct generated from the given module.","ref":"Map.html#from_struct/1"},{"type":"function","title":"Example - Map.from_struct/1","doc":"defmodule User do\n      defstruct [:name]\n    end\n\n    Map.from_struct(User)\n    #=> %{name: nil}\n\n    Map.from_struct(%User{name: \"john\"})\n    #=> %{name: \"john\"}","ref":"Map.html#from_struct/1-example"},{"type":"function","title":"Map.get/3","doc":"Gets the value for a specific `key` in `map`.\n\nIf `key` is present in `map` then its value `value` is\nreturned. Otherwise, `default` is returned.\n\nIf `default` is not provided, `nil` is used.","ref":"Map.html#get/3"},{"type":"function","title":"Examples - Map.get/3","doc":"iex> Map.get(%{}, :a)\n    nil\n    iex> Map.get(%{a: 1}, :a)\n    1\n    iex> Map.get(%{a: 1}, :b)\n    nil\n    iex> Map.get(%{a: 1}, :b, 3)\n    3\n    iex> Map.get(%{a: nil}, :a, 1)\n    nil","ref":"Map.html#get/3-examples"},{"type":"function","title":"Map.get_and_update/3","doc":"Gets the value from `key` and updates it, all in one pass.\n\n`fun` is called with the current value under `key` in `map` (or `nil` if `key`\nis not present in `map`) and must return a two-element tuple: the current value\n(the retrieved value, which can be operated on before being returned) and the\nnew value to be stored under `key` in the resulting new map. `fun` may also\nreturn `:pop`, which means the current value shall be removed from `map` and\nreturned (making this function behave like `Map.pop(map, key)`).\n\nThe returned value is a two-element tuple with the current value returned by\n`fun` and a new map with the updated value under `key`.","ref":"Map.html#get_and_update/3"},{"type":"function","title":"Examples - Map.get_and_update/3","doc":"iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, %{a: \"new value!\"}}\n\n    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {nil, %{a: 1, b: \"new value!\"}}\n\n    iex> Map.get_and_update(%{a: 1}, :a, fn _ -> :pop end)\n    {1, %{}}\n\n    iex> Map.get_and_update(%{a: 1}, :b, fn _ -> :pop end)\n    {nil, %{a: 1}}","ref":"Map.html#get_and_update/3-examples"},{"type":"function","title":"Map.get_and_update!/3","doc":"Gets the value from `key` and updates it, all in one pass. Raises if there is no `key`.\n\nBehaves exactly like `get_and_update/3`, but raises a `KeyError` exception if\n`key` is not present in `map`.","ref":"Map.html#get_and_update!/3"},{"type":"function","title":"Examples - Map.get_and_update!/3","doc":"iex> Map.get_and_update!(%{a: 1}, :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, %{a: \"new value!\"}}\n\n    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    ** (KeyError) key :b not found in: %{a: 1}\n\n    iex> Map.get_and_update!(%{a: 1}, :a, fn _ ->\n    ...>   :pop\n    ...> end)\n    {1, %{}}","ref":"Map.html#get_and_update!/3-examples"},{"type":"function","title":"Map.get_lazy/3","doc":"Gets the value for a specific `key` in `map`.\n\nIf `key` is present in `map` then its value `value` is\nreturned. Otherwise, `fun` is evaluated and its result is returned.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to setup and teardown again.","ref":"Map.html#get_lazy/3"},{"type":"function","title":"Examples - Map.get_lazy/3","doc":"iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Map.get_lazy(map, :a, fun)\n    1\n    iex> Map.get_lazy(map, :b, fun)\n    13","ref":"Map.html#get_lazy/3-examples"},{"type":"function","title":"Map.has_key?/2","doc":"Returns whether the given `key` exists in the given `map`.\n\nInlined by the compiler.","ref":"Map.html#has_key?/2"},{"type":"function","title":"Examples - Map.has_key?/2","doc":"iex> Map.has_key?(%{a: 1}, :a)\n    true\n    iex> Map.has_key?(%{a: 1}, :b)\n    false","ref":"Map.html#has_key?/2-examples"},{"type":"function","title":"Map.intersect/2","doc":"Intersects two maps, returning a map with the common keys.\n\nThe values in the returned map are the values of the intersected keys in `map2`.\n\nInlined by the compiler.","ref":"Map.html#intersect/2"},{"type":"function","title":"Examples - Map.intersect/2","doc":"iex> Map.intersect(%{a: 1, b: 2}, %{b: \"b\", c: \"c\"})\n    %{b: \"b\"}","ref":"Map.html#intersect/2-examples"},{"type":"function","title":"Map.intersect/3","doc":"Intersects two maps, returning a map with the common keys and resolving conflicts through a function.\n\nThe given function will be invoked when there are duplicate keys; its\narguments are `key` (the duplicate key), `value1` (the value of `key` in\n`map1`), and `value2` (the value of `key` in `map2`). The value returned by\n`fun` is used as the value under `key` in the resulting map.","ref":"Map.html#intersect/3"},{"type":"function","title":"Examples - Map.intersect/3","doc":"iex> Map.intersect(%{a: 1, b: 2}, %{b: 2, c: 3}, fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    %{b: 4}","ref":"Map.html#intersect/3-examples"},{"type":"type","title":"Map.key/0","doc":"","ref":"Map.html#t:key/0"},{"type":"function","title":"Map.keys/1","doc":"Returns all keys from `map`.\n\nInlined by the compiler.","ref":"Map.html#keys/1"},{"type":"function","title":"Examples - Map.keys/1","doc":"Map.keys(%{a: 1, b: 2})\n    [:a, :b]","ref":"Map.html#keys/1-examples"},{"type":"function","title":"Map.merge/2","doc":"Merges two maps into one.\n\nAll keys in `map2` will be added to `map1`, overriding any existing one\n(i.e., the keys in `map2` \"have precedence\" over the ones in `map1`).\n\nIf you have a struct and you would like to merge a set of keys into the\nstruct, do not use this function, as it would merge all keys on the right\nside into the struct, even if the key is not part of the struct. Instead,\nuse `struct/2`.\n\nInlined by the compiler.","ref":"Map.html#merge/2"},{"type":"function","title":"Examples - Map.merge/2","doc":"iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n    %{a: 3, b: 2, d: 4}","ref":"Map.html#merge/2-examples"},{"type":"function","title":"Map.merge/3","doc":"Merges two maps into one, resolving conflicts through the given `fun`.\n\nAll keys in `map2` will be added to `map1`. The given function will be invoked\nwhen there are duplicate keys; its arguments are `key` (the duplicate key),\n`value1` (the value of `key` in `map1`), and `value2` (the value of `key` in\n`map2`). The value returned by `fun` is used as the value under `key` in\nthe resulting map.","ref":"Map.html#merge/3"},{"type":"function","title":"Examples - Map.merge/3","doc":"iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    %{a: 4, b: 2, d: 4}","ref":"Map.html#merge/3-examples"},{"type":"function","title":"Map.new/0","doc":"Returns a new empty map.","ref":"Map.html#new/0"},{"type":"function","title":"Examples - Map.new/0","doc":"iex> Map.new()\n    %{}","ref":"Map.html#new/0-examples"},{"type":"function","title":"Map.new/1","doc":"Creates a map from an `enumerable`.\n\nDuplicated keys are removed; the latest one prevails.","ref":"Map.html#new/1"},{"type":"function","title":"Examples - Map.new/1","doc":"iex> Map.new([{:b, 1}, {:a, 2}])\n    %{a: 2, b: 1}\n    iex> Map.new(a: 1, a: 2, a: 3)\n    %{a: 3}","ref":"Map.html#new/1-examples"},{"type":"function","title":"Map.new/2","doc":"Creates a map from an `enumerable` via the given transformation function.\n\nDuplicated keys are removed; the latest one prevails.","ref":"Map.html#new/2"},{"type":"function","title":"Examples - Map.new/2","doc":"iex> Map.new([:a, :b], fn x -> {x, x} end)\n    %{a: :a, b: :b}\n\n    iex> Map.new(%{a: 2, b: 3, c: 4}, fn {key, val} -> {key, val * 2} end)\n    %{a: 4, b: 6, c: 8}","ref":"Map.html#new/2-examples"},{"type":"function","title":"Map.pop/3","doc":"Removes the value associated with `key` in `map` and returns the value and the updated map.\n\nIf `key` is present in `map`, it returns `{value, updated_map}` where `value` is the value of\nthe key and `updated_map` is the result of removing `key` from `map`. If `key`\nis not present in `map`, `{default, map}` is returned.","ref":"Map.html#pop/3"},{"type":"function","title":"Examples - Map.pop/3","doc":"iex> Map.pop(%{a: 1}, :a)\n    {1, %{}}\n    iex> Map.pop(%{a: 1}, :b)\n    {nil, %{a: 1}}\n    iex> Map.pop(%{a: 1}, :b, 3)\n    {3, %{a: 1}}","ref":"Map.html#pop/3-examples"},{"type":"function","title":"Map.pop!/2","doc":"Removes the value associated with `key` in `map` and returns the value\nand the updated map, or it raises if `key` is not present.\n\nBehaves the same as `pop/3` but raises if `key` is not present in `map`.","ref":"Map.html#pop!/2"},{"type":"function","title":"Examples - Map.pop!/2","doc":"iex> Map.pop!(%{a: 1}, :a)\n    {1, %{}}\n    iex> Map.pop!(%{a: 1, b: 2}, :a)\n    {1, %{b: 2}}\n    iex> Map.pop!(%{a: 1}, :b)\n    ** (KeyError) key :b not found in: %{a: 1}","ref":"Map.html#pop!/2-examples"},{"type":"function","title":"Map.pop_lazy/3","doc":"Lazily returns and removes the value associated with `key` in `map`.\n\nIf `key` is present in `map`, it returns `{value, new_map}` where `value` is the value of\nthe key and `new_map` is the result of removing `key` from `map`. If `key`\nis not present in `map`, `{fun_result, map}` is returned, where `fun_result`\nis the result of applying `fun`.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to setup and teardown again.","ref":"Map.html#pop_lazy/3"},{"type":"function","title":"Examples - Map.pop_lazy/3","doc":"iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Map.pop_lazy(map, :a, fun)\n    {1, %{}}\n    iex> Map.pop_lazy(map, :b, fun)\n    {13, %{a: 1}}","ref":"Map.html#pop_lazy/3-examples"},{"type":"function","title":"Map.put/3","doc":"Puts the given `value` under `key` in `map`.\n\nInlined by the compiler.","ref":"Map.html#put/3"},{"type":"function","title":"Examples - Map.put/3","doc":"iex> Map.put(%{a: 1}, :b, 2)\n    %{a: 1, b: 2}\n    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}","ref":"Map.html#put/3-examples"},{"type":"function","title":"Map.put_new/3","doc":"Puts the given `value` under `key` unless the entry `key`\nalready exists in `map`.","ref":"Map.html#put_new/3"},{"type":"function","title":"Examples - Map.put_new/3","doc":"iex> Map.put_new(%{a: 1}, :b, 2)\n    %{a: 1, b: 2}\n    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n    %{a: 1, b: 2}","ref":"Map.html#put_new/3-examples"},{"type":"function","title":"Map.put_new_lazy/3","doc":"Evaluates `fun` and puts the result under `key`\nin `map` unless `key` is already present.\n\nThis function is useful in case you want to compute the value to put under\n`key` only if `key` is not already present, as for example, when the value is expensive to\ncalculate or generally difficult to setup and teardown again.","ref":"Map.html#put_new_lazy/3"},{"type":"function","title":"Examples - Map.put_new_lazy/3","doc":"iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   3\n    ...> end\n    iex> Map.put_new_lazy(map, :a, fun)\n    %{a: 1}\n    iex> Map.put_new_lazy(map, :b, fun)\n    %{a: 1, b: 3}","ref":"Map.html#put_new_lazy/3-examples"},{"type":"function","title":"Map.reject/2","doc":"Returns map excluding the pairs from `map` for which `fun` returns\na truthy value.\n\nSee also `filter/2`.","ref":"Map.html#reject/2"},{"type":"function","title":"Examples - Map.reject/2","doc":"iex> Map.reject(%{one: 1, two: 2, three: 3}, fn {_key, val} -> rem(val, 2) == 1 end)\n    %{two: 2}","ref":"Map.html#reject/2-examples"},{"type":"function","title":"Map.replace/3","doc":"Puts a value under `key` only if the `key` already exists in `map`.","ref":"Map.html#replace/3"},{"type":"function","title":"Examples - Map.replace/3","doc":"iex> Map.replace(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n    iex> Map.replace(%{a: 1}, :b, 2)\n    %{a: 1}","ref":"Map.html#replace/3-examples"},{"type":"function","title":"Map.replace!/3","doc":"Puts a value under `key` only if the `key` already exists in `map`.\n\nIf `key` is not present in `map`, a `KeyError` exception is raised.\n\nInlined by the compiler.","ref":"Map.html#replace!/3"},{"type":"function","title":"Examples - Map.replace!/3","doc":"iex> Map.replace!(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n    iex> Map.replace!(%{a: 1}, :b, 2)\n    ** (KeyError) key :b not found in: %{a: 1}","ref":"Map.html#replace!/3-examples"},{"type":"function","title":"Map.replace_lazy/3","doc":"Replaces the value under `key` using the given function only if\n`key` already exists in `map`.\n\nIn comparison to `replace/3`, this can be useful when it's expensive to calculate the value.\n\nIf `key` does not exist, the original map is returned unchanged.","ref":"Map.html#replace_lazy/3"},{"type":"function","title":"Examples - Map.replace_lazy/3","doc":"iex> Map.replace_lazy(%{a: 1, b: 2}, :a, fn v -> v * 4 end)\n    %{a: 4, b: 2}\n\n    iex> Map.replace_lazy(%{a: 1, b: 2}, :c, fn v -> v * 4 end)\n    %{a: 1, b: 2}","ref":"Map.html#replace_lazy/3-examples"},{"type":"function","title":"Map.split/2","doc":"Takes all entries corresponding to the given `keys` in `map` and extracts\nthem into a separate map.\n\nReturns a tuple with the new map and the old map with removed keys.\n\nKeys for which there are no entries in `map` are ignored.","ref":"Map.html#split/2"},{"type":"function","title":"Examples - Map.split/2","doc":"iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n    {%{a: 1, c: 3}, %{b: 2}}","ref":"Map.html#split/2-examples"},{"type":"function","title":"Map.split_with/2","doc":"Splits the `map` into two maps according to the given function `fun`.\n\n`fun` receives each `{key, value}` pair in the `map` as its only argument. Returns\na tuple with the first map containing all the elements in `map` for which\napplying `fun` returned a truthy value, and a second map with all the elements\nfor which applying `fun` returned a falsy value (`false` or `nil`).","ref":"Map.html#split_with/2"},{"type":"function","title":"Examples - Map.split_with/2","doc":"iex> Map.split_with(%{a: 1, b: 2, c: 3, d: 4}, fn {_k, v} -> rem(v, 2) == 0 end)\n    {%{b: 2, d: 4}, %{a: 1, c: 3}}\n\n    iex> Map.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {k, _v} -> k in [:b, :d] end)\n    {%{b: -2, d: -3}, %{a: 1, c: 1}}\n\n    iex> Map.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -> v > 50 end)\n    {%{}, %{a: 1, b: -2, c: 1, d: -3}}\n\n    iex> Map.split_with(%{}, fn {_k, v} -> v > 50 end)\n    {%{}, %{}}","ref":"Map.html#split_with/2-examples"},{"type":"function","title":"Map.take/2","doc":"Returns a new map with all the key-value pairs in `map` where the key\nis in `keys`.\n\nIf `keys` contains keys that are not in `map`, they're simply ignored.","ref":"Map.html#take/2"},{"type":"function","title":"Examples - Map.take/2","doc":"iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n    %{a: 1, c: 3}","ref":"Map.html#take/2-examples"},{"type":"function","title":"Map.to_list/1","doc":"Converts `map` to a list.\n\nEach key-value pair in the map is converted to a two-element tuple `{key,\nvalue}` in the resulting list.\n\nInlined by the compiler.","ref":"Map.html#to_list/1"},{"type":"function","title":"Examples - Map.to_list/1","doc":"iex> Map.to_list(%{a: 1})\n    [a: 1]\n    iex> Map.to_list(%{1 => 2})\n    [{1, 2}]","ref":"Map.html#to_list/1-examples"},{"type":"function","title":"Map.update/4","doc":"Updates the `key` in `map` with the given function.\n\nIf `key` is present in `map` then the existing value is passed to `fun` and its result is\nused as the updated value of `key`. If `key` is\nnot present in `map`, `default` is inserted as the value of `key`. The default\nvalue will not be passed through the update function.","ref":"Map.html#update/4"},{"type":"function","title":"Examples - Map.update/4","doc":"iex> Map.update(%{a: 1}, :a, 13, fn existing_value -> existing_value * 2 end)\n    %{a: 2}\n    iex> Map.update(%{a: 1}, :b, 11, fn existing_value -> existing_value * 2 end)\n    %{a: 1, b: 11}","ref":"Map.html#update/4-examples"},{"type":"function","title":"Map.update!/3","doc":"Updates `key` with the given function.\n\nIf `key` is present in `map` then the existing value is passed to `fun` and its result is\nused as the updated value of `key`. If `key` is\nnot present in `map`, a `KeyError` exception is raised.","ref":"Map.html#update!/3"},{"type":"function","title":"Examples - Map.update!/3","doc":"iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n    %{a: 2}\n\n    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n    ** (KeyError) key :b not found in: %{a: 1}","ref":"Map.html#update!/3-examples"},{"type":"type","title":"Map.value/0","doc":"","ref":"Map.html#t:value/0"},{"type":"function","title":"Map.values/1","doc":"Returns all values from `map`.\n\nInlined by the compiler.","ref":"Map.html#values/1"},{"type":"function","title":"Examples - Map.values/1","doc":"Map.values(%{a: 1, b: 2})\n    [1, 2]","ref":"Map.html#values/1-examples"},{"type":"module","title":"MapSet","doc":"Functions that work on sets.\n\nA set is a data structure that can contain unique elements of any kind,\nwithout any particular order. `MapSet` is the \"go to\" set data structure in Elixir.\n\nA set can be constructed using `MapSet.new/0`:\n\n    iex> MapSet.new()\n    MapSet.new([])\n\nElements in a set don't have to be of the same type and they can be\npopulated from an [enumerable](`t:Enumerable.t/0`) using `MapSet.new/1`:\n\n    iex> MapSet.new([1, :two, {\"three\"}])\n    MapSet.new([1, :two, {\"three\"}])\n\nElements can be inserted using `MapSet.put/2`:\n\n    iex> MapSet.new([2]) |> MapSet.put(4) |> MapSet.put(0)\n    MapSet.new([0, 2, 4])\n\nBy definition, sets can't contain duplicate elements: when\ninserting an element in a set where it's already present, the insertion is\nsimply a no-op.\n\n    iex> map_set = MapSet.new()\n    iex> MapSet.put(map_set, \"foo\")\n    MapSet.new([\"foo\"])\n    iex> map_set |> MapSet.put(\"foo\") |> MapSet.put(\"foo\")\n    MapSet.new([\"foo\"])\n\nA `MapSet` is represented internally using the `%MapSet{}` struct. This struct\ncan be used whenever there's a need to pattern match on something being a `MapSet`:\n\n    iex> match?(%MapSet{}, MapSet.new())\n    true\n\nNote that, however, the struct fields are private and must not be accessed\ndirectly; use the functions in this module to perform operations on sets.\n\n`MapSet`s can also be constructed starting from other collection-type data\nstructures: for example, see `MapSet.new/1` or `Enum.into/2`.\n\n`MapSet` is built on top of Erlang's\n[`:sets`](https://www.erlang.org/doc/man/sets.html) (version 2). This means\nthat they share many properties, including logarithmic time complexity. Erlang\n`:sets` (version 2) are implemented on top of maps, so see the documentation\nfor `Map` for more information on its execution time complexity.","ref":"MapSet.html"},{"type":"function","title":"MapSet.delete/2","doc":"Deletes `value` from `map_set`.\n\nReturns a new set which is a copy of `map_set` but without `value`.","ref":"MapSet.html#delete/2"},{"type":"function","title":"Examples - MapSet.delete/2","doc":"iex> map_set = MapSet.new([1, 2, 3])\n    iex> MapSet.delete(map_set, 4)\n    MapSet.new([1, 2, 3])\n    iex> MapSet.delete(map_set, 2)\n    MapSet.new([1, 3])","ref":"MapSet.html#delete/2-examples"},{"type":"function","title":"MapSet.difference/2","doc":"Returns a set that is `map_set1` without the members of `map_set2`.","ref":"MapSet.html#difference/2"},{"type":"function","title":"Examples - MapSet.difference/2","doc":"iex> MapSet.difference(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([1])","ref":"MapSet.html#difference/2-examples"},{"type":"function","title":"MapSet.disjoint?/2","doc":"Checks if `map_set1` and `map_set2` have no members in common.","ref":"MapSet.html#disjoint?/2"},{"type":"function","title":"Examples - MapSet.disjoint?/2","doc":"iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    true\n    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([2, 3]))\n    false","ref":"MapSet.html#disjoint?/2-examples"},{"type":"function","title":"MapSet.equal?/2","doc":"Checks if two sets are equal.\n\nThe comparison between elements is done using `===/2`,\nwhich a set with `1` is not equivalent to a set with\n`1.0`.","ref":"MapSet.html#equal?/2"},{"type":"function","title":"Examples - MapSet.equal?/2","doc":"iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([2, 1, 1]))\n    true\n    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    false\n    iex> MapSet.equal?(MapSet.new([1]), MapSet.new([1.0]))\n    false","ref":"MapSet.html#equal?/2-examples"},{"type":"function","title":"MapSet.filter/2","doc":"Filters the set by returning only the elements from `map_set` for which invoking\n`fun` returns a truthy value.\n\nAlso see `reject/2` which discards all elements where the function returns\na truthy value.\n\n> #### Performance considerations {: .tip}\n>\n> If you find yourself doing multiple calls to `MapSet.filter/2`\n> and `MapSet.reject/2` in a pipeline, it is likely more efficient\n> to use `Enum.map/2` and `Enum.filter/2` instead and convert to\n> a map at the end using `MapSet.new/1`.","ref":"MapSet.html#filter/2"},{"type":"function","title":"Examples - MapSet.filter/2","doc":"iex> MapSet.filter(MapSet.new(1..5), fn x -> x > 3 end)\n    MapSet.new([4, 5])\n\n    iex> MapSet.filter(MapSet.new([\"a\", :b, \"c\"]), &is_atom/1)\n    MapSet.new([:b])","ref":"MapSet.html#filter/2-examples"},{"type":"opaque","title":"MapSet.internal/1","doc":"","ref":"MapSet.html#t:internal/1"},{"type":"function","title":"MapSet.intersection/2","doc":"Returns a set containing only members that `map_set1` and `map_set2` have in common.","ref":"MapSet.html#intersection/2"},{"type":"function","title":"Examples - MapSet.intersection/2","doc":"iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([2])\n\n    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    MapSet.new([])","ref":"MapSet.html#intersection/2-examples"},{"type":"function","title":"MapSet.member?/2","doc":"Checks if `map_set` contains `value`.","ref":"MapSet.html#member?/2"},{"type":"function","title":"Examples - MapSet.member?/2","doc":"iex> MapSet.member?(MapSet.new([1, 2, 3]), 2)\n    true\n    iex> MapSet.member?(MapSet.new([1, 2, 3]), 4)\n    false","ref":"MapSet.html#member?/2-examples"},{"type":"function","title":"MapSet.new/0","doc":"Returns a new set.","ref":"MapSet.html#new/0"},{"type":"function","title":"Examples - MapSet.new/0","doc":"iex> MapSet.new()\n    MapSet.new([])","ref":"MapSet.html#new/0-examples"},{"type":"function","title":"MapSet.new/1","doc":"Creates a set from an enumerable.","ref":"MapSet.html#new/1"},{"type":"function","title":"Examples - MapSet.new/1","doc":"iex> MapSet.new([:b, :a, 3])\n    MapSet.new([3, :a, :b])\n    iex> MapSet.new([3, 3, 3, 2, 2, 1])\n    MapSet.new([1, 2, 3])","ref":"MapSet.html#new/1-examples"},{"type":"function","title":"MapSet.new/2","doc":"Creates a set from an enumerable via the transformation function.","ref":"MapSet.html#new/2"},{"type":"function","title":"Examples - MapSet.new/2","doc":"iex> MapSet.new([1, 2, 1], fn x -> 2 * x end)\n    MapSet.new([2, 4])","ref":"MapSet.html#new/2-examples"},{"type":"function","title":"MapSet.put/2","doc":"Inserts `value` into `map_set` if `map_set` doesn't already contain it.","ref":"MapSet.html#put/2"},{"type":"function","title":"Examples - MapSet.put/2","doc":"iex> MapSet.put(MapSet.new([1, 2, 3]), 3)\n    MapSet.new([1, 2, 3])\n    iex> MapSet.put(MapSet.new([1, 2, 3]), 4)\n    MapSet.new([1, 2, 3, 4])","ref":"MapSet.html#put/2-examples"},{"type":"function","title":"MapSet.reject/2","doc":"Returns a set by excluding the elements from `map_set` for which invoking `fun`\nreturns a truthy value.\n\nSee also `filter/2`.","ref":"MapSet.html#reject/2"},{"type":"function","title":"Examples - MapSet.reject/2","doc":"iex> MapSet.reject(MapSet.new(1..5), fn x -> rem(x, 2) != 0 end)\n    MapSet.new([2, 4])\n\n    iex> MapSet.reject(MapSet.new([\"a\", :b, \"c\"]), &is_atom/1)\n    MapSet.new([\"a\", \"c\"])","ref":"MapSet.html#reject/2-examples"},{"type":"function","title":"MapSet.size/1","doc":"Returns the number of elements in `map_set`.","ref":"MapSet.html#size/1"},{"type":"function","title":"Examples - MapSet.size/1","doc":"iex> MapSet.size(MapSet.new([1, 2, 3]))\n    3","ref":"MapSet.html#size/1-examples"},{"type":"function","title":"MapSet.split_with/2","doc":"Splits the `map_set` into two `MapSet`s according to the given function `fun`.\n\n`fun` receives each element in the `map_set` as its only argument. Returns\na tuple with the first `MapSet` containing all the elements in `map_set` for which\napplying `fun` returned a truthy value, and a second `MapSet` with all the elements\nfor which applying `fun` returned a falsy value (`false` or `nil`).","ref":"MapSet.html#split_with/2"},{"type":"function","title":"Examples - MapSet.split_with/2","doc":"iex> {while_true, while_false} = MapSet.split_with(MapSet.new([1, 2, 3, 4]), fn v -> rem(v, 2) == 0 end)\n    iex> while_true\n    MapSet.new([2, 4])\n    iex> while_false\n    MapSet.new([1, 3])\n\n    iex> {while_true, while_false} = MapSet.split_with(MapSet.new(), fn {_k, v} -> v > 50 end)\n    iex> while_true\n    MapSet.new([])\n    iex> while_false\n    MapSet.new([])","ref":"MapSet.html#split_with/2-examples"},{"type":"function","title":"MapSet.subset?/2","doc":"Checks if `map_set1`'s members are all contained in `map_set2`.\n\nThis function checks if `map_set1` is a subset of `map_set2`.","ref":"MapSet.html#subset?/2"},{"type":"function","title":"Examples - MapSet.subset?/2","doc":"iex> MapSet.subset?(MapSet.new([1, 2]), MapSet.new([1, 2, 3]))\n    true\n    iex> MapSet.subset?(MapSet.new([1, 2, 3]), MapSet.new([1, 2]))\n    false","ref":"MapSet.html#subset?/2-examples"},{"type":"function","title":"MapSet.symmetric_difference/2","doc":"Returns a set with elements that are present in only one but not both sets.","ref":"MapSet.html#symmetric_difference/2"},{"type":"function","title":"Examples - MapSet.symmetric_difference/2","doc":"iex> MapSet.symmetric_difference(MapSet.new([1, 2, 3]), MapSet.new([2, 3, 4]))\n    MapSet.new([1, 4])","ref":"MapSet.html#symmetric_difference/2-examples"},{"type":"type","title":"MapSet.t/0","doc":"","ref":"MapSet.html#t:t/0"},{"type":"type","title":"MapSet.t/1","doc":"","ref":"MapSet.html#t:t/1"},{"type":"function","title":"MapSet.to_list/1","doc":"Converts `map_set` to a list.","ref":"MapSet.html#to_list/1"},{"type":"function","title":"Examples - MapSet.to_list/1","doc":"iex> MapSet.to_list(MapSet.new([1, 2, 3]))\n    [1, 2, 3]","ref":"MapSet.html#to_list/1-examples"},{"type":"function","title":"MapSet.union/2","doc":"Returns a set containing all members of `map_set1` and `map_set2`.","ref":"MapSet.html#union/2"},{"type":"function","title":"Examples - MapSet.union/2","doc":"iex> MapSet.union(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([1, 2, 3, 4])","ref":"MapSet.html#union/2-examples"},{"type":"type","title":"MapSet.value/0","doc":"","ref":"MapSet.html#t:value/0"},{"type":"module","title":"Range","doc":"Ranges represent a sequence of zero, one or many, ascending\nor descending integers with a common difference called step.\n\nThe most common form of creating and matching on ranges is\nvia the [`first..last`](`../2`) and [`first..last//step`](`..///3`)\nnotations, auto-imported from `Kernel`:\n\n    iex> 1 in 1..10\n    true\n    iex> 5 in 1..10\n    true\n    iex> 10 in 1..10\n    true\n\nRanges are always inclusive in Elixir. When a step is defined,\nintegers will only belong to the range if they match the step:\n\n    iex> 5 in 1..10//2\n    true\n    iex> 4 in 1..10//2\n    false\n\nWhen defining a range without a step, the step will be\ndefined based on the first and last position of the\nrange, If `last >= first`, it will be an increasing range\nwith a step of 1. Otherwise, it is a decreasing range.\nNote, however, implicit decreasing ranges are deprecated.\nTherefore, if you need a decreasing range from `3` to `1`,\nprefer to write `3..1//-1` instead.\n\n`../0` can also be used as a shortcut to create the range `0..-1//1`,\nalso known as the full-slice range:\n\n    iex> ..\n    0..-1//1","ref":"Range.html"},{"type":"module","title":"Use cases - Range","doc":"Ranges typically have two uses in Elixir: as a collection or\nto represent a slice of another data structure.","ref":"Range.html#module-use-cases"},{"type":"module","title":"Ranges as collections - Range","doc":"Ranges in Elixir are enumerables and therefore can be used\nwith the `Enum` module:\n\n    iex> Enum.to_list(1..3)\n    [1, 2, 3]\n    iex> Enum.to_list(3..1//-1)\n    [3, 2, 1]\n    iex> Enum.to_list(1..5//2)\n    [1, 3, 5]\n\nRanges may also have a single element:\n\n    iex> Enum.to_list(1..1)\n    [1]\n    iex> Enum.to_list(1..1//2)\n    [1]\n\nOr even no elements at all:\n\n    iex> Enum.to_list(10..0//1)\n    []\n    iex> Enum.to_list(0..10//-1)\n    []\n\nThe full-slice range, returned by `../0`, is an empty collection:\n\n    iex> Enum.to_list(..)\n    []","ref":"Range.html#module-ranges-as-collections"},{"type":"module","title":"Ranges as slices - Range","doc":"Ranges are also frequently used to slice collections.\nYou can slice strings or any enumerable:\n\n    iex> String.slice(\"elixir\", 1..4)\n    \"lixi\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], 1..4)\n    [1, 2, 3, 4]\n\nIn those cases, the first and last values of the range\nare mapped to positions in the collections.\n\nIf a negative number is given, it maps to a position\nfrom the back:\n\n    iex> String.slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], 1..-2//1)\n    [1, 2, 3, 4]\n\nThe range `0..-1//1`, returned by `../0`, returns the\ncollection as is, which is why it is called the full-slice\nrange:\n\n    iex> String.slice(\"elixir\", ..)\n    \"elixir\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], ..)\n    [0, 1, 2, 3, 4, 5]","ref":"Range.html#module-ranges-as-slices"},{"type":"module","title":"Definition - Range","doc":"An increasing range `first..last//step` is a range from `first`\nto `last` increasing by `step` where  `step` must be a positive\ninteger and all values `v` must be `first <= v and v <= last`.\nTherefore, a range `10..0//1` is an empty range because there\nis no value `v` that is `10 <= v and v <= 0`.\n\nSimilarly, a decreasing range `first..last//step` is a range\nfrom `first` to `last` decreasing by `step` where `step` must\nbe a negative integer and  values `v` must be `first >= v and v >= last`.\nTherefore, a range `0..10//-1` is an empty range because there\nis no value `v` that is `0 >= v and v >= 10`.","ref":"Range.html#module-definition"},{"type":"module","title":"Representation - Range","doc":"Internally, ranges are represented as structs:\n\n    iex> range = 1..9//2\n    1..9//2\n    iex> first..last//step = range\n    iex> first\n    1\n    iex> last\n    9\n    iex> step\n    2\n    iex> range.step\n    2\n\nYou can access the range fields (`first`, `last`, and `step`)\ndirectly but you should not modify nor create ranges by hand.\nInstead use the proper operators or `new/2` and `new/3`.\n\nRanges implement the `Enumerable` protocol with memory\nefficient versions of all `Enumerable` callbacks:\n\n    iex> range = 1..10\n    1..10\n    iex> Enum.reduce(range, 0, fn i, acc -> i * i + acc end)\n    385\n    iex> Enum.count(range)\n    10\n    iex> Enum.member?(range, 11)\n    false\n    iex> Enum.member?(range, 8)\n    true\n\nSuch function calls are efficient memory-wise no matter the\nsize of the range. The implementation of the `Enumerable`\nprotocol uses logic based solely on the endpoints and does\nnot materialize the whole list of integers.","ref":"Range.html#module-representation"},{"type":"function","title":"Range.disjoint?/2","doc":"Checks if two ranges are disjoint.","ref":"Range.html#disjoint?/2"},{"type":"function","title":"Examples - Range.disjoint?/2","doc":"iex> Range.disjoint?(1..5, 6..9)\n    true\n    iex> Range.disjoint?(5..1//-1, 6..9)\n    true\n    iex> Range.disjoint?(1..5, 5..9)\n    false\n    iex> Range.disjoint?(1..5, 2..7)\n    false\n\nSteps are also considered when computing the ranges to be disjoint:\n\n    iex> Range.disjoint?(1..10//2, 2..10//2)\n    true\n\n    # First element in common is 29\n    iex> Range.disjoint?(1..100//14, 8..100//21)\n    false\n    iex> Range.disjoint?(57..-1//-14, 8..100//21)\n    false\n    iex> Range.disjoint?(1..100//14, 50..8//-21)\n    false\n    iex> Range.disjoint?(1..28//14, 8..28//21)\n    true\n\n    # First element in common is 14\n    iex> Range.disjoint?(2..28//3, 9..28//5)\n    false\n    iex> Range.disjoint?(26..2//-3, 29..9//-5)\n    false\n\n    # Starting from the back without alignment\n    iex> Range.disjoint?(27..11//-3, 30..0//-7)\n    true","ref":"Range.html#disjoint?/2-examples"},{"type":"type","title":"Range.limit/0","doc":"","ref":"Range.html#t:limit/0"},{"type":"function","title":"Range.new/2","doc":"Creates a new range.\n\nIf `first` is less than `last`, the range will be increasing from\n`first` to `last`. If `first` is equal to `last`, the range will contain\none element, which is the number itself.\n\nIf `first` is greater than `last`, the range will be decreasing from `first`\nto `last`, albeit this behavior is deprecated. Therefore, it is advised to\nexplicitly list the step with `new/3`.","ref":"Range.html#new/2"},{"type":"function","title":"Examples - Range.new/2","doc":"iex> Range.new(-100, 100)\n    -100..100","ref":"Range.html#new/2-examples"},{"type":"function","title":"Range.new/3","doc":"Creates a new range with `step`.","ref":"Range.html#new/3"},{"type":"function","title":"Examples - Range.new/3","doc":"iex> Range.new(-100, 100, 2)\n    -100..100//2","ref":"Range.html#new/3-examples"},{"type":"function","title":"Range.shift/2","doc":"Shifts a range by the given number of steps.","ref":"Range.html#shift/2"},{"type":"function","title":"Examples - Range.shift/2","doc":"iex> Range.shift(0..10, 1)\n    1..11\n    iex> Range.shift(0..10, 2)\n    2..12\n\n    iex> Range.shift(0..10//2, 2)\n    4..14//2\n    iex> Range.shift(10..0//-2, 2)\n    6..-4//-2","ref":"Range.html#shift/2-examples"},{"type":"function","title":"Range.size/1","doc":"Returns the size of `range`.","ref":"Range.html#size/1"},{"type":"function","title":"Examples - Range.size/1","doc":"iex> Range.size(1..10)\n    10\n    iex> Range.size(1..10//2)\n    5\n    iex> Range.size(1..10//3)\n    4\n    iex> Range.size(1..10//-1)\n    0\n\n    iex> Range.size(10..1//-1)\n    10\n    iex> Range.size(10..1//-2)\n    5\n    iex> Range.size(10..1//-3)\n    4\n    iex> Range.size(10..1//1)\n    0","ref":"Range.html#size/1-examples"},{"type":"function","title":"Range.split/2","doc":"Splits a range in two.\n\nIt returns a tuple of two elements.\n\nIf `split` is less than the number of elements in the range, the first\nelement in the range will have `split` entries and the second will have\nall remaining entries.\n\nIf `split` is more than the number of elements in the range, the second\nrange in the tuple will emit zero elements.","ref":"Range.html#split/2"},{"type":"function","title":"Examples - Range.split/2","doc":"Increasing ranges:\n\n    iex> Range.split(1..5, 2)\n    {1..2, 3..5}\n\n    iex> Range.split(1..5//2, 2)\n    {1..3//2, 5..5//2}\n\n    iex> Range.split(1..5//2, 0)\n    {1..-1//2, 1..5//2}\n\n    iex> Range.split(1..5//2, 10)\n    {1..5//2, 7..5//2}\n\nDecreasing ranges can also be split:\n\n    iex> Range.split(5..1//-1, 2)\n    {5..4//-1, 3..1//-1}\n\n    iex> Range.split(5..1//-2, 2)\n    {5..3//-2, 1..1//-2}\n\n    iex> Range.split(5..1//-2, 0)\n    {5..7//-2, 5..1//-2}\n\n    iex> Range.split(5..1//-2, 10)\n    {5..1//-2, -1..1//-2}\n\nEmpty ranges preserve their property but still return empty ranges:\n\n    iex> Range.split(2..5//-1, 2)\n    {2..3//-1, 4..5//-1}\n\n    iex> Range.split(2..5//-1, 10)\n    {2..3//-1, 4..5//-1}\n\n    iex> Range.split(5..2//1, 2)\n    {5..4//1, 3..2//1}\n\n    iex> Range.split(5..2//1, 10)\n    {5..4//1, 3..2//1}\n\nIf the number to split is negative, it splits from the back:\n\n    iex> Range.split(1..5, -2)\n    {1..3, 4..5}\n\n    iex> Range.split(5..1//-1, -2)\n    {5..3//-1, 2..1//-1}\n\nIf it is negative and greater than the elements in the range,\nthe first element of the tuple will be an empty range:\n\n    iex> Range.split(1..5, -10)\n    {1..0//1, 1..5}\n\n    iex> Range.split(5..1//-1, -10)\n    {5..6//-1, 5..1//-1}","ref":"Range.html#split/2-examples"},{"type":"function","title":"Properties - Range.split/2","doc":"When a range is split, the following properties are observed.\nGiven `split(input)` returns `{left, right}`, we have:\n\n    assert input.first == left.first\n    assert input.last == right.last\n    assert input.step == left.step\n    assert input.step == right.step\n    assert Range.size(input) == Range.size(left) + Range.size(right)","ref":"Range.html#split/2-properties"},{"type":"type","title":"Range.step/0","doc":"","ref":"Range.html#t:step/0"},{"type":"type","title":"Range.t/0","doc":"","ref":"Range.html#t:t/0"},{"type":"type","title":"Range.t/2","doc":"","ref":"Range.html#t:t/2"},{"type":"function","title":"Range.to_list/1","doc":"Converts a range to a list.","ref":"Range.html#to_list/1"},{"type":"function","title":"Examples - Range.to_list/1","doc":"iex> Range.to_list(0..5)\n    [0, 1, 2, 3, 4, 5]\n    iex> Range.to_list(-3..0)\n    [-3, -2, -1, 0]","ref":"Range.html#to_list/1-examples"},{"type":"module","title":"Stream","doc":"Functions for creating and composing streams.\n\nStreams are composable, lazy enumerables (for an introduction on\nenumerables, see the `Enum` module). Any enumerable that generates\nelements one by one during enumeration is called a stream. For example,\nElixir's `Range` is a stream:\n\n    iex> range = 1..5\n    1..5\n    iex> Enum.map(range, &(&1 * 2))\n    [2, 4, 6, 8, 10]\n\nIn the example above, as we mapped over the range, the elements being\nenumerated were created one by one, during enumeration. The `Stream`\nmodule allows us to map the range, without triggering its enumeration:\n\n    iex> range = 1..3\n    iex> stream = Stream.map(range, &(&1 * 2))\n    iex> Enum.map(stream, &(&1 + 1))\n    [3, 5, 7]\n\nNote that we started with a range and then we created a stream that is\nmeant to multiply each element in the range by 2. At this point, no\ncomputation was done. Only when `Enum.map/2` is called we actually\nenumerate over each element in the range, multiplying it by 2 and adding 1.\nWe say the functions in `Stream` are *lazy* and the functions in `Enum`\nare *eager*.\n\nDue to their laziness, streams are useful when working with large\n(or even infinite) collections. When chaining many operations with `Enum`,\nintermediate lists are created, while `Stream` creates a recipe of\ncomputations that are executed at a later moment. Let's see another\nexample:\n\n    1..3\n    |> Enum.map(&IO.inspect(&1))\n    |> Enum.map(&(&1 * 2))\n    |> Enum.map(&IO.inspect(&1))\n    1\n    2\n    3\n    2\n    4\n    6\n    #=> [2, 4, 6]\n\nNote that we first printed each element in the list, then multiplied each\nelement by 2 and finally printed each new value. In this example, the list\nwas enumerated three times. Let's see an example with streams:\n\n    stream = 1..3\n    |> Stream.map(&IO.inspect(&1))\n    |> Stream.map(&(&1 * 2))\n    |> Stream.map(&IO.inspect(&1))\n    Enum.to_list(stream)\n    1\n    2\n    2\n    4\n    3\n    6\n    #=> [2, 4, 6]\n\nAlthough the end result is the same, the order in which the elements were\nprinted changed! With streams, we print the first element and then print\nits double. In this example, the list was enumerated just once!\n\nThat's what we meant when we said earlier that streams are composable,\nlazy enumerables. Note that we could call `Stream.map/2` multiple times,\neffectively composing the streams and keeping them lazy. The computations\nare only performed when you call a function from the `Enum` module.\n\nLike with `Enum`, the functions in this module work in linear time. This\nmeans that, the time it takes to perform an operation grows at the same\nrate as the length of the list. This is expected on operations such as\n`Stream.map/2`. After all, if we want to traverse every element on a\nstream, the longer the stream, the more elements we need to traverse,\nand the longer it will take.","ref":"Stream.html"},{"type":"module","title":"Creating Streams - Stream","doc":"There are many functions in Elixir's standard library that return\nstreams, some examples are:\n\n  * `IO.stream/2`         - streams input lines, one by one\n  * `URI.query_decoder/1` - decodes a query string, pair by pair\n\nThis module also provides many convenience functions for creating streams,\nlike `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n\nNote the functions in this module are guaranteed to return enumerables.\nSince enumerables can have different shapes (structs, anonymous functions,\nand so on), the functions in this module may return any of those shapes\nand this may change at any time. For example, a function that today\nreturns an anonymous function may return a struct in future releases.","ref":"Stream.html#module-creating-streams"},{"type":"type","title":"Stream.acc/0","doc":"","ref":"Stream.html#t:acc/0"},{"type":"function","title":"Stream.chunk_by/2","doc":"Chunks the `enum` by buffering elements for which `fun` returns the same value.\n\nElements are only emitted when `fun` returns a new value or the `enum` finishes.","ref":"Stream.html#chunk_by/2"},{"type":"function","title":"Examples - Stream.chunk_by/2","doc":"iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n    iex> Enum.to_list(stream)\n    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]","ref":"Stream.html#chunk_by/2-examples"},{"type":"function","title":"Stream.chunk_every/2","doc":"Shortcut to `chunk_every(enum, count, count)`.","ref":"Stream.html#chunk_every/2"},{"type":"function","title":"Stream.chunk_every/4","doc":"Streams the enumerable in chunks, containing `count` elements each,\nwhere each new chunk starts `step` elements into the enumerable.\n\n`step` is optional and, if not passed, defaults to `count`, i.e.\nchunks do not overlap. Chunking will stop as soon as the collection\nends or when we emit an incomplete chunk.\n\nIf the last chunk does not have `count` elements to fill the chunk,\nelements are taken from `leftover` to fill in the chunk. If `leftover`\ndoes not have enough elements to fill the chunk, then a partial chunk\nis returned with less than `count` elements.\n\nIf `:discard` is given in `leftover`, the last chunk is discarded\nunless it has exactly `count` elements.","ref":"Stream.html#chunk_every/4"},{"type":"function","title":"Examples - Stream.chunk_every/4","doc":"iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list()\n    [[1, 2], [3, 4], [5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list()\n    [[1, 2, 3], [4, 5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0])) |> Enum.to_list()\n    [[1, 2, 3], [4, 0, 0]]","ref":"Stream.html#chunk_every/4-examples"},{"type":"function","title":"Stream.chunk_while/4","doc":"Chunks the `enum` with fine grained control when every chunk is emitted.\n\n`chunk_fun` receives the current element and the accumulator and\nmust return `{:cont, element, acc}` to emit the given chunk and\ncontinue with accumulator or `{:cont, acc}` to not emit any chunk\nand continue with the return accumulator.\n\n`after_fun` is invoked when iteration is done and must also return\n`{:cont, element, acc}` or `{:cont, acc}`.","ref":"Stream.html#chunk_while/4"},{"type":"function","title":"Examples - Stream.chunk_while/4","doc":"iex> chunk_fun = fn element, acc ->\n    ...>   if rem(element, 2) == 0 do\n    ...>     {:cont, Enum.reverse([element | acc]), []}\n    ...>   else\n    ...>     {:cont, [element | acc]}\n    ...>   end\n    ...> end\n    iex> after_fun = fn\n    ...>   [] -> {:cont, []}\n    ...>   acc -> {:cont, Enum.reverse(acc), []}\n    ...> end\n    iex> stream = Stream.chunk_while(1..10, [], chunk_fun, after_fun)\n    iex> Enum.to_list(stream)\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]","ref":"Stream.html#chunk_while/4-examples"},{"type":"function","title":"Stream.concat/1","doc":"Creates a stream that enumerates each enumerable in an enumerable.","ref":"Stream.html#concat/1"},{"type":"function","title":"Examples - Stream.concat/1","doc":"iex> stream = Stream.concat([1..3, 4..6, 7..9])\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]","ref":"Stream.html#concat/1-examples"},{"type":"function","title":"Stream.concat/2","doc":"Creates a stream that enumerates the first argument, followed by the second.","ref":"Stream.html#concat/2"},{"type":"function","title":"Examples - Stream.concat/2","doc":"iex> stream = Stream.concat(1..3, 4..6)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> stream1 = Stream.cycle([1, 2, 3])\n    iex> stream2 = Stream.cycle([4, 5, 6])\n    iex> stream = Stream.concat(stream1, stream2)\n    iex> Enum.take(stream, 6)\n    [1, 2, 3, 1, 2, 3]","ref":"Stream.html#concat/2-examples"},{"type":"function","title":"Stream.cycle/1","doc":"Creates a stream that cycles through the given enumerable,\ninfinitely.","ref":"Stream.html#cycle/1"},{"type":"function","title":"Examples - Stream.cycle/1","doc":"iex> stream = Stream.cycle([1, 2, 3])\n    iex> Enum.take(stream, 5)\n    [1, 2, 3, 1, 2]","ref":"Stream.html#cycle/1-examples"},{"type":"function","title":"Stream.dedup/1","doc":"Creates a stream that only emits elements if they are different from the last emitted element.\n\nThis function only ever needs to store the last emitted element.\n\nElements are compared using `===/2`.","ref":"Stream.html#dedup/1"},{"type":"function","title":"Examples - Stream.dedup/1","doc":"iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3, 2, 1]","ref":"Stream.html#dedup/1-examples"},{"type":"function","title":"Stream.dedup_by/2","doc":"Creates a stream that only emits elements if the result of calling `fun` on the element is\ndifferent from the (stored) result of calling `fun` on the last emitted element.","ref":"Stream.html#dedup_by/2"},{"type":"function","title":"Examples - Stream.dedup_by/2","doc":"iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}, {1, :x}]","ref":"Stream.html#dedup_by/2-examples"},{"type":"type","title":"Stream.default/0","doc":"","ref":"Stream.html#t:default/0"},{"type":"function","title":"Stream.drop/2","doc":"Lazily drops the next `n` elements from the enumerable.\n\nIf a negative `n` is given, it will drop the last `n` elements from\nthe collection. Note that the mechanism by which this is implemented\nwill delay the emission of any element until `n` additional elements have\nbeen emitted by the enum.","ref":"Stream.html#drop/2"},{"type":"function","title":"Examples - Stream.drop/2","doc":"iex> stream = Stream.drop(1..10, 5)\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]\n\n    iex> stream = Stream.drop(1..10, -5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]","ref":"Stream.html#drop/2-examples"},{"type":"function","title":"Stream.drop_every/2","doc":"Creates a stream that drops every `nth` element from the enumerable.\n\nThe first element is always dropped, unless `nth` is 0.\n\n`nth` must be a non-negative integer.","ref":"Stream.html#drop_every/2"},{"type":"function","title":"Examples - Stream.drop_every/2","doc":"iex> stream = Stream.drop_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.drop_every(1..1000, 1)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.drop_every([1, 2, 3, 4, 5], 0)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]","ref":"Stream.html#drop_every/2-examples"},{"type":"function","title":"Stream.drop_while/2","doc":"Lazily drops elements of the enumerable while the given\nfunction returns a truthy value.","ref":"Stream.html#drop_while/2"},{"type":"function","title":"Examples - Stream.drop_while/2","doc":"iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]","ref":"Stream.html#drop_while/2-examples"},{"type":"function","title":"Stream.duplicate/2","doc":"Duplicates the given element `n` times in a stream.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty stream is returned.","ref":"Stream.html#duplicate/2"},{"type":"function","title":"Examples - Stream.duplicate/2","doc":"iex> stream = Stream.duplicate(\"hello\", 0)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.duplicate(\"hi\", 1)\n    iex> Enum.to_list(stream)\n    [\"hi\"]\n\n    iex> stream = Stream.duplicate(\"bye\", 2)\n    iex> Enum.to_list(stream)\n    [\"bye\", \"bye\"]\n\n    iex> stream = Stream.duplicate([1, 2], 3)\n    iex> Enum.to_list(stream)\n    [[1, 2], [1, 2], [1, 2]]","ref":"Stream.html#duplicate/2-examples"},{"type":"function","title":"Stream.each/2","doc":"Executes the given function for each element.\n\nThe values in the stream do not change, therefore this\nfunction is useful for adding side effects (like printing)\nto a stream. See `map/2` if producing a different stream\nis desired.","ref":"Stream.html#each/2"},{"type":"function","title":"Examples - Stream.each/2","doc":"iex> stream = Stream.each([1, 2, 3], fn x -> send(self(), x) end)\n    iex> Enum.to_list(stream)\n    iex> receive do: (x when is_integer(x) -> x)\n    1\n    iex> receive do: (x when is_integer(x) -> x)\n    2\n    iex> receive do: (x when is_integer(x) -> x)\n    3","ref":"Stream.html#each/2-examples"},{"type":"type","title":"Stream.element/0","doc":"","ref":"Stream.html#t:element/0"},{"type":"function","title":"Stream.filter/2","doc":"Creates a stream that filters elements according to\nthe given function on enumeration.","ref":"Stream.html#filter/2"},{"type":"function","title":"Examples - Stream.filter/2","doc":"iex> stream = Stream.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [2]","ref":"Stream.html#filter/2-examples"},{"type":"function","title":"Stream.flat_map/2","doc":"Maps the given `fun` over `enumerable` and flattens the result.\n\nThis function returns a new stream built by appending the result of invoking `fun`\non each element of `enumerable` together.","ref":"Stream.html#flat_map/2"},{"type":"function","title":"Examples - Stream.flat_map/2","doc":"iex> stream = Stream.flat_map([1, 2, 3], fn x -> [x, x * 2] end)\n    iex> Enum.to_list(stream)\n    [1, 2, 2, 4, 3, 6]\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [[x]] end)\n    iex> Enum.to_list(stream)\n    [[1], [2], [3]]","ref":"Stream.html#flat_map/2-examples"},{"type":"function","title":"Stream.from_index/1","doc":"Builds a stream from an index, either starting from offset, or given by function.\n\nMay receive a function or an integer offset.\n\nIf an `offset` is given, it will emit elements from offset.\n\nIf a `function` is given, it will invoke the function with\nelements from offset.","ref":"Stream.html#from_index/1"},{"type":"function","title":"Examples - Stream.from_index/1","doc":"iex> Stream.from_index() |> Enum.take(3)\n    [0, 1, 2]\n\n    iex> Stream.from_index(1) |> Enum.take(3)\n    [1, 2, 3]\n\n    iex> Stream.from_index(fn x -> x * 10 end) |> Enum.take(3)\n    [0, 10, 20]","ref":"Stream.html#from_index/1-examples"},{"type":"type","title":"Stream.index/0","doc":"Zero-based index.","ref":"Stream.html#t:index/0"},{"type":"function","title":"Stream.intersperse/2","doc":"Lazily intersperses `intersperse_element` between each element of the enumeration.","ref":"Stream.html#intersperse/2"},{"type":"function","title":"Examples - Stream.intersperse/2","doc":"iex> Stream.intersperse([1, 2, 3], 0) |> Enum.to_list()\n    [1, 0, 2, 0, 3]\n\n    iex> Stream.intersperse([1], 0) |> Enum.to_list()\n    [1]\n\n    iex> Stream.intersperse([], 0) |> Enum.to_list()\n    []","ref":"Stream.html#intersperse/2-examples"},{"type":"function","title":"Stream.interval/1","doc":"Creates a stream that emits a value after the given period `n`\nin milliseconds.\n\nThe values emitted are an increasing counter starting at `0`.\nThis operation will block the caller by the given interval\nevery time a new element is streamed.\n\nDo not use this function to generate a sequence of numbers.\nIf blocking the caller process is not necessary, use\n`Stream.iterate(0, & &1 + 1)` instead.","ref":"Stream.html#interval/1"},{"type":"function","title":"Examples - Stream.interval/1","doc":"iex> Stream.interval(10) |> Enum.take(10)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","ref":"Stream.html#interval/1-examples"},{"type":"function","title":"Stream.into/3","doc":"Injects the stream values into the given collectable as a side-effect.\n\nThis function is often used with `run/1` since any evaluation\nis delayed until the stream is executed. See `run/1` for an example.","ref":"Stream.html#into/3"},{"type":"function","title":"Stream.iterate/2","doc":"Emits a sequence of values, starting with `start_value`.\n\nSuccessive values are generated by calling `next_fun`\non the previous value.","ref":"Stream.html#iterate/2"},{"type":"function","title":"Examples - Stream.iterate/2","doc":"iex> Stream.iterate(1, &(&1 * 2)) |> Enum.take(5)\n    [1, 2, 4, 8, 16]","ref":"Stream.html#iterate/2-examples"},{"type":"function","title":"Stream.map/2","doc":"Creates a stream that will apply the given function on\nenumeration.","ref":"Stream.html#map/2"},{"type":"function","title":"Examples - Stream.map/2","doc":"iex> stream = Stream.map([1, 2, 3], fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6]","ref":"Stream.html#map/2-examples"},{"type":"function","title":"Stream.map_every/3","doc":"Creates a stream that will apply the given function on\nevery `nth` element from the enumerable.\n\nThe first element is always passed to the given function.\n\n`nth` must be a non-negative integer.","ref":"Stream.html#map_every/3"},{"type":"function","title":"Examples - Stream.map_every/3","doc":"iex> stream = Stream.map_every(1..10, 2, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n\n    iex> stream = Stream.map_every([1, 2, 3, 4, 5], 1, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.map_every(1..5, 0, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]","ref":"Stream.html#map_every/3-examples"},{"type":"function","title":"Stream.reject/2","doc":"Creates a stream that will reject elements according to\nthe given function on enumeration.","ref":"Stream.html#reject/2"},{"type":"function","title":"Examples - Stream.reject/2","doc":"iex> stream = Stream.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [1, 3]","ref":"Stream.html#reject/2-examples"},{"type":"function","title":"Stream.repeatedly/1","doc":"Returns a stream generated by calling `generator_fun` repeatedly.","ref":"Stream.html#repeatedly/1"},{"type":"function","title":"Examples - Stream.repeatedly/1","doc":"# Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Stream.repeatedly(&:rand.uniform/0) |> Enum.take(3)\n    [0.5455598952593053, 0.6039309974353404, 0.6684893034823949]","ref":"Stream.html#repeatedly/1-examples"},{"type":"function","title":"Stream.resource/3","doc":"Emits a sequence of values for the given resource.\n\nSimilar to `transform/3` but the initial accumulated value is\ncomputed lazily via `start_fun` and executes an `after_fun` at\nthe end of enumeration (both in cases of success and failure).\n\nSuccessive values are generated by calling `next_fun` with the\nprevious accumulator (the initial value being the result returned\nby `start_fun`) and it must return a tuple containing a list\nof elements to be emitted and the next accumulator. The enumeration\nfinishes if it returns `{:halt, acc}`.\n\nAs the function name suggests, this function is useful to stream values from\nresources.","ref":"Stream.html#resource/3"},{"type":"function","title":"Examples - Stream.resource/3","doc":"Stream.resource(\n      fn -> File.open!(\"sample\") end,\n      fn file ->\n        case IO.read(file, :line) do\n          data when is_binary(data) -> {[data], file}\n          _ -> {:halt, file}\n        end\n      end,\n      fn file -> File.close(file) end\n    )\n\n    iex> Stream.resource(\n    ...>  fn ->\n    ...>    {:ok, pid} = StringIO.open(\"string\")\n    ...>    pid\n    ...>  end,\n    ...>  fn pid ->\n    ...>    case IO.getn(pid, \"\", 1) do\n    ...>      :eof -> {:halt, pid}\n    ...>      char -> {[char], pid}\n    ...>    end\n    ...>  end,\n    ...>  fn pid -> StringIO.close(pid) end\n    ...> ) |> Enum.to_list()\n    [\"s\", \"t\", \"r\", \"i\", \"n\", \"g\"]","ref":"Stream.html#resource/3-examples"},{"type":"function","title":"Stream.run/1","doc":"Runs the given stream.\n\nThis is useful when a stream needs to be run, for side effects,\nand there is no interest in its return result.","ref":"Stream.html#run/1"},{"type":"function","title":"Examples - Stream.run/1","doc":"Open up a file, replace all `#` by `%` and stream to another file\nwithout loading the whole file in memory:\n\n    File.stream!(\"/path/to/file\")\n    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n    |> Stream.into(File.stream!(\"/path/to/other/file\"))\n    |> Stream.run()\n\nNo computation will be done until we call one of the `Enum` functions\nor `run/1`.","ref":"Stream.html#run/1-examples"},{"type":"function","title":"Stream.scan/2","doc":"Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the first element in the enumerable\nas the starting value.","ref":"Stream.html#scan/2"},{"type":"function","title":"Examples - Stream.scan/2","doc":"iex> stream = Stream.scan(1..5, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]","ref":"Stream.html#scan/2-examples"},{"type":"function","title":"Stream.scan/3","doc":"Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the given `acc` as the starting value.","ref":"Stream.html#scan/3"},{"type":"function","title":"Examples - Stream.scan/3","doc":"iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]","ref":"Stream.html#scan/3-examples"},{"type":"function","title":"Stream.take/2","doc":"Lazily takes the next `count` elements from the enumerable and stops\nenumeration.\n\nIf a negative `count` is given, the last `count` values will be taken.\nFor such, the collection is fully enumerated keeping up to `2 * count`\nelements in memory. Once the end of the collection is reached,\nthe last `count` elements will be executed. Therefore, using\na negative `count` on an infinite collection will never return.","ref":"Stream.html#take/2"},{"type":"function","title":"Examples - Stream.take/2","doc":"iex> stream = Stream.take(1..100, 5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take(1..100, -5)\n    iex> Enum.to_list(stream)\n    [96, 97, 98, 99, 100]\n\n    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 1, 2]","ref":"Stream.html#take/2-examples"},{"type":"function","title":"Stream.take_every/2","doc":"Creates a stream that takes every `nth` element from the enumerable.\n\nThe first element is always included, unless `nth` is 0.\n\n`nth` must be a non-negative integer.","ref":"Stream.html#take_every/2"},{"type":"function","title":"Examples - Stream.take_every/2","doc":"iex> stream = Stream.take_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [1, 3, 5, 7, 9]\n\n    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take_every(1..1000, 0)\n    iex> Enum.to_list(stream)\n    []","ref":"Stream.html#take_every/2-examples"},{"type":"function","title":"Stream.take_while/2","doc":"Lazily takes elements of the enumerable while the given\nfunction returns a truthy value.","ref":"Stream.html#take_while/2"},{"type":"function","title":"Examples - Stream.take_while/2","doc":"iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]","ref":"Stream.html#take_while/2-examples"},{"type":"type","title":"Stream.timer/0","doc":"","ref":"Stream.html#t:timer/0"},{"type":"function","title":"Stream.timer/1","doc":"Creates a stream that emits a single value after `n` milliseconds.\n\nThe value emitted is `0`. This operation will block the caller by\nthe given time until the element is streamed.","ref":"Stream.html#timer/1"},{"type":"function","title":"Examples - Stream.timer/1","doc":"iex> Stream.timer(10) |> Enum.to_list()\n    [0]","ref":"Stream.html#timer/1-examples"},{"type":"function","title":"Stream.transform/3","doc":"Transforms an existing stream.\n\nIt expects an accumulator and a function that receives two arguments,\nthe stream element and the updated accumulator. It must return a tuple,\nwhere the first element is a new stream (often a list) or the atom `:halt`,\nand the second element is the accumulator to be used by the next element.\n\nNote: this function is equivalent to `Enum.flat_map_reduce/3`, except this\nfunction does not return the accumulator once the stream is processed.","ref":"Stream.html#transform/3"},{"type":"function","title":"Examples - Stream.transform/3","doc":"`Stream.transform/3` is useful as it can be used as the basis to implement\nmany of the functions defined in this module. For example, we can implement\n`Stream.take(enum, n)` as follows:\n\n    iex> enum = 1001..9999\n    iex> n = 3\n    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n    ...>   if acc   end)\n    iex> Enum.to_list(stream)\n    [1001, 1002, 1003]\n\n`Stream.transform/5` further generalizes this function to allow wrapping\naround resources.","ref":"Stream.html#transform/3-examples"},{"type":"function","title":"Stream.transform/4","doc":"Similar to `Stream.transform/5`, except `last_fun` is not supplied.\n\nThis function can be seen as a combination of `Stream.resource/3` with\n`Stream.transform/3`.","ref":"Stream.html#transform/4"},{"type":"function","title":"Stream.transform/5","doc":"Transforms an existing stream with function-based start, last, and after\ncallbacks.\n\nOnce transformation starts, `start_fun` is invoked to compute the initial\naccumulator. Then, for each element in the enumerable, the `reducer` function\nis invoked with the element and the accumulator, returning new elements and a\nnew accumulator, as in `transform/3`.\n\nOnce the collection is done, `last_fun` is invoked with the accumulator to\nemit any remaining items. Then `after_fun` is invoked, to close any resource,\nbut not emitting any new items. `last_fun` is only invoked if the given\nenumerable terminates successfully (either because it is done or it halted\nitself). `after_fun` is always invoked, therefore `after_fun` must be the\none used for closing resources.","ref":"Stream.html#transform/5"},{"type":"function","title":"Stream.unfold/2","doc":"Emits a sequence of values for the given accumulator.\n\nSuccessive values are generated by calling `next_fun` with the previous\naccumulator and it must return a tuple with the current value and next\naccumulator. The enumeration finishes if it returns `nil`.","ref":"Stream.html#unfold/2"},{"type":"function","title":"Examples - Stream.unfold/2","doc":"To create a stream that counts down and stops before zero:\n\n    iex> Stream.unfold(5, fn\n    ...>   0 -> nil\n    ...>   n -> {n, n - 1}\n    ...> end) |> Enum.to_list()\n    [5, 4, 3, 2, 1]\n\nIf `next_fun` never returns `nil`, the returned stream is *infinite*:\n\n    iex> Stream.unfold(0, fn\n    ...>   n -> {n, n + 1}\n    ...> end) |> Enum.take(10)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    iex> Stream.unfold(1, fn\n    ...>   n -> {n, n * 2}\n    ...> end) |> Enum.take(10)\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]","ref":"Stream.html#unfold/2-examples"},{"type":"function","title":"Stream.uniq/1","doc":"Creates a stream that only emits elements if they are unique.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.","ref":"Stream.html#uniq/1"},{"type":"function","title":"Examples - Stream.uniq/1","doc":"iex> Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3]","ref":"Stream.html#uniq/1-examples"},{"type":"function","title":"Stream.uniq_by/2","doc":"Creates a stream that only emits elements if they are unique, by removing the\nelements for which function `fun` returned duplicate elements.\n\nThe function `fun` maps every element to a term which is used to\ndetermine if two elements are duplicates.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.","ref":"Stream.html#uniq_by/2"},{"type":"function","title":"Example - Stream.uniq_by/2","doc":"iex> Stream.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}]\n\n    iex> Stream.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end) |> Enum.to_list()\n    [a: {:tea, 2}, c: {:coffee, 1}]","ref":"Stream.html#uniq_by/2-example"},{"type":"function","title":"Stream.with_index/2","doc":"Creates a stream where each element in the enumerable will\nbe wrapped in a tuple alongside its index or according to a given function.\n\nMay receive a function or an integer offset.\n\nIf an `offset` is given, it will index from the given offset instead of from\nzero.\n\nIf a `function` is given, it will index by invoking the function for each\nelement and index (zero-based) of the enumerable.","ref":"Stream.html#with_index/2"},{"type":"function","title":"Examples - Stream.with_index/2","doc":"iex> stream = Stream.with_index([1, 2, 3])\n    iex> Enum.to_list(stream)\n    [{1, 0}, {2, 1}, {3, 2}]\n\n    iex> stream = Stream.with_index([1, 2, 3], 3)\n    iex> Enum.to_list(stream)\n    [{1, 3}, {2, 4}, {3, 5}]\n\n    iex> stream = Stream.with_index([1, 2, 3], fn x, index -> x + index end)\n    iex> Enum.to_list(stream)\n    [1, 3, 5]","ref":"Stream.html#with_index/2-examples"},{"type":"function","title":"Stream.zip/1","doc":"Zips corresponding elements from a finite collection of enumerables\ninto one stream of tuples.\n\nThe zipping finishes as soon as any enumerable in the given collection completes.","ref":"Stream.html#zip/1"},{"type":"function","title":"Examples - Stream.zip/1","doc":"iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([\"foo\", \"bar\", \"baz\"])\n    iex> Stream.zip([concat, [:a, :b, :c], cycle]) |> Enum.to_list()\n    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]","ref":"Stream.html#zip/1-examples"},{"type":"function","title":"Stream.zip/2","doc":"Zips two enumerables together, lazily.\n\nBecause a list of two-element tuples with atoms as the first\ntuple element is a keyword list (`Keyword`), zipping a first `Stream`\nof atoms with a second `Stream` of any kind creates a `Stream`\nthat generates a keyword list.\n\nThe zipping finishes as soon as either enumerable completes.","ref":"Stream.html#zip/2"},{"type":"function","title":"Examples - Stream.zip/2","doc":"iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([:a, :b, :c])\n    iex> Stream.zip(concat, cycle) |> Enum.to_list()\n    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]\n    iex> Stream.zip(cycle, concat) |> Enum.to_list()\n    [a: 1, b: 2, c: 3, a: 4, b: 5, c: 6]","ref":"Stream.html#zip/2-examples"},{"type":"function","title":"Stream.zip_with/2","doc":"Lazily zips corresponding elements from a finite collection of enumerables into a new\nenumerable, transforming them with the `zip_fun` function as it goes.\n\nThe first element from each of the enums in `enumerables` will be put into a list which is then passed to\nthe one-arity `zip_fun` function. Then, the second elements from each of the enums are put into a list and passed to\n`zip_fun`, and so on until any one of the enums in `enumerables` completes.\n\nReturns a new enumerable with the results of calling `zip_fun`.","ref":"Stream.html#zip_with/2"},{"type":"function","title":"Examples - Stream.zip_with/2","doc":"iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat], fn [a, b] -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat, 1..3], fn [a, b, c] -> a + b + c end) |> Enum.to_list()\n    [3, 6, 9]","ref":"Stream.html#zip_with/2-examples"},{"type":"function","title":"Stream.zip_with/3","doc":"Lazily zips corresponding elements from two enumerables into a new one, transforming them with\nthe `zip_fun` function as it goes.\n\nThe `zip_fun` will be called with the first element from `enumerable1` and the first\nelement from `enumerable2`, then with the second element from each, and so on until\neither one of the enumerables completes.","ref":"Stream.html#zip_with/3"},{"type":"function","title":"Examples - Stream.zip_with/3","doc":"iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with(concat, concat, fn a, b -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]","ref":"Stream.html#zip_with/3-examples"},{"type":"module","title":"File","doc":"This module contains functions to manipulate files.\n\nSome of those functions are low-level, allowing the user\nto interact with files or IO devices, like `open/2`,\n`copy/3` and others. This module also provides higher\nlevel functions that work with filenames and have their naming\nbased on Unix variants. For example, one can copy a file\nvia `cp/3` and remove files and directories recursively\nvia `rm_rf/1`.\n\nPaths given to functions in this module can be either relative to the\ncurrent working directory (as returned by `File.cwd/0`), or absolute\npaths. Shell conventions like `~` are not expanded automatically.\nTo use paths like `~/Downloads`, you can use `Path.expand/1` or\n`Path.expand/2` to expand your path to an absolute path.","ref":"File.html"},{"type":"module","title":"Encoding - File","doc":"In order to write and read files, one must use the functions\nin the `IO` module. By default, a file is opened in binary mode,\nwhich requires the functions `IO.binread/2` and `IO.binwrite/2`\nto interact with the file. A developer may pass `:utf8` as an\noption when opening the file, then the slower `IO.read/2` and\n`IO.write/2` functions must be used as they are responsible for\ndoing the proper conversions and providing the proper data guarantees.\n\nNote that filenames when given as charlists in Elixir are\nalways treated as UTF-8. In particular, we expect that the\nshell and the operating system are configured to use UTF-8\nencoding. Binary filenames are considered raw and passed\nto the operating system as is.","ref":"File.html#module-encoding"},{"type":"module","title":"API - File","doc":"Most of the functions in this module return `:ok` or\n`{:ok, result}` in case of success, `{:error, reason}`\notherwise. Those functions also have a variant\nthat ends with `!` which returns the result (instead of the\n`{:ok, result}` tuple) in case of success or raises an\nexception in case it fails. For example:\n\n    File.read(\"hello.txt\")\n    #=> {:ok, \"World\"}\n\n    File.read(\"invalid.txt\")\n    #=> {:error, :enoent}\n\n    File.read!(\"hello.txt\")\n    #=> \"World\"\n\n    File.read!(\"invalid.txt\")\n    #=> raises File.Error\n\nIn general, a developer should use the former in case they want\nto react if the file does not exist. The latter should be used\nwhen the developer expects their software to fail in case the\nfile cannot be read (i.e. it is literally an exception).","ref":"File.html#module-api"},{"type":"module","title":"Processes and raw files - File","doc":"Every time a file is opened, Elixir spawns a new process. Writing\nto a file is equivalent to sending messages to the process that\nwrites to the file descriptor.\n\nThis means files can be passed between nodes and message passing\nguarantees they can write to the same file in a network.\n\nHowever, you may not always want to pay the price for this abstraction.\nIn such cases, a file can be opened in `:raw` mode. The options `:read_ahead`\nand `:delayed_write` are also useful when operating on large files or\nworking with files in tight loops.\n\nCheck `:file.open/2` for more information about such options and\nother performance considerations.","ref":"File.html#module-processes-and-raw-files"},{"type":"module","title":"Seeking within a file - File","doc":"You may also use any of the functions from the [`:file`](`:file`)\nmodule to interact with files returned by Elixir. For example,\nto read from a specific position in a file, use `:file.pread/3`:\n\n    File.write!(\"example.txt\", \"Eats, Shoots & Leaves\")\n    file = File.open!(\"example.txt\")\n    :file.pread(file, 15, 6)\n    #=> {:ok, \"Leaves\"}\n\nAlternatively, if you need to keep track of the current position,\nuse `:file.position/2` and `:file.read/2`:\n\n    :file.position(file, 6)\n    #=> {:ok, 6}\n    :file.read(file, 6)\n    #=> {:ok, \"Shoots\"}\n    :file.position(file, {:cur, -12})\n    #=> {:ok, 0}\n    :file.read(file, 4)\n    #=> {:ok, \"Eats\"}","ref":"File.html#module-seeking-within-a-file"},{"type":"function","title":"File.cd/1","doc":"Sets the current working directory.\n\nThe current working directory is set for the BEAM globally. This can lead to\nrace conditions if multiple processes are changing the current working\ndirectory concurrently. To run an external command in a given directory\nwithout changing the global current working directory, use the `:cd` option\nof `System.cmd/3` and `Port.open/2`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.","ref":"File.html#cd/1"},{"type":"function","title":"File.cd!/1","doc":"The same as `cd/1`, but raises a `File.Error` exception if it fails.","ref":"File.html#cd!/1"},{"type":"function","title":"File.cd!/2","doc":"Changes the current directory to the given `path`,\nexecutes the given function and then reverts back\nto the previous path regardless of whether there is an exception.\n\nThe current working directory is temporarily set for the BEAM globally. This\ncan lead to race conditions if multiple processes are changing the current\nworking directory concurrently. To run an external command in a given\ndirectory without changing the global current working directory, use the\n`:cd` option of `System.cmd/3` and `Port.open/2`.\n\nRaises an error if retrieving or changing the current\ndirectory fails.","ref":"File.html#cd!/2"},{"type":"function","title":"File.chgrp/2","doc":"Changes the group given by the group ID `gid`\nfor a given `file`. Returns `:ok` on success, or\n`{:error, reason}` on failure.","ref":"File.html#chgrp/2"},{"type":"function","title":"File.chgrp!/2","doc":"Same as `chgrp/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","ref":"File.html#chgrp!/2"},{"type":"function","title":"File.chmod/2","doc":"Changes the `mode` for a given `file`.\n\nReturns `:ok` on success, or `{:error, reason}` on failure.","ref":"File.html#chmod/2"},{"type":"function","title":"Permissions - File.chmod/2","doc":"File permissions are specified by adding together the following octal modes:\n\n  * `0o400` - read permission: owner\n  * `0o200` - write permission: owner\n  * `0o100` - execute permission: owner\n\n  * `0o040` - read permission: group\n  * `0o020` - write permission: group\n  * `0o010` - execute permission: group\n\n  * `0o004` - read permission: other\n  * `0o002` - write permission: other\n  * `0o001` - execute permission: other\n\nFor example, setting the mode `0o755` gives it\nwrite, read and execute permission to the owner\nand both read and execute permission to group\nand others.","ref":"File.html#chmod/2-permissions"},{"type":"function","title":"File.chmod!/2","doc":"Same as `chmod/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","ref":"File.html#chmod!/2"},{"type":"function","title":"File.chown/2","doc":"Changes the owner given by the user ID `uid`\nfor a given `file`. Returns `:ok` on success,\nor `{:error, reason}` on failure.","ref":"File.html#chown/2"},{"type":"function","title":"File.chown!/2","doc":"Same as `chown/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","ref":"File.html#chown!/2"},{"type":"function","title":"File.close/1","doc":"Closes the file referenced by `io_device`. It mostly returns `:ok`, except\nfor some severe errors such as out of memory.\n\nNote that if the option `:delayed_write` was used when opening the file,\n`close/1` might return an old write error and not even try to close the file.\nSee `open/2` for more information.","ref":"File.html#close/1"},{"type":"function","title":"File.copy/3","doc":"Copies the contents of `source` to `destination`.\n\nBoth parameters can be a filename or an IO device opened\nwith `open/2`. `bytes_count` specifies the number of\nbytes to copy, the default being `:infinity`.\n\nIf file `destination` already exists, it is overwritten\nby the contents in `source`.\n\nReturns `{:ok, bytes_copied}` if successful,\n`{:error, reason}` otherwise.\n\nCompared to the `cp/3`, this function is more low-level,\nallowing a copy from device to device limited by a number of\nbytes. On the other hand, `cp/3` performs more extensive\nchecks on both source and destination and it also preserves\nthe file mode after copy.\n\nTypical error reasons are the same as in `open/2`,\n`read/1` and `write/3`.","ref":"File.html#copy/3"},{"type":"function","title":"File.copy!/3","doc":"The same as `copy/3` but raises a `File.CopyError` exception if it fails.\nReturns the `bytes_copied` otherwise.","ref":"File.html#copy!/3"},{"type":"function","title":"File.cp/3","doc":"Copies the contents of `source_file` to `destination_file` preserving its modes.\n\n`source_file` must be a file or a symbolic link to one. `destination_file` must\nbe a path to a non-existent file. If either is a directory, `{:error, :eisdir}`\nwill be returned.\n\nThe function returns `:ok` in case of success. Otherwise, it returns\n`{:error, reason}`.\n\nIf you want to copy contents from an IO device to another device\nor do a straight copy from a source to a destination without\npreserving modes, check `copy/3` instead.\n\nNote: The command `cp` in Unix-like systems behaves differently depending on\nwhether the destination is an existing directory or not. We have chosen to\nexplicitly disallow copying to a destination which is a directory,\nand an error will be returned if tried.","ref":"File.html#cp/3"},{"type":"function","title":"Options - File.cp/3","doc":"* `:on_conflict` - (since v1.14.0) Invoked when a file already exists in the destination.\n    The function receives arguments for `source_file` and `destination_file`. It should\n    return `true` if the existing file should be overwritten, `false` if otherwise.\n    The default callback returns `true`. On earlier versions, this callback could be\n    given as third argument, but such behavior is now deprecated.","ref":"File.html#cp/3-options"},{"type":"function","title":"File.cp!/3","doc":"The same as `cp/3`, but raises a `File.CopyError` exception if it fails.\nReturns `:ok` otherwise.","ref":"File.html#cp!/3"},{"type":"function","title":"File.cp_r/3","doc":"Copies the contents in `source` to `destination` recursively, maintaining the\nsource directory structure and modes.\n\nIf `source` is a file or a symbolic link to it, `destination` must be a path\nto an existent file, a symbolic link to one, or a path to a non-existent file.\n\nIf `source` is a directory, or a symbolic link to it, then `destination` must\nbe an existent `directory` or a symbolic link to one, or a path to a non-existent directory.\n\nIf the source is a file, it copies `source` to `destination`. If the `source`\nis a directory, it copies the contents inside source into the `destination` directory.\n\nIf a file already exists in the destination, it invokes the optional `on_conflict`\ncallback given as an option. See \"Options\" for more information.\n\nThis function may fail while copying files, in such cases, it will leave the\ndestination directory in a dirty state, where file which have already been\ncopied won't be removed.\n\nThe function returns `{:ok, files_and_directories}` in case of\nsuccess, `files_and_directories` lists all files and directories copied in no\nspecific order. It returns `{:error, reason, file}` otherwise.\n\nNote: The command `cp` in Unix-like systems behaves differently depending on\nwhether `destination` is an existing directory or not. We have chosen to\nexplicitly disallow this behavior. If `source` is a `file` and `destination`\nis a directory, `{:error, :eisdir}` will be returned.","ref":"File.html#cp_r/3"},{"type":"function","title":"Options - File.cp_r/3","doc":"* `:on_conflict` - (since v1.14.0) Invoked when a file already exists in the destination.\n    The function receives arguments for `source` and `destination`. It should return\n    `true` if the existing file should be overwritten, `false` if otherwise. The default\n    callback returns `true`. On earlier versions, this callback could be given as third\n    argument, but such behavior is now deprecated.\n\n  * `:dereference_symlinks` - (since v1.14.0) By default, this function will copy symlinks\n    by creating symlinks that point to the same location. This option forces symlinks to be\n    dereferenced and have their contents copied instead when set to `true`. If the dereferenced\n    files do not exist, than the operation fails. The default is `false`.","ref":"File.html#cp_r/3-options"},{"type":"function","title":"Examples - File.cp_r/3","doc":"# Copies file \"a.txt\" to \"b.txt\"\n    File.cp_r(\"a.txt\", \"b.txt\")\n\n    # Copies all files in \"samples\" to \"tmp\"\n    File.cp_r(\"samples\", \"tmp\")\n\n    # Same as before, but asks the user how to proceed in case of conflicts\n    File.cp_r(\"samples\", \"tmp\", on_conflict: fn source, destination ->\n      IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm. \") == \"y\\n\"\n    end)","ref":"File.html#cp_r/3-examples"},{"type":"function","title":"File.cp_r!/3","doc":"The same as `cp_r/3`, but raises a `File.CopyError` exception if it fails.\nReturns the list of copied files otherwise.","ref":"File.html#cp_r!/3"},{"type":"function","title":"File.cwd/0","doc":"Gets the current working directory.\n\nIn rare circumstances, this function can fail on Unix-like systems. It may happen\nif read permissions do not exist for the parent directories of the\ncurrent directory. For this reason, returns `{:ok, cwd}` in case\nof success, `{:error, reason}` otherwise.","ref":"File.html#cwd/0"},{"type":"function","title":"File.cwd!/0","doc":"The same as `cwd/0`, but raises a `File.Error` exception if it fails.","ref":"File.html#cwd!/0"},{"type":"function","title":"File.dir?/2","doc":"Returns `true` if the given path is a directory.\n\nThis function follows symbolic links, so if a symbolic link points to a\ndirectory, `true` is returned.","ref":"File.html#dir?/2"},{"type":"function","title":"Options - File.dir?/2","doc":"The supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally","ref":"File.html#dir?/2-options"},{"type":"function","title":"Examples - File.dir?/2","doc":"File.dir?(\"./test\")\n    #=> true\n\n    File.dir?(\"test\")\n    #=> true\n\n    File.dir?(\"/usr/bin\")\n    #=> true\n\n    File.dir?(\"~/Downloads\")\n    #=> false\n\n    \"~/Downloads\" |> Path.expand() |> File.dir?()\n    #=> true","ref":"File.html#dir?/2-examples"},{"type":"type","title":"File.encoding_mode/0","doc":"","ref":"File.html#t:encoding_mode/0"},{"type":"type","title":"File.erlang_time/0","doc":"","ref":"File.html#t:erlang_time/0"},{"type":"function","title":"File.exists?/2","doc":"Returns `true` if the given path exists.\n\nIt can be a regular file, directory, socket, symbolic link, named pipe, or device file.\nReturns `false` for symbolic links pointing to non-existing targets.","ref":"File.html#exists?/2"},{"type":"function","title":"Options - File.exists?/2","doc":"The supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally","ref":"File.html#exists?/2-options"},{"type":"function","title":"Examples - File.exists?/2","doc":"File.exists?(\"test/\")\n    #=> true\n\n    File.exists?(\"missing.txt\")\n    #=> false\n\n    File.exists?(\"/dev/null\")\n    #=> true","ref":"File.html#exists?/2-examples"},{"type":"type","title":"File.file_descriptor/0","doc":"","ref":"File.html#t:file_descriptor/0"},{"type":"type","title":"File.io_device/0","doc":"","ref":"File.html#t:io_device/0"},{"type":"function","title":"File.ln/2","doc":"Creates a hard link `new` to the file `existing`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.\nIf the operating system does not support hard links, returns\n`{:error, :enotsup}`.","ref":"File.html#ln/2"},{"type":"function","title":"File.ln!/2","doc":"Same as `ln/2` but raises a `File.LinkError` exception if it fails.\nReturns `:ok` otherwise.","ref":"File.html#ln!/2"},{"type":"function","title":"File.ln_s/2","doc":"Creates a symbolic link `new` to the file or directory `existing`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.\nIf the operating system does not support symlinks, returns\n`{:error, :enotsup}`.","ref":"File.html#ln_s/2"},{"type":"function","title":"File.ln_s!/2","doc":"Same as `ln_s/2` but raises a `File.LinkError` exception if it fails.\nReturns `:ok` otherwise.","ref":"File.html#ln_s!/2"},{"type":"function","title":"File.ls/1","doc":"Returns the list of files in the given directory.\n\nHidden files are not ignored and the results are *not* sorted.\n\nSince directories are considered files by the file system,\nthey are also included in the returned value.\n\nReturns `{:ok, files}` in case of success,\n`{:error, reason}` otherwise.","ref":"File.html#ls/1"},{"type":"function","title":"File.ls!/1","doc":"The same as `ls/1` but raises a `File.Error` exception in case of an error.","ref":"File.html#ls!/1"},{"type":"function","title":"File.lstat/2","doc":"Returns information about the `path`. If the file is a symlink, sets\nthe `type` to `:symlink` and returns a `File.Stat` struct for the link. For any\nother file, returns exactly the same values as `stat/2`.\n\nFor more details, see `:file.read_link_info/2`.","ref":"File.html#lstat/2"},{"type":"function","title":"Options - File.lstat/2","doc":"The accepted options are:\n\n  * `:time` - configures how the file timestamps are returned\n\nThe values for `:time` can be:\n\n  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n  * `:local` - returns a `{date, time}` tuple using the machine time\n  * `:posix` - returns the time as integer seconds since epoch\n\nNote: Since file times are stored in POSIX time format on most operating systems,\nit is faster to retrieve file information with the `time: :posix` option.","ref":"File.html#lstat/2-options"},{"type":"function","title":"File.lstat!/2","doc":"Same as `lstat/2` but returns the `File.Stat` struct directly,\nor raises a `File.Error` exception if an error is returned.","ref":"File.html#lstat!/2"},{"type":"function","title":"File.mkdir/1","doc":"Tries to create the directory `path`.\n\nMissing parent directories are not created.\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\n\nTypical error reasons are:\n\n  * `:eacces`  - missing search or write permissions for the parent\n    directories of `path`\n  * `:eexist`  - there is already a file or directory named `path`\n  * `:enoent`  - a component of `path` does not exist\n  * `:enospc`  - there is no space left on the device\n  * `:enotdir` - a component of `path` is not a directory;\n    on some platforms, `:enoent` is returned instead","ref":"File.html#mkdir/1"},{"type":"function","title":"File.mkdir!/1","doc":"Same as `mkdir/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","ref":"File.html#mkdir!/1"},{"type":"function","title":"File.mkdir_p/1","doc":"Tries to create the directory `path`.\n\nMissing parent directories are created. Returns `:ok` if successful, or\n`{:error, reason}` if an error occurs.\n\nTypical error reasons are:\n\n  * `:eacces`  - missing search or write permissions for the parent\n    directories of `path`\n  * `:enospc`  - there is no space left on the device\n  * `:enotdir` - a component of `path` is not a directory","ref":"File.html#mkdir_p/1"},{"type":"function","title":"File.mkdir_p!/1","doc":"Same as `mkdir_p/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","ref":"File.html#mkdir_p!/1"},{"type":"type","title":"File.mode/0","doc":"","ref":"File.html#t:mode/0"},{"type":"type","title":"File.on_conflict_callback/0","doc":"","ref":"File.html#t:on_conflict_callback/0"},{"type":"function","title":"File.open/2","doc":"Opens the given `path`.\n\n`modes_or_function` can either be a list of modes or a function. If it's a\nlist, it's considered to be a list of modes (that are documented below). If\nit's a function, then it's equivalent to calling `open(path, [],\nmodes_or_function)`. See the documentation for `open/3` for more information\non this function.\n\nThe allowed modes:\n\n  * `:binary` - opens the file in binary mode, disabling special handling of\n    Unicode sequences (default mode).\n\n  * `:read` - the file, which must exist, is opened for reading.\n\n  * `:write` - the file is opened for writing. It is created if it does not\n    exist.\n\n    If the file does exist, and if write is not combined with read, the file\n    will be truncated.\n\n  * `:append` - the file will be opened for writing, and it will be created\n    if it does not exist. Every write operation to a file opened with append\n    will take place at the end of the file.\n\n  * `:exclusive` - the file, when opened for writing, is created if it does\n    not exist. If the file exists, open will return `{:error, :eexist}`.\n\n  * `:charlist` - when this term is given, read operations on the file will\n    return charlists rather than binaries.\n\n  * `:compressed` - makes it possible to read or write gzip compressed files.\n\n    The compressed option must be combined with either read or write, but not\n    both. Note that the file size obtained with `stat/1` will most probably\n    not match the number of bytes that can be read from a compressed file.\n\n  * `:utf8` - this option denotes how data is actually stored in the disk\n    file and makes the file perform automatic translation of characters to\n    and from UTF-8.\n\n    If data is sent to a file in a format that cannot be converted to the\n    UTF-8 or if data is read by a function that returns data in a format that\n    cannot cope with the character range of the data, an error occurs and the\n    file will be closed.\n\n  * `:delayed_write`, `:raw`, `:ram`, `:read_ahead`, `:sync`, `{:encoding, ...}`,\n    `{:read_ahead, pos_integer}`, `{:delayed_write, non_neg_integer, non_neg_integer}` -\n    for more information about these options see `:file.open/2`.\n\nThis function returns:\n\n  * `{:ok, io_device | file_descriptor}` - the file has been opened in\n    the requested mode. We explore the differences between these two results\n    in the following section\n\n  * `{:error, reason}` - the file could not be opened due to `reason`.","ref":"File.html#open/2"},{"type":"function","title":"IO devices - File.open/2","doc":"By default, this function returns an IO device. An `io_device` is\na process which handles the file and you can interact with it using\nthe functions in the `IO` module. By default, a file is opened in\n`:binary` mode, which requires the functions `IO.binread/2` and\n`IO.binwrite/2` to interact with the file. A developer may pass `:utf8`\nas a mode when opening the file and then all other functions from\n`IO` are available, since they work directly with Unicode data.\n\nGiven the IO device is a file, if the owner process terminates,\nthe file is closed and the process itself terminates too. If any\nprocess to which the `io_device` is linked terminates, the file\nwill be closed and the process itself will be terminated.","ref":"File.html#open/2-io-devices"},{"type":"function","title":"File descriptors - File.open/2","doc":"When the `:raw` or `:ram` modes are given, this function returns\na low-level file descriptors. This avoids creating a process but\nrequires using the functions in the [`:file`](`:file`) module to\ninteract with it.","ref":"File.html#open/2-file-descriptors"},{"type":"function","title":"Examples - File.open/2","doc":"{:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n    IO.read(file, :line)\n    File.close(file)","ref":"File.html#open/2-examples"},{"type":"function","title":"File.open/3","doc":"Similar to `open/2` but expects a function as its last argument.\n\nThe file is opened, given to the function as an argument and\nautomatically closed after the function returns, regardless\nif there was an error when executing the function.\n\nReturns `{:ok, function_result}` in case of success,\n`{:error, reason}` otherwise.\n\nThis function expects the file to be closed with success,\nwhich is usually the case unless the `:delayed_write` option\nis given. For this reason, we do not recommend passing\n`:delayed_write` to this function.","ref":"File.html#open/3"},{"type":"function","title":"Examples - File.open/3","doc":"File.open(\"file.txt\", [:read, :write], fn file ->\n      IO.read(file, :line)\n    end)\n\nSee `open/2` for the list of available `modes`.","ref":"File.html#open/3-examples"},{"type":"function","title":"File.open!/2","doc":"Similar to `open/2` but raises a `File.Error` exception if the file\ncould not be opened. Returns the IO device otherwise.\n\nSee `open/2` for the list of available modes.","ref":"File.html#open!/2"},{"type":"function","title":"File.open!/3","doc":"Similar to `open/3` but raises a `File.Error` exception if the file\ncould not be opened.\n\nIf it succeeds opening the file, it returns the `function` result on the IO device.\n\nSee `open/2` for the list of available `modes`.","ref":"File.html#open!/3"},{"type":"type","title":"File.posix/0","doc":"","ref":"File.html#t:posix/0"},{"type":"type","title":"File.posix_time/0","doc":"","ref":"File.html#t:posix_time/0"},{"type":"function","title":"File.read/1","doc":"Returns `{:ok, binary}`, where `binary` is a binary data object that contains the contents\nof `path`, or `{:error, reason}` if an error occurs.\n\nTypical error reasons:\n\n  * `:enoent`  - the file does not exist\n  * `:eacces`  - missing permission for reading the file,\n    or for searching one of the parent directories\n  * `:eisdir`  - the named file is a directory\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:enomem`  - there is not enough memory for the contents of the file\n\nYou can use `:file.format_error/1` to get a descriptive string of the error.","ref":"File.html#read/1"},{"type":"function","title":"File.read!/1","doc":"Returns a binary with the contents of the given filename,\nor raises a `File.Error` exception if an error occurs.","ref":"File.html#read!/1"},{"type":"function","title":"File.read_link/1","doc":"Reads the symbolic link at `path`.\n\nIf `path` exists and is a symlink, returns `{:ok, target}`, otherwise returns\n`{:error, reason}`.\n\nFor more details, see `:file.read_link/1`.\n\nTypical error reasons are:\n\n  * `:einval` - path is not a symbolic link\n  * `:enoent` - path does not exist\n  * `:enotsup` - symbolic links are not supported on the current platform","ref":"File.html#read_link/1"},{"type":"function","title":"File.read_link!/1","doc":"Same as `read_link/1` but returns the target directly,\nor raises a `File.Error` exception if an error is returned.","ref":"File.html#read_link!/1"},{"type":"type","title":"File.read_offset_mode/0","doc":"","ref":"File.html#t:read_offset_mode/0"},{"type":"function","title":"File.regular?/2","doc":"Returns `true` if the path is a regular file.\n\nThis function follows symbolic links, so if a symbolic link points to a\nregular file, `true` is returned.","ref":"File.html#regular?/2"},{"type":"function","title":"Options - File.regular?/2","doc":"The supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally","ref":"File.html#regular?/2-options"},{"type":"function","title":"Examples - File.regular?/2","doc":"File.regular?(__ENV__.file)\n    #=> true","ref":"File.html#regular?/2-examples"},{"type":"function","title":"File.rename/2","doc":"Renames the `source` file to `destination` file.  It can be used to move files\n(and directories) between directories.  If moving a file, you must fully\nspecify the `destination` filename, it is not sufficient to simply specify\nits directory.\n\nReturns `:ok` in case of success, `{:error, reason}` otherwise.\n\nNote: The command `mv` in Unix-like systems behaves differently depending on\nwhether `source` is a file and the `destination` is an existing directory.\nWe have chosen to explicitly disallow this behavior.","ref":"File.html#rename/2"},{"type":"function","title":"Examples - File.rename/2","doc":"# Rename file \"a.txt\" to \"b.txt\"\n    File.rename(\"a.txt\", \"b.txt\")\n\n    # Rename directory \"samples\" to \"tmp\"\n    File.rename(\"samples\", \"tmp\")","ref":"File.html#rename/2-examples"},{"type":"function","title":"File.rename!/2","doc":"The same as `rename/2` but raises a `File.RenameError` exception if it fails.\nReturns `:ok` otherwise.","ref":"File.html#rename!/2"},{"type":"function","title":"File.rm/1","doc":"Tries to delete the file `path`.\n\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\n\nNote the file is deleted even if in read-only mode.\n\nTypical error reasons are:\n\n  * `:enoent`  - the file does not exist\n  * `:eacces`  - missing permission for the file or one of its parents\n  * `:eperm`   - the file is a directory and user is not super-user\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:einval`  - filename had an improper type, such as tuple","ref":"File.html#rm/1"},{"type":"function","title":"Examples - File.rm/1","doc":"File.rm(\"file.txt\")\n    #=> :ok\n\n    File.rm(\"tmp_dir/\")\n    #=> {:error, :eperm}","ref":"File.html#rm/1-examples"},{"type":"function","title":"File.rm!/1","doc":"Same as `rm/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","ref":"File.html#rm!/1"},{"type":"function","title":"File.rm_rf/1","doc":"Removes files and directories recursively at the given `path`.\nSymlinks are not followed but simply removed, non-existing\nfiles are simply ignored (i.e. doesn't make this function fail).\n\nReturns `{:ok, files_and_directories}` with all files and\ndirectories removed in no specific order, `{:error, reason, file}`\notherwise.","ref":"File.html#rm_rf/1"},{"type":"function","title":"Examples - File.rm_rf/1","doc":"File.rm_rf(\"samples\")\n    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n\n    File.rm_rf(\"unknown\")\n    #=> {:ok, []}","ref":"File.html#rm_rf/1-examples"},{"type":"function","title":"File.rm_rf!/1","doc":"Same as `rm_rf/1` but raises a `File.Error` exception in case of failures,\notherwise the list of files or directories removed.","ref":"File.html#rm_rf!/1"},{"type":"function","title":"File.rmdir/1","doc":"Tries to delete the dir at `path`.\n\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\nIt returns `{:error, :eexist}` if the directory is not empty.","ref":"File.html#rmdir/1"},{"type":"function","title":"Examples - File.rmdir/1","doc":"File.rmdir(\"tmp_dir\")\n    #=> :ok\n\n    File.rmdir(\"non_empty_dir\")\n    #=> {:error, :eexist}\n\n    File.rmdir(\"file.txt\")\n    #=> {:error, :enotdir}","ref":"File.html#rmdir/1-examples"},{"type":"function","title":"File.rmdir!/1","doc":"Same as `rmdir/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","ref":"File.html#rmdir!/1"},{"type":"function","title":"File.stat/2","doc":"Returns information about the `path`. If it exists, it\nreturns a `{:ok, info}` tuple, where info is a\n`File.Stat` struct. Returns `{:error, reason}` with\nthe same reasons as `read/1` if a failure occurs.","ref":"File.html#stat/2"},{"type":"function","title":"Options - File.stat/2","doc":"The accepted options are:\n\n  * `:time` - configures how the file timestamps are returned\n\nThe values for `:time` can be:\n\n  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n  * `:local` - returns a `{date, time}` tuple using the same time zone as the\n    machine\n  * `:posix` - returns the time as integer seconds since epoch\n\nNote: Since file times are stored in POSIX time format on most operating systems,\nit is faster to retrieve file information with the `time: :posix` option.","ref":"File.html#stat/2-options"},{"type":"function","title":"File.stat!/2","doc":"Same as `stat/2` but returns the `File.Stat` directly,\nor raises a `File.Error` exception if an error is returned.","ref":"File.html#stat!/2"},{"type":"type","title":"File.stat_options/0","doc":"","ref":"File.html#t:stat_options/0"},{"type":"function","title":"File.stream!/2","doc":"Shortcut for `File.stream!/3`.","ref":"File.html#stream!/2"},{"type":"function","title":"File.stream!/3","doc":"Returns a `File.Stream` for the given `path` with the given `modes`.\n\nThe stream implements both `Enumerable` and `Collectable` protocols,\nwhich means it can be used both for read and write.\n\nThe `line_or_bytes` argument configures how the file is read when\nstreaming, by `:line` (default) or by a given number of bytes. When\nusing the `:line` option, CRLF line breaks (`\"\\r\\n\"`) are normalized\nto LF (`\"\\n\"`).\n\nSimilar to other file operations, a stream can be created in one node\nand forwarded to another node. Once the stream is opened in another node,\na request will be sent to the creator node to spawn a process for file\nstreaming.\n\nOperating the stream can fail on open for the same reasons as\n`File.open!/2`. Note that the file is automatically opened each time streaming\nbegins. There is no need to pass `:read` and `:write` modes, as those are\nautomatically set by Elixir.","ref":"File.html#stream!/3"},{"type":"function","title":"Raw files - File.stream!/3","doc":"Since Elixir controls when the streamed file is opened, the underlying\ndevice cannot be shared and as such it is convenient to open the file\nin raw mode for performance reasons. Therefore, Elixir **will** open\nstreams in `:raw` mode with the `:read_ahead` option if the stream is\nopen in the same node as it is created and no encoding has been specified.\nThis means any data streamed into the file must be converted to `t:iodata/0`\ntype. If you pass, for example, `[encoding: :utf8]` or\n`[encoding: {:utf16, :little}]` in the modes parameter, the underlying stream\nwill use `IO.write/2` and the `String.Chars` protocol to convert the data.\nSee `IO.binwrite/2` and `IO.write/2` .\n\nOne may also consider passing the `:delayed_write` option if the stream\nis meant to be written to under a tight loop.","ref":"File.html#stream!/3-raw-files"},{"type":"function","title":"Byte order marks and read offset - File.stream!/3","doc":"If you pass `:trim_bom` in the modes parameter, the stream will\ntrim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.\n\nNote that this function does not try to discover the file encoding\nbased on BOM. From Elixir v1.16.0, you may also pass a `:read_offset`\nthat is skipped whenever enumerating the stream (if both `:read_offset`\nand `:trim_bom` are given, the offset is skipped after the BOM).","ref":"File.html#stream!/3-byte-order-marks-and-read-offset"},{"type":"function","title":"Examples - File.stream!/3","doc":"# Read a utf8 text file which may include BOM\n    File.stream!(\"./test/test.txt\", [:trim_bom, encoding: :utf8])\n\n    # Read in 2048 byte chunks rather than lines\n    File.stream!(\"./test/test.data\", 2048)\n\nSee `Stream.run/1` for an example of streaming into a file.","ref":"File.html#stream!/3-examples"},{"type":"type","title":"File.stream_mode/0","doc":"","ref":"File.html#t:stream_mode/0"},{"type":"function","title":"File.touch/2","doc":"Updates modification time (mtime) and access time (atime) of\nthe given file.\n\nThe file is created if it doesn't exist. Requires datetime in UTC\n(as returned by `:erlang.universaltime()`) or an integer\nrepresenting the POSIX timestamp (as returned by `System.os_time(:second)`).\n\nIn Unix-like systems, changing the modification time may require\nyou to be either `root` or the owner of the file. Having write\naccess may not be enough. In those cases, touching the file the\nfirst time (to create it) will succeed, but touching an existing\nfile with fail with `{:error, :eperm}`.","ref":"File.html#touch/2"},{"type":"function","title":"Examples - File.touch/2","doc":"File.touch(\"/tmp/a.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    #=> :ok\n    File.touch(\"/fakedir/b.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    {:error, :enoent}\n\n    File.touch(\"/tmp/a.txt\", 1544519753)\n    #=> :ok","ref":"File.html#touch/2-examples"},{"type":"function","title":"File.touch!/2","doc":"Same as `touch/2` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.\n\nThe file is created if it doesn't exist. Requires datetime in UTC\n(as returned by `:erlang.universaltime()`) or an integer\nrepresenting the POSIX timestamp (as returned by `System.os_time(:second)`).","ref":"File.html#touch!/2"},{"type":"function","title":"Examples - File.touch!/2","doc":"File.touch!(\"/tmp/a.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    #=> :ok\n    File.touch!(\"/fakedir/b.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    ** (File.Error) could not touch \"/fakedir/b.txt\": no such file or directory\n\n    File.touch!(\"/tmp/a.txt\", 1544519753)","ref":"File.html#touch!/2-examples"},{"type":"function","title":"File.write/3","doc":"Writes `content` to the file `path`.\n\nThe file is created if it does not exist. If it exists, the previous\ncontents are overwritten. Returns `:ok` if successful, or `{:error, reason}`\nif an error occurs.\n\n`content` must be `iodata` (a list of bytes or a binary). Setting the\nencoding for this function has no effect.\n\n**Warning:** Every time this function is invoked, a file descriptor is opened\nand a new process is spawned to write to the file. For this reason, if you are\ndoing multiple writes in a loop, opening the file via `File.open/2` and using\nthe functions in `IO` to write to the file will yield much better performance\nthan calling this function multiple times.\n\nTypical error reasons are:\n\n  * `:enoent`  - a component of the file name does not exist\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:enospc`  - there is no space left on the device\n  * `:eacces`  - missing permission for writing the file or searching one of\n    the parent directories\n  * `:eisdir`  - the named file is a directory\n\nCheck `File.open/2` for other available options.","ref":"File.html#write/3"},{"type":"function","title":"File.write!/3","doc":"Same as `write/3` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.","ref":"File.html#write!/3"},{"type":"function","title":"File.write_stat/3","doc":"Writes the given `File.Stat` back to the file system at the given\npath. Returns `:ok` or `{:error, reason}`.","ref":"File.html#write_stat/3"},{"type":"function","title":"File.write_stat!/3","doc":"Same as `write_stat/3` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.","ref":"File.html#write_stat!/3"},{"type":"module","title":"File.Stat","doc":"A struct that holds file information.\n\nIn Erlang, this struct is represented by a `:file_info` record.\nTherefore this module also provides functions for converting\nbetween the Erlang record and the Elixir struct.\n\nIts fields are:\n\n  * `size` - size of file in bytes.\n\n  * `type` - `:device | :directory | :regular | :other | :symlink`; the type of the\n    file.\n\n  * `access` - `:read | :write | :read_write | :none`; the current system\n    access to the file.\n\n  * `atime` - the last time the file was read.\n\n  * `mtime` - the last time the file was written.\n\n  * `ctime` - the interpretation of this time field depends on the operating\n    system. On Unix-like operating systems, it is the last time the file or the inode was changed.\n    In Windows, it is the time of creation.\n\n  * `mode` - the file permissions.\n\n  * `links` - the number of links to this file. This is always 1 for file\n    systems which have no concept of links.\n\n  * `major_device` - identifies the file system where the file is located.\n    In Windows, the number indicates a drive as follows: 0 means A:, 1 means\n    B:, and so on.\n\n  * `minor_device` - only valid for character devices on Unix-like systems. In all other\n    cases, this field is zero.\n\n  * `inode` - gives the inode number. On non-Unix-like file systems, this field\n    will be zero.\n\n  * `uid` - indicates the owner of the file. Will be zero for non-Unix-like file\n    systems.\n\n  * `gid` - indicates the group that owns the file. Will be zero for\n    non-Unix-like file systems.\n\nThe time type returned in `atime`, `mtime`, and `ctime` is dependent on the\ntime type set in options. `{:time, type}` where type can be `:local`,\n`:universal`, or `:posix`. Default is `:universal`.","ref":"File.Stat.html"},{"type":"function","title":"File.Stat.from_record/1","doc":"Converts a `:file_info` record into a `File.Stat`.","ref":"File.Stat.html#from_record/1"},{"type":"type","title":"File.Stat.t/0","doc":"","ref":"File.Stat.html#t:t/0"},{"type":"function","title":"File.Stat.to_record/1","doc":"Converts a `File.Stat` struct to a `:file_info` record.","ref":"File.Stat.html#to_record/1"},{"type":"module","title":"File.Stream","doc":"Defines a `File.Stream` struct returned by `File.stream!/3`.\n\nThe following fields are public:\n\n  * `path`          - the file path\n  * `modes`         - the file modes\n  * `raw`           - a boolean indicating if bin functions should be used\n  * `line_or_bytes` - if reading should read lines or a given number of bytes\n  * `node`          - the node the file belongs to","ref":"File.Stream.html"},{"type":"type","title":"File.Stream.t/0","doc":"","ref":"File.Stream.html#t:t/0"},{"type":"module","title":"IO","doc":"Functions handling input/output (IO).\n\nMany functions in this module expect an IO device as an argument.\nAn IO device must be a PID or an atom representing a process.\nFor convenience, Elixir provides `:stdio` and `:stderr` as\nshortcuts to Erlang's `:standard_io` and `:standard_error`.\n\nThe majority of the functions expect chardata. In case another type is given,\nfunctions will convert those types to string via the `String.Chars` protocol\n(as shown in typespecs). For more information on chardata, see the\n\"IO data\" section below.","ref":"IO.html"},{"type":"module","title":"IO devices - IO","doc":"An IO device may be an atom or a PID. In case it is an atom,\nthe atom must be the name of a registered process. In addition,\nElixir provides two shortcuts:\n\n  * `:stdio` - a shortcut for `:standard_io`, which maps to\n    the current `Process.group_leader/0` in Erlang\n\n  * `:stderr` - a shortcut for the named process `:standard_error`\n    provided in Erlang\n\nIO devices maintain their position, which means subsequent calls to any\nreading or writing functions will start from the place where the device\nwas last accessed. The position of files can be changed using the\n`:file.position/2` function.","ref":"IO.html#module-io-devices"},{"type":"module","title":"IO data - IO","doc":"IO data is a data type that can be used as a more efficient alternative to binaries\nin certain situations.\n\nA term of type **IO data** is a binary or a list containing bytes (integers within the `0..255` range)\nor nested IO data. The type is recursive. Let's see an example of one of\nthe possible IO data representing the binary `\"hello\"`:\n\n    [?h, \"el\", [\"l\", [?o]]]\n\nThe built-in `t:iodata/0` type is defined in terms of `t:iolist/0`. An IO list is\nthe same as IO data but it doesn't allow for a binary at the top level (but binaries\nare still allowed in the list itself).","ref":"IO.html#module-io-data"},{"type":"module","title":"Use cases for IO data - IO","doc":"IO data exists because often you need to do many append operations\non smaller chunks of binaries in order to create a bigger binary. However, in\nErlang and Elixir concatenating binaries will copy the concatenated binaries\ninto a new binary.\n\n    def email(username, domain) do\n      username <> \"@\" <> domain\n    end\n\nIn this function, creating the email address will copy the `username` and `domain`\nbinaries. Now imagine you want to use the resulting email inside another binary:\n\n    def welcome_message(name, username, domain) do\n      \"Welcome #{name}, your email is: #{email(username, domain)}\"\n    end\n\n    IO.puts(welcome_message(\"Meg\", \"meg\", \"example.com\"))\n    #=> \"Welcome Meg, your email is: meg@example.com\"\n\nEvery time you concatenate binaries or use interpolation (`#{}`) you are making\ncopies of those binaries. However, in many cases you don't need the complete\nbinary while you create it, but only at the end to print it out or send it\nsomewhere. In such cases, you can construct the binary by creating IO data:\n\n    def email(username, domain) do\n      [username, ?@, domain]\n    end\n\n    def welcome_message(name, username, domain) do\n      [\"Welcome \", name, \", your email is: \", email(username, domain)]\n    end\n\n    IO.puts(welcome_message(\"Meg\", \"meg\", \"example.com\"))\n    #=> \"Welcome Meg, your email is: meg@example.com\"\n\nBuilding IO data is cheaper than concatenating binaries. Concatenating multiple\npieces of IO data just means putting them together inside a list since IO data\ncan be arbitrarily nested, and that's a cheap and efficient operation. Most of\nthe IO-based APIs, such as `:gen_tcp` and `IO`, receive IO data and write it\nto the socket directly without converting it to binary.\n\nOne drawback of IO data is that you can't do things like pattern match on the\nfirst part of a piece of IO data like you can with a binary, because you usually\ndon't know the shape of the IO data. In those cases, you may need to convert it\nto a binary by calling `iodata_to_binary/1`, which is reasonably efficient\nsince it's implemented natively in C. Other functionality, like computing the\nlength of IO data, can be computed directly on the iodata by calling `iodata_length/1`.","ref":"IO.html#module-use-cases-for-io-data"},{"type":"module","title":"Chardata - IO","doc":"Erlang and Elixir also have the idea of `t:chardata/0`. Chardata is very\nsimilar to IO data: the only difference is that integers in IO data represent\nbytes while integers in chardata represent Unicode code points. Bytes\n(`t:byte/0`) are integers within the `0..255` range, while Unicode code points\n(`t:char/0`) are integers within the `0..0x10FFFF` range. The `IO` module provides\nthe `chardata_to_string/1` function for chardata as the \"counter-part\" of the\n`iodata_to_binary/1` function for IO data.\n\nIf you try to use `iodata_to_binary/1` on chardata, it will result in an\nargument error. For example, let's try to put a code point that is not\nrepresentable with one byte, like `?π`, inside IO data:\n\n    IO.iodata_to_binary([\"The symbol for pi is: \", ?π])\n    #=> ** (ArgumentError) argument error\n\nIf we use chardata instead, it will work as expected:\n\n    iex> IO.chardata_to_string([\"The symbol for pi is: \", ?π])\n    \"The symbol for pi is: π\"","ref":"IO.html#module-chardata"},{"type":"function","title":"IO.binread/2","doc":"Reads from the IO `device`. The operation is Unicode unsafe.\n\nThe `device` is iterated as specified by the `line_or_chars` argument:\n\n  * if `line_or_chars` is an integer, it represents a number of bytes. The device is\n    iterated by that number of bytes.\n\n  * if `line_or_chars` is `:line`, the device is iterated line by line.\n\n  * if `line_or_chars` is `:eof` (since v1.13), the device is iterated until `:eof`.\n    If the device is already at the end, it returns `:eof` itself.\n\nIt returns:\n\n  * `data` - the output bytes\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\nNote: do not use this function on IO devices in Unicode mode\nas it will return the wrong result.","ref":"IO.html#binread/2"},{"type":"function","title":"IO.binstream/0","doc":"Returns a raw, line-based `IO.Stream` on `:stdio`. The operation is Unicode unsafe.\n\nThis is equivalent to:\n\n    IO.binstream(:stdio, :line)","ref":"IO.html#binstream/0"},{"type":"function","title":"IO.binstream/2","doc":"Converts the IO `device` into an `IO.Stream`. The operation is Unicode unsafe.\n\nAn `IO.Stream` implements both `Enumerable` and\n`Collectable`, allowing it to be used for both read\nand write.\n\nThe `device` is iterated by the given number of bytes or line by line if\n`:line` is given. This reads from the IO device as a raw binary.\n\nNote that an IO stream has side effects and every time\nyou go over the stream you may get different results.\n\nFinally, do not use this function on IO devices in Unicode\nmode as it will return the wrong result.\n\n`binstream/0` has been introduced in Elixir v1.12.0,\nwhile `binstream/2` has been available since v1.0.0.","ref":"IO.html#binstream/2"},{"type":"function","title":"IO.binwrite/2","doc":"Writes `iodata` to the given `device`.\n\nThis operation is meant to be used with \"raw\" devices\nthat are started without an encoding. The given `iodata`\nis written as is to the device, without conversion. For\nmore information on IO data, see the \"IO data\" section in\nthe module documentation.\n\nUse `write/2` for devices with encoding.\n\nImportant: do **not** use this function on IO devices in\nUnicode mode as it will write the wrong data. In particular,\nthe standard IO device is set to Unicode by default, so writing\nto stdio with this function will likely result in the wrong data\nbeing sent down the wire.","ref":"IO.html#binwrite/2"},{"type":"type","title":"IO.chardata/0","doc":"","ref":"IO.html#t:chardata/0"},{"type":"function","title":"IO.chardata_to_string/1","doc":"Converts chardata into a string.\n\nFor more information about chardata, see the [\"Chardata\"](#module-chardata)\nsection in the module documentation.\n\nIn case the conversion fails, it raises an `UnicodeConversionError`.\nIf a string is given, it returns the string itself.","ref":"IO.html#chardata_to_string/1"},{"type":"function","title":"Examples - IO.chardata_to_string/1","doc":"iex> IO.chardata_to_string([0x00E6, 0x00DF])\n    \"æß\"\n\n    iex> IO.chardata_to_string([0x0061, \"bc\"])\n    \"abc\"\n\n    iex> IO.chardata_to_string(\"string\")\n    \"string\"","ref":"IO.html#chardata_to_string/1-examples"},{"type":"type","title":"IO.device/0","doc":"","ref":"IO.html#t:device/0"},{"type":"function","title":"IO.getn/2","doc":"Gets a number of bytes from IO device `:stdio`.\n\nIf `:stdio` is a Unicode device, `count` implies\nthe number of Unicode code points to be retrieved.\nOtherwise, `count` is the number of raw bytes to be retrieved.\n\nSee `IO.getn/3` for a description of return values.","ref":"IO.html#getn/2"},{"type":"function","title":"IO.getn/3","doc":"Gets a number of bytes from the IO `device`.\n\nIf the IO `device` is a Unicode device, `count` implies\nthe number of Unicode code points to be retrieved.\nOtherwise, `count` is the number of raw bytes to be retrieved.\n\nIt returns:\n\n  * `data` - the input characters\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume","ref":"IO.html#getn/3"},{"type":"function","title":"IO.gets/2","doc":"Reads a line from the IO `device`.\n\nIt returns:\n\n  * `data` - the characters in the line terminated\n    by a line-feed (LF) or end of file (EOF)\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume","ref":"IO.html#gets/2"},{"type":"function","title":"Examples - IO.gets/2","doc":"To display \"What is your name?\" as a prompt and await user input:\n\n    IO.gets(\"What is your name?\\n\")","ref":"IO.html#gets/2-examples"},{"type":"function","title":"IO.inspect/2","doc":"Inspects and writes the given `item` to the standard output.\n\nIt's important to note that it returns the given `item` unchanged.\nThis makes it possible to \"spy\" on values by inserting an\n`IO.inspect/2` call almost anywhere in your code, for example,\nin the middle of a pipeline.\n\nIt enables pretty printing by default with width of\n80 characters. The width can be changed by explicitly\npassing the `:width` option.\n\nThe output can be decorated with a label, by providing the `:label`\noption to easily distinguish it from other `IO.inspect/2` calls.\nThe label will be printed before the inspected `item`.\n\nSee `Inspect.Opts` for a full list of remaining formatting options.\nTo print to other IO devices, see `IO.inspect/3`","ref":"IO.html#inspect/2"},{"type":"function","title":"Examples - IO.inspect/2","doc":"IO.inspect(<<0, 1, 2>>, width: 40)\n\nPrints:\n\n    <<0, 1, 2>>\n\nWe can use the `:label` option to decorate the output:\n\n    IO.inspect(1..100, label: \"a wonderful range\")\n\nPrints:\n\n    a wonderful range: 1..100\n\nThe `:label` option is especially useful with pipelines:\n\n    [1, 2, 3]\n    |> IO.inspect(label: \"before\")\n    |> Enum.map(&(&1 * 2))\n    |> IO.inspect(label: \"after\")\n    |> Enum.sum()\n\nPrints:\n\n    before: [1, 2, 3]\n    after: [2, 4, 6]","ref":"IO.html#inspect/2-examples"},{"type":"function","title":"IO.inspect/3","doc":"Inspects `item` according to the given options using the IO `device`.\n\nSee `inspect/2` for a full list of options.","ref":"IO.html#inspect/3"},{"type":"function","title":"IO.iodata_length/1","doc":"Returns the size of an IO data.\n\nFor more information about IO data, see the [\"IO data\"](#module-io-data)\nsection in the module documentation.\n\nInlined by the compiler.","ref":"IO.html#iodata_length/1"},{"type":"function","title":"Examples - IO.iodata_length/1","doc":"iex> IO.iodata_length([1, 2 | <<3, 4>>])\n    4","ref":"IO.html#iodata_length/1-examples"},{"type":"function","title":"IO.iodata_to_binary/1","doc":"Converts IO data into a binary\n\nThe operation is Unicode unsafe.\n\nNote that this function treats integers in the given IO data as\nraw bytes and does not perform any kind of encoding conversion.\nIf you want to convert from a charlist to a UTF-8-encoded string,\nuse `chardata_to_string/1` instead. For more information about\nIO data and chardata, see the [\"IO data\"](#module-io-data) section in the\nmodule documentation.\n\nIf this function receives a binary, the same binary is returned.\n\nInlined by the compiler.","ref":"IO.html#iodata_to_binary/1"},{"type":"function","title":"Examples - IO.iodata_to_binary/1","doc":"iex> bin1 = <<1, 2, 3>>\n    iex> bin2 = <<4, 5>>\n    iex> bin3 = <<6>>\n    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4 | bin3])\n    <<1, 2, 3, 1, 2, 3, 4, 5, 4, 6>>\n\n    iex> bin = <<1, 2, 3>>\n    iex> IO.iodata_to_binary(bin)\n    <<1, 2, 3>>","ref":"IO.html#iodata_to_binary/1-examples"},{"type":"type","title":"IO.nodata/0","doc":"","ref":"IO.html#t:nodata/0"},{"type":"function","title":"IO.puts/2","doc":"Writes `item` to the given `device`, similar to `write/2`,\nbut adds a newline at the end.\n\nBy default, the `device` is the standard output. It returns `:ok`\nif it succeeds.","ref":"IO.html#puts/2"},{"type":"function","title":"Examples - IO.puts/2","doc":"IO.puts(\"Hello World!\")\n    #=> Hello World!\n\n    IO.puts(:stderr, \"error\")\n    #=> error","ref":"IO.html#puts/2-examples"},{"type":"function","title":"IO.read/2","doc":"Reads from the IO `device`.\n\nThe `device` is iterated as specified by the `line_or_chars` argument:\n\n  * if `line_or_chars` is an integer, it represents a number of bytes. The device is\n    iterated by that number of bytes.\n\n  * if `line_or_chars` is `:line`, the device is iterated line by line.\n\n  * if `line_or_chars` is `:eof` (since v1.13), the device is iterated until `:eof`.\n    If the device is already at the end, it returns `:eof` itself.\n\nIt returns:\n\n  * `data` - the output characters\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume","ref":"IO.html#read/2"},{"type":"function","title":"IO.stream/0","doc":"Returns a line-based `IO.Stream` on `:stdio`.\n\nThis is equivalent to:\n\n    IO.stream(:stdio, :line)","ref":"IO.html#stream/0"},{"type":"function","title":"IO.stream/2","doc":"Converts the IO `device` into an `IO.Stream`.\n\nAn `IO.Stream` implements both `Enumerable` and\n`Collectable`, allowing it to be used for both read\nand write.\n\nThe `device` is iterated by the given number of characters or line by line if\n`:line` is given.\n\nThis reads from the IO as UTF-8. Check out\n`IO.binstream/2` to handle the IO as a raw binary.\n\nNote that an IO stream has side effects and every time\nyou go over the stream you may get different results.\n\n`stream/0` has been introduced in Elixir v1.12.0,\nwhile `stream/2` has been available since v1.0.0.","ref":"IO.html#stream/2"},{"type":"function","title":"Examples - IO.stream/2","doc":"Here is an example on how we mimic an echo server\nfrom the command line:\n\n    Enum.each(IO.stream(:stdio, :line), &IO.write(&1))\n\nAnother example where you might want to collect a user input\nevery new line and break on an empty line, followed by removing\nredundant new line characters (`\"\\n\"`):\n\n    IO.stream(:stdio, :line)\n    |> Enum.take_while(&(&1 != \"\\n\"))\n    |> Enum.map(&String.replace(&1, \"\\n\", \"\"))","ref":"IO.html#stream/2-examples"},{"type":"function","title":"IO.warn/1","doc":"Writes a `message` to stderr, along with the current stacktrace.\n\nIt returns `:ok` if it succeeds.\n\nDo not call this function at the tail of another function. Due to tail\ncall optimization, a stacktrace entry would not be added and the\nstacktrace would be incorrectly trimmed. Therefore make sure at least\none expression (or an atom such as `:ok`) follows the `IO.warn/1` call.","ref":"IO.html#warn/1"},{"type":"function","title":"Examples - IO.warn/1","doc":"IO.warn(\"variable bar is unused\")\n    #=> warning: variable bar is unused\n    #=>   (iex) evaluator.ex:108: IEx.Evaluator.eval/4","ref":"IO.html#warn/1-examples"},{"type":"function","title":"IO.warn/2","doc":"Writes a `message` to stderr, along with the given `stacktrace_info`.\n\nThe `stacktrace_info` must be one of:\n\n  * a `__STACKTRACE__`, where all entries in the stacktrace will be\n    included in the error message\n\n  * a `Macro.Env` structure (since v1.14.0), where a single stacktrace\n    entry from the compilation environment will be used\n\n  * a keyword list with at least the `:file` option representing\n    a single stacktrace entry (since v1.14.0). The `:line`, `:column`,\n    `:module`, and `:function` options are also supported\n\nThis function notifies the compiler a warning was printed\nand emits a compiler diagnostic (`t:Code.diagnostic/1`).\nThe diagnostic will include precise file and location information\nif a `Macro.Env` is given or those values have been passed as\nkeyword list, but not for stacktraces, as they are often imprecise.\n\nIt returns `:ok` if it succeeds.","ref":"IO.html#warn/2"},{"type":"function","title":"Examples - IO.warn/2","doc":"IO.warn(\"variable bar is unused\", module: MyApp, function: {:main, 1}, line: 4, file: \"my_app.ex\")\n    #=> warning: variable bar is unused\n    #=>   my_app.ex:4: MyApp.main/1","ref":"IO.html#warn/2-examples"},{"type":"function","title":"IO.write/2","doc":"Writes `chardata` to the given `device`.\n\nBy default, the `device` is the standard output.","ref":"IO.html#write/2"},{"type":"function","title":"Examples - IO.write/2","doc":"IO.write(\"sample\")\n    #=> sample\n\n    IO.write(:stderr, \"error\")\n    #=> error","ref":"IO.html#write/2-examples"},{"type":"module","title":"IO.ANSI","doc":"Functionality to render ANSI escape sequences.\n\n[ANSI escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code)\nare characters embedded in text used to control formatting, color, and\nother output options on video text terminals.\n\nANSI escapes are typically enabled on all Unix terminals. They are also\navailable on Windows consoles from Windows 10, although it must be\nexplicitly enabled for the current user in the registry by running the\nfollowing command:\n\n    reg add HKCU\\Console /v VirtualTerminalLevel /t REG_DWORD /d 1\n\nAfter running the command above, you must restart your current console.","ref":"IO.ANSI.html"},{"type":"module","title":"Examples - IO.ANSI","doc":"Because the ANSI escape sequences are embedded in text, the normal usage of\nthese functions is to concatenate their output with text.\n\n    formatted_text = IO.ANSI.blue_background() <> \"Example\" <> IO.ANSI.reset()\n    IO.puts(formatted_text)\n\nA higher level and more convenient API is also available via `IO.ANSI.format/1`,\nwhere you use atoms to represent each ANSI escape sequence and by default\nchecks if ANSI is enabled:\n\n    IO.puts(IO.ANSI.format([:blue_background, \"Example\"]))\n\nIn case ANSI is disabled, the ANSI escape sequences are simply discarded.","ref":"IO.ANSI.html#module-examples"},{"type":"type","title":"IO.ANSI.ansicode/0","doc":"","ref":"IO.ANSI.html#t:ansicode/0"},{"type":"type","title":"IO.ANSI.ansidata/0","doc":"","ref":"IO.ANSI.html#t:ansidata/0"},{"type":"type","title":"IO.ANSI.ansilist/0","doc":"","ref":"IO.ANSI.html#t:ansilist/0"},{"type":"function","title":"IO.ANSI.black/0","doc":"Sets foreground color to black.","ref":"IO.ANSI.html#black/0"},{"type":"function","title":"IO.ANSI.black_background/0","doc":"Sets background color to black.","ref":"IO.ANSI.html#black_background/0"},{"type":"function","title":"IO.ANSI.blink_off/0","doc":"Blink: off.","ref":"IO.ANSI.html#blink_off/0"},{"type":"function","title":"IO.ANSI.blink_rapid/0","doc":"Blink: rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported.","ref":"IO.ANSI.html#blink_rapid/0"},{"type":"function","title":"IO.ANSI.blink_slow/0","doc":"Blink: slow. Less than 150 per minute.","ref":"IO.ANSI.html#blink_slow/0"},{"type":"function","title":"IO.ANSI.blue/0","doc":"Sets foreground color to blue.","ref":"IO.ANSI.html#blue/0"},{"type":"function","title":"IO.ANSI.blue_background/0","doc":"Sets background color to blue.","ref":"IO.ANSI.html#blue_background/0"},{"type":"function","title":"IO.ANSI.bright/0","doc":"Bright (increased intensity) or bold.","ref":"IO.ANSI.html#bright/0"},{"type":"function","title":"IO.ANSI.clear/0","doc":"Clears screen.","ref":"IO.ANSI.html#clear/0"},{"type":"function","title":"IO.ANSI.clear_line/0","doc":"Clears line.","ref":"IO.ANSI.html#clear_line/0"},{"type":"function","title":"IO.ANSI.color/1","doc":"Sets foreground color.","ref":"IO.ANSI.html#color/1"},{"type":"function","title":"IO.ANSI.color/3","doc":"Sets the foreground color from individual RGB values.\n\nValid values for each color are in the range 0 to 5.","ref":"IO.ANSI.html#color/3"},{"type":"function","title":"IO.ANSI.color_background/1","doc":"Sets background color.","ref":"IO.ANSI.html#color_background/1"},{"type":"function","title":"IO.ANSI.color_background/3","doc":"Sets the background color from individual RGB values.\n\nValid values for each color are in the range 0 to 5.","ref":"IO.ANSI.html#color_background/3"},{"type":"function","title":"IO.ANSI.conceal/0","doc":"Conceal. Not widely supported.","ref":"IO.ANSI.html#conceal/0"},{"type":"function","title":"IO.ANSI.crossed_out/0","doc":"Crossed-out. Characters legible, but marked for deletion. Not widely supported.","ref":"IO.ANSI.html#crossed_out/0"},{"type":"function","title":"IO.ANSI.cursor/2","doc":"Sends cursor to the absolute position specified by `line` and `column`.\n\nLine `0` and column `0` would mean the top left corner.","ref":"IO.ANSI.html#cursor/2"},{"type":"function","title":"IO.ANSI.cursor_down/1","doc":"Sends cursor `lines` down.","ref":"IO.ANSI.html#cursor_down/1"},{"type":"function","title":"IO.ANSI.cursor_left/1","doc":"Sends cursor `columns` to the left.","ref":"IO.ANSI.html#cursor_left/1"},{"type":"function","title":"IO.ANSI.cursor_right/1","doc":"Sends cursor `columns` to the right.","ref":"IO.ANSI.html#cursor_right/1"},{"type":"function","title":"IO.ANSI.cursor_up/1","doc":"Sends cursor `lines` up.","ref":"IO.ANSI.html#cursor_up/1"},{"type":"function","title":"IO.ANSI.cyan/0","doc":"Sets foreground color to cyan.","ref":"IO.ANSI.html#cyan/0"},{"type":"function","title":"IO.ANSI.cyan_background/0","doc":"Sets background color to cyan.","ref":"IO.ANSI.html#cyan_background/0"},{"type":"function","title":"IO.ANSI.default_background/0","doc":"Default background color.","ref":"IO.ANSI.html#default_background/0"},{"type":"function","title":"IO.ANSI.default_color/0","doc":"Default text color.","ref":"IO.ANSI.html#default_color/0"},{"type":"function","title":"IO.ANSI.enabled?/0","doc":"Checks if ANSI coloring is supported and enabled on this machine.\n\nThis function simply reads the configuration value for\n`:ansi_enabled` in the `:elixir` application. The value is by\ndefault `false` unless Elixir can detect during startup that\nboth `stdout` and `stderr` are terminals.","ref":"IO.ANSI.html#enabled?/0"},{"type":"function","title":"IO.ANSI.encircled/0","doc":"Encircled.","ref":"IO.ANSI.html#encircled/0"},{"type":"function","title":"IO.ANSI.faint/0","doc":"Faint (decreased intensity). Not widely supported.","ref":"IO.ANSI.html#faint/0"},{"type":"function","title":"IO.ANSI.font_1/0","doc":"Sets alternative font 1.","ref":"IO.ANSI.html#font_1/0"},{"type":"function","title":"IO.ANSI.font_2/0","doc":"Sets alternative font 2.","ref":"IO.ANSI.html#font_2/0"},{"type":"function","title":"IO.ANSI.font_3/0","doc":"Sets alternative font 3.","ref":"IO.ANSI.html#font_3/0"},{"type":"function","title":"IO.ANSI.font_4/0","doc":"Sets alternative font 4.","ref":"IO.ANSI.html#font_4/0"},{"type":"function","title":"IO.ANSI.font_5/0","doc":"Sets alternative font 5.","ref":"IO.ANSI.html#font_5/0"},{"type":"function","title":"IO.ANSI.font_6/0","doc":"Sets alternative font 6.","ref":"IO.ANSI.html#font_6/0"},{"type":"function","title":"IO.ANSI.font_7/0","doc":"Sets alternative font 7.","ref":"IO.ANSI.html#font_7/0"},{"type":"function","title":"IO.ANSI.font_8/0","doc":"Sets alternative font 8.","ref":"IO.ANSI.html#font_8/0"},{"type":"function","title":"IO.ANSI.font_9/0","doc":"Sets alternative font 9.","ref":"IO.ANSI.html#font_9/0"},{"type":"function","title":"IO.ANSI.format/2","doc":"Formats a chardata-like argument by converting named ANSI sequences into actual\nANSI codes.\n\nThe named sequences are represented by atoms.\n\nIt will also append an `IO.ANSI.reset/0` to the chardata when a conversion is\nperformed. If you don't want this behavior, use `format_fragment/2`.\n\nAn optional boolean parameter can be passed to enable or disable\nemitting actual ANSI codes. When `false`, no ANSI codes will be emitted.\nBy default checks if ANSI is enabled using the `enabled?/0` function.\n\nAn `ArgumentError` will be raised if an invalid ANSI code is provided.","ref":"IO.ANSI.html#format/2"},{"type":"function","title":"Examples - IO.ANSI.format/2","doc":"iex> IO.ANSI.format([\"Hello, \", :red, :bright, \"world!\"], true)\n    [[[[[[], \"Hello, \"] | \"\\e[31m\"] | \"\\e[1m\"], \"world!\"] | \"\\e[0m\"]","ref":"IO.ANSI.html#format/2-examples"},{"type":"function","title":"IO.ANSI.format_fragment/2","doc":"Formats a chardata-like argument by converting named ANSI sequences into actual\nANSI codes.\n\nThe named sequences are represented by atoms.\n\nAn optional boolean parameter can be passed to enable or disable\nemitting actual ANSI codes. When `false`, no ANSI codes will be emitted.\nBy default checks if ANSI is enabled using the `enabled?/0` function.","ref":"IO.ANSI.html#format_fragment/2"},{"type":"function","title":"Examples - IO.ANSI.format_fragment/2","doc":"iex> IO.ANSI.format_fragment([:bright, ~c\"Word\"], true)\n    [[[[[[] | \"\\e[1m\"], 87], 111], 114], 100]","ref":"IO.ANSI.html#format_fragment/2-examples"},{"type":"function","title":"IO.ANSI.framed/0","doc":"Framed.","ref":"IO.ANSI.html#framed/0"},{"type":"function","title":"IO.ANSI.green/0","doc":"Sets foreground color to green.","ref":"IO.ANSI.html#green/0"},{"type":"function","title":"IO.ANSI.green_background/0","doc":"Sets background color to green.","ref":"IO.ANSI.html#green_background/0"},{"type":"function","title":"IO.ANSI.home/0","doc":"Sends cursor home.","ref":"IO.ANSI.html#home/0"},{"type":"function","title":"IO.ANSI.inverse/0","doc":"Image: negative. Swap foreground and background.","ref":"IO.ANSI.html#inverse/0"},{"type":"function","title":"IO.ANSI.inverse_off/0","doc":"Image: positive. Normal foreground and background.","ref":"IO.ANSI.html#inverse_off/0"},{"type":"function","title":"IO.ANSI.italic/0","doc":"Italic: on. Not widely supported. Sometimes treated as inverse.","ref":"IO.ANSI.html#italic/0"},{"type":"function","title":"IO.ANSI.light_black/0","doc":"Sets foreground color to light black.","ref":"IO.ANSI.html#light_black/0"},{"type":"function","title":"IO.ANSI.light_black_background/0","doc":"Sets background color to light black.","ref":"IO.ANSI.html#light_black_background/0"},{"type":"function","title":"IO.ANSI.light_blue/0","doc":"Sets foreground color to light blue.","ref":"IO.ANSI.html#light_blue/0"},{"type":"function","title":"IO.ANSI.light_blue_background/0","doc":"Sets background color to light blue.","ref":"IO.ANSI.html#light_blue_background/0"},{"type":"function","title":"IO.ANSI.light_cyan/0","doc":"Sets foreground color to light cyan.","ref":"IO.ANSI.html#light_cyan/0"},{"type":"function","title":"IO.ANSI.light_cyan_background/0","doc":"Sets background color to light cyan.","ref":"IO.ANSI.html#light_cyan_background/0"},{"type":"function","title":"IO.ANSI.light_green/0","doc":"Sets foreground color to light green.","ref":"IO.ANSI.html#light_green/0"},{"type":"function","title":"IO.ANSI.light_green_background/0","doc":"Sets background color to light green.","ref":"IO.ANSI.html#light_green_background/0"},{"type":"function","title":"IO.ANSI.light_magenta/0","doc":"Sets foreground color to light magenta.","ref":"IO.ANSI.html#light_magenta/0"},{"type":"function","title":"IO.ANSI.light_magenta_background/0","doc":"Sets background color to light magenta.","ref":"IO.ANSI.html#light_magenta_background/0"},{"type":"function","title":"IO.ANSI.light_red/0","doc":"Sets foreground color to light red.","ref":"IO.ANSI.html#light_red/0"},{"type":"function","title":"IO.ANSI.light_red_background/0","doc":"Sets background color to light red.","ref":"IO.ANSI.html#light_red_background/0"},{"type":"function","title":"IO.ANSI.light_white/0","doc":"Sets foreground color to light white.","ref":"IO.ANSI.html#light_white/0"},{"type":"function","title":"IO.ANSI.light_white_background/0","doc":"Sets background color to light white.","ref":"IO.ANSI.html#light_white_background/0"},{"type":"function","title":"IO.ANSI.light_yellow/0","doc":"Sets foreground color to light yellow.","ref":"IO.ANSI.html#light_yellow/0"},{"type":"function","title":"IO.ANSI.light_yellow_background/0","doc":"Sets background color to light yellow.","ref":"IO.ANSI.html#light_yellow_background/0"},{"type":"function","title":"IO.ANSI.magenta/0","doc":"Sets foreground color to magenta.","ref":"IO.ANSI.html#magenta/0"},{"type":"function","title":"IO.ANSI.magenta_background/0","doc":"Sets background color to magenta.","ref":"IO.ANSI.html#magenta_background/0"},{"type":"function","title":"IO.ANSI.no_underline/0","doc":"Underline: none.","ref":"IO.ANSI.html#no_underline/0"},{"type":"function","title":"IO.ANSI.normal/0","doc":"Normal color or intensity.","ref":"IO.ANSI.html#normal/0"},{"type":"function","title":"IO.ANSI.not_framed_encircled/0","doc":"Not framed or encircled.","ref":"IO.ANSI.html#not_framed_encircled/0"},{"type":"function","title":"IO.ANSI.not_italic/0","doc":"Not italic.","ref":"IO.ANSI.html#not_italic/0"},{"type":"function","title":"IO.ANSI.not_overlined/0","doc":"Not overlined.","ref":"IO.ANSI.html#not_overlined/0"},{"type":"function","title":"IO.ANSI.overlined/0","doc":"Overlined.","ref":"IO.ANSI.html#overlined/0"},{"type":"function","title":"IO.ANSI.primary_font/0","doc":"Sets primary (default) font.","ref":"IO.ANSI.html#primary_font/0"},{"type":"function","title":"IO.ANSI.red/0","doc":"Sets foreground color to red.","ref":"IO.ANSI.html#red/0"},{"type":"function","title":"IO.ANSI.red_background/0","doc":"Sets background color to red.","ref":"IO.ANSI.html#red_background/0"},{"type":"function","title":"IO.ANSI.reset/0","doc":"Resets all attributes.","ref":"IO.ANSI.html#reset/0"},{"type":"function","title":"IO.ANSI.reverse/0","doc":"Image: negative. Swap foreground and background.","ref":"IO.ANSI.html#reverse/0"},{"type":"function","title":"IO.ANSI.reverse_off/0","doc":"Image: positive. Normal foreground and background.","ref":"IO.ANSI.html#reverse_off/0"},{"type":"function","title":"IO.ANSI.syntax_colors/0","doc":"Syntax colors to be used by `Inspect`.\n\nThose colors are used throughout Elixir's standard library,\nsuch as `dbg/2` and `IEx`.\n\nThe colors can be changed by setting the `:ansi_syntax_colors`\nin the `:elixir` application configuration. Configuration for\nmost built-in data types are supported: `:atom`, `:binary`,\n`:boolean`, `:charlist`, `:list`, `:map`, `:nil`, `:number`,\n`:string`, and `:tuple`. The default is:\n\n    [\n      atom: :cyan\n      boolean: :magenta,\n      charlist: :yellow,\n      nil: :magenta,\n      number: :yellow,\n      string: :green\n    ]","ref":"IO.ANSI.html#syntax_colors/0"},{"type":"function","title":"IO.ANSI.underline/0","doc":"Underline: single.","ref":"IO.ANSI.html#underline/0"},{"type":"function","title":"IO.ANSI.white/0","doc":"Sets foreground color to white.","ref":"IO.ANSI.html#white/0"},{"type":"function","title":"IO.ANSI.white_background/0","doc":"Sets background color to white.","ref":"IO.ANSI.html#white_background/0"},{"type":"function","title":"IO.ANSI.yellow/0","doc":"Sets foreground color to yellow.","ref":"IO.ANSI.html#yellow/0"},{"type":"function","title":"IO.ANSI.yellow_background/0","doc":"Sets background color to yellow.","ref":"IO.ANSI.html#yellow_background/0"},{"type":"module","title":"IO.Stream","doc":"Defines an `IO.Stream` struct returned by `IO.stream/2` and `IO.binstream/2`.\n\nThe following fields are public:\n\n  * `device`        - the IO device\n  * `raw`           - a boolean indicating if bin functions should be used\n  * `line_or_bytes` - if reading should read lines or a given number of bytes\n\nIt is worth noting that an IO stream has side effects and every time you go\nover the stream you may get different results.","ref":"IO.Stream.html"},{"type":"type","title":"IO.Stream.t/0","doc":"","ref":"IO.Stream.html#t:t/0"},{"type":"module","title":"OptionParser","doc":"Functions for parsing command line arguments.\n\nWhen calling a command, it's possible to pass command line options\nto modify what the command does. In this documentation, those are\ncalled \"switches\", in other situations they may be called \"flags\"\nor simply \"options\". A switch can be given a value, also called an\n\"argument\".\n\nThe main function in this module is `parse/2`, which parses a list\nof command line options and arguments into a keyword list:\n\n    iex> OptionParser.parse([\"--debug\"], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n`OptionParser` provides some conveniences out of the box,\nsuch as aliases and automatic handling of negation switches.\n\nThe `parse_head/2` function is an alternative to `parse/2`\nwhich stops parsing as soon as it finds a value that is not\na switch nor a value for a previous switch.\n\nThis module also provides low-level functions, such as `next/2`,\nfor parsing switches manually, as well as `split/1` and `to_argv/1`\nfor parsing from and converting switches to strings.","ref":"OptionParser.html"},{"type":"type","title":"OptionParser.argv/0","doc":"","ref":"OptionParser.html#t:argv/0"},{"type":"type","title":"OptionParser.errors/0","doc":"","ref":"OptionParser.html#t:errors/0"},{"type":"function","title":"OptionParser.next/2","doc":"Low-level function that parses one option.\n\nIt accepts the same options as `parse/2` and `parse_head/2`\nas both functions are built on top of this function. This function\nmay return:\n\n  * `{:ok, key, value, rest}` - the option `key` with `value` was\n    successfully parsed\n\n  * `{:invalid, key, value, rest}` - the option `key` is invalid with `value`\n    (returned when the value cannot be parsed according to the switch type)\n\n  * `{:undefined, key, value, rest}` - the option `key` is undefined\n    (returned in strict mode when the switch is unknown or on nonexistent atoms)\n\n  * `{:error, rest}` - there are no switches at the head of the given `argv`","ref":"OptionParser.html#next/2"},{"type":"type","title":"OptionParser.options/0","doc":"","ref":"OptionParser.html#t:options/0"},{"type":"function","title":"OptionParser.parse/2","doc":"Parses `argv` into a keyword list.\n\nIt returns a three-element tuple with the form `{parsed, args, invalid}`, where:\n\n  * `parsed` is a keyword list of parsed switches with `{switch_name, value}`\n    tuples in it; `switch_name` is the atom representing the switch name while\n    `value` is the value for that switch parsed according to `opts` (see the\n    \"Examples\" section for more information)\n  * `args` is a list of the remaining arguments in `argv` as strings\n  * `invalid` is a list of invalid options as `{option_name, value}` where\n    `option_name` is the raw option and `value` is `nil` if the option wasn't\n    expected or the string value if the value didn't have the expected type for\n    the corresponding option\n\nElixir converts switches to underscored atoms, so `--source-path` becomes\n`:source_path`. This is done to better suit Elixir conventions. However, this\nmeans that switches can't contain underscores and switches that do contain\nunderscores are always returned in the list of invalid switches.\n\nWhen parsing, it is common to list switches and their expected types:\n\n    iex> OptionParser.parse([\"--debug\"], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n    iex> OptionParser.parse([\"--source\", \"lib\"], strict: [source: :string])\n    {[source: \"lib\"], [], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--source-path\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   strict: [source_path: :string, verbose: :boolean]\n    ...> )\n    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n\nWe will explore the valid switches and operation modes of option parser below.","ref":"OptionParser.html#parse/2"},{"type":"function","title":"Options - OptionParser.parse/2","doc":"The following options are supported:\n\n  * `:switches` or `:strict` - see the \"Switch definitions\" section below\n  * `:allow_nonexistent_atoms` - see the \"Parsing unknown switches\" section below\n  * `:aliases` - see the \"Aliases\" section below\n  * `:return_separator` - see the \"Return separator\" section below","ref":"OptionParser.html#parse/2-options"},{"type":"function","title":"Switch definitions - OptionParser.parse/2","doc":"Switches can be specified via one of two options:\n\n  * `:strict` - defines strict switches and their types. Any switch\n    in `argv` that is not specified in the list is returned in the\n    invalid options list. This is the preferred way to parse options.\n\n  * `:switches` - defines switches and their types. This function\n    still attempts to parse switches that are not in this list.\n\nBoth these options accept a keyword list where the key is an atom\ndefining the name of the switch and value is the `type` of the\nswitch (see the \"Types\" section below for more information).\n\nNote that you should only supply the `:switches` or the `:strict` option.\nIf you supply both, an `ArgumentError` exception will be raised.","ref":"OptionParser.html#parse/2-switch-definitions"},{"type":"function","title":"Types - OptionParser.parse/2","doc":"Switches parsed by `OptionParser` may take zero or one arguments.\n\nThe following switches types take no arguments:\n\n  * `:boolean` - sets the value to `true` when given (see also the\n    \"Negation switches\" section below)\n  * `:count` - counts the number of times the switch is given\n\nThe following switches take one argument:\n\n  * `:integer` - parses the value as an integer\n  * `:float` - parses the value as a float\n  * `:string` - parses the value as a string\n\nIf a switch can't be parsed according to the given type, it is\nreturned in the invalid options list.","ref":"OptionParser.html#parse/2-types"},{"type":"function","title":"Modifiers - OptionParser.parse/2","doc":"Switches can be specified with modifiers, which change how\nthey behave. The following modifiers are supported:\n\n  * `:keep` - keeps duplicate elements instead of overriding them;\n    works with all types except `:count`. Specifying `switch_name: :keep`\n    assumes the type of `:switch_name` will be `:string`.\n\nTo use `:keep` with a type other than `:string`, use a list as the type\nfor the switch. For example: `[foo: [:integer, :keep]]`.","ref":"OptionParser.html#parse/2-modifiers"},{"type":"function","title":"Negation switches - OptionParser.parse/2","doc":"In case a switch `SWITCH` is specified to have type `:boolean`, it may be\npassed as `--no-SWITCH` as well which will set the option to `false`:\n\n    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :boolean])\n    {[op: false], [\"path/to/file\"], []}","ref":"OptionParser.html#parse/2-negation-switches"},{"type":"function","title":"Parsing unknown switches - OptionParser.parse/2","doc":"When the `:switches` option is given, `OptionParser` will attempt to parse\nunknown switches.\n\nSwitches without an argument will be set to `true`:\n\n    iex> OptionParser.parse([\"--debug\"], switches: [key: :string])\n    {[debug: true], [], []}\n\nEven though we haven't specified `--debug` in the list of switches, it is part\nof the returned options. The same happens for switches followed by another switch:\n\n    iex> OptionParser.parse([\"--debug\", \"--ok\"], switches: [])\n    {[debug: true, ok: true], [], []}\n\nSwitches followed by a value will be assigned the value, as a string:\n\n    iex> OptionParser.parse([\"--debug\", \"value\"], switches: [key: :string])\n    {[debug: \"value\"], [], []}\n\nSince we cannot assert the type of the switch value, it is preferred to use the\n`:strict` option that accepts only known switches and always verify their types.\n\nIf you do want to parse unknown switches, remember that Elixir converts switches\nto atoms. Since atoms are not garbage-collected, to avoid creating new ones,\nOptionParser by default only parses switches that translate to existing atoms.\nThe code below discards the `--option-parser-example` switch because the\n`:option_parser_example` atom is never used anywhere:\n\n    iex> OptionParser.parse([\"--option-parser-example\"], switches: [])\n    {[], [], []}\n\nIf a switch corresponds to an existing Elixir atom, whether from your\ncode, a dependency or from Elixir itself, it will be accepted. However,\nit is best to not rely on external code, and always define the atoms\nyou want to parse in the same module that calls `OptionParser` itself,\nas direct arguments to the `:switches` or `:strict` options.\n\nIf you would like to parse all switches, regardless if they exist or not,\nyou can force creation of atoms by passing `allow_nonexistent_atoms: true`\nas option. Use this option with care. It is only useful when you are building\ncommand-line applications that receive dynamically-named arguments and must\nbe avoided in long-running systems.","ref":"OptionParser.html#parse/2-parsing-unknown-switches"},{"type":"function","title":"Aliases - OptionParser.parse/2","doc":"A set of aliases can be specified in the `:aliases` option:\n\n    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug], strict: [debug: :boolean])\n    {[debug: true], [], []}","ref":"OptionParser.html#parse/2-aliases"},{"type":"function","title":"Examples - OptionParser.parse/2","doc":"Here are some examples of working with different types and modifiers:\n\n    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: [unlock: :boolean])\n    {[unlock: true], [\"path/to/file\"], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--unlock\", \"--limit\", \"0\", \"path/to/file\"],\n    ...>   strict: [unlock: :boolean, limit: :integer]\n    ...> )\n    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n\n    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :integer])\n    {[limit: 3], [], []}\n\n    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :integer])\n    {[], [], [{\"--limit\", \"xyz\"}]}\n\n    iex> OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n    {[verbose: 1], [], []}\n\n    iex> OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], strict: [verbose: :count])\n    {[verbose: 2], [], []}\n\n    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n\n    iex> OptionParser.parse(\n    ...>   [\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n    ...>   switches: [limit: :integer]\n    ...> )\n    {[limit: 3, unknown: \"xyz\"], [], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--unlock\", \"path/to/file\", \"--unlock\", \"path/to/another/file\"],\n    ...>   strict: [unlock: :keep]\n    ...> )\n    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}","ref":"OptionParser.html#parse/2-examples"},{"type":"function","title":"Return separator - OptionParser.parse/2","doc":"The separator `--` implies options should no longer be processed.\nBy default, the separator is not returned as parts of the arguments,\nbut that can be changed via the `:return_separator` option:\n\n    iex> OptionParser.parse([\"--\", \"lib\"], return_separator: true, strict: [])\n    {[], [\"--\", \"lib\"], []}\n\n    iex> OptionParser.parse([\"--no-halt\", \"--\", \"lib\"], return_separator: true, switches: [halt: :boolean])\n    {[halt: false], [\"--\", \"lib\"], []}\n\n    iex> OptionParser.parse([\"script.exs\", \"--no-halt\", \"--\", \"foo\"], return_separator: true, switches: [halt: :boolean])\n    {[{:halt, false}], [\"script.exs\", \"--\", \"foo\"], []}","ref":"OptionParser.html#parse/2-return-separator"},{"type":"function","title":"OptionParser.parse!/2","doc":"The same as `parse/2` but raises an `OptionParser.ParseError`\nexception if any invalid options are given.\n\nIf there are no errors, returns a `{parsed, rest}` tuple where:\n\n  * `parsed` is the list of parsed switches (same as in `parse/2`)\n  * `rest` is the list of arguments (same as in `parse/2`)","ref":"OptionParser.html#parse!/2"},{"type":"function","title":"Examples - OptionParser.parse!/2","doc":"iex> OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: [debug: :boolean])\n    {[debug: true], [\"path/to/file\"]}\n\n    iex> OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :integer])\n    ** (OptionParser.ParseError) 1 error found!\n    --limit : Expected type integer, got \"xyz\"\n\n    iex> OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n    ** (OptionParser.ParseError) 1 error found!\n    --unknown : Unknown option\n\n    iex> OptionParser.parse!(\n    ...>   [\"-l\", \"xyz\", \"-f\", \"bar\"],\n    ...>   switches: [limit: :integer, foo: :integer],\n    ...>   aliases: [l: :limit, f: :foo]\n    ...> )\n    ** (OptionParser.ParseError) 2 errors found!\n    -l : Expected type integer, got \"xyz\"\n    -f : Expected type integer, got \"bar\"","ref":"OptionParser.html#parse!/2-examples"},{"type":"function","title":"OptionParser.parse_head/2","doc":"Similar to `parse/2` but only parses the head of `argv`;\nas soon as it finds a non-switch, it stops parsing.\n\nSee `parse/2` for more information.","ref":"OptionParser.html#parse_head/2"},{"type":"function","title":"Example - OptionParser.parse_head/2","doc":"iex> OptionParser.parse_head(\n    ...>   [\"--source\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   switches: [source: :string, verbose: :boolean]\n    ...> )\n    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n\n    iex> OptionParser.parse_head(\n    ...>   [\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n    ...>   switches: [source: :string, verbose: :boolean, unlock: :boolean]\n    ...> )\n    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock\"], []}","ref":"OptionParser.html#parse_head/2-example"},{"type":"function","title":"OptionParser.parse_head!/2","doc":"The same as `parse_head/2` but raises an `OptionParser.ParseError`\nexception if any invalid options are given.\n\nIf there are no errors, returns a `{parsed, rest}` tuple where:\n\n  * `parsed` is the list of parsed switches (same as in `parse_head/2`)\n  * `rest` is the list of arguments (same as in `parse_head/2`)","ref":"OptionParser.html#parse_head!/2"},{"type":"function","title":"Examples - OptionParser.parse_head!/2","doc":"iex> OptionParser.parse_head!(\n    ...>   [\"--source\", \"lib\", \"path/to/file\", \"--verbose\"],\n    ...>   switches: [source: :string, verbose: :boolean]\n    ...> )\n    {[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--number\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   strict: [number: :integer]\n    ...> )\n    ** (OptionParser.ParseError) 1 error found!\n    --number : Expected type integer, got \"lib\"\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n    ...>   strict: [verbose: :integer, source: :integer]\n    ...> )\n    ** (OptionParser.ParseError) 2 errors found!\n    --verbose : Missing argument of type integer\n    --source : Expected type integer, got \"lib\"","ref":"OptionParser.html#parse_head!/2-examples"},{"type":"type","title":"OptionParser.parsed/0","doc":"","ref":"OptionParser.html#t:parsed/0"},{"type":"function","title":"OptionParser.split/1","doc":"Splits a string into `t:argv/0` chunks.\n\nThis function splits the given `string` into a list of strings in a similar\nway to many shells.","ref":"OptionParser.html#split/1"},{"type":"function","title":"Examples - OptionParser.split/1","doc":"iex> OptionParser.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n    [\"foo\", \"bar baz\"]","ref":"OptionParser.html#split/1-examples"},{"type":"function","title":"OptionParser.to_argv/2","doc":"Receives a key-value enumerable and converts it to `t:argv/0`.\n\nKeys must be atoms. Keys with `nil` value are discarded,\nboolean values are converted to `--key` or `--no-key`\n(if the value is `true` or `false`, respectively),\nand all other values are converted using `to_string/1`.\n\nIt is advised to pass to `to_argv/2` the same set of `options`\ngiven to `parse/2`. Some switches can only be reconstructed\ncorrectly with the `:switches` information in hand.","ref":"OptionParser.html#to_argv/2"},{"type":"function","title":"Examples - OptionParser.to_argv/2","doc":"iex> OptionParser.to_argv(foo_bar: \"baz\")\n    [\"--foo-bar\", \"baz\"]\n    iex> OptionParser.to_argv(bool: true, bool: false, discarded: nil)\n    [\"--bool\", \"--no-bool\"]\n\nSome switches will output different values based on the switches\ntypes:\n\n    iex> OptionParser.to_argv([number: 2], switches: [])\n    [\"--number\", \"2\"]\n    iex> OptionParser.to_argv([number: 2], switches: [number: :count])\n    [\"--number\", \"--number\"]","ref":"OptionParser.html#to_argv/2-examples"},{"type":"module","title":"Path","doc":"This module provides conveniences for manipulating or\nretrieving file system paths.\n\nThe functions in this module may receive chardata as\narguments and will always return a string encoded in UTF-8. Chardata\nis a string or a list of characters and strings, see `t:IO.chardata/0`.\nIf a binary is given, in whatever encoding, its encoding will be kept.\n\nThe majority of the functions in this module do not\ninteract with the file system, except for a few functions\nthat require it (like `wildcard/2` and `expand/1`).","ref":"Path.html"},{"type":"function","title":"Path.absname/1","doc":"Converts the given path to an absolute one.\n\nUnlike `expand/1`, no attempt is made to resolve `..`, `.`, or `~`.","ref":"Path.html#absname/1"},{"type":"function","title":"Examples - Path.absname/1","doc":"","ref":"Path.html#absname/1-examples"},{"type":"function","title":"Unix-like operating systems - Path.absname/1","doc":"Path.absname(\"foo\")\n    #=> \"/usr/local/foo\"\n\n    Path.absname(\"../x\")\n    #=> \"/usr/local/../x\"","ref":"Path.html#absname/1-unix-like-operating-systems"},{"type":"function","title":"Windows - Path.absname/1","doc":"Path.absname(\"foo\")\n    #=> \"D:/usr/local/foo\"\n\n    Path.absname(\"../x\")\n    #=> \"D:/usr/local/../x\"","ref":"Path.html#absname/1-windows"},{"type":"function","title":"Path.absname/2","doc":"Builds a path from `relative_to` to `path`.\n\nIf `path` is already an absolute path, `relative_to` is ignored. See also\n`relative_to/3`. `relative_to` is either a path or an anonymous function,\nwhich is invoked only when necessary, that returns a path.\n\nUnlike `expand/2`, no attempt is made to resolve `..`, `.` or `~`.","ref":"Path.html#absname/2"},{"type":"function","title":"Examples - Path.absname/2","doc":"iex> Path.absname(\"foo\", \"bar\")\n    \"bar/foo\"\n\n    iex> Path.absname(\"../x\", \"bar\")\n    \"bar/../x\"\n\n    iex> Path.absname(\"foo\", fn -> \"lazy\" end)\n    \"lazy/foo\"","ref":"Path.html#absname/2-examples"},{"type":"function","title":"Path.basename/1","doc":"Returns the last component of the path or the path\nitself if it does not contain any directory separators.","ref":"Path.html#basename/1"},{"type":"function","title":"Examples - Path.basename/1","doc":"iex> Path.basename(\"foo\")\n    \"foo\"\n\n    iex> Path.basename(\"foo/bar\")\n    \"bar\"\n\n    iex> Path.basename(\"lib/module/submodule.ex\")\n    \"submodule.ex\"\n\n    iex> Path.basename(\"/\")\n    \"\"","ref":"Path.html#basename/1-examples"},{"type":"function","title":"Path.basename/2","doc":"Returns the last component of `path` with the `extension`\nstripped.\n\nThis function should be used to remove a specific\nextension which may or may not be there.","ref":"Path.html#basename/2"},{"type":"function","title":"Examples - Path.basename/2","doc":"iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n    \"bar\"\n\n    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n    \"bar.exs\"\n\n    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n    \"bar.old\"","ref":"Path.html#basename/2-examples"},{"type":"function","title":"Path.dirname/1","doc":"Returns the directory component of `path`.","ref":"Path.html#dirname/1"},{"type":"function","title":"Examples - Path.dirname/1","doc":"iex> Path.dirname(\"/foo/bar.ex\")\n    \"/foo\"\n\n    iex> Path.dirname(\"/foo/bar/baz.ex\")\n    \"/foo/bar\"\n\n    iex> Path.dirname(\"/foo/bar/\")\n    \"/foo/bar\"\n\n    iex> Path.dirname(\"bar.ex\")\n    \".\"","ref":"Path.html#dirname/1-examples"},{"type":"function","title":"Path.expand/1","doc":"Converts the path to an absolute one, expanding\nany `.` and `..` components and a leading `~`.\n\nIf a relative path is provided it is expanded relatively to\nthe current working directory.","ref":"Path.html#expand/1"},{"type":"function","title":"Examples - Path.expand/1","doc":"Path.expand(\"/foo/bar/../baz\")\n    #=> \"/foo/baz\"\n\n    Path.expand(\"foo/bar/../baz\")\n    #=> \"$PWD/foo/baz\"","ref":"Path.html#expand/1-examples"},{"type":"function","title":"Path.expand/2","doc":"Expands the path relative to the path given as the second argument\nexpanding any `.` and `..` characters.\n\nIf the path is already an absolute path, `relative_to` is ignored.\n\nNote that this function treats a `path` with a leading `~` as\nan absolute one.\n\nThe second argument is first expanded to an absolute path.","ref":"Path.html#expand/2"},{"type":"function","title":"Examples - Path.expand/2","doc":"# Assuming that the absolute path to baz is /quux/baz\n    Path.expand(\"foo/bar/../bar\", \"baz\")\n    #=> \"/quux/baz/foo/bar\"\n\n    Path.expand(\"foo/bar/../bar\", \"/baz\")\n    #=> \"/baz/foo/bar\"\n\n    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n    #=> \"/foo/bar\"","ref":"Path.html#expand/2-examples"},{"type":"function","title":"Path.extname/1","doc":"Returns the extension of the last component of `path`.\n\nFor filenames starting with a dot and without an extension, it returns\nan empty string.\n\nSee `basename/1` and `rootname/1` for related functions to extract\ninformation from paths.","ref":"Path.html#extname/1"},{"type":"function","title":"Examples - Path.extname/1","doc":"iex> Path.extname(\"foo.erl\")\n    \".erl\"\n\n    iex> Path.extname(\"~/foo/bar\")\n    \"\"\n\n    iex> Path.extname(\".gitignore\")\n    \"\"","ref":"Path.html#extname/1-examples"},{"type":"function","title":"Path.join/1","doc":"Joins a list of paths.\n\nThis function should be used to convert a list of paths to a path.\nNote that any trailing slash is removed when joining.\n\nRaises an error if the given list of paths is empty.","ref":"Path.html#join/1"},{"type":"function","title":"Examples - Path.join/1","doc":"iex> Path.join([\"~\", \"foo\"])\n    \"~/foo\"\n\n    iex> Path.join([\"foo\"])\n    \"foo\"\n\n    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n    \"/foo/bar\"","ref":"Path.html#join/1-examples"},{"type":"function","title":"Path.join/2","doc":"Joins two paths.\n\nThe right path will always be expanded to its relative format\nand any trailing slash will be removed when joining.","ref":"Path.html#join/2"},{"type":"function","title":"Examples - Path.join/2","doc":"iex> Path.join(\"foo\", \"bar\")\n    \"foo/bar\"\n\n    iex> Path.join(\"/foo\", \"/bar/\")\n    \"/foo/bar\"\n\nThe functions in this module support chardata, so giving a list will\ntreat it as a single entity:\n\n    iex> Path.join(\"foo\", [\"bar\", \"fiz\"])\n    \"foo/barfiz\"\n\n    iex> Path.join([\"foo\", \"bar\"], \"fiz\")\n    \"foobar/fiz\"\n\nUse `join/1` if you need to join a list of paths instead.","ref":"Path.html#join/2-examples"},{"type":"function","title":"Path.relative/1","doc":"Forces the path to be a relative path.\n\nIf an absolute path is given, it is stripped from its root component.","ref":"Path.html#relative/1"},{"type":"function","title":"Examples - Path.relative/1","doc":"","ref":"Path.html#relative/1-examples"},{"type":"function","title":"Unix-like operating systems - Path.relative/1","doc":"Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"","ref":"Path.html#relative/1-unix-like-operating-systems"},{"type":"function","title":"Windows - Path.relative/1","doc":"Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"","ref":"Path.html#relative/1-windows"},{"type":"function","title":"Path.relative_to/3","doc":"Returns the direct relative path from `path` in relation to `cwd`.\n\nIn other words, this function attempts to return a path such that\n`Path.expand(result, cwd)` points to `path`. This function aims\nto return a relative path whenever possible, but that's not guaranteed:\n\n  * If both paths are relative, a relative path is always returned\n\n  * If both paths are absolute, a relative path may be returned if\n    they share a common prefix. You can pass the `:force` option to\n    force this function to traverse up, but even then a relative\n    path is not guaranteed (for example, if the absolute paths\n    belong to different drives on Windows)\n\n  * If a mixture of paths are given, the result will always match\n    the given `path` (the first argument)\n\nThis function expands `.` and `..` entries without traversing the\nfile system, so it assumes no symlinks between the paths. See\n`safe_relative_to/2` for a safer alternative.","ref":"Path.html#relative_to/3"},{"type":"function","title":"Options - Path.relative_to/3","doc":"* `:force` - (boolean since v1.16.0) if `true` forces a relative\n  path to be returned by traversing the path up. Except if the paths\n  are in different volumes on Windows. Defaults to `false`.","ref":"Path.html#relative_to/3-options"},{"type":"function","title":"Examples - Path.relative_to/3","doc":"","ref":"Path.html#relative_to/3-examples"},{"type":"function","title":"With relative `cwd` - Path.relative_to/3","doc":"If both paths are relative, a minimum path is computed:\n\n    Path.relative_to(\"tmp/foo/bar\", \"tmp\")      #=> \"foo/bar\"\n    Path.relative_to(\"tmp/foo/bar\", \"tmp/foo\")  #=> \"bar\"\n    Path.relative_to(\"tmp/foo/bar\", \"tmp/bat\")  #=> \"../foo/bar\"\n\nIf an absolute path is given with relative `cwd`, it is returned as:\n\n    Path.relative_to(\"/usr/foo/bar\", \"tmp/bat\")  #=> \"/usr/foo/bar\"","ref":"Path.html#relative_to/3-with-relative-cwd"},{"type":"function","title":"With absolute `cwd` - Path.relative_to/3","doc":"If both paths are absolute, a relative is computed if possible,\nwithout traversing up:\n\n    Path.relative_to(\"/usr/local/foo\", \"/usr/local\")      #=> \"foo\"\n    Path.relative_to(\"/usr/local/foo\", \"/\")               #=> \"usr/local/foo\"\n    Path.relative_to(\"/usr/local/foo\", \"/etc\")            #=> \"/usr/local/foo\"\n    Path.relative_to(\"/usr/local/foo\", \"/usr/local/foo\")  #=> \".\"\n    Path.relative_to(\"/usr/local/../foo\", \"/usr/foo\")     #=> \".\"\n    Path.relative_to(\"/usr/local/../foo/bar\", \"/usr/foo\") #=> \"bar\"\n\nIf `:force` is set to `true` paths are traversed up:\n\n    Path.relative_to(\"/usr\", \"/usr/local\", force: true)          #=> \"..\"\n    Path.relative_to(\"/usr/foo\", \"/usr/local\", force: true)      #=> \"../foo\"\n    Path.relative_to(\"/usr/../foo/bar\", \"/etc/foo\", force: true) #=> \"../../foo/bar\"\n\nIf a relative path is given, it is assumed to be relative to the\ngiven path, so the path is returned with \".\" and \"..\" expanded:\n\n    Path.relative_to(\".\", \"/usr/local\")          #=> \".\"\n    Path.relative_to(\"foo\", \"/usr/local\")        #=> \"foo\"\n    Path.relative_to(\"foo/../bar\", \"/usr/local\") #=> \"bar\"\n    Path.relative_to(\"foo/..\", \"/usr/local\")     #=> \".\"\n    Path.relative_to(\"../foo\", \"/usr/local\")     #=> \"../foo\"","ref":"Path.html#relative_to/3-with-absolute-cwd"},{"type":"function","title":"Path.relative_to_cwd/2","doc":"Convenience to get the path relative to the current working\ndirectory.\n\nIf, for some reason, the current working directory\ncannot be retrieved, this function returns the given `path`.\n\nCheck `relative_to/3` for the supported options.","ref":"Path.html#relative_to_cwd/2"},{"type":"function","title":"Path.rootname/1","doc":"Returns the `path` with the `extension` stripped.","ref":"Path.html#rootname/1"},{"type":"function","title":"Examples - Path.rootname/1","doc":"iex> Path.rootname(\"/foo/bar\")\n    \"/foo/bar\"\n\n    iex> Path.rootname(\"/foo/bar.ex\")\n    \"/foo/bar\"","ref":"Path.html#rootname/1-examples"},{"type":"function","title":"Path.rootname/2","doc":"Returns the `path` with the `extension` stripped.\n\nThis function should be used to remove a specific extension which may\nor may not be there.","ref":"Path.html#rootname/2"},{"type":"function","title":"Examples - Path.rootname/2","doc":"iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n    \"/foo/bar\"\n\n    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n    \"/foo/bar.erl\"","ref":"Path.html#rootname/2-examples"},{"type":"function","title":"Path.safe_relative/2","doc":"Returns a relative path that is protected from directory-traversal attacks.\n\nThe given relative path is sanitized by eliminating `..` and `.` components.\n\nThis function checks that, after expanding those components, the path is still \"safe\".\nPaths are considered unsafe if either of these is true:\n\n  * The path is not relative, such as `\"/foo/bar\"`.\n\n  * A `..` component would make it so that the path would traverse up above\n    the root of `relative_to`.\n\n  * A symbolic link in the path points to something above the root of `cwd`.","ref":"Path.html#safe_relative/2"},{"type":"function","title":"Examples - Path.safe_relative/2","doc":"iex> Path.safe_relative(\"foo\")\n    {:ok, \"foo\"}\n\n    iex> Path.safe_relative(\"deps/my_dep/app.beam\")\n    {:ok, \"deps/my_dep/app.beam\"}\n\n    iex> Path.safe_relative(\"deps/my_dep/./build/../app.beam\", File.cwd!())\n    {:ok, \"deps/my_dep/app.beam\"}\n\n    iex> Path.safe_relative(\"my_dep/../..\")\n    :error\n\n    iex> Path.safe_relative(\"/usr/local\", File.cwd!())\n    :error","ref":"Path.html#safe_relative/2-examples"},{"type":"function","title":"Path.safe_relative_to/2","doc":"Returns a relative path that is protected from directory-traversal attacks.\n\nSee `safe_relative/2` for a non-deprecated version of this API.","ref":"Path.html#safe_relative_to/2"},{"type":"function","title":"Path.split/1","doc":"Splits the path into a list at the path separator.\n\nIf an empty string is given, returns an empty list.\n\nOn Windows, path is split on both `\"\\\"` and `\"/\"` separators\nand the driver letter, if there is one, is always returned\nin lowercase.","ref":"Path.html#split/1"},{"type":"function","title":"Examples - Path.split/1","doc":"iex> Path.split(\"\")\n    []\n\n    iex> Path.split(\"foo\")\n    [\"foo\"]\n\n    iex> Path.split(\"/foo/bar\")\n    [\"/\", \"foo\", \"bar\"]","ref":"Path.html#split/1-examples"},{"type":"type","title":"Path.t/0","doc":"A path.","ref":"Path.html#t:t/0"},{"type":"function","title":"Path.type/1","doc":"Returns the path type.","ref":"Path.html#type/1"},{"type":"function","title":"Examples - Path.type/1","doc":"","ref":"Path.html#type/1-examples"},{"type":"function","title":"Unix-like operating systems - Path.type/1","doc":"Path.type(\"/\")                #=> :absolute\n    Path.type(\"/usr/local/bin\")   #=> :absolute\n    Path.type(\"usr/local/bin\")    #=> :relative\n    Path.type(\"../usr/local/bin\") #=> :relative\n    Path.type(\"~/file\")           #=> :relative","ref":"Path.html#type/1-unix-like-operating-systems"},{"type":"function","title":"Windows - Path.type/1","doc":"Path.type(\"D:/usr/local/bin\") #=> :absolute\n    Path.type(\"usr/local/bin\")    #=> :relative\n    Path.type(\"D:bar.ex\")         #=> :volumerelative\n    Path.type(\"/bar/foo.ex\")      #=> :volumerelative","ref":"Path.html#type/1-windows"},{"type":"function","title":"Path.wildcard/2","doc":"Traverses paths according to the given `glob` expression and returns a\nlist of matches.\n\nThe wildcard looks like an ordinary path, except that the following\n\"wildcard characters\" are interpreted in a special way:\n\n  * `?` - matches one character.\n\n  * `*` - matches any number of characters up to the end of the filename, the\n    next dot, or the next slash.\n\n  * `**` - two adjacent `*`'s used as a single pattern will match all\n    files and zero or more directories and subdirectories.\n\n  * `[char1,char2,...]` - matches any of the characters listed; two\n    characters separated by a hyphen will match a range of characters.\n    Do not add spaces before and after the comma as it would then match\n    paths containing the space character itself.\n\n  * `{item1,item2,...}` - matches one of the alternatives.\n    Do not add spaces before and after the comma as it would then match\n    paths containing the space character itself.\n\nOther characters represent themselves. Only paths that have\nexactly the same character in the same position will match. Note\nthat matching is case-sensitive: `\"a\"` will not match `\"A\"`.\n\nDirectory separators must always be written as `/`, even on Windows.\nYou may call `Path.expand/1` to normalize the path before invoking\nthis function.\n\nA character preceded by `\\\\` loses its special meaning.\nNote that `\\\\` must be written as `\\\\\\\\` in a string literal.\nFor example, `\"\\\\\\\\?*\"` will match any filename starting with `?.`.\n\nBy default, the patterns `*` and `?` do not match files starting\nwith a dot `.`. See the `:match_dot` option in the \"Options\" section\nbelow.","ref":"Path.html#wildcard/2"},{"type":"function","title":"Options - Path.wildcard/2","doc":"* `:match_dot` - (boolean) if `false`, the special wildcard characters `*` and `?`\n    will not match files starting with a dot (`.`). If `true`, files starting with\n    a `.` will not be treated specially. Defaults to `false`.","ref":"Path.html#wildcard/2-options"},{"type":"function","title":"Examples - Path.wildcard/2","doc":"Imagine you have a directory called `projects` with three Elixir projects\ninside of it: `elixir`, `ex_doc`, and `plug`. You can find all `.beam` files\ninside the `ebin` directory of each project as follows:\n\n    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n\nIf you want to search for both `.beam` and `.app` files, you could do:\n\n    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")","ref":"Path.html#wildcard/2-examples"},{"type":"module","title":"Port","doc":"Functions for interacting with the external world through ports.\n\nPorts provide a mechanism to start operating system processes external\nto the Erlang VM and communicate with them via message passing.","ref":"Port.html"},{"type":"module","title":"Example - Port","doc":"iex> port = Port.open({:spawn, \"cat\"}, [:binary])\n    iex> send(port, {self(), {:command, \"hello\"}})\n    iex> send(port, {self(), {:command, \"world\"}})\n    iex> flush()\n    {#Port<0.1444>, {:data, \"hello\"}}\n    {#Port<0.1444>, {:data, \"world\"}}\n    iex> send(port, {self(), :close})\n    :ok\n    iex> flush()\n    {#Port<0.1444>, :closed}\n    :ok\n\nIn the example above, we have created a new port that executes the\nprogram `cat`. `cat` is a program available on Unix-like operating systems that\nreceives data from multiple inputs and concatenates them in the output.\n\nAfter the port was created, we sent it two commands in the form of\nmessages using `send/2`. The first command has the binary payload\nof \"hello\" and the second has \"world\".\n\nAfter sending those two messages, we invoked the IEx helper `flush()`,\nwhich printed all messages received from the port, in this case we got\n\"hello\" and \"world\" back. Note that the messages are in binary because we\npassed the `:binary` option when opening the port in `Port.open/2`. Without\nsuch option, it would have yielded a list of bytes.\n\nOnce everything was done, we closed the port.\n\nElixir provides many conveniences for working with ports and some drawbacks.\nWe will explore those below.","ref":"Port.html#module-example"},{"type":"module","title":"Message and function APIs - Port","doc":"There are two APIs for working with ports. It can be either asynchronous via\nmessage passing, as in the example above, or by calling the functions on this\nmodule.\n\nThe messages supported by ports and their counterpart function APIs are\nlisted below:\n\n  * `{pid, {:command, binary}}` - sends the given data to the port.\n    See `command/3`.\n\n  * `{pid, :close}` - closes the port. Unless the port is already closed,\n    the port will reply with `{port, :closed}` message once it has flushed\n    its buffers and effectively closed. See `close/1`.\n\n  * `{pid, {:connect, new_pid}}` - sets the `new_pid` as the new owner of\n    the port. Once a port is opened, the port is linked and connected to the\n    caller process and communication to the port only happens through the\n    connected process. This message makes `new_pid` the new connected processes.\n    Unless the port is dead, the port will reply to the old owner with\n    `{port, :connected}`. See `connect/2`.\n\nOn its turn, the port will send the connected process the following messages:\n\n  * `{port, {:data, data}}` - data sent by the port\n  * `{port, :closed}` - reply to the `{pid, :close}` message\n  * `{port, :connected}` - reply to the `{pid, {:connect, new_pid}}` message\n  * `{:EXIT, port, reason}` - exit signals in case the port crashes. If reason\n    is not `:normal`, this message will only be received if the owner process\n    is trapping exits","ref":"Port.html#module-message-and-function-apis"},{"type":"module","title":"Open mechanisms - Port","doc":"The port can be opened through four main mechanisms.\n\nAs a short summary, prefer to using the `:spawn` and `:spawn_executable`\noptions mentioned below. The other two options, `:spawn_driver` and `:fd`\nare for advanced usage within the VM. Also consider using `System.cmd/3`\nif all you want is to execute a program and retrieve its return value.\n\n> #### Windows argument splitting and untrusted arguments {: .warning}\n>\n> On Unix systems, arguments are passed to a new operating system\n> process as an array of strings but on Windows it is up to the child\n> process to parse them and some Windows programs may apply their own\n> rules, which are inconsistent with the standard C runtime `argv` parsing\n>\n> This is particularly troublesome when invoking `.bat` or `.com` files\n> as these run implicitly through `cmd.exe`, whose argument parsing is\n> vulnerable to malicious input and can be used to run arbitrary shell\n> commands.\n>\n> Therefore, if you are running on Windows and you execute batch\n> files or `.com` applications, you must not pass untrusted input as\n> arguments to the program. You may avoid accidentally executing them\n> by explicitly passing the extension of the program you want to run,\n> such as `.exe`, and double check the program is indeed not a batch\n> file or `.com` application.\n>\n> This affects both `spawn` and `spawn_executable`.","ref":"Port.html#module-open-mechanisms"},{"type":"module","title":"spawn - Port","doc":"The `:spawn` tuple receives a binary that is going to be executed as a\nfull invocation. For example, we can use it to invoke \"echo hello\" directly:\n\n    iex> port = Port.open({:spawn, \"echo hello\"}, [:binary])\n    iex> flush()\n    {#Port<0.1444>, {:data, \"hello\\n\"}}\n\n`:spawn` will retrieve the program name from the argument and traverse your\noperating system `$PATH` environment variable looking for a matching program.\n\nAlthough the above is handy, it means it is impossible to invoke an executable\nthat has whitespaces on its name or in any of its arguments. For those reasons,\nmost times it is preferable to execute `:spawn_executable`.","ref":"Port.html#module-spawn"},{"type":"module","title":"spawn_executable - Port","doc":"Spawn executable is a more restricted and explicit version of spawn. It expects\nfull file paths to the executable you want to execute. If they are in your `$PATH`,\nthey can be retrieved by calling `System.find_executable/1`:\n\n    iex> path = System.find_executable(\"echo\")\n    iex> port = Port.open({:spawn_executable, path}, [:binary, args: [\"hello world\"]])\n    iex> flush()\n    {#Port<0.1380>, {:data, \"hello world\\n\"}}\n\nWhen using `:spawn_executable`, the list of arguments can be passed via\nthe `:args` option as done above. For the full list of options, see the\ndocumentation for the Erlang function `:erlang.open_port/2`.","ref":"Port.html#module-spawn_executable"},{"type":"module","title":"fd - Port","doc":"The `:fd` name option allows developers to access `in` and `out` file\ndescriptors used by the Erlang VM. You would use those only if you are\nreimplementing core part of the Runtime System, such as the `:user` and\n`:shell` processes.","ref":"Port.html#module-fd"},{"type":"module","title":"Zombie operating system processes - Port","doc":"A port can be closed via the `close/1` function or by sending a `{pid, :close}`\nmessage. However, if the VM crashes, a long-running program started by the port\nwill have its stdin and stdout channels closed but **it won't be automatically\nterminated**.\n\nWhile most Unix command line tools will exit once its communication channels\nare closed, not all command line applications will do so. You can easily check\nthis by starting the port and then shutting down the VM and inspecting your\noperating system to see if the port process is still running.\n\nWhile we encourage graceful termination by detecting if stdin/stdout has been\nclosed, we do not always have control over how third-party software terminates.\nIn those cases, you can wrap the application in a script that checks for stdin.\nHere is such script that has been verified to work on bash shells:\n\n    #!/usr/bin/env bash\n\n    # Start the program in the background\n    exec \"$@\" &\n    pid1=$!\n\n    # Silence warnings from here on\n    exec >/dev/null 2>&1\n\n    # Read from stdin in the background and\n    # kill running program when stdin closes\n    exec 0<&0 $(\n      while read; do :; done\n      kill -KILL $pid1\n    ) &\n    pid2=$!\n\n    # Clean up\n    wait $pid1\n    ret=$?\n    kill -KILL $pid2\n    exit $ret\n\nNote the program above hijacks stdin, so you won't be able to communicate\nwith the underlying software via stdin (on the positive side, software that\nreads from stdin typically terminates when stdin closes).\n\nNow instead of:\n\n    Port.open(\n      {:spawn_executable, \"/path/to/program\"},\n      args: [\"a\", \"b\", \"c\"]\n    )\n\nYou may invoke:\n\n    Port.open(\n      {:spawn_executable, \"/path/to/wrapper\"},\n      args: [\"/path/to/program\", \"a\", \"b\", \"c\"]\n    )","ref":"Port.html#module-zombie-operating-system-processes"},{"type":"function","title":"Port.close/1","doc":"Closes the `port`.\n\nFor more information, see `:erlang.port_close/1`.\n\nInlined by the compiler.","ref":"Port.html#close/1"},{"type":"function","title":"Port.command/3","doc":"Sends `data` to the port driver `port`.\n\nFor more information, see `:erlang.port_command/3`.\n\nInlined by the compiler.","ref":"Port.html#command/3"},{"type":"function","title":"Port.connect/2","doc":"Associates the `port` identifier with a `pid`.\n\nFor more information, see `:erlang.port_connect/2`.\n\nInlined by the compiler.","ref":"Port.html#connect/2"},{"type":"function","title":"Port.demonitor/2","doc":"Demonitors the monitor identified by the given `reference`.\n\nIf `monitor_ref` is a reference which the calling process\nobtained by calling `monitor/1`, that monitoring is turned off.\nIf the monitoring is already turned off, nothing happens.\n\nSee `:erlang.demonitor/2` for more information.\n\nInlined by the compiler.","ref":"Port.html#demonitor/2"},{"type":"function","title":"Port.info/1","doc":"Returns information about the `port` (or `nil` if the port is closed).\n\nFor more information, see `:erlang.port_info/1`.","ref":"Port.html#info/1"},{"type":"function","title":"Port.info/2","doc":"Returns information about a specific field within\nthe `port` (or `nil` if the port is closed).\n\nFor more information, see `:erlang.port_info/2`.","ref":"Port.html#info/2"},{"type":"function","title":"Port.list/0","doc":"Returns a list of all ports in the current node.\n\nInlined by the compiler.","ref":"Port.html#list/0"},{"type":"function","title":"Port.monitor/1","doc":"Starts monitoring the given `port` from the calling process.\n\nOnce the monitored port process dies, a message is delivered to the\nmonitoring process in the shape of:\n\n    {:DOWN, ref, :port, object, reason}\n\nwhere:\n\n  * `ref` is a monitor reference returned by this function;\n  * `object` is either the `port` being monitored (when monitoring by port ID)\n  or `{name, node}` (when monitoring by a port name);\n  * `reason` is the exit reason.\n\nSee `:erlang.monitor/2` for more information.\n\nInlined by the compiler.","ref":"Port.html#monitor/1"},{"type":"type","title":"Port.name/0","doc":"","ref":"Port.html#t:name/0"},{"type":"function","title":"Port.open/2","doc":"Opens a port given a tuple `name` and a list of `options`.\n\nThe module documentation above contains documentation and examples\nfor the supported `name` values, summarized below:\n\n  * `{:spawn, command}` - runs an external program. `command` must contain\n    the program name and optionally a list of arguments separated by space.\n    If passing programs or arguments with space in their name, use the next option.\n  * `{:spawn_executable, filename}` - runs the executable given by the absolute\n    file name `filename`. Arguments can be passed via the `:args` option.\n  * `{:spawn_driver, command}` - spawns so-called port drivers.\n  * `{:fd, fd_in, fd_out}` - accesses file descriptors, `fd_in` and `fd_out`\n    opened by the VM.\n\nFor more information and the list of options, see `:erlang.open_port/2`.\n\nInlined by the compiler.","ref":"Port.html#open/2"},{"type":"module","title":"StringIO","doc":"Controls an IO device process that wraps a string.\n\nA `StringIO` IO device can be passed as a \"device\" to\nmost of the functions in the `IO` module.","ref":"StringIO.html"},{"type":"module","title":"Examples - StringIO","doc":"iex> {:ok, pid} = StringIO.open(\"foo\")\n    iex> IO.read(pid, 2)\n    \"fo\"","ref":"StringIO.html#module-examples"},{"type":"function","title":"StringIO.close/1","doc":"Stops the IO device and returns the remaining input/output\nbuffers.","ref":"StringIO.html#close/1"},{"type":"function","title":"Examples - StringIO.close/1","doc":"iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.close(pid)\n    {:ok, {\"in\", \"out\"}}","ref":"StringIO.html#close/1-examples"},{"type":"function","title":"StringIO.contents/1","doc":"Returns the current input/output buffers for the given IO\ndevice.","ref":"StringIO.html#contents/1"},{"type":"function","title":"Examples - StringIO.contents/1","doc":"iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.contents(pid)\n    {\"in\", \"out\"}","ref":"StringIO.html#contents/1-examples"},{"type":"function","title":"StringIO.flush/1","doc":"Flushes the output buffer and returns its current contents.","ref":"StringIO.html#flush/1"},{"type":"function","title":"Examples - StringIO.flush/1","doc":"iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.flush(pid)\n    \"out\"\n    iex> StringIO.contents(pid)\n    {\"in\", \"\"}","ref":"StringIO.html#flush/1-examples"},{"type":"function","title":"StringIO.open/2","doc":"Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\n`options_or_function` can be a keyword list of options or\na function.\n\nIf options are provided, the result will be `{:ok, pid}`, returning the\nIO device created. The option `:capture_prompt`, when set to `true`, causes\nprompts (which are specified as arguments to `IO.get*` functions) to be\nincluded in the device's output.\n\nIf a function is provided, the device will be created and sent to the\nfunction. When the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.","ref":"StringIO.html#open/2"},{"type":"function","title":"Examples - StringIO.open/2","doc":"iex> {:ok, pid} = StringIO.open(\"foo\")\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \"\"}\n\n    iex> {:ok, pid} = StringIO.open(\"foo\", capture_prompt: true)\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \">\"}\n\n    iex> StringIO.open(\"foo\", fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}","ref":"StringIO.html#open/2-examples"},{"type":"function","title":"StringIO.open/3","doc":"Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\nThe device will be created and sent to the function given.\nWhen the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.","ref":"StringIO.html#open/3"},{"type":"function","title":"Options - StringIO.open/3","doc":"* `:capture_prompt` - if set to `true`, prompts (specified as\n    arguments to `IO.get*` functions) are captured in the output.\n    Defaults to `false`.\n\n  * `:encoding` (since v1.10.0) - encoding of the IO device. Allowed\n    values are `:unicode` (default) and `:latin1`.","ref":"StringIO.html#open/3-options"},{"type":"function","title":"Examples - StringIO.open/3","doc":"iex> StringIO.open(\"foo\", [], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}\n\n    iex> StringIO.open(\"foo\", [capture_prompt: true], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \">The input was foo\"}}","ref":"StringIO.html#open/3-examples"},{"type":"module","title":"System","doc":"The `System` module provides functions that interact directly\nwith the VM or the host system.","ref":"System.html"},{"type":"module","title":"Time - System","doc":"The `System` module also provides functions that work with time,\nreturning different times kept by the system with support for\ndifferent time units.\n\nOne of the complexities in relying on system times is that they\nmay be adjusted. For example, when you enter and leave daylight\nsaving time, the system clock will be adjusted, often adding\nor removing one hour. We call such changes \"time warps\". In\norder to understand how such changes may be harmful, imagine\nthe following code:","ref":"System.html#module-time"},{"type":"module","title":"DO NOT DO THIS - System","doc":"prev = System.os_time()\n    # ... execute some code ...\n    next = System.os_time()\n    diff = next - prev\n\nIf, while the code is executing, the system clock changes,\nsome code that executed in 1 second may be reported as taking\nover 1 hour! To address such concerns, the VM provides a\nmonotonic time via `System.monotonic_time/0` which never\ndecreases and does not leap:","ref":"System.html#module-do-not-do-this"},{"type":"module","title":"DO THIS - System","doc":"prev = System.monotonic_time()\n    # ... execute some code ...\n    next = System.monotonic_time()\n    diff = next - prev\n\nGenerally speaking, the VM provides three time measurements:\n\n  * `os_time/0` - the time reported by the operating system (OS). This time may be\n    adjusted forwards or backwards in time with no limitation;\n\n  * `system_time/0` - the VM view of the `os_time/0`. The system time and operating\n    system time may not match in case of time warps although the VM works towards\n    aligning them. This time is not monotonic (i.e., it may decrease)\n    as its behavior is configured [by the VM time warp\n    mode](https://www.erlang.org/doc/apps/erts/time_correction.html#Time_Warp_Modes);\n\n  * `monotonic_time/0` - a monotonically increasing time provided\n    by the Erlang VM. This is not strictly monotonically increasing. Multiple\n    sequential calls of the function may return the same value.\n\nThe time functions in this module work in the `:native` unit\n(unless specified otherwise), which is operating system dependent. Most of\nthe time, all calculations are done in the `:native` unit, to\navoid loss of precision, with `convert_time_unit/3` being\ninvoked at the end to convert to a specific time unit like\n`:millisecond` or `:microsecond`. See the `t:time_unit/0` type for\nmore information.\n\nFor a more complete rundown on the VM support for different\ntimes, see the [chapter on time and time\ncorrection](https://www.erlang.org/doc/apps/erts/time_correction.html)\nin the Erlang docs.","ref":"System.html#module-do-this"},{"type":"function","title":"System.argv/0","doc":"Lists command line arguments.\n\nReturns the list of command line arguments passed to the program.","ref":"System.html#argv/0"},{"type":"function","title":"System.argv/1","doc":"Modifies command line arguments.\n\nChanges the list of command line arguments. Use it with caution,\nas it destroys any previous argv information.","ref":"System.html#argv/1"},{"type":"function","title":"System.at_exit/1","doc":"Registers a program exit handler function.\n\nRegisters a function that will be invoked at the end of an Elixir script.\nA script is typically started via the command line via the `elixir` and\n`mix` executables.\n\nThe handler always executes in a different process from the one it was\nregistered in. As a consequence, any resources managed by the calling process\n(ETS tables, open files, and others) won't be available by the time the handler\nfunction is invoked.\n\nThe function must receive the exit status code as an argument.\n\nIf the VM terminates programmatically, via `System.stop/1`, `System.halt/1`,\nor exit signals, the `at_exit/1` callbacks are not guaranteed to be executed.","ref":"System.html#at_exit/1"},{"type":"function","title":"System.build_info/0","doc":"Elixir build information.\n\nReturns a map with the Elixir version, the Erlang/OTP release it was compiled\nwith, a short Git revision hash and the date and time it was built.\n\nEvery value in the map is a string, and these are:\n\n  * `:build` - the Elixir version, short Git revision hash and\n    Erlang/OTP release it was compiled with\n  * `:date` - a string representation of the ISO8601 date and time it was built\n  * `:otp_release` - OTP release it was compiled with\n  * `:revision` - short Git revision hash. If Git was not available at building\n    time, it is set to `\"\"`\n  * `:version` - the Elixir version\n\nOne should not rely on the specific formats returned by each of those fields.\nInstead one should use specialized functions, such as `version/0` to retrieve\nthe Elixir version and `otp_release/0` to retrieve the Erlang/OTP release.","ref":"System.html#build_info/0"},{"type":"function","title":"Examples - System.build_info/0","doc":"iex> System.build_info()\n    %{\n      build: \"1.9.0-dev (772a00a0c) (compiled with Erlang/OTP 21)\",\n      date: \"2018-12-24T01:09:21Z\",\n      otp_release: \"21\",\n      revision: \"772a00a0c\",\n      version: \"1.9.0-dev\"\n    }","ref":"System.html#build_info/0-examples"},{"type":"function","title":"System.cmd/3","doc":"Executes the given `command` with `args`.\n\n`command` is expected to be an executable available in PATH\nunless an absolute path is given.\n\n`args` must be a list of binaries which the executable will receive\nas its arguments as is. This means that:\n\n  * environment variables will not be interpolated\n  * wildcard expansion will not happen (unless `Path.wildcard/2` is used\n    explicitly)\n  * arguments do not need to be escaped or quoted for shell safety\n\nThis function returns a tuple containing the collected result\nand the command exit status.\n\nInternally, this function uses a `Port` for interacting with the\noutside world. However, if you plan to run a long-running program,\nports guarantee stdin/stdout devices will be closed but it does not\nautomatically terminate the program. The documentation for the\n`Port` module describes this problem and possible solutions under\nthe \"Zombie processes\" section.\n\n> #### Windows argument splitting and untrusted arguments {: .warning}\n>\n> On Unix systems, arguments are passed to a new operating system\n> process as an array of strings but on Windows it is up to the child\n> process to parse them and some Windows programs may apply their own\n> rules, which are inconsistent with the standard C runtime `argv` parsing\n>\n> This is particularly troublesome when invoking `.bat` or `.com` files\n> as these run implicitly through `cmd.exe`, whose argument parsing is\n> vulnerable to malicious input and can be used to run arbitrary shell\n> commands.\n>\n> Therefore, if you are running on Windows and you execute batch\n> files or `.com` applications, you must not pass untrusted input as\n> arguments to the program. You may avoid accidentally executing them\n> by explicitly passing the extension of the program you want to run,\n> such as `.exe`, and double check the program is indeed not a batch\n> file or `.com` application.","ref":"System.html#cmd/3"},{"type":"function","title":"Examples - System.cmd/3","doc":"iex> System.cmd(\"echo\", [\"hello\"])\n    {\"hello\\n\", 0}\n\n    iex> System.cmd(\"echo\", [\"hello\"], env: [{\"MIX_ENV\", \"test\"}])\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.cmd(\"echo\", [\"hello\"], into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}\n\nIf you want to read lines:\n\n    iex> System.cmd(\"echo\", [\"hello\\nworld\"], into: [], lines: 1024)\n    {[\"hello\", \"world\"], 0}","ref":"System.html#cmd/3-examples"},{"type":"function","title":"Options - System.cmd/3","doc":"* `:into` - injects the result into the given collectable, defaults to `\"\"`\n\n  * `:lines` - (since v1.15.0) reads the output by lines instead of in bytes. It expects a\n    number of maximum bytes to buffer internally (1024 is a reasonable default).\n    The collectable will be called with each finished line (regardless of buffer\n    size) and without the EOL character\n\n  * `:cd` - the directory to run the command in\n\n  * `:env` - an enumerable of tuples containing environment key-value as\n    binary. The child process inherits all environment variables from its\n    parent process, the Elixir application, except those overwritten or\n    cleared using this option. Specify a value of `nil` to clear (unset) an\n    environment variable, which is useful for preventing credentials passed\n    to the application from leaking into child processes\n\n  * `:arg0` - sets the command arg0\n\n  * `:stderr_to_stdout` - redirects stderr to stdout when `true`, no effect\n    if `use_stdio` is `false`.\n\n  * `:use_stdio` - `true` by default, setting it to false allows direct\n    interaction with the terminal from the callee\n\n  * `:parallelism` - when `true`, the VM will schedule port tasks to improve\n    parallelism in the system. If set to `false`, the VM will try to perform\n    commands immediately, improving latency at the expense of parallelism.\n    The default is `false`, and can be set on system startup by passing the\n    [`+spp`](https://www.erlang.org/doc/man/erl.html#+spp) flag to `--erl`.\n    Use `:erlang.system_info(:port_parallelism)` to check if enabled.","ref":"System.html#cmd/3-options"},{"type":"function","title":"Error reasons - System.cmd/3","doc":"If invalid arguments are given, `ArgumentError` is raised by\n`System.cmd/3`. `System.cmd/3` also expects a strict set of\noptions and will raise if unknown or invalid options are given.\n\nFurthermore, `System.cmd/3` may fail with one of the POSIX reasons\ndetailed below:\n\n  * `:system_limit` - all available ports in the Erlang emulator are in use\n\n  * `:enomem` - there was not enough memory to create the port\n\n  * `:eagain` - there are no more available operating system processes\n\n  * `:enametoolong` - the external command given was too long\n\n  * `:emfile` - there are no more available file descriptors\n    (for the operating system process that the Erlang emulator runs in)\n\n  * `:enfile` - the file table is full (for the entire operating system)\n\n  * `:eacces` - the command does not point to an executable file\n\n  * `:enoent` - the command does not point to an existing file","ref":"System.html#cmd/3-error-reasons"},{"type":"function","title":"Shell commands - System.cmd/3","doc":"If you desire to execute a trusted command inside a shell, with pipes,\nredirecting and so on, please check `shell/2`.","ref":"System.html#cmd/3-shell-commands"},{"type":"function","title":"System.compiled_endianness/0","doc":"Returns the endianness the system was compiled with.","ref":"System.html#compiled_endianness/0"},{"type":"function","title":"System.convert_time_unit/3","doc":"Converts `time` from time unit `from_unit` to time unit `to_unit`.\n\nThe result is rounded via the floor function.\n\n`convert_time_unit/3` accepts an additional time unit (other than the\nones in the `t:time_unit/0` type) called `:native`. `:native` is the time\nunit used by the Erlang runtime system. It's determined when the runtime\nstarts and stays the same until the runtime is stopped, but could differ\nthe next time the runtime is started on the same machine. For this reason,\nyou should use this function to convert `:native` time units to a predictable\nunit before you display them to humans.\n\nTo determine how many seconds the `:native` unit represents in your current\nruntime, you can call this function to convert 1 second to the `:native`\ntime unit: `System.convert_time_unit(1, :second, :native)`.","ref":"System.html#convert_time_unit/3"},{"type":"function","title":"System.cwd/0","doc":"Current working directory.\n\nReturns the current working directory or `nil` if one\nis not available.","ref":"System.html#cwd/0"},{"type":"function","title":"System.cwd!/0","doc":"Current working directory, exception on error.\n\nReturns the current working directory or raises `RuntimeError`.","ref":"System.html#cwd!/0"},{"type":"function","title":"System.delete_env/1","doc":"Deletes an environment variable.\n\nRemoves the variable `varname` from the environment.","ref":"System.html#delete_env/1"},{"type":"function","title":"System.endianness/0","doc":"Returns the endianness.","ref":"System.html#endianness/0"},{"type":"function","title":"System.fetch_env/1","doc":"Returns the value of the given environment variable or `:error` if not found.\n\nIf the environment variable `varname` is set, then `{:ok, value}` is returned\nwhere `value` is a string. If `varname` is not set, `:error` is returned.","ref":"System.html#fetch_env/1"},{"type":"function","title":"Examples - System.fetch_env/1","doc":"iex> System.fetch_env(\"PORT\")\n    {:ok, \"4000\"}\n\n    iex> System.fetch_env(\"NOT_SET\")\n    :error","ref":"System.html#fetch_env/1-examples"},{"type":"function","title":"System.fetch_env!/1","doc":"Returns the value of the given environment variable or raises if not found.\n\nSame as `get_env/1` but raises instead of returning `nil` when the variable is\nnot set.","ref":"System.html#fetch_env!/1"},{"type":"function","title":"Examples - System.fetch_env!/1","doc":"iex> System.fetch_env!(\"PORT\")\n    \"4000\"\n\n    iex> System.fetch_env!(\"NOT_SET\")\n    ** (System.EnvError) could not fetch environment variable \"NOT_SET\" because it is not set","ref":"System.html#fetch_env!/1-examples"},{"type":"function","title":"System.find_executable/1","doc":"Locates an executable on the system.\n\nThis function looks up an executable program given\nits name using the environment variable PATH on Windows and Unix-like\noperating systems. It also considers the proper executable\nextension for each operating system, so for Windows it will try to\nlookup files with `.com`, `.cmd` or similar extensions.","ref":"System.html#find_executable/1"},{"type":"function","title":"System.get_env/0","doc":"Returns all system environment variables.\n\nThe returned value is a map containing name-value pairs.\nVariable names and their values are strings.","ref":"System.html#get_env/0"},{"type":"function","title":"System.get_env/2","doc":"Returns the value of the given environment variable.\n\nThe returned value of the environment variable\n`varname` is a string. If the environment variable\nis not set, returns the string specified in `default` or\n`nil` if none is specified.","ref":"System.html#get_env/2"},{"type":"function","title":"Examples - System.get_env/2","doc":"iex> System.get_env(\"PORT\")\n    \"4000\"\n\n    iex> System.get_env(\"NOT_SET\")\n    nil\n\n    iex> System.get_env(\"NOT_SET\", \"4001\")\n    \"4001\"","ref":"System.html#get_env/2-examples"},{"type":"function","title":"System.get_pid/0","doc":"Erlang VM process identifier.\n\nReturns the process identifier of the current Erlang emulator\nin the format most commonly used by the operating system environment.\n\nFor more information, see `:os.getpid/0`.","ref":"System.html#get_pid/0"},{"type":"function","title":"System.halt/1","doc":"Immediately halts the Erlang runtime system.\n\nTerminates the Erlang runtime system without properly shutting down\napplications and ports. Please see `stop/1` for a careful shutdown of the\nsystem.\n\n`status` must be a non-negative integer, the atom `:abort` or a binary.\n\n  * If an integer, the runtime system exits with the integer value which\n    is returned to the operating system.\n\n  * If `:abort`, the runtime system aborts producing a core dump, if that is\n    enabled in the operating system.\n\n  * If a string, an Erlang crash dump is produced with status as slogan,\n    and then the runtime system exits with status code 1.\n\nNote that on many platforms, only the status codes 0-255 are supported\nby the operating system.\n\nFor more information, see `:erlang.halt/1`.","ref":"System.html#halt/1"},{"type":"function","title":"Examples - System.halt/1","doc":"System.halt(0)\n    System.halt(1)\n    System.halt(:abort)","ref":"System.html#halt/1-examples"},{"type":"function","title":"System.monotonic_time/0","doc":"Returns the current monotonic time in the `:native` time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time. This is not strictly monotonically increasing. Multiple\nsequential calls of the function may return the same value.\n\nInlined by the compiler.","ref":"System.html#monotonic_time/0"},{"type":"function","title":"System.monotonic_time/1","doc":"Returns the current monotonic time in the given time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time.","ref":"System.html#monotonic_time/1"},{"type":"function","title":"System.no_halt/0","doc":"Checks if the system will halt or not at the end of ARGV processing.","ref":"System.html#no_halt/0"},{"type":"function","title":"System.no_halt/1","doc":"Marks if the system should halt or not at the end of ARGV processing.","ref":"System.html#no_halt/1"},{"type":"function","title":"System.os_time/0","doc":"Returns the current operating system (OS) time.\n\nThe result is returned in the `:native` time unit.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic.\n\nInlined by the compiler.","ref":"System.html#os_time/0"},{"type":"function","title":"System.os_time/1","doc":"Returns the current operating system (OS) time in the given time `unit`.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic.","ref":"System.html#os_time/1"},{"type":"function","title":"System.otp_release/0","doc":"Returns the Erlang/OTP release number.","ref":"System.html#otp_release/0"},{"type":"function","title":"System.pid/0","doc":"Returns the operating system PID for the current Erlang runtime system instance.\n\nReturns a string containing the (usually) numerical identifier for a process.\nOn Unix-like operating systems, this is typically the return value of the `getpid()` system call.\nOn Windows, the process ID as returned by the `GetCurrentProcessId()` system\ncall is used.","ref":"System.html#pid/0"},{"type":"function","title":"Examples - System.pid/0","doc":"System.pid()","ref":"System.html#pid/0-examples"},{"type":"function","title":"System.put_env/1","doc":"Sets multiple environment variables.\n\nSets a new value for each environment variable corresponding\nto each `{key, value}` pair in `enum`. Keys and non-nil values\nare automatically converted to charlists. `nil` values erase\nthe given keys.\n\nOverall, this is a convenience wrapper around `put_env/2` and\n`delete_env/2` with support for different key and value formats.","ref":"System.html#put_env/1"},{"type":"function","title":"System.put_env/2","doc":"Sets an environment variable value.\n\nSets a new `value` for the environment variable `varname`.","ref":"System.html#put_env/2"},{"type":"function","title":"System.restart/0","doc":"Restarts all applications in the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system starts all applications once again.","ref":"System.html#restart/0"},{"type":"function","title":"Examples - System.restart/0","doc":"System.restart()","ref":"System.html#restart/0-examples"},{"type":"function","title":"System.schedulers/0","doc":"Returns the number of schedulers in the VM.","ref":"System.html#schedulers/0"},{"type":"function","title":"System.schedulers_online/0","doc":"Returns the number of schedulers online in the VM.","ref":"System.html#schedulers_online/0"},{"type":"function","title":"System.shell/2","doc":"Executes the given `command` in the OS shell.\n\nIt uses `sh` for Unix-like systems and `cmd` for Windows.\n\n> #### Watch out {: .warning}\n>\n> Use this function with care. In particular, **never\n> pass untrusted user input to this function**, as the user would be\n> able to perform \"command injection attacks\" by executing any code\n> directly on the machine. Generally speaking, prefer to use `cmd/3`\n> over this function.","ref":"System.html#shell/2"},{"type":"function","title":"Examples - System.shell/2","doc":"iex> System.shell(\"echo hello\")\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.shell(\"echo hello\", into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}","ref":"System.html#shell/2-examples"},{"type":"function","title":"Options - System.shell/2","doc":"It accepts the same options as `cmd/3` (except for `arg0`).\nIt also accepts the following exclusive options:\n\n  * `:close_stdin` (since v1.14.1) - if the stdin should be closed\n    on Unix systems, forcing any command that waits on stdin to\n    immediately terminate. Defaults to false.","ref":"System.html#shell/2-options"},{"type":"type","title":"System.signal/0","doc":"","ref":"System.html#t:signal/0"},{"type":"function","title":"System.stacktrace/0","doc":"Deprecated mechanism to retrieve the last exception stacktrace.\n\nIt always return an empty list.","ref":"System.html#stacktrace/0"},{"type":"function","title":"System.stop/1","doc":"Asynchronously and carefully stops the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system terminates by calling `halt/1`.\n\n`status` must be a non-negative integer or a binary.\n\n  * If an integer, the runtime system exits with the integer value which is\n    returned to the operating system. On many platforms, only the status codes\n    0-255 are supported by the operating system.\n\n  * If a binary, an Erlang crash dump is produced with status as slogan, and\n    then the runtime system exits with status code 1.\n\nNote this function is asynchronous and the current process will continue\nexecuting after this function is invoked. In case you want to block the\ncurrent process until the system effectively shuts down, you can invoke\n`Process.sleep(:infinity)`.","ref":"System.html#stop/1"},{"type":"function","title":"Examples - System.stop/1","doc":"System.stop(0)\n    System.stop(1)","ref":"System.html#stop/1-examples"},{"type":"function","title":"System.system_time/0","doc":"Returns the current system time in the `:native` time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic.\n\nInlined by the compiler.","ref":"System.html#system_time/0"},{"type":"function","title":"System.system_time/1","doc":"Returns the current system time in the given time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic.","ref":"System.html#system_time/1"},{"type":"function","title":"System.time_offset/0","doc":"Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the `:native` time unit.\n\nSee `time_offset/1` for more information.\n\nInlined by the compiler.","ref":"System.html#time_offset/0"},{"type":"function","title":"System.time_offset/1","doc":"Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the given time unit `unit`. The returned\noffset, added to an Erlang monotonic time (for instance, one obtained with\n`monotonic_time/1`), gives the Erlang system time that corresponds\nto that monotonic time.","ref":"System.html#time_offset/1"},{"type":"type","title":"System.time_unit/0","doc":"The time unit to be passed to functions like `monotonic_time/1` and others.\n\nThe `:second`, `:millisecond`, `:microsecond` and `:nanosecond` time\nunits controls the return value of the functions that accept a time unit.\n\nA time unit can also be a strictly positive integer. In this case, it\nrepresents the \"parts per second\": the time will be returned in `1 /\nparts_per_second` seconds. For example, using the `:millisecond` time unit\nis equivalent to using `1000` as the time unit (as the time will be returned\nin 1/1000 seconds - milliseconds).","ref":"System.html#t:time_unit/0"},{"type":"function","title":"System.tmp_dir/0","doc":"Writable temporary directory.\n\nReturns a writable temporary directory.\nSearches for directories in the following order:\n\n  1. the directory named by the TMPDIR environment variable\n  2. the directory named by the TEMP environment variable\n  3. the directory named by the TMP environment variable\n  4. `C:\\TMP` on Windows or `/tmp` on Unix-like operating systems\n  5. as a last resort, the current working directory\n\nReturns `nil` if none of the above are writable.","ref":"System.html#tmp_dir/0"},{"type":"function","title":"System.tmp_dir!/0","doc":"Writable temporary directory, exception on error.\n\nSame as `tmp_dir/0` but raises `RuntimeError`\ninstead of returning `nil` if no temp dir is set.","ref":"System.html#tmp_dir!/0"},{"type":"function","title":"System.trap_signal/3","doc":"Traps the given `signal` to execute the `fun`.\n\n> #### Avoid setting traps in libraries {: .warning}\n>\n> Trapping signals may have strong implications\n> on how a system shuts down and behaves in production and\n> therefore it is extremely discouraged for libraries to\n> set their own traps. Instead, they should redirect users\n> to configure them themselves. The only cases where it is\n> acceptable for libraries to set their own traps is when\n> using Elixir in script mode, such as in `.exs` files and\n> via Mix tasks.\n\nAn optional `id` that uniquely identifies the function\ncan be given, otherwise a unique one is automatically\ngenerated. If a previously registered `id` is given,\nthis function returns an error tuple. The `id` can be\nused to remove a registered signal by calling\n`untrap_signal/2`.\n\nThe given `fun` receives no arguments and it must return\n`:ok`.\n\nIt returns `{:ok, id}` in case of success,\n`{:error, :already_registered}` in case the id has already\nbeen registered for the given signal, or `{:error, :not_sup}`\nin case trapping exists is not supported by the current OS.\n\nThe first time a signal is trapped, it will override the\ndefault behavior from the operating system. If the same\nsignal is trapped multiple times, subsequent functions\ngiven to `trap_signal` will execute *first*. In other\nwords, you can consider each function is prepended to\nthe signal handler.\n\nBy default, the Erlang VM register traps to the three\nsignals:\n\n  * `:sigstop` - gracefully shuts down the VM with `stop/0`\n  * `:sigquit` - halts the VM via `halt/0`\n  * `:sigusr1` - halts the VM via status code of 1\n\nTherefore, if you add traps to the signals above, the\ndefault behavior above will be executed after all user\nsignals.","ref":"System.html#trap_signal/3"},{"type":"function","title":"Implementation notes - System.trap_signal/3","doc":"All signals run from a single process. Therefore, blocking the\n`fun` will block subsequent traps. It is also not possible to add\nor remove traps from within a trap itself.\n\nInternally, this functionality is built on top of `:os.set_signal/2`.\nWhen you register a trap, Elixir automatically sets it to `:handle`\nand it reverts it back to `:default` once all traps are removed\n(except for `:sigquit`, `:sigterm`, and `:sigusr1` which are always\nhandled). If you or a library call `:os.set_signal/2` directly,\nit may disable Elixir traps (or Elixir may override your configuration).","ref":"System.html#trap_signal/3-implementation-notes"},{"type":"function","title":"System.unique_integer/1","doc":"Generates and returns an integer that is unique in the current runtime\ninstance.\n\n\"Unique\" means that this function, called with the same list of `modifiers`,\nwill never return the same integer more than once on the current runtime\ninstance.\n\nIf `modifiers` is `[]`, then a unique integer (that can be positive or negative) is returned.\nOther modifiers can be passed to change the properties of the returned integer:\n\n  * `:positive` - the returned integer is guaranteed to be positive.\n  * `:monotonic` - the returned integer is monotonically increasing. This\n    means that, on the same runtime instance (but even on different\n    processes), integers returned using the `:monotonic` modifier will always\n    be strictly less than integers returned by successive calls with the\n    `:monotonic` modifier.\n\nAll modifiers listed above can be combined; repeated modifiers in `modifiers`\nwill be ignored.\n\nInlined by the compiler.","ref":"System.html#unique_integer/1"},{"type":"function","title":"System.untrap_signal/2","doc":"Removes a previously registered `signal` with `id`.","ref":"System.html#untrap_signal/2"},{"type":"function","title":"System.user_home/0","doc":"User home directory.\n\nReturns the user home directory (platform independent).","ref":"System.html#user_home/0"},{"type":"function","title":"System.user_home!/0","doc":"User home directory, exception on error.\n\nSame as `user_home/0` but raises `RuntimeError`\ninstead of returning `nil` if no user home is set.","ref":"System.html#user_home!/0"},{"type":"function","title":"System.version/0","doc":"Elixir version information.\n\nReturns Elixir's version as binary.","ref":"System.html#version/0"},{"type":"behaviour","title":"Calendar","doc":"This module defines the responsibilities for working with\ncalendars, dates, times and datetimes in Elixir.\n\nIt defines types and the minimal implementation\nfor a calendar behaviour in Elixir. The goal of the calendar\nfeatures in Elixir is to provide a base for interoperability\nrather than a full-featured datetime API.\n\nFor the actual date, time and datetime structs, see `Date`,\n`Time`, `NaiveDateTime`, and `DateTime`.\n\nTypes for year, month, day, and more are *overspecified*.\nFor example, the `t:month/0` type is specified as an integer\ninstead of `1..12`. This is because different calendars may\nhave a different number of days per month.","ref":"Calendar.html"},{"type":"type","title":"Calendar.calendar/0","doc":"A calendar implementation.","ref":"Calendar.html#t:calendar/0"},{"type":"function","title":"Calendar.compatible_calendars?/2","doc":"Returns `true` if two calendars have the same moment of starting a new day,\n`false` otherwise.\n\nIf two calendars are not compatible, we can only convert datetimes and times\nbetween them. If they are compatible, this means that we can also convert\ndates as well as naive datetimes between them.","ref":"Calendar.html#compatible_calendars?/2"},{"type":"type","title":"Calendar.date/0","doc":"Any map or struct that contains the date fields.","ref":"Calendar.html#t:date/0"},{"type":"callback","title":"Calendar.date_to_string/3","doc":"Converts the date into a string according to the calendar.","ref":"Calendar.html#c:date_to_string/3"},{"type":"type","title":"Calendar.datetime/0","doc":"Any map or struct that contains the datetime fields.","ref":"Calendar.html#t:datetime/0"},{"type":"callback","title":"Calendar.datetime_to_string/11","doc":"Converts the datetime (with time zone) into a string according to the calendar.","ref":"Calendar.html#c:datetime_to_string/11"},{"type":"type","title":"Calendar.day/0","doc":"","ref":"Calendar.html#t:day/0"},{"type":"type","title":"Calendar.day_fraction/0","doc":"The internal time format is used when converting between calendars.\n\nIt represents time as a fraction of a day (starting from midnight).\n`parts_in_day` specifies how much of the day is already passed,\nwhile `parts_per_day` signifies how many parts are there in a day.","ref":"Calendar.html#t:day_fraction/0"},{"type":"type","title":"Calendar.day_of_era/0","doc":"A tuple representing the `day` and the `era`.","ref":"Calendar.html#t:day_of_era/0"},{"type":"callback","title":"Calendar.day_of_era/3","doc":"Calculates the day and era from the given `year`, `month`, and `day`.","ref":"Calendar.html#c:day_of_era/3"},{"type":"type","title":"Calendar.day_of_week/0","doc":"","ref":"Calendar.html#t:day_of_week/0"},{"type":"callback","title":"Calendar.day_of_week/4","doc":"Calculates the day of the week from the given `year`, `month`, and `day`.\n\n`starting_on` represents the starting day of the week. All\ncalendars must support at least the `:default` value. They may\nalso support other values representing their days of the week.","ref":"Calendar.html#c:day_of_week/4"},{"type":"callback","title":"Calendar.day_of_year/3","doc":"Calculates the day of the year from the given `year`, `month`, and `day`.","ref":"Calendar.html#c:day_of_year/3"},{"type":"callback","title":"Calendar.day_rollover_relative_to_midnight_utc/0","doc":"Define the rollover moment for the calendar.\n\nThis is the moment, in your calendar, when the current day ends\nand the next day starts.\n\nThe result of this function is used to check if two calendars roll over at\nthe same time of day. If they do not, we can only convert datetimes and times\nbetween them. If they do, this means that we can also convert dates as well\nas naive datetimes between them.\n\nThis day fraction should be in its most simplified form possible, to make comparisons fast.","ref":"Calendar.html#c:day_rollover_relative_to_midnight_utc/0"},{"type":"callback","title":"Examples - Calendar.day_rollover_relative_to_midnight_utc/0","doc":"* If in your calendar a new day starts at midnight, return `{0, 1}`.\n  * If in your calendar a new day starts at sunrise, return `{1, 4}`.\n  * If in your calendar a new day starts at noon, return `{1, 2}`.\n  * If in your calendar a new day starts at sunset, return `{3, 4}`.","ref":"Calendar.html#c:day_rollover_relative_to_midnight_utc/0-examples"},{"type":"callback","title":"Calendar.days_in_month/2","doc":"Returns how many days there are in the given month of the given year.","ref":"Calendar.html#c:days_in_month/2"},{"type":"type","title":"Calendar.era/0","doc":"","ref":"Calendar.html#t:era/0"},{"type":"function","title":"Calendar.get_time_zone_database/0","doc":"Gets the current time zone database.","ref":"Calendar.html#get_time_zone_database/0"},{"type":"type","title":"Calendar.hour/0","doc":"","ref":"Calendar.html#t:hour/0"},{"type":"type","title":"Calendar.iso_days/0","doc":"The internal date format that is used when converting between calendars.\n\nThis is the number of days including the fractional part that has passed of\nthe last day since `0000-01-01+00:00T00:00.000000` in ISO 8601 notation (also\nknown as *midnight 1 January BC 1* of the proleptic Gregorian calendar).","ref":"Calendar.html#t:iso_days/0"},{"type":"callback","title":"Calendar.iso_days_to_beginning_of_day/1","doc":"Converts the given `t:iso_days/0` to the first moment of the day.","ref":"Calendar.html#c:iso_days_to_beginning_of_day/1"},{"type":"callback","title":"Calendar.iso_days_to_end_of_day/1","doc":"Converts the given `t:iso_days/0` to the last moment of the day.","ref":"Calendar.html#c:iso_days_to_end_of_day/1"},{"type":"callback","title":"Calendar.leap_year?/1","doc":"Returns `true` if the given year is a leap year.\n\nA leap year is a year of a longer length than normal. The exact meaning\nis up to the calendar. A calendar must return `false` if it does not support\nthe concept of leap years.","ref":"Calendar.html#c:leap_year?/1"},{"type":"type","title":"Calendar.microsecond/0","doc":"Microseconds with stored precision.\n\nThe precision represents the number of digits that must be used when\nrepresenting the microseconds to external format. If the precision is `0`,\nit means microseconds must be skipped.","ref":"Calendar.html#t:microsecond/0"},{"type":"type","title":"Calendar.minute/0","doc":"","ref":"Calendar.html#t:minute/0"},{"type":"type","title":"Calendar.month/0","doc":"","ref":"Calendar.html#t:month/0"},{"type":"callback","title":"Calendar.months_in_year/1","doc":"Returns how many months there are in the given year.","ref":"Calendar.html#c:months_in_year/1"},{"type":"type","title":"Calendar.naive_datetime/0","doc":"Any map or struct that contains the naive datetime fields.","ref":"Calendar.html#t:naive_datetime/0"},{"type":"callback","title":"Calendar.naive_datetime_from_iso_days/1","doc":"Converts `t:iso_days/0` to the calendar's datetime format.","ref":"Calendar.html#c:naive_datetime_from_iso_days/1"},{"type":"callback","title":"Calendar.naive_datetime_to_iso_days/7","doc":"Converts the datetime (without time zone) into the `t:iso_days/0` format.","ref":"Calendar.html#c:naive_datetime_to_iso_days/7"},{"type":"callback","title":"Calendar.naive_datetime_to_string/7","doc":"Converts the naive datetime (without time zone) into a string according to the calendar.","ref":"Calendar.html#c:naive_datetime_to_string/7"},{"type":"callback","title":"Calendar.parse_date/1","doc":"Parses the string representation for a date returned by `c:date_to_string/3`\ninto a date tuple.","ref":"Calendar.html#c:parse_date/1"},{"type":"callback","title":"Calendar.parse_naive_datetime/1","doc":"Parses the string representation for a naive datetime returned by\n`c:naive_datetime_to_string/7` into a naive datetime tuple.\n\nThe given string may contain a timezone offset but it is ignored.","ref":"Calendar.html#c:parse_naive_datetime/1"},{"type":"callback","title":"Calendar.parse_time/1","doc":"Parses the string representation for a time returned by `c:time_to_string/4`\ninto a time tuple.","ref":"Calendar.html#c:parse_time/1"},{"type":"callback","title":"Calendar.parse_utc_datetime/1","doc":"Parses the string representation for a datetime returned by\n`c:datetime_to_string/11` into a datetime tuple.\n\nThe returned datetime must be in UTC. The original `utc_offset`\nit was written in must be returned in the result.","ref":"Calendar.html#c:parse_utc_datetime/1"},{"type":"function","title":"Calendar.put_time_zone_database/1","doc":"Sets the current time zone database.","ref":"Calendar.html#put_time_zone_database/1"},{"type":"callback","title":"Calendar.quarter_of_year/3","doc":"Calculates the quarter of the year from the given `year`, `month`, and `day`.","ref":"Calendar.html#c:quarter_of_year/3"},{"type":"type","title":"Calendar.second/0","doc":"","ref":"Calendar.html#t:second/0"},{"type":"callback","title":"Calendar.shift_date/4","doc":"Shifts date by given duration according to its calendar.","ref":"Calendar.html#c:shift_date/4"},{"type":"callback","title":"Calendar.shift_naive_datetime/8","doc":"Shifts naive datetime by given duration according to its calendar.","ref":"Calendar.html#c:shift_naive_datetime/8"},{"type":"callback","title":"Calendar.shift_time/5","doc":"Shifts time by given duration according to its calendar.","ref":"Calendar.html#c:shift_time/5"},{"type":"type","title":"Calendar.std_offset/0","doc":"The time zone standard offset in ISO seconds (typically not zero in summer times).\n\nIt must be added to `t:utc_offset/0` to get the total offset from UTC used for \"wall time\".","ref":"Calendar.html#t:std_offset/0"},{"type":"function","title":"Calendar.strftime/3","doc":"Formats the given date, time, or datetime into a string.\n\nThe datetime can be any of the `Calendar` types (`Time`, `Date`,\n`NaiveDateTime`, and `DateTime`) or any map, as long as they\ncontain all of the relevant fields necessary for formatting.\nFor example, if you use `%Y` to format the year, the datetime\nmust have the `:year` field. Therefore, if you pass a `Time`,\nor a map without the `:year` field to a format that expects `%Y`,\nan error will be raised.\n\nExamples of common usage:\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%y-%m-%d %I:%M:%S %p\")\n    \"19-08-26 01:52:06 PM\"\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%a, %B %d %Y\")\n    \"Mon, August 26 2019\"","ref":"Calendar.html#strftime/3"},{"type":"function","title":"User Options - Calendar.strftime/3","doc":"* `:preferred_datetime` - a string for the preferred format to show datetimes,\n    it can't contain the `%c` format and defaults to `\"%Y-%m-%d %H:%M:%S\"`\n    if the option is not received\n\n  * `:preferred_date` - a string for the preferred format to show dates,\n    it can't contain the `%x` format and defaults to `\"%Y-%m-%d\"`\n    if the option is not received\n\n  * `:preferred_time` - a string for the preferred format to show times,\n    it can't contain the `%X` format and defaults to `\"%H:%M:%S\"`\n    if the option is not received\n\n  * `:am_pm_names` - a function that receives either `:am` or `:pm` and returns\n    the name of the period of the day, if the option is not received it defaults\n    to a function that returns `\"am\"` and `\"pm\"`, respectively\n\n  *  `:month_names` - a function that receives a number and returns the name of\n    the corresponding month, if the option is not received it defaults to a\n    function that returns the month names in English\n\n  * `:abbreviated_month_names` - a function that receives a number and returns the\n    abbreviated name of the corresponding month, if the option is not received it\n    defaults to a function that returns the abbreviated month names in English\n\n  * `:day_of_week_names` - a function that receives a number and returns the name of\n    the corresponding day of week, if the option is not received it defaults to a\n    function that returns the day of week names in English\n\n  * `:abbreviated_day_of_week_names` - a function that receives a number and returns\n    the abbreviated name of the corresponding day of week, if the option is not received\n    it defaults to a function that returns the abbreviated day of week names in English","ref":"Calendar.html#strftime/3-user-options"},{"type":"function","title":"Formatting syntax - Calendar.strftime/3","doc":"The formatting syntax for the `string_format` argument is a sequence of characters in\nthe following format:\n\n    %   \n\nwhere:\n\n  * `%`: indicates the start of a formatted section\n  * ` `: set the padding (see below)\n  * ` `: a number indicating the minimum size of the formatted section\n  * ` `: the format itself (see below)","ref":"Calendar.html#strftime/3-formatting-syntax"},{"type":"function","title":"Accepted padding options - Calendar.strftime/3","doc":"* `-`: no padding, removes all padding from the format\n  * `_`: pad with spaces\n  * `0`: pad with zeroes","ref":"Calendar.html#strftime/3-accepted-padding-options"},{"type":"function","title":"Accepted string formats - Calendar.strftime/3","doc":"The accepted formats for `string_format` are:\n\nFormat | Description                                                             | Examples (in ISO)\n:----- | :-----------------------------------------------------------------------| :------------------------\na      | Abbreviated name of day                                                 | Mon\nA      | Full name of day                                                        | Monday\nb      | Abbreviated month name                                                  | Jan\nB      | Full month name                                                         | January\nc      | Preferred date+time representation                                      | 2018-10-17 12:34:56\nd      | Day of the month                                                        | 01, 31\nf      | Microseconds *(does not support width and padding modifiers)*           | 000000, 999999, 0123\nH      | Hour using a 24-hour clock                                              | 00, 23\nI      | Hour using a 12-hour clock                                              | 01, 12\nj      | Day of the year                                                         | 001, 366\nm      | Month                                                                   | 01, 12\nM      | Minute                                                                  | 00, 59\np      | \"AM\" or \"PM\" (noon is \"PM\", midnight as \"AM\")                           | AM, PM\nP      | \"am\" or \"pm\" (noon is \"pm\", midnight as \"am\")                           | am, pm\nq      | Quarter                                                                 | 1, 2, 3, 4\ns      | Number of seconds since the Epoch, 1970-01-01 00:00:00+0000 (UTC)       | 1565888877\nS      | Second                                                                  | 00, 59, 60\nu      | Day of the week                                                         | 1 (Monday), 7 (Sunday)\nx      | Preferred date (without time) representation                            | 2018-10-17\nX      | Preferred time (without date) representation                            | 12:34:56\ny      | Year as 2-digits                                                        | 01, 01, 86, 18\nY      | Year                                                                    | -0001, 0001, 1986\nz      | +hhmm/-hhmm time zone offset from UTC (empty string if naive)           | +0300, -0530\nZ      | Time zone abbreviation (empty string if naive)                          | CET, BRST\n%      | Literal \"%\" character                                                   | %\n\nAny other character will be interpreted as an invalid format and raise an error.","ref":"Calendar.html#strftime/3-accepted-string-formats"},{"type":"function","title":"Examples - Calendar.strftime/3","doc":"Without user options:\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%y-%m-%d %I:%M:%S %p\")\n    \"19-08-26 01:52:06 PM\"\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%a, %B %d %Y\")\n    \"Mon, August 26 2019\"\n\n    iex> Calendar.strftime(~U[2020-04-02 13:52:06.0Z], \"%B %-d, %Y\")\n    \"April 2, 2020\"\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%c\")\n    \"2019-08-26 13:52:06\"\n\nWith user options:\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%c\", preferred_datetime: \"%H:%M:%S %d-%m-%y\")\n    \"13:52:06 26-08-19\"\n\n    iex> Calendar.strftime(\n    ...>  ~U[2019-08-26 13:52:06.0Z],\n    ...>  \"%A\",\n    ...>  day_of_week_names: fn day_of_week ->\n    ...>    {\"segunda-feira\", \"terça-feira\", \"quarta-feira\", \"quinta-feira\",\n    ...>    \"sexta-feira\", \"sábado\", \"domingo\"}\n    ...>    |> elem(day_of_week - 1)\n    ...>  end\n    ...>)\n    \"segunda-feira\"\n\n    iex> Calendar.strftime(\n    ...>  ~U[2019-08-26 13:52:06.0Z],\n    ...>  \"%B\",\n    ...>  month_names: fn month ->\n    ...>    {\"січень\", \"лютий\", \"березень\", \"квітень\", \"травень\", \"червень\",\n    ...>    \"липень\", \"серпень\", \"вересень\", \"жовтень\", \"листопад\", \"грудень\"}\n    ...>    |> elem(month - 1)\n    ...>  end\n    ...>)\n    \"серпень\"","ref":"Calendar.html#strftime/3-examples"},{"type":"type","title":"Calendar.time/0","doc":"Any map or struct that contains the time fields.","ref":"Calendar.html#t:time/0"},{"type":"callback","title":"Calendar.time_from_day_fraction/1","doc":"Converts `t:day_fraction/0` to the calendar's time format.","ref":"Calendar.html#c:time_from_day_fraction/1"},{"type":"callback","title":"Calendar.time_to_day_fraction/4","doc":"Converts the given time to the `t:day_fraction/0` format.","ref":"Calendar.html#c:time_to_day_fraction/4"},{"type":"callback","title":"Calendar.time_to_string/4","doc":"Converts the time into a string according to the calendar.","ref":"Calendar.html#c:time_to_string/4"},{"type":"type","title":"Calendar.time_zone/0","doc":"The time zone ID according to the IANA tz database (for example, `Europe/Zurich`).","ref":"Calendar.html#t:time_zone/0"},{"type":"type","title":"Calendar.time_zone_database/0","doc":"Specifies the time zone database for calendar operations.\n\nMany functions in the `DateTime` module require a time zone database.\nBy default, this module uses the default time zone database returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase`. This database only handles `Etc/UTC`\ndatetimes and returns `{:error, :utc_only_time_zone_database}`\nfor any other time zone.\n\nOther time zone databases (including ones provided by packages)\ncan be configured as default either via configuration:\n\n    config :elixir, :time_zone_database, CustomTimeZoneDatabase\n\nor by calling `Calendar.put_time_zone_database/1`.\n\nSee `Calendar.TimeZoneDatabase` for more information on custom\ntime zone databases.","ref":"Calendar.html#t:time_zone_database/0"},{"type":"function","title":"Calendar.truncate/2","doc":"Returns a microsecond tuple truncated to a given precision (`:microsecond`,\n`:millisecond`, or `:second`).","ref":"Calendar.html#truncate/2"},{"type":"type","title":"Calendar.utc_offset/0","doc":"The time zone UTC offset in ISO seconds for standard time.\n\nSee also `t:std_offset/0`.","ref":"Calendar.html#t:utc_offset/0"},{"type":"callback","title":"Calendar.valid_date?/3","doc":"Should return `true` if the given date describes a proper date in the calendar.","ref":"Calendar.html#c:valid_date?/3"},{"type":"callback","title":"Calendar.valid_time?/4","doc":"Should return `true` if the given time describes a proper time in the calendar.","ref":"Calendar.html#c:valid_time?/4"},{"type":"type","title":"Calendar.week/0","doc":"","ref":"Calendar.html#t:week/0"},{"type":"type","title":"Calendar.year/0","doc":"","ref":"Calendar.html#t:year/0"},{"type":"callback","title":"Calendar.year_of_era/3","doc":"Calculates the year and era from the given `year`.","ref":"Calendar.html#c:year_of_era/3"},{"type":"type","title":"Calendar.zone_abbr/0","doc":"The time zone abbreviation (for example, `CET` or `CEST` or `BST`).","ref":"Calendar.html#t:zone_abbr/0"},{"type":"module","title":"Calendar.ISO","doc":"The default calendar implementation, a Gregorian calendar following ISO 8601.\n\nThis calendar implements a proleptic Gregorian calendar and\nis therefore compatible with the calendar used in most countries\ntoday. The proleptic means the Gregorian rules for leap years are\napplied for all time, consequently the dates give different results\nbefore the year 1583 from when the Gregorian calendar was adopted.","ref":"Calendar.ISO.html"},{"type":"module","title":"ISO 8601 compliance - Calendar.ISO","doc":"The ISO 8601 specification is feature-rich, but allows applications\nto selectively implement most parts of it. The choices Elixir makes\nare catalogued below.","ref":"Calendar.ISO.html#module-iso-8601-compliance"},{"type":"module","title":"Features - Calendar.ISO","doc":"The standard library supports a minimal set of possible ISO 8601 features.\nSpecifically, the parser only supports calendar dates and does not support\nordinal and week formats. Additionally, it supports parsing ISO 8601\nformatted durations, including negative time units and fractional seconds.\n\nBy default Elixir only parses extended-formatted date/times. You can opt-in\nto parse basic-formatted date/times.\n\n`NaiveDateTime.to_iso8601/2` and `DateTime.to_iso8601/2` allow you to produce\neither basic or extended formatted strings, and `Calendar.strftime/2` allows\nyou to format datetimes however else you desire.\n\nElixir does not support reduced accuracy formats (for example, a date without\nthe day component) nor decimal precisions in the lowest component (such as\n`10:01:25,5`).\n\n#### Examples\n\nElixir expects the extended format by default when parsing:\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23T23:50:07\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123T235007\")\n    {:error, :invalid_format}\n\nParsing can be restricted to basic if desired:\n\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123T235007Z\", :basic)\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123T235007Z\", :extended)\n    {:error, :invalid_format}\n\nOnly calendar dates are supported in parsing; ordinal and week dates are not.\n\n    iex> Calendar.ISO.parse_date(\"2015-04-15\")\n    {:ok, {2015, 4, 15}}\n    iex> Calendar.ISO.parse_date(\"2015-105\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015-W16\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015-W016-3\")\n    {:error, :invalid_format}\n\nYears, months, days, hours, minutes, and seconds must be fully specified:\n\n    iex> Calendar.ISO.parse_date(\"2015-04-15\")\n    {:ok, {2015, 4, 15}}\n    iex> Calendar.ISO.parse_date(\"2015-04\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015\")\n    {:error, :invalid_format}\n\n    iex> Calendar.ISO.parse_time(\"23:50:07.0123456\")\n    {:ok, {23, 50, 7, {12345, 6}}}\n    iex> Calendar.ISO.parse_time(\"23:50:07\")\n    {:ok, {23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_time(\"23:50\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_time(\"23\")\n    {:error, :invalid_format}","ref":"Calendar.ISO.html#module-features"},{"type":"module","title":"Extensions - Calendar.ISO","doc":"The parser and formatter adopt one ISO 8601 extension: extended year notation.\n\nThis allows dates to be prefixed with a `+` or `-` sign, extending the range of\nexpressible years from the default (`0000..9999`) to `-9999..9999`. Elixir still\nrestricts years in this format to four digits.\n\n#### Examples\n\n    iex> Calendar.ISO.parse_date(\"-2015-01-23\")\n    {:ok, {-2015, 1, 23}}\n    iex> Calendar.ISO.parse_date(\"+2015-01-23\")\n    {:ok, {2015, 1, 23}}\n\n    iex> Calendar.ISO.parse_naive_datetime(\"-2015-01-23 23:50:07\")\n    {:ok, {-2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"+2015-01-23 23:50:07\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"-2015-01-23 23:50:07Z\")\n    {:ok, {-2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n    iex> Calendar.ISO.parse_utc_datetime(\"+2015-01-23 23:50:07Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}, 0}","ref":"Calendar.ISO.html#module-extensions"},{"type":"module","title":"Additions - Calendar.ISO","doc":"ISO 8601 does not allow a whitespace instead of `T` as a separator\nbetween date and times, both when parsing and formatting.\nThis is a common enough representation, Elixir allows it during parsing.\n\nThe formatting of dates in `NaiveDateTime.to_iso8601/1` and `DateTime.to_iso8601/1`\ndo produce specification-compliant string representations using the `T` separator.\n\n#### Examples\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07.0123456\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23T23:50:07.0123456\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07.0123456Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}, 0}\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23T23:50:07.0123456Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}, 0}","ref":"Calendar.ISO.html#module-additions"},{"type":"type","title":"Calendar.ISO.bce/0","doc":"\"Before the Current Era\" or \"Before the Common Era\" (BCE), for those years less than `1`.","ref":"Calendar.ISO.html#t:bce/0"},{"type":"type","title":"Calendar.ISO.ce/0","doc":"The \"Current Era\" or the \"Common Era\" (CE) which starts in year `1`.","ref":"Calendar.ISO.html#t:ce/0"},{"type":"function","title":"Calendar.ISO.date_to_string/4","doc":"Converts the given date into a string.\n\nBy default, returns dates formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.","ref":"Calendar.ISO.html#date_to_string/4"},{"type":"function","title":"Examples - Calendar.ISO.date_to_string/4","doc":"iex> Calendar.ISO.date_to_string(2015, 2, 28)\n    \"2015-02-28\"\n    iex> Calendar.ISO.date_to_string(2017, 8, 1)\n    \"2017-08-01\"\n    iex> Calendar.ISO.date_to_string(-99, 1, 31)\n    \"-0099-01-31\"\n\n    iex> Calendar.ISO.date_to_string(2015, 2, 28, :basic)\n    \"20150228\"\n    iex> Calendar.ISO.date_to_string(-99, 1, 31, :basic)\n    \"-00990131\"","ref":"Calendar.ISO.html#date_to_string/4-examples"},{"type":"function","title":"Calendar.ISO.datetime_to_string/12","doc":"Converts the datetime (with time zone) into a string.\n\nBy default, returns datetimes formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.","ref":"Calendar.ISO.html#datetime_to_string/12"},{"type":"function","title":"Examples - Calendar.ISO.datetime_to_string/12","doc":"iex> time_zone = \"Etc/UTC\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 0, 0)\n    \"2017-08-01 01:02:03.00000Z\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 3600, 0)\n    \"2017-08-01 01:02:03.00000+01:00\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 3600, 3600)\n    \"2017-08-01 01:02:03.00000+02:00\"\n\n    iex> time_zone = \"Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CET\", 3600, 0)\n    \"2017-08-01 01:02:03.00000+01:00 CET Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CDT\", 3600, 3600)\n    \"2017-08-01 01:02:03.00000+02:00 CDT Europe/Berlin\"\n\n    iex> time_zone = \"America/Los_Angeles\"\n    iex> Calendar.ISO.datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 5}, time_zone, \"PST\", -28800, 0)\n    \"2015-02-28 01:02:03.00000-08:00 PST America/Los_Angeles\"\n    iex> Calendar.ISO.datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 5}, time_zone, \"PDT\", -28800, 3600)\n    \"2015-02-28 01:02:03.00000-07:00 PDT America/Los_Angeles\"\n\n    iex> time_zone = \"Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CET\", 3600, 0, :basic)\n    \"20170801 010203.00000+0100 CET Europe/Berlin\"","ref":"Calendar.ISO.html#datetime_to_string/12-examples"},{"type":"type","title":"Calendar.ISO.day/0","doc":"","ref":"Calendar.ISO.html#t:day/0"},{"type":"function","title":"Calendar.ISO.day_of_era/3","doc":"Calculates the day and era from the given `year`, `month`, and `day`.","ref":"Calendar.ISO.html#day_of_era/3"},{"type":"function","title":"Examples - Calendar.ISO.day_of_era/3","doc":"iex> Calendar.ISO.day_of_era(0, 1, 1)\n    {366, 0}\n    iex> Calendar.ISO.day_of_era(1, 1, 1)\n    {1, 1}\n    iex> Calendar.ISO.day_of_era(0, 12, 31)\n    {1, 0}\n    iex> Calendar.ISO.day_of_era(0, 12, 30)\n    {2, 0}\n    iex> Calendar.ISO.day_of_era(-1, 12, 31)\n    {367, 0}","ref":"Calendar.ISO.html#day_of_era/3-examples"},{"type":"type","title":"Calendar.ISO.day_of_week/0","doc":"Integer that represents the day of the week, where 1 is Monday and 7 is Sunday.","ref":"Calendar.ISO.html#t:day_of_week/0"},{"type":"function","title":"Calendar.ISO.day_of_week/4","doc":"Calculates the day of the week from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 7, where 1 is the given `starting_on` weekday.\nFor example, if `starting_on` is set to `:monday`, then 1 is Monday and\n7 is Sunday.\n\n`starting_on` can also be `:default`, which is equivalent to `:monday`.","ref":"Calendar.ISO.html#day_of_week/4"},{"type":"function","title":"Examples - Calendar.ISO.day_of_week/4","doc":"iex> Calendar.ISO.day_of_week(2016, 10, 31, :monday)\n    {1, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 1, :monday)\n    {2, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 2, :monday)\n    {3, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 3, :monday)\n    {4, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 4, :monday)\n    {5, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 5, :monday)\n    {6, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 6, :monday)\n    {7, 1, 7}\n    iex> Calendar.ISO.day_of_week(-99, 1, 31, :monday)\n    {4, 1, 7}\n\n    iex> Calendar.ISO.day_of_week(2016, 10, 31, :sunday)\n    {2, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 1, :sunday)\n    {3, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 2, :sunday)\n    {4, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 3, :sunday)\n    {5, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 4, :sunday)\n    {6, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 5, :sunday)\n    {7, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 6, :sunday)\n    {1, 1, 7}\n    iex> Calendar.ISO.day_of_week(-99, 1, 31, :sunday)\n    {5, 1, 7}\n\n    iex> Calendar.ISO.day_of_week(2016, 10, 31, :saturday)\n    {3, 1, 7}","ref":"Calendar.ISO.html#day_of_week/4-examples"},{"type":"type","title":"Calendar.ISO.day_of_year/0","doc":"","ref":"Calendar.ISO.html#t:day_of_year/0"},{"type":"function","title":"Calendar.ISO.day_of_year/3","doc":"Calculates the day of the year from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 366.","ref":"Calendar.ISO.html#day_of_year/3"},{"type":"function","title":"Examples - Calendar.ISO.day_of_year/3","doc":"iex> Calendar.ISO.day_of_year(2016, 1, 31)\n    31\n    iex> Calendar.ISO.day_of_year(-99, 2, 1)\n    32\n    iex> Calendar.ISO.day_of_year(2018, 2, 28)\n    59","ref":"Calendar.ISO.html#day_of_year/3-examples"},{"type":"function","title":"Calendar.ISO.day_rollover_relative_to_midnight_utc/0","doc":"See `c:Calendar.day_rollover_relative_to_midnight_utc/0` for documentation.","ref":"Calendar.ISO.html#day_rollover_relative_to_midnight_utc/0"},{"type":"function","title":"Calendar.ISO.days_in_month/2","doc":"Returns how many days there are in the given year-month.","ref":"Calendar.ISO.html#days_in_month/2"},{"type":"function","title":"Examples - Calendar.ISO.days_in_month/2","doc":"iex> Calendar.ISO.days_in_month(1900, 1)\n    31\n    iex> Calendar.ISO.days_in_month(1900, 2)\n    28\n    iex> Calendar.ISO.days_in_month(2000, 2)\n    29\n    iex> Calendar.ISO.days_in_month(2001, 2)\n    28\n    iex> Calendar.ISO.days_in_month(2004, 2)\n    29\n    iex> Calendar.ISO.days_in_month(2004, 4)\n    30\n    iex> Calendar.ISO.days_in_month(-1, 5)\n    31","ref":"Calendar.ISO.html#days_in_month/2-examples"},{"type":"type","title":"Calendar.ISO.era/0","doc":"The calendar era.\n\nThe ISO calendar has two eras:\n* [CE](`t:ce/0`) - which starts in year `1` and is defined as era `1`.\n* [BCE](`t:bce/0`) - for those years less than `1` and is defined as era `0`.","ref":"Calendar.ISO.html#t:era/0"},{"type":"type","title":"Calendar.ISO.format/0","doc":"","ref":"Calendar.ISO.html#t:format/0"},{"type":"type","title":"Calendar.ISO.hour/0","doc":"","ref":"Calendar.ISO.html#t:hour/0"},{"type":"function","title":"Calendar.ISO.iso_days_to_beginning_of_day/1","doc":"Converts the `t:Calendar.iso_days/0` to the first moment of the day.","ref":"Calendar.ISO.html#iso_days_to_beginning_of_day/1"},{"type":"function","title":"Examples - Calendar.ISO.iso_days_to_beginning_of_day/1","doc":"iex> Calendar.ISO.iso_days_to_beginning_of_day({0, {0, 86400000000}})\n    {0, {0, 86400000000}}\n    iex> Calendar.ISO.iso_days_to_beginning_of_day({730485, {43200000000, 86400000000}})\n    {730485, {0, 86400000000}}\n    iex> Calendar.ISO.iso_days_to_beginning_of_day({730485, {46800000000, 86400000000}})\n    {730485, {0, 86400000000}}","ref":"Calendar.ISO.html#iso_days_to_beginning_of_day/1-examples"},{"type":"function","title":"Calendar.ISO.iso_days_to_end_of_day/1","doc":"Converts the `t:Calendar.iso_days/0` to the last moment of the day.","ref":"Calendar.ISO.html#iso_days_to_end_of_day/1"},{"type":"function","title":"Examples - Calendar.ISO.iso_days_to_end_of_day/1","doc":"iex> Calendar.ISO.iso_days_to_end_of_day({0, {0, 86400000000}})\n    {0, {86399999999, 86400000000}}\n    iex> Calendar.ISO.iso_days_to_end_of_day({730485, {43200000000, 86400000000}})\n    {730485, {86399999999, 86400000000}}\n    iex> Calendar.ISO.iso_days_to_end_of_day({730485, {46800000000, 86400000000}})\n    {730485, {86399999999, 86400000000}}","ref":"Calendar.ISO.html#iso_days_to_end_of_day/1-examples"},{"type":"function","title":"Calendar.ISO.leap_year?/1","doc":"Returns if the given year is a leap year.","ref":"Calendar.ISO.html#leap_year?/1"},{"type":"function","title":"Examples - Calendar.ISO.leap_year?/1","doc":"iex> Calendar.ISO.leap_year?(2000)\n    true\n    iex> Calendar.ISO.leap_year?(2001)\n    false\n    iex> Calendar.ISO.leap_year?(2004)\n    true\n    iex> Calendar.ISO.leap_year?(1900)\n    false\n    iex> Calendar.ISO.leap_year?(-4)\n    true","ref":"Calendar.ISO.html#leap_year?/1-examples"},{"type":"type","title":"Calendar.ISO.microsecond/0","doc":"Microseconds with stored precision.\n\nThe precision represents the number of digits that must be used when\nrepresenting the microseconds to external format. If the precision is 0,\nit means microseconds must be skipped.","ref":"Calendar.ISO.html#t:microsecond/0"},{"type":"type","title":"Calendar.ISO.minute/0","doc":"","ref":"Calendar.ISO.html#t:minute/0"},{"type":"type","title":"Calendar.ISO.month/0","doc":"","ref":"Calendar.ISO.html#t:month/0"},{"type":"function","title":"Calendar.ISO.months_in_year/1","doc":"Returns how many months there are in the given year.","ref":"Calendar.ISO.html#months_in_year/1"},{"type":"function","title":"Example - Calendar.ISO.months_in_year/1","doc":"iex> Calendar.ISO.months_in_year(2004)\n    12","ref":"Calendar.ISO.html#months_in_year/1-example"},{"type":"function","title":"Calendar.ISO.naive_datetime_from_iso_days/1","doc":"Converts the `t:Calendar.iso_days/0` format to the datetime format specified by this calendar.","ref":"Calendar.ISO.html#naive_datetime_from_iso_days/1"},{"type":"function","title":"Examples - Calendar.ISO.naive_datetime_from_iso_days/1","doc":"iex> Calendar.ISO.naive_datetime_from_iso_days({0, {0, 86400}})\n    {0, 1, 1, 0, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({730_485, {0, 86400}})\n    {2000, 1, 1, 0, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({730_485, {43200, 86400}})\n    {2000, 1, 1, 12, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({-365, {0, 86400000000}})\n    {-1, 1, 1, 0, 0, 0, {0, 6}}","ref":"Calendar.ISO.html#naive_datetime_from_iso_days/1-examples"},{"type":"function","title":"Calendar.ISO.naive_datetime_to_iso_days/7","doc":"Returns the `t:Calendar.iso_days/0` format of the specified date.","ref":"Calendar.ISO.html#naive_datetime_to_iso_days/7"},{"type":"function","title":"Examples - Calendar.ISO.naive_datetime_to_iso_days/7","doc":"iex> Calendar.ISO.naive_datetime_to_iso_days(0, 1, 1, 0, 0, 0, {0, 6})\n    {0, {0, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(2000, 1, 1, 12, 0, 0, {0, 6})\n    {730485, {43200000000, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(2000, 1, 1, 13, 0, 0, {0, 6})\n    {730485, {46800000000, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(-1, 1, 1, 0, 0, 0, {0, 6})\n    {-365, {0, 86400000000}}","ref":"Calendar.ISO.html#naive_datetime_to_iso_days/7-examples"},{"type":"function","title":"Calendar.ISO.naive_datetime_to_string/8","doc":"Converts the datetime (without time zone) into a string.\n\nBy default, returns datetimes formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.","ref":"Calendar.ISO.html#naive_datetime_to_string/8"},{"type":"function","title":"Examples - Calendar.ISO.naive_datetime_to_string/8","doc":"iex> Calendar.ISO.naive_datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 6})\n    \"2015-02-28 01:02:03.000004\"\n    iex> Calendar.ISO.naive_datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5})\n    \"2017-08-01 01:02:03.00000\"\n\n    iex> Calendar.ISO.naive_datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 6}, :basic)\n    \"20150228 010203.000004\"","ref":"Calendar.ISO.html#naive_datetime_to_string/8-examples"},{"type":"function","title":"Calendar.ISO.parse_date/1","doc":"Parses a date `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).","ref":"Calendar.ISO.html#parse_date/1"},{"type":"function","title":"Examples - Calendar.ISO.parse_date/1","doc":"iex> Calendar.ISO.parse_date(\"2015-01-23\")\n    {:ok, {2015, 1, 23}}\n\n    iex> Calendar.ISO.parse_date(\"2015:01:23\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015-01-32\")\n    {:error, :invalid_date}","ref":"Calendar.ISO.html#parse_date/1-examples"},{"type":"function","title":"Calendar.ISO.parse_date/2","doc":"Parses a date `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).","ref":"Calendar.ISO.html#parse_date/2"},{"type":"function","title":"Examples - Calendar.ISO.parse_date/2","doc":"iex> Calendar.ISO.parse_date(\"20150123\", :basic)\n    {:ok, {2015, 1, 23}}\n    iex> Calendar.ISO.parse_date(\"20150123\", :extended)\n    {:error, :invalid_format}","ref":"Calendar.ISO.html#parse_date/2-examples"},{"type":"function","title":"Calendar.ISO.parse_duration/1","doc":"Parses an ISO 8601 formatted duration string to a list of `Duration` compabitble unit pairs.\n\nSee `Duration.from_iso8601/1`.","ref":"Calendar.ISO.html#parse_duration/1"},{"type":"function","title":"Calendar.ISO.parse_naive_datetime/1","doc":"Parses a naive datetime `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).","ref":"Calendar.ISO.html#parse_naive_datetime/1"},{"type":"function","title":"Examples - Calendar.ISO.parse_naive_datetime/1","doc":"iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07-02:30\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07.0\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 1}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07,0123456\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}}","ref":"Calendar.ISO.html#parse_naive_datetime/1-examples"},{"type":"function","title":"Calendar.ISO.parse_naive_datetime/2","doc":"Parses a naive datetime `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).","ref":"Calendar.ISO.html#parse_naive_datetime/2"},{"type":"function","title":"Examples - Calendar.ISO.parse_naive_datetime/2","doc":"iex> Calendar.ISO.parse_naive_datetime(\"20150123 235007\", :basic)\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123 235007\", :extended)\n    {:error, :invalid_format}","ref":"Calendar.ISO.html#parse_naive_datetime/2-examples"},{"type":"function","title":"Calendar.ISO.parse_time/1","doc":"Parses a time `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).","ref":"Calendar.ISO.html#parse_time/1"},{"type":"function","title":"Examples - Calendar.ISO.parse_time/1","doc":"iex> Calendar.ISO.parse_time(\"23:50:07\")\n    {:ok, {23, 50, 7, {0, 0}}}\n\n    iex> Calendar.ISO.parse_time(\"23:50:07Z\")\n    {:ok, {23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_time(\"T23:50:07Z\")\n    {:ok, {23, 50, 7, {0, 0}}}","ref":"Calendar.ISO.html#parse_time/1-examples"},{"type":"function","title":"Calendar.ISO.parse_time/2","doc":"Parses a time `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).","ref":"Calendar.ISO.html#parse_time/2"},{"type":"function","title":"Examples - Calendar.ISO.parse_time/2","doc":"iex> Calendar.ISO.parse_time(\"235007\", :basic)\n    {:ok, {23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_time(\"235007\", :extended)\n    {:error, :invalid_format}","ref":"Calendar.ISO.html#parse_time/2-examples"},{"type":"function","title":"Calendar.ISO.parse_utc_datetime/1","doc":"Parses a UTC datetime `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).","ref":"Calendar.ISO.html#parse_utc_datetime/1"},{"type":"function","title":"Examples - Calendar.ISO.parse_utc_datetime/1","doc":"iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07+02:30\")\n    {:ok, {2015, 1, 23, 21, 20, 7, {0, 0}}, 9000}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07\")\n    {:error, :missing_offset}","ref":"Calendar.ISO.html#parse_utc_datetime/1-examples"},{"type":"function","title":"Calendar.ISO.parse_utc_datetime/2","doc":"Parses a UTC datetime `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).","ref":"Calendar.ISO.html#parse_utc_datetime/2"},{"type":"function","title":"Examples - Calendar.ISO.parse_utc_datetime/2","doc":"iex> Calendar.ISO.parse_utc_datetime(\"20150123 235007Z\", :basic)\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n    iex> Calendar.ISO.parse_utc_datetime(\"20150123 235007Z\", :extended)\n    {:error, :invalid_format}","ref":"Calendar.ISO.html#parse_utc_datetime/2-examples"},{"type":"type","title":"Calendar.ISO.quarter_of_year/0","doc":"","ref":"Calendar.ISO.html#t:quarter_of_year/0"},{"type":"function","title":"Calendar.ISO.quarter_of_year/3","doc":"Calculates the quarter of the year from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 4.","ref":"Calendar.ISO.html#quarter_of_year/3"},{"type":"function","title":"Examples - Calendar.ISO.quarter_of_year/3","doc":"iex> Calendar.ISO.quarter_of_year(2016, 1, 31)\n    1\n    iex> Calendar.ISO.quarter_of_year(2016, 4, 3)\n    2\n    iex> Calendar.ISO.quarter_of_year(-99, 9, 31)\n    3\n    iex> Calendar.ISO.quarter_of_year(2018, 12, 28)\n    4","ref":"Calendar.ISO.html#quarter_of_year/3-examples"},{"type":"type","title":"Calendar.ISO.second/0","doc":"","ref":"Calendar.ISO.html#t:second/0"},{"type":"function","title":"Calendar.ISO.shift_date/4","doc":"Shifts Date by Duration according to its calendar.","ref":"Calendar.ISO.html#shift_date/4"},{"type":"function","title":"Examples - Calendar.ISO.shift_date/4","doc":"iex> Calendar.ISO.shift_date(2016, 1, 3, Duration.new!(month: 2))\n    {2016, 3, 3}\n    iex> Calendar.ISO.shift_date(2016, 2, 29, Duration.new!(month: 1))\n    {2016, 3, 29}\n    iex> Calendar.ISO.shift_date(2016, 1, 31, Duration.new!(month: 1))\n    {2016, 2, 29}\n    iex> Calendar.ISO.shift_date(2016, 1, 31, Duration.new!(year: 4, day: 1))\n    {2020, 2, 1}","ref":"Calendar.ISO.html#shift_date/4-examples"},{"type":"function","title":"Calendar.ISO.shift_naive_datetime/8","doc":"Shifts NaiveDateTime by Duration according to its calendar.","ref":"Calendar.ISO.html#shift_naive_datetime/8"},{"type":"function","title":"Examples - Calendar.ISO.shift_naive_datetime/8","doc":"iex> Calendar.ISO.shift_naive_datetime(2016, 1, 3, 0, 0, 0, {0, 0}, Duration.new!(hour: 1))\n    {2016, 1, 3, 1, 0, 0, {0, 0}}\n    iex> Calendar.ISO.shift_naive_datetime(2016, 1, 3, 0, 0, 0, {0, 0}, Duration.new!(hour: 30))\n    {2016, 1, 4, 6, 0, 0, {0, 0}}\n    iex> Calendar.ISO.shift_naive_datetime(2016, 1, 3, 0, 0, 0, {0, 0}, Duration.new!(microsecond: {100, 6}))\n    {2016, 1, 3, 0, 0, 0, {100, 6}}","ref":"Calendar.ISO.html#shift_naive_datetime/8-examples"},{"type":"function","title":"Calendar.ISO.shift_time/5","doc":"Shifts Time by Duration units according to its calendar.","ref":"Calendar.ISO.html#shift_time/5"},{"type":"function","title":"Examples - Calendar.ISO.shift_time/5","doc":"iex> Calendar.ISO.shift_time(13, 0, 0, {0, 0}, Duration.new!(hour: 2))\n    {15, 0, 0, {0, 0}}\n    iex> Calendar.ISO.shift_time(13, 0, 0, {0, 0}, Duration.new!(microsecond: {100, 6}))\n    {13, 0, 0, {100, 6}}","ref":"Calendar.ISO.html#shift_time/5-examples"},{"type":"function","title":"Calendar.ISO.time_from_day_fraction/1","doc":"Converts a day fraction to this Calendar's representation of time.","ref":"Calendar.ISO.html#time_from_day_fraction/1"},{"type":"function","title":"Examples - Calendar.ISO.time_from_day_fraction/1","doc":"iex> Calendar.ISO.time_from_day_fraction({1, 2})\n    {12, 0, 0, {0, 6}}\n    iex> Calendar.ISO.time_from_day_fraction({13, 24})\n    {13, 0, 0, {0, 6}}","ref":"Calendar.ISO.html#time_from_day_fraction/1-examples"},{"type":"function","title":"Calendar.ISO.time_to_day_fraction/4","doc":"Returns the normalized day fraction of the specified time.","ref":"Calendar.ISO.html#time_to_day_fraction/4"},{"type":"function","title":"Examples - Calendar.ISO.time_to_day_fraction/4","doc":"iex> Calendar.ISO.time_to_day_fraction(0, 0, 0, {0, 6})\n    {0, 86400000000}\n    iex> Calendar.ISO.time_to_day_fraction(12, 34, 56, {123, 6})\n    {45296000123, 86400000000}","ref":"Calendar.ISO.html#time_to_day_fraction/4-examples"},{"type":"function","title":"Calendar.ISO.time_to_string/5","doc":"Converts the given time into a string.\n\nBy default, returns times formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.","ref":"Calendar.ISO.html#time_to_string/5"},{"type":"function","title":"Examples - Calendar.ISO.time_to_string/5","doc":"iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6})\n    \"02:02:02.000002\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 2})\n    \"02:02:02.00\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 0})\n    \"02:02:02\"\n\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6}, :basic)\n    \"020202.000002\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6}, :extended)\n    \"02:02:02.000002\"","ref":"Calendar.ISO.html#time_to_string/5-examples"},{"type":"function","title":"Calendar.ISO.time_unit_to_precision/1","doc":"Converts a `t:System.time_unit/0` to precision.\n\nInteger-based time units always get maximum precision.","ref":"Calendar.ISO.html#time_unit_to_precision/1"},{"type":"function","title":"Examples - Calendar.ISO.time_unit_to_precision/1","doc":"iex> Calendar.ISO.time_unit_to_precision(:nanosecond)\n    6\n\n    iex> Calendar.ISO.time_unit_to_precision(:second)\n    0\n\n    iex> Calendar.ISO.time_unit_to_precision(1)\n    6","ref":"Calendar.ISO.html#time_unit_to_precision/1-examples"},{"type":"type","title":"Calendar.ISO.utc_offset/0","doc":"","ref":"Calendar.ISO.html#t:utc_offset/0"},{"type":"function","title":"Calendar.ISO.valid_date?/3","doc":"Determines if the date given is valid according to the proleptic Gregorian calendar.","ref":"Calendar.ISO.html#valid_date?/3"},{"type":"function","title":"Examples - Calendar.ISO.valid_date?/3","doc":"iex> Calendar.ISO.valid_date?(2015, 2, 28)\n    true\n    iex> Calendar.ISO.valid_date?(2015, 2, 30)\n    false\n    iex> Calendar.ISO.valid_date?(-1, 12, 31)\n    true\n    iex> Calendar.ISO.valid_date?(-1, 12, 32)\n    false","ref":"Calendar.ISO.html#valid_date?/3-examples"},{"type":"function","title":"Calendar.ISO.valid_time?/4","doc":"Determines if the date given is valid according to the proleptic Gregorian calendar.\n\nLeap seconds are not supported by the built-in Calendar.ISO.","ref":"Calendar.ISO.html#valid_time?/4"},{"type":"function","title":"Examples - Calendar.ISO.valid_time?/4","doc":"iex> Calendar.ISO.valid_time?(10, 50, 25, {3006, 6})\n    true\n    iex> Calendar.ISO.valid_time?(23, 59, 60, {0, 0})\n    false\n    iex> Calendar.ISO.valid_time?(24, 0, 0, {0, 0})\n    false","ref":"Calendar.ISO.html#valid_time?/4-examples"},{"type":"type","title":"Calendar.ISO.weekday/0","doc":"","ref":"Calendar.ISO.html#t:weekday/0"},{"type":"type","title":"Calendar.ISO.year/0","doc":"","ref":"Calendar.ISO.html#t:year/0"},{"type":"type","title":"Calendar.ISO.year_of_era/0","doc":"","ref":"Calendar.ISO.html#t:year_of_era/0"},{"type":"function","title":"Calendar.ISO.year_of_era/1","doc":"Calculates the year and era from the given `year`.\n\nThe ISO calendar has two eras: the \"current era\" (CE) which\nstarts in year `1` and is defined as era `1`. And \"before the current\nera\" (BCE) for those years less than `1`, defined as era `0`.","ref":"Calendar.ISO.html#year_of_era/1"},{"type":"function","title":"Examples - Calendar.ISO.year_of_era/1","doc":"iex> Calendar.ISO.year_of_era(1)\n    {1, 1}\n    iex> Calendar.ISO.year_of_era(2018)\n    {2018, 1}\n    iex> Calendar.ISO.year_of_era(0)\n    {1, 0}\n    iex> Calendar.ISO.year_of_era(-1)\n    {2, 0}","ref":"Calendar.ISO.html#year_of_era/1-examples"},{"type":"function","title":"Calendar.ISO.year_of_era/3","doc":"Calendar callback to compute the year and era from the\ngiven `year`, `month` and `day`.\n\nIn the ISO calendar, the new year coincides with the new era,\nso the `month` and `day` arguments are discarded. If you only\nhave the year available, you can `year_of_era/1` instead.","ref":"Calendar.ISO.html#year_of_era/3"},{"type":"function","title":"Examples - Calendar.ISO.year_of_era/3","doc":"iex> Calendar.ISO.year_of_era(1, 1, 1)\n    {1, 1}\n    iex> Calendar.ISO.year_of_era(2018, 12, 1)\n    {2018, 1}\n    iex> Calendar.ISO.year_of_era(0, 1, 1)\n    {1, 0}\n    iex> Calendar.ISO.year_of_era(-1, 12, 1)\n    {2, 0}","ref":"Calendar.ISO.html#year_of_era/3-examples"},{"type":"behaviour","title":"Calendar.TimeZoneDatabase","doc":"This module defines a behaviour for providing time zone data.\n\nIANA provides time zone data that includes data about different\nUTC offsets and standard offsets for time zones.","ref":"Calendar.TimeZoneDatabase.html"},{"type":"type","title":"Calendar.TimeZoneDatabase.time_zone_period/0","doc":"A period where a certain combination of UTC offset, standard offset, and zone\nabbreviation is in effect.\n\nFor example, one period could be the summer of 2018 in the `Europe/London` timezone,\nwhere summer time/daylight saving time is in effect and lasts from spring to autumn.\nIn autumn, the `std_offset` changes along with the `zone_abbr` so a different\nperiod is needed during winter.","ref":"Calendar.TimeZoneDatabase.html#t:time_zone_period/0"},{"type":"callback","title":"Calendar.TimeZoneDatabase.time_zone_period_from_utc_iso_days/2","doc":"Time zone period for a point in time in UTC for a specific time zone.\n\nTakes a time zone name and a point in time for UTC and returns a\n`time_zone_period` for that point in time.","ref":"Calendar.TimeZoneDatabase.html#c:time_zone_period_from_utc_iso_days/2"},{"type":"type","title":"Calendar.TimeZoneDatabase.time_zone_period_limit/0","doc":"Limit for when a certain time zone period begins or ends.\n\nA beginning is inclusive. An ending is exclusive. For example, if a period is from\n`2015-03-29 01:00:00` and until `2015-10-25 01:00:00`, the period includes and\nbegins from the beginning of `2015-03-29 01:00:00` and lasts until just before\n`2015-10-25 01:00:00`.\n\nA beginning or end for certain periods are infinite, such as the latest\nperiod for time zones without DST or plans to change. However, for the purpose\nof this behaviour, they are only used for gaps in wall time where the needed\nperiod limits are at a certain time.","ref":"Calendar.TimeZoneDatabase.html#t:time_zone_period_limit/0"},{"type":"callback","title":"Calendar.TimeZoneDatabase.time_zone_periods_from_wall_datetime/2","doc":"Possible time zone periods for a certain time zone and wall clock date and time.\n\nWhen the provided naive datetime is ambiguous, return a tuple with `:ambiguous`\nand the two possible periods. The periods in the tuple must be sorted with the\nfirst element being the one that begins first.\n\nWhen the provided naive datetime is in a gap, such as during the \"spring forward\" when going\nfrom winter time to summer time, return a tuple with `:gap` and two periods with limits\nin a nested tuple. The first nested two-tuple is the period before the gap and a naive datetime\nwith a limit for when the period ends (wall time). The second nested two-tuple is the period\njust after the gap and a datetime (wall time) for when the period begins just after the gap.\n\nIf there is only a single possible period for the provided `datetime`, then return a tuple\nwith `:ok` and the `time_zone_period`.","ref":"Calendar.TimeZoneDatabase.html#c:time_zone_periods_from_wall_datetime/2"},{"type":"module","title":"Calendar.UTCOnlyTimeZoneDatabase","doc":"Built-in time zone database that works only in the `Etc/UTC` timezone.\n\nFor all other time zones, it returns `{:error, :utc_only_time_zone_database}`.","ref":"Calendar.UTCOnlyTimeZoneDatabase.html"},{"type":"module","title":"Agent","doc":"Agents are a simple abstraction around state.\n\nOften in Elixir there is a need to share or store state that\nmust be accessed from different processes or by the same process\nat different points in time.\n\nThe `Agent` module provides a basic server implementation that\nallows state to be retrieved and updated via a simple API.","ref":"Agent.html"},{"type":"module","title":"Examples - Agent","doc":"For example, the following agent implements a counter:\n\n    defmodule Counter do\n      use Agent\n\n      def start_link(initial_value) do\n        Agent.start_link(fn -> initial_value end, name: __MODULE__)\n      end\n\n      def value do\n        Agent.get(__MODULE__, & &1)\n      end\n\n      def increment do\n        Agent.update(__MODULE__, &(&1 + 1))\n      end\n    end\n\nUsage would be:\n\n    Counter.start_link(0)\n    #=> {:ok, #PID<0.123.0>}\n\n    Counter.value()\n    #=> 0\n\n    Counter.increment()\n    #=> :ok\n\n    Counter.increment()\n    #=> :ok\n\n    Counter.value()\n    #=> 2\n\nThanks to the agent server process, the counter can be safely incremented\nconcurrently.\n\n> #### `use Agent` {: .info}\n>\n> When you `use Agent`, the `Agent` module will define a\n> `child_spec/1` function, so your module can be used\n> as a child in a supervision tree.\n\nAgents provide a segregation between the client and server APIs (similar to\n`GenServer`s). In particular, the functions passed as arguments to the calls to\n`Agent` functions are invoked inside the agent (the server). This distinction\nis important because you may want to avoid expensive operations inside the\nagent, as they will effectively block the agent until the request is\nfulfilled.\n\nConsider these two examples:\n\n    # Compute in the agent/server\n    def get_something(agent) do\n      Agent.get(agent, fn state -> do_something_expensive(state) end)\n    end\n\n    # Compute in the agent/client\n    def get_something(agent) do\n      Agent.get(agent, & &1) |> do_something_expensive()\n    end\n\nThe first function blocks the agent. The second function copies all the state\nto the client and then executes the operation in the client. One aspect to\nconsider is whether the data is large enough to require processing in the server,\nat least initially, or small enough to be sent to the client cheaply. Another\nfactor is whether the data needs to be processed atomically: getting the\nstate and calling `do_something_expensive(state)` outside of the agent means\nthat the agent's state can be updated in the meantime. This is specially\nimportant in case of updates as computing the new state in the client rather\nthan in the server can lead to race conditions if multiple clients are trying\nto update the same state to different values.","ref":"Agent.html#module-examples"},{"type":"module","title":"How to supervise - Agent","doc":"An `Agent` is most commonly started under a supervision tree.\nWhen we invoke `use Agent`, it automatically defines a `child_spec/1`\nfunction that allows us to start the agent directly under a supervisor.\nTo start an agent under a supervisor with an initial counter of 0,\none may do:\n\n    children = [\n      {Counter, 0}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nWhile one could also simply pass the `Counter` as a child to the supervisor,\nsuch as:\n\n    children = [\n      Counter # Same as {Counter, []}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nThe definition above wouldn't work for this particular example,\nas it would attempt to start the counter with an initial value\nof an empty list. However, this may be a viable option in your\nown agents. A common approach is to use a keyword list, as that\nwould allow setting the initial value and giving a name to the\ncounter process, for example:\n\n    def start_link(opts) do\n      {initial_value, opts} = Keyword.pop(opts, :initial_value, 0)\n      Agent.start_link(fn -> initial_value end, opts)\n    end\n\nand then you can use `Counter`, `{Counter, name: :my_counter}` or\neven `{Counter, initial_value: 0, name: :my_counter}` as a child\nspecification.\n\n`use Agent` also accepts a list of options which configures the\nchild specification and therefore how it runs under a supervisor.\nThe generated `child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:permanent`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nFor example:\n\n    use Agent, restart: :transient, shutdown: 10_000\n\nSee the \"Child specification\" section in the `Supervisor` module for more\ndetailed information. The `@doc` annotation immediately preceding\n`use Agent` will be attached to the generated `child_spec/1` function.","ref":"Agent.html#module-how-to-supervise"},{"type":"module","title":"Name registration - Agent","doc":"An agent is bound to the same name registration rules as GenServers.\nRead more about it in the `GenServer` documentation.","ref":"Agent.html#module-name-registration"},{"type":"module","title":"A word on distributed agents - Agent","doc":"It is important to consider the limitations of distributed agents. Agents\nprovide two APIs, one that works with anonymous functions and another\nthat expects an explicit module, function, and arguments.\n\nIn a distributed setup with multiple nodes, the API that accepts anonymous\nfunctions only works if the caller (client) and the agent have the same\nversion of the caller module.\n\nKeep in mind this issue also shows up when performing \"rolling upgrades\"\nwith agents. By rolling upgrades we mean the following situation: you wish\nto deploy a new version of your software by *shutting down* some of your\nnodes and replacing them with nodes running a new version of the software.\nIn this setup, part of your environment will have one version of a given\nmodule and the other part another version (the newer one) of the same module.\n\nThe best solution is to simply use the explicit module, function, and arguments\nAPIs when working with distributed agents.","ref":"Agent.html#module-a-word-on-distributed-agents"},{"type":"module","title":"Hot code swapping - Agent","doc":"An agent can have its code hot swapped live by simply passing a module,\nfunction, and arguments tuple to the update instruction. For example, imagine\nyou have an agent named `:sample` and you want to convert its inner state\nfrom a keyword list to a map. It can be done with the following\ninstruction:\n\n    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n\nThe agent's state will be added to the given list of arguments (`[%{}]`) as\nthe first argument.","ref":"Agent.html#module-hot-code-swapping"},{"type":"type","title":"Agent.agent/0","doc":"The agent reference","ref":"Agent.html#t:agent/0"},{"type":"function","title":"Agent.cast/2","doc":"Performs a cast (*fire and forget*) operation on the agent state.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The return value of `fun` becomes the new\nstate of the agent.\n\nNote that `cast` returns `:ok` immediately, regardless of whether `agent` (or\nthe node it should live on) exists.","ref":"Agent.html#cast/2"},{"type":"function","title":"Examples - Agent.cast/2","doc":"iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.cast(pid, fn state -> state + 1 end)\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    43","ref":"Agent.html#cast/2-examples"},{"type":"function","title":"Agent.cast/4","doc":"Performs a cast (*fire and forget*) operation on the agent state.\n\nSame as `cast/2` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.","ref":"Agent.html#cast/4"},{"type":"function","title":"Examples - Agent.cast/4","doc":"iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.cast(pid, Kernel, :+, [12])\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    54","ref":"Agent.html#cast/4-examples"},{"type":"function","title":"Agent.child_spec/1","doc":"Returns a specification to start an agent under a supervisor.\n\nSee the \"Child specification\" section in the `Supervisor` module for more detailed information.","ref":"Agent.html#child_spec/1"},{"type":"function","title":"Agent.get/3","doc":"Gets an agent value via the given anonymous function.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The result of the function invocation is\nreturned from this function.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.","ref":"Agent.html#get/3"},{"type":"function","title":"Examples - Agent.get/3","doc":"iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42","ref":"Agent.html#get/3-examples"},{"type":"function","title":"Agent.get/5","doc":"Gets an agent value via the given function.\n\nSame as `get/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.","ref":"Agent.html#get/5"},{"type":"function","title":"Agent.get_and_update/3","doc":"Gets and updates the agent state in one operation via the given anonymous\nfunction.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The function must return a tuple with two\nelements, the first being the value to return (that is, the \"get\" value)\nand the second one being the new state of the agent.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.","ref":"Agent.html#get_and_update/3"},{"type":"function","title":"Examples - Agent.get_and_update/3","doc":"iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get_and_update(pid, fn state -> {state, state + 1} end)\n    42\n    iex> Agent.get(pid, fn state -> state end)\n    43","ref":"Agent.html#get_and_update/3-examples"},{"type":"function","title":"Agent.get_and_update/5","doc":"Gets and updates the agent state in one operation via the given function.\n\nSame as `get_and_update/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.","ref":"Agent.html#get_and_update/5"},{"type":"type","title":"Agent.name/0","doc":"The agent name","ref":"Agent.html#t:name/0"},{"type":"type","title":"Agent.on_start/0","doc":"Return values of `start*` functions","ref":"Agent.html#t:on_start/0"},{"type":"function","title":"Agent.start/2","doc":"Starts an agent process without links (outside of a supervision tree).\n\nSee `start_link/2` for more information.","ref":"Agent.html#start/2"},{"type":"function","title":"Examples - Agent.start/2","doc":"iex> {:ok, pid} = Agent.start(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42","ref":"Agent.html#start/2-examples"},{"type":"function","title":"Agent.start/4","doc":"Starts an agent without links with the given module, function, and arguments.\n\nSee `start_link/4` for more information.","ref":"Agent.html#start/4"},{"type":"function","title":"Agent.start_link/2","doc":"Starts an agent linked to the current process with the given function.\n\nThis is often used to start the agent as part of a supervision tree.\n\nOnce the agent is spawned, the given function `fun` is invoked in the server\nprocess, and should return the initial agent state. Note that `start_link/2`\ndoes not return until the given function has returned.","ref":"Agent.html#start_link/2"},{"type":"function","title":"Options - Agent.start_link/2","doc":"The `:name` option is used for registration as described in the module\ndocumentation.\n\nIf the `:timeout` option is present, the agent is allowed to spend at most\nthe given number of milliseconds on initialization or it will be terminated\nand the start function will return `{:error, :timeout}`.\n\nIf the `:debug` option is present, the corresponding function in the\n[`:sys` module](`:sys`) will be invoked.\n\nIf the `:spawn_opt` option is present, its value will be passed as options\nto the underlying process as in `Process.spawn/4`.","ref":"Agent.html#start_link/2-options"},{"type":"function","title":"Return values - Agent.start_link/2","doc":"If the server is successfully created and initialized, the function returns\n`{:ok, pid}`, where `pid` is the PID of the server. If an agent with the\nspecified name already exists, the function returns\n`{:error, {:already_started, pid}}` with the PID of that process.\n\nIf the given function callback fails, the function returns `{:error, reason}`.","ref":"Agent.html#start_link/2-return-values"},{"type":"function","title":"Examples - Agent.start_link/2","doc":"iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42\n\n    iex> {:error, {exception, _stacktrace}} = Agent.start(fn -> raise \"oops\" end)\n    iex> exception\n    %RuntimeError{message: \"oops\"}","ref":"Agent.html#start_link/2-examples"},{"type":"function","title":"Agent.start_link/4","doc":"Starts an agent linked to the current process.\n\nSame as `start_link/2` but a module, function, and arguments are expected\ninstead of an anonymous function; `fun` in `module` will be called with the\ngiven arguments `args` to initialize the state.","ref":"Agent.html#start_link/4"},{"type":"type","title":"Agent.state/0","doc":"The agent state","ref":"Agent.html#t:state/0"},{"type":"function","title":"Agent.stop/3","doc":"Synchronously stops the agent with the given `reason`.\n\nIt returns `:ok` if the agent terminates with the given\nreason. If the agent terminates with another reason, the call will\nexit.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report will be logged.","ref":"Agent.html#stop/3"},{"type":"function","title":"Examples - Agent.stop/3","doc":"iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.stop(pid)\n    :ok","ref":"Agent.html#stop/3-examples"},{"type":"function","title":"Agent.update/3","doc":"Updates the agent state via the given anonymous function.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The return value of `fun` becomes the new\nstate of the agent.\n\nThis function always returns `:ok`.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.","ref":"Agent.html#update/3"},{"type":"function","title":"Examples - Agent.update/3","doc":"iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.update(pid, fn state -> state + 1 end)\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    43","ref":"Agent.html#update/3-examples"},{"type":"function","title":"Agent.update/5","doc":"Updates the agent state via the given function.\n\nSame as `update/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.","ref":"Agent.html#update/5"},{"type":"function","title":"Examples - Agent.update/5","doc":"iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.update(pid, Kernel, :+, [12])\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    54","ref":"Agent.html#update/5-examples"},{"type":"behaviour","title":"Application","doc":"A module for working with applications and defining application callbacks.\n\nApplications are the idiomatic way to package software in Erlang/OTP. To get\nthe idea, they are similar to the \"library\" concept common in other\nprogramming languages, but with some additional characteristics.\n\nAn application is a component implementing some specific functionality, with a\nstandardized directory structure, configuration, and life cycle. Applications\nare *loaded*, *started*, and *stopped*. Each application also has its own\nenvironment, which provides a unified API for configuring each application.\n\nDevelopers typically interact with the application environment and its\ncallback module. Therefore those will be the topics we will cover first\nbefore jumping into details about the application resource file and life cycle.","ref":"Application.html"},{"type":"behaviour","title":"The application environment - Application","doc":"Each application has its own environment. The environment is a keyword list\nthat maps atoms to terms. Note that this environment is unrelated to the\noperating system environment.\n\nBy default, the environment of an application is an empty list. In a Mix\nproject's `mix.exs` file, you can set the `:env` key in `application/0`:\n\n    def application do\n      [env: [db_host: \"localhost\"]]\n    end\n\nNow, in your application, you can read this environment by using functions\nsuch as `fetch_env!/2` and friends:\n\n    defmodule MyApp.DBClient do\n      def start_link() do\n        SomeLib.DBClient.start_link(host: db_host())\n      end\n\n      defp db_host do\n        Application.fetch_env!(:my_app, :db_host)\n      end\n    end\n\nIn Mix projects, the environment of the application and its dependencies can\nbe overridden via the `config/config.exs` and `config/runtime.exs` files. The\nformer is loaded at build-time, before your code compiles, and the latter at\nruntime, just before your app starts. For example, someone using your application\ncan override its `:db_host` environment variable as follows:\n\n    import Config\n    config :my_app, :db_host, \"db.local\"\n\nSee the \"Configuration\" section in the `Mix` module for more information.\nYou can also change the application environment dynamically by using functions\nsuch as `put_env/3` and `delete_env/2`.\n\n> #### Environment in libraries {: .tip}\n>\n> The config files `config/config.exs` and `config/runtime.exs`\n> are rarely used by libraries. Libraries typically define their environment\n> in the `application/0` function of their `mix.exs`. Configuration files\n> are rather used by applications to configure their libraries.\n\n> #### Reading the environment of other applications {: .warning}\n>\n> Each application is responsible for its own environment. Do not\n> use the functions in this module for directly accessing or modifying\n> the environment of other applications. Whenever you change the application\n> environment, Elixir's build tool will only recompile the files that\n> belong to that application. So if you read the application environment\n> of another application, there is a chance you will be depending on\n> outdated configuration, as your file won't be recompiled as it changes.","ref":"Application.html#module-the-application-environment"},{"type":"behaviour","title":"Compile-time environment - Application","doc":"In the previous example, we read the application environment at runtime:\n\n    defmodule MyApp.DBClient do\n      def start_link() do\n        SomeLib.DBClient.start_link(host: db_host())\n      end\n\n      defp db_host do\n        Application.fetch_env!(:my_app, :db_host)\n      end\n    end\n\nIn other words, the environment key `:db_host` for application `:my_app`\nwill only be read when `MyApp.DBClient` effectively starts. While reading\nthe application environment at runtime is the preferred approach, in some\nrare occasions you may want to use the application environment to configure\nthe compilation of a certain project. However, if you try to access\n`Application.fetch_env!/2` outside of a function:\n\n    defmodule MyApp.DBClient do\n      @db_host Application.fetch_env!(:my_app, :db_host)\n\n      def start_link() do\n        SomeLib.DBClient.start_link(host: @db_host)\n      end\n    end\n\nYou might see warnings and errors:\n\n    warning: Application.fetch_env!/2 is discouraged in the module body,\n    use Application.compile_env/3 instead\n      iex:3: MyApp.DBClient\n\n    ** (ArgumentError) could not fetch application environment :db_host\n    for application :my_app because the application was not loaded nor\n    configured\n\nThis happens because, when defining modules, the application environment\nis not yet available. Luckily, the warning tells us how to solve this\nissue, by using `Application.compile_env/3` instead:\n\n    defmodule MyApp.DBClient do\n      @db_host Application.compile_env(:my_app, :db_host, \"db.local\")\n\n      def start_link() do\n        SomeLib.DBClient.start_link(host: @db_host)\n      end\n    end\n\nThe difference here is that `compile_env` expects the default value to be\ngiven as an argument, instead of using the `def application` function of\nyour `mix.exs`. Furthermore, by using `compile_env/3`, tools like Mix will\nstore the values used during compilation and compare the compilation values\nwith the runtime values whenever your system starts, raising an error in\ncase they differ.\n\nIn any case, compile-time environments should be avoided. Whenever possible,\nreading the application environment at runtime should be the first choice.","ref":"Application.html#module-compile-time-environment"},{"type":"behaviour","title":"The application callback module - Application","doc":"Applications can be loaded, started, and stopped. Generally, build tools\nlike Mix take care of starting an application and all of its dependencies\nfor you, but you can also do it manually by calling:\n\n    {:ok, _} = Application.ensure_all_started(:some_app)\n\nWhen an application starts, developers may configure a callback module\nthat executes custom code. Developers use this callback to start the\napplication supervision tree.\n\nThe first step to do so is to add a `:mod` key to the `application/0`\ndefinition in your `mix.exs` file. It expects a tuple, with the application\ncallback module and start argument (commonly an empty list):\n\n    def application do\n      [mod: {MyApp, []}]\n    end\n\nThe `MyApp` module given to `:mod` needs to implement the `Application` behaviour.\nThis can be done by putting `use Application` in that module and implementing the\n`c:start/2` callback, for example:\n\n    defmodule MyApp do\n      use Application\n\n      def start(_type, _args) do\n        children = []\n        Supervisor.start_link(children, strategy: :one_for_one)\n      end\n    end\n\n> #### `use Application` {: .info}\n>\n> When you `use Application`, the `Application` module will\n> set `@behaviour Application` and define an overridable\n> definition for the `c:stop/1` function, which is required\n> by Erlang/OTP.\n\nThe `c:start/2` callback has to spawn and link a supervisor and return `{:ok,\npid}` or `{:ok, pid, state}`, where `pid` is the PID of the supervisor, and\n`state` is an optional application state. `args` is the second element of the\ntuple given to the `:mod` option.\n\nThe `type` argument passed to `c:start/2` is usually `:normal` unless in a\ndistributed setup where application takeovers and failovers are configured.\nDistributed applications are beyond the scope of this documentation.\n\nWhen an application is shutting down, its `c:stop/1` callback is called after\nthe supervision tree has been stopped by the runtime. This callback allows the\napplication to do any final cleanup. The argument is the state returned by\n`c:start/2`, if it did, or `[]` otherwise. The return value of `c:stop/1` is\nignored.\n\nBy using `Application`, modules get a default implementation of `c:stop/1`\nthat ignores its argument and returns `:ok`, but it can be overridden.\n\nApplication callback modules may also implement the optional callback\n`c:prep_stop/1`. If present, `c:prep_stop/1` is invoked before the supervision\ntree is terminated. Its argument is the state returned by `c:start/2`, if it did,\nor `[]` otherwise, and its return value is passed to `c:stop/1`.","ref":"Application.html#module-the-application-callback-module"},{"type":"behaviour","title":"The application resource file - Application","doc":"In the sections above, we have configured an application in the\n`application/0` section of the `mix.exs` file. Ultimately, Mix will use\nthis configuration to create an [*application resource\nfile*](https://www.erlang.org/doc/man/app), which is a file called\n`APP_NAME.app`. For example, the application resource file of the OTP\napplication `ex_unit` is called `ex_unit.app`.\n\nYou can learn more about the generation of application resource files in\nthe documentation of `Mix.Tasks.Compile.App`, available as well by running\n`mix help compile.app`.","ref":"Application.html#module-the-application-resource-file"},{"type":"behaviour","title":"The application life cycle - Application","doc":"","ref":"Application.html#module-the-application-life-cycle"},{"type":"behaviour","title":"Loading applications - Application","doc":"Applications are *loaded*, which means that the runtime finds and processes\ntheir resource files:\n\n    Application.load(:ex_unit)\n    #=> :ok\n\nWhen an application is loaded, the environment specified in its resource file\nis merged with any overrides from config files.\n\nLoading an application *does not* load its modules.\n\nIn practice, you rarely load applications by hand because that is part of the\nstart process, explained next.","ref":"Application.html#module-loading-applications"},{"type":"behaviour","title":"Starting applications - Application","doc":"Applications are also *started*:\n\n    Application.start(:ex_unit)\n    #=> :ok\n\nOnce your application is compiled, running your system is a matter of starting\nyour current application and its dependencies. Differently from other languages,\nElixir does not have a `main` procedure that is responsible for starting your\nsystem. Instead, you start one or more applications, each with their own\ninitialization and termination logic.\n\nWhen an application is started, the `Application.load/1` is automatically\ninvoked if it hasn't been done yet. Then, it checks if the dependencies listed\nin the `applications` key of the resource file are already started. Having at\nleast one dependency not started is an error condition. Functions like\n`ensure_all_started/1` takes care of starting an application and all of its\ndependencies for you.\n\nIf the application does not have a callback module configured, starting is\ndone at this point. Otherwise, its `c:start/2` callback is invoked. The PID of\nthe top-level supervisor returned by this function is stored by the runtime\nfor later use, and the returned application state is saved too, if any.","ref":"Application.html#module-starting-applications"},{"type":"behaviour","title":"Stopping applications - Application","doc":"Started applications are, finally, *stopped*:\n\n    Application.stop(:ex_unit)\n    #=> :ok\n\nStopping an application without a callback module defined, is in practice a\nno-op, except for some system tracing.\n\nStopping an application with a callback module has three steps:\n\n  1. If present, invoke the optional callback `c:prep_stop/1`.\n  2. Terminate the top-level supervisor.\n  3. Invoke the required callback `c:stop/1`.\n\nThe arguments passed to the callbacks are related to the state optionally\nreturned by `c:start/2`, and are documented in the section about the callback\nmodule above.\n\nIt is important to highlight that step 2 is a blocking one. Termination of a\nsupervisor triggers a recursive chain of children terminations, therefore\norderly shutting down all descendant processes. The `c:stop/1` callback is\ninvoked only after termination of the whole supervision tree.\n\nShutting down a live system cleanly can be done by calling `System.stop/1`. It\nwill shut down every application in the reverse order they were started.\n\nBy default, a SIGTERM from the operating system will automatically translate to\n`System.stop/0`. You can also have more explicit control over operating system\nsignals via the `:os.set_signal/2` function.","ref":"Application.html#module-stopping-applications"},{"type":"behaviour","title":"Tooling - Application","doc":"The Mix build tool automates most of the application management tasks. For example,\n`mix test` automatically starts your application dependencies and your application\nitself before your test runs. `mix run --no-halt` boots your current project and\ncan be used to start a long running system. See `mix help run`.\n\nDevelopers can also use `mix release` to build **releases**. Releases are able to\npackage all of your source code as well as the Erlang VM into a single directory.\nReleases also give you explicit control over how each application is started and in\nwhich order. They also provide a more streamlined mechanism for starting and\nstopping systems, debugging, logging, as well as system monitoring.\n\nFinally, Elixir provides tools such as escripts and archives, which are\ndifferent mechanisms for packaging your application. Those are typically used\nwhen tools must be shared between developers and not as deployment options.\nSee `mix help archive.build` and `mix help escript.build` for more detail.","ref":"Application.html#module-tooling"},{"type":"behaviour","title":"Further information - Application","doc":"For further details on applications please check the documentation of the\n[`:application` Erlang module](`:application`), and the\n[Applications](https://www.erlang.org/doc/design_principles/applications.html)\nsection of the [OTP Design Principles User's\nGuide](https://www.erlang.org/doc/design_principles/users_guide.html).","ref":"Application.html#module-further-information"},{"type":"type","title":"Application.app/0","doc":"","ref":"Application.html#t:app/0"},{"type":"function","title":"Application.app_dir/1","doc":"Gets the directory for app.\n\nThis information is returned based on the code path. Here is an\nexample:\n\n    File.mkdir_p!(\"foo/ebin\")\n    Code.prepend_path(\"foo/ebin\")\n    Application.app_dir(:foo)\n    #=> \"foo\"\n\nEven though the directory is empty and there is no `.app` file\nit is considered the application directory based on the name\n\"foo/ebin\". The name may contain a dash `-` which is considered\nto be the app version and it is removed for the lookup purposes:\n\n    File.mkdir_p!(\"bar-123/ebin\")\n    Code.prepend_path(\"bar-123/ebin\")\n    Application.app_dir(:bar)\n    #=> \"bar-123\"\n\nFor more information on code paths, check the `Code` module in\nElixir and also Erlang's [`:code` module](`:code`).","ref":"Application.html#app_dir/1"},{"type":"function","title":"Application.app_dir/2","doc":"Returns the given path inside `app_dir/1`.\n\nIf `path` is a string, then it will be used as the path inside `app_dir/1`. If\n`path` is a list of strings, it will be joined (see `Path.join/1`) and the result\nwill be used as the path inside `app_dir/1`.","ref":"Application.html#app_dir/2"},{"type":"function","title":"Examples - Application.app_dir/2","doc":"File.mkdir_p!(\"foo/ebin\")\n    Code.prepend_path(\"foo/ebin\")\n\n    Application.app_dir(:foo, \"my_path\")\n    #=> \"foo/my_path\"\n\n    Application.app_dir(:foo, [\"my\", \"nested\", \"path\"])\n    #=> \"foo/my/nested/path\"","ref":"Application.html#app_dir/2-examples"},{"type":"type","title":"Application.application_key/0","doc":"","ref":"Application.html#t:application_key/0"},{"type":"macro","title":"Application.compile_env/3","doc":"Reads the application environment at compilation time.\n\nSimilar to `get_env/3`, except it must be used to read values\nat compile time. This allows Elixir to track when configuration\nvalues change between compile time and runtime.\n\nThe first argument is the application name. The second argument\n`key_or_path` is either an atom key or a path to traverse in\nsearch of the configuration, starting with an atom key.\n\nFor example, imagine the following configuration:\n\n    config :my_app, :key, [foo: [bar: :baz]]\n\nWe can access it during compile time as:\n\n    Application.compile_env(:my_app, :key)\n    #=> [foo: [bar: :baz]]\n\n    Application.compile_env(:my_app, [:key, :foo])\n    #=> [bar: :baz]\n\n    Application.compile_env(:my_app, [:key, :foo, :bar])\n    #=> :baz\n\nA default value can also be given as third argument. If\nany of the keys in the path along the way is missing, the\ndefault value is used:\n\n    Application.compile_env(:my_app, [:unknown, :foo, :bar], :default)\n    #=> :default\n\n    Application.compile_env(:my_app, [:key, :unknown, :bar], :default)\n    #=> :default\n\n    Application.compile_env(:my_app, [:key, :foo, :unknown], :default)\n    #=> :default\n\nGiving a path is useful to let Elixir know that only certain paths\nin a large configuration are compile time dependent.","ref":"Application.html#compile_env/3"},{"type":"function","title":"Application.compile_env/4","doc":"Reads the application environment at compilation time from a macro.\n\nTypically, developers will use `compile_env/3`. This function must\nonly be invoked from macros which aim to read the compilation environment\ndynamically.\n\nIt expects a `Macro.Env` as first argument, where the `Macro.Env` is\ntypically the `__CALLER__` in a macro. It raises if `Macro.Env` comes\nfrom a function.","ref":"Application.html#compile_env/4"},{"type":"macro","title":"Application.compile_env!/2","doc":"Reads the application environment at compilation time or raises.\n\nThis is the same as `compile_env/3` but it raises an\n`ArgumentError` if the configuration is not available.","ref":"Application.html#compile_env!/2"},{"type":"function","title":"Application.compile_env!/3","doc":"Reads the application environment at compilation time from a macro\nor raises.\n\nTypically, developers will use `compile_env!/2`. This function must\nonly be invoked from macros which aim to read the compilation environment\ndynamically.\n\nIt expects a `Macro.Env` as first argument, where the `Macro.Env` is\ntypically the `__CALLER__` in a macro. It raises if `Macro.Env` comes\nfrom a function.","ref":"Application.html#compile_env!/3"},{"type":"callback","title":"Application.config_change/3","doc":"Callback invoked after code upgrade, if the application environment\nhas changed.\n\n`changed` is a keyword list of keys and their changed values in the\napplication environment. `new` is a keyword list with all new keys\nand their values. `removed` is a list with all removed keys.","ref":"Application.html#c:config_change/3"},{"type":"function","title":"Application.delete_env/3","doc":"Deletes the `key` from the given `app` environment.\n\nIt receives the same options as `put_env/4`. Returns `:ok`.","ref":"Application.html#delete_env/3"},{"type":"function","title":"Application.ensure_all_started/2","doc":"Ensures the given `app` or `apps` and their child applications are started.\n\nThe second argument is either the `t:restart_type/1` (for consistency with\n`start/2`) or a keyword list.","ref":"Application.html#ensure_all_started/2"},{"type":"function","title":"Options - Application.ensure_all_started/2","doc":"* `:type` - if the application should be started `:temporary` (default),\n    `:permanent`, or `:transient`. See `t:restart_type/1` for more information.\n\n  * `:mode` - (since v1.15.0) if the applications should be started serially\n    (`:serial`, default) or concurrently (`:concurrent`). This option requires\n    Erlang/OTP 26+.","ref":"Application.html#ensure_all_started/2-options"},{"type":"function","title":"Application.ensure_loaded/1","doc":"Ensures the given `app` is loaded.\n\nSame as `load/1` but returns `:ok` if the application was already\nloaded.","ref":"Application.html#ensure_loaded/1"},{"type":"function","title":"Application.ensure_started/2","doc":"Ensures the given `app` is started with `t:restart_type/0`.\n\nSame as `start/2` but returns `:ok` if the application was already\nstarted.","ref":"Application.html#ensure_started/2"},{"type":"function","title":"Application.fetch_env/2","doc":"Returns the value for `key` in `app`'s environment in a tuple.\n\nIf the configuration parameter does not exist, the function returns `:error`.\n\n> #### Warning {: .warning}\n>\n> You must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> #### Application environment in info\n>\n> If you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).","ref":"Application.html#fetch_env/2"},{"type":"function","title":"Application.fetch_env!/2","doc":"Returns the value for `key` in `app`'s environment.\n\nIf the configuration parameter does not exist, raises `ArgumentError`.\n\n> #### Warning {: .warning}\n>\n> You must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> #### Application environment in info\n>\n> If you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).","ref":"Application.html#fetch_env!/2"},{"type":"function","title":"Application.format_error/1","doc":"Formats the error reason returned by `start/2`,\n`ensure_started/2`, `stop/1`, `load/1` and `unload/1`,\nreturns a string.","ref":"Application.html#format_error/1"},{"type":"function","title":"Application.get_all_env/1","doc":"Returns all key-value pairs for `app`.","ref":"Application.html#get_all_env/1"},{"type":"function","title":"Application.get_application/1","doc":"Gets the application for the given module.\n\nThe application is located by analyzing the spec\nof all loaded applications. Returns `nil` if\nthe module is not listed in any application spec.","ref":"Application.html#get_application/1"},{"type":"function","title":"Application.get_env/3","doc":"Returns the value for `key` in `app`'s environment.\n\nIf the configuration parameter does not exist, the function returns the\n`default` value.\n\n> #### Warning {: .warning}\n>\n> You must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> #### Application environment in libraries {: .info}\n>\n> If you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).","ref":"Application.html#get_env/3"},{"type":"function","title":"Examples - Application.get_env/3","doc":"`get_env/3` is commonly used to read the configuration of your OTP applications.\nSince Mix configurations are commonly used to configure applications, we will use\nthis as a point of illustration.\n\nConsider a new application `:my_app`. `:my_app` contains a database engine which\nsupports a pool of databases. The database engine needs to know the configuration for\neach of those databases, and that configuration is supplied by key-value pairs in\nenvironment of `:my_app`.\n\n    config :my_app, Databases.RepoOne,\n      # A database configuration\n      ip: \"localhost\",\n      port: 5433\n\n    config :my_app, Databases.RepoTwo,\n      # Another database configuration (for the same OTP app)\n      ip: \"localhost\",\n      port: 20717\n\n    config :my_app, my_app_databases: [Databases.RepoOne, Databases.RepoTwo]\n\nOur database engine used by `:my_app` needs to know what databases exist, and\nwhat the database configurations are. The database engine can make a call to\n`Application.get_env(:my_app, :my_app_databases, [])` to retrieve the list of\ndatabases (specified by module names).\n\nThe engine can then traverse each repository in the list and call\n`Application.get_env(:my_app, Databases.RepoOne)` and so forth to retrieve the\nconfiguration of each one. In this case, each configuration will be a keyword\nlist, so you can use the functions in the `Keyword` module or even the `Access`\nmodule to traverse it, for example:\n\n    config = Application.get_env(:my_app, Databases.RepoOne)\n    config[:ip]","ref":"Application.html#get_env/3-examples"},{"type":"type","title":"Application.key/0","doc":"","ref":"Application.html#t:key/0"},{"type":"function","title":"Application.load/1","doc":"Loads the given `app`.\n\nIn order to be loaded, an `.app` file must be in the load paths.\nAll `:included_applications` will also be loaded.\n\nLoading the application does not start it nor load its modules, but\nit does load its environment.","ref":"Application.html#load/1"},{"type":"function","title":"Application.loaded_applications/0","doc":"Returns a list with information about the applications which have been loaded.","ref":"Application.html#loaded_applications/0"},{"type":"callback","title":"Application.prep_stop/1","doc":"Called before stopping the application.\n\nThis function is called before the top-level supervisor is terminated. It\nreceives the state returned by `c:start/2`, if it did, or `[]` otherwise.\nThe return value is later passed to `c:stop/1`.","ref":"Application.html#c:prep_stop/1"},{"type":"function","title":"Application.put_all_env/2","doc":"Puts the environment for multiple applications at the same time.\n\nThe given config should not:\n\n  * have the same application listed more than once\n  * have the same key inside the same application listed more than once\n\nIf those conditions are not met, this function will raise.\n\nThis function receives the same options as `put_env/4`. Returns `:ok`.","ref":"Application.html#put_all_env/2"},{"type":"function","title":"Examples - Application.put_all_env/2","doc":"Application.put_all_env(\n      my_app: [\n        key: :value,\n        another_key: :another_value\n      ],\n      another_app: [\n        key: :value\n      ]\n    )","ref":"Application.html#put_all_env/2-examples"},{"type":"function","title":"Application.put_env/4","doc":"Puts the `value` in `key` for the given `app`.","ref":"Application.html#put_env/4"},{"type":"function","title":"Options - Application.put_env/4","doc":"* `:timeout` - the timeout for the change (defaults to `5_000` milliseconds)\n  * `:persistent` - persists the given value on application load and reloads\n\nIf `put_env/4` is called before the application is loaded, the application\nenvironment values specified in the `.app` file will override the ones\npreviously set.\n\nThe `:persistent` option can be set to `true` when there is a need to guarantee\nparameters set with this function will not be overridden by the ones defined\nin the application resource file on load. This means persistent values will\nstick after the application is loaded and also on application reload.","ref":"Application.html#put_env/4-options"},{"type":"type","title":"Application.restart_type/0","doc":"Specifies the type of the application:\n\n  * `:permanent` - if `app` terminates, all other applications and the entire\n    node are also terminated.\n\n  * `:transient` - if `app` terminates with `:normal` reason, it is reported\n    but no other applications are terminated. If a transient application\n    terminates abnormally, all other applications and the entire node are\n    also terminated.\n\n  * `:temporary` - if `app` terminates, it is reported but no other\n    applications are terminated (the default).\n\nNote that it is always possible to stop an application explicitly by calling\n`stop/1`. Regardless of the type of the application, no other applications will\nbe affected.\n\nNote also that the `:transient` type is of little practical use, since when a\nsupervision tree terminates, the reason is set to `:shutdown`, not `:normal`.","ref":"Application.html#t:restart_type/0"},{"type":"function","title":"Application.spec/1","doc":"Returns the spec for `app`.\n\nThe following keys are returned:\n\n  * `:description`\n  * `:id`\n  * `:vsn`\n  * `:modules`\n  * `:maxP`\n  * `:maxT`\n  * `:registered`\n  * `:included_applications`\n  * `:optional_applications`\n  * `:applications`\n  * `:mod`\n  * `:start_phases`\n\nFor a description of all fields, see [Erlang's application\nspecification](https://www.erlang.org/doc/man/app).\n\nNote the environment is not returned as it can be accessed via\n`fetch_env/2`. Returns `nil` if the application is not loaded.","ref":"Application.html#spec/1"},{"type":"function","title":"Application.spec/2","doc":"Returns the value for `key` in `app`'s specification.\n\nSee `spec/1` for the supported keys. If the given\nspecification parameter does not exist, this function\nwill raise. Returns `nil` if the application is not loaded.","ref":"Application.html#spec/2"},{"type":"function","title":"Application.start/2","doc":"Starts the given `app` with `t:restart_type/0`.\n\nIf the `app` is not loaded, the application will first be loaded using `load/1`.\nAny included application, defined in the `:included_applications` key of the\n`.app` file will also be loaded, but they won't be started.\n\nFurthermore, all applications listed in the `:applications` key must be explicitly\nstarted before this application is. If not, `{:error, {:not_started, app}}` is\nreturned, where `app` is the name of the missing application.\n\nIn case you want to automatically load **and start** all of `app`'s dependencies,\nsee `ensure_all_started/2`.","ref":"Application.html#start/2"},{"type":"callback","title":"Application.start/2","doc":"Called when an application is started.\n\nThis function is called when an application is started using\n`Application.start/2` (and functions on top of that, such as\n`Application.ensure_started/2`). This function should start the top-level\nprocess of the application (which should be the top supervisor of the\napplication's supervision tree if the application follows the OTP design\nprinciples around supervision).\n\n`start_type` defines how the application is started:\n\n  * `:normal` - used if the startup is a normal startup or if the application\n    is distributed and is started on the current node because of a failover\n    from another node and the application specification key `:start_phases`\n    is `:undefined`.\n  * `{:takeover, node}` - used if the application is distributed and is\n    started on the current node because of a failover on the node `node`.\n  * `{:failover, node}` - used if the application is distributed and is\n    started on the current node because of a failover on node `node`, and the\n    application specification key `:start_phases` is not `:undefined`.\n\n`start_args` are the arguments passed to the application in the `:mod`\nspecification key (for example, `mod: {MyApp, [:my_args]}`).\n\nThis function should either return `{:ok, pid}` or `{:ok, pid, state}` if\nstartup is successful. `pid` should be the PID of the top supervisor. `state`\ncan be an arbitrary term, and if omitted will default to `[]`; if the\napplication is later stopped, `state` is passed to the `stop/1` callback (see\nthe documentation for the `c:stop/1` callback for more information).\n\n`use Application` provides no default implementation for the `start/2`\ncallback.","ref":"Application.html#c:start/2"},{"type":"callback","title":"Application.start_phase/3","doc":"Starts an application in synchronous phases.\n\nThis function is called after `start/2` finishes but before\n`Application.start/2` returns. It will be called once for every start phase\ndefined in the application's (and any included applications') specification,\nin the order they are listed in.","ref":"Application.html#c:start_phase/3"},{"type":"type","title":"Application.start_type/0","doc":"","ref":"Application.html#t:start_type/0"},{"type":"function","title":"Application.started_applications/1","doc":"Returns a list with information about the applications which are currently running.","ref":"Application.html#started_applications/1"},{"type":"type","title":"Application.state/0","doc":"","ref":"Application.html#t:state/0"},{"type":"function","title":"Application.stop/1","doc":"Stops the given `app`.\n\nWhen stopped, the application is still loaded.","ref":"Application.html#stop/1"},{"type":"callback","title":"Application.stop/1","doc":"Called after an application has been stopped.\n\nThis function is called after an application has been stopped, i.e., after its\nsupervision tree has been stopped. It should do the opposite of what the\n`c:start/2` callback did, and should perform any necessary cleanup. The return\nvalue of this callback is ignored.\n\n`state` is the state returned by `c:start/2`, if it did, or `[]` otherwise.\nIf the optional callback `c:prep_stop/1` is present, `state` is its return\nvalue instead.\n\n`use Application` defines a default implementation of this function which does\nnothing and just returns `:ok`.","ref":"Application.html#c:stop/1"},{"type":"function","title":"Application.unload/1","doc":"Unloads the given `app`.\n\nIt will also unload all `:included_applications`.\nNote that the function does not purge the application modules.","ref":"Application.html#unload/1"},{"type":"type","title":"Application.value/0","doc":"","ref":"Application.html#t:value/0"},{"type":"module","title":"Config","doc":"A simple keyword-based configuration API.","ref":"Config.html"},{"type":"module","title":"Example - Config","doc":"This module is most commonly used to define application configuration,\ntypically in `config/config.exs`:\n\n    import Config\n\n    config :some_app,\n      key1: \"value1\",\n      key2: \"value2\"\n\n    import_config \"#{config_env()}.exs\"\n\n`import Config` will import the functions `config/2`, `config/3`\n`config_env/0`, `config_target/0`, and `import_config/1`\nto help you manage your configuration.\n\n`config/2` and `config/3` are used to define key-value configuration\nfor a given application. Once Mix starts, it will automatically\nevaluate the configuration file and persist the configuration above\ninto `:some_app`'s application environment, which can be accessed in\nas follows:\n\n    \"value1\" = Application.fetch_env!(:some_app, :key1)\n\nFinally, the line `import_config \"#{config_env()}.exs\"` will import\nother config files based on the current configuration environment,\nsuch as `config/dev.exs` and `config/test.exs`.\n\n`Config` also provides a low-level API for evaluating and reading\nconfiguration, under the `Config.Reader` module.\n\n> #### Avoid application environment in libraries {: .info}\n>\n> If you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. Also note that\n> the `config/config.exs` of a library is not evaluated when the library is\n> used as a dependency, as configuration is always meant to configure the\n> current project. For more information, read our [library guidelines](library-guidelines.md).","ref":"Config.html#module-example"},{"type":"module","title":"Migrating from `use Mix.Config` - Config","doc":"The `Config` module in Elixir was introduced in v1.9 as a replacement to\n`use Mix.Config`, which was specific to Mix and has been deprecated.\n\nYou can leverage `Config` instead of `use Mix.Config` in three steps. The first\nstep is to replace `use Mix.Config` at the top of your config files by\n`import Config`.\n\nThe second is to make sure your `import_config/1` calls do not have a\nwildcard character. If so, you need to perform the wildcard lookup\nmanually. For example, if you did:\n\n    import_config \"../apps/*/config/config.exs\"\n\nIt has to be replaced by:\n\n    for config <- \"../apps/*/config/config.exs\" |> Path.expand(__DIR__) |> Path.wildcard() do\n      import_config config\n    end\n\nThe last step is to replace all `Mix.env()` calls in the config files with `config_env()`.\n\nKeep in mind you must also avoid using `Mix.env()` inside your project files.\nTo check the environment at _runtime_, you may add a configuration key:\n\n    # config.exs\n    ...\n    config :my_app, env: config_env()\n\nThen, in other scripts and modules, you may get the environment with\n`Application.fetch_env!/2`:\n\n    # router.exs\n    ...\n    if Application.fetch_env!(:my_app, :env) == :prod do\n      ...\n    end\n\nThe only places where you may access functions from the `Mix` module are\nthe `mix.exs` file and inside custom Mix tasks, which are always within\nthe `Mix.Tasks` namespace.\n\n## `config/runtime.exs`\n\nFor runtime configuration, you can use the `config/runtime.exs` file.\nIt is executed right before applications start in both Mix and releases\n(assembled with `mix release`).","ref":"Config.html#module-migrating-from-use-mix-config"},{"type":"function","title":"Config.config/2","doc":"Configures the given `root_key`.\n\nKeyword lists are always deep-merged.","ref":"Config.html#config/2"},{"type":"function","title":"Examples - Config.config/2","doc":"The given `opts` are merged into the existing configuration\nfor the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`, unless they are keywords, which are\ndeep merged recursively. For example, the application configuration\nbelow\n\n    config :logger,\n      level: :warn,\n      backends: [:console]\n\n    config :logger,\n      level: :info,\n      truncate: 1024\n\nwill have a final configuration for `:logger` of:\n\n    [level: :info, backends: [:console], truncate: 1024]","ref":"Config.html#config/2-examples"},{"type":"function","title":"Config.config/3","doc":"Configures the given `key` for the given `root_key`.\n\nKeyword lists are always deep merged.","ref":"Config.html#config/3"},{"type":"function","title":"Examples - Config.config/3","doc":"The given `opts` are merged into the existing values for `key`\nin the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`, unless they are keywords, which are\ndeep merged recursively. For example, the application configuration\nbelow\n\n    config :ecto, Repo,\n      log_level: :warn,\n      adapter: Ecto.Adapters.Postgres,\n      metadata: [read_only: true]\n\n    config :ecto, Repo,\n      log_level: :info,\n      pool_size: 10,\n      metadata: [replica: true]\n\nwill have a final value of the configuration for the `Repo`\nkey in the `:ecto` application of:\n\n    Application.get_env(:ecto, Repo)\n    #=> [\n    #=>   log_level: :info,\n    #=>   pool_size: 10,\n    #=>   adapter: Ecto.Adapters.Postgres,\n    #=>   metadata: [read_only: true, replica: true]\n    #=> ]","ref":"Config.html#config/3-examples"},{"type":"macro","title":"Config.config_env/0","doc":"Returns the environment this configuration file is executed on.\n\nIn Mix projects this function returns the environment this configuration\nfile is executed on. In releases, the environment when `mix release` ran.\n\nThis is most often used to execute conditional code:\n\n    if config_env() == :prod do\n      config :my_app, :debug, false\n    end","ref":"Config.html#config_env/0"},{"type":"macro","title":"Config.config_target/0","doc":"Returns the target this configuration file is executed on.\n\nThis is most often used to execute conditional code:\n\n    if config_target() == :host do\n      config :my_app, :debug, false\n    end","ref":"Config.html#config_target/0"},{"type":"macro","title":"Config.import_config/1","doc":"Imports configuration from the given file.\n\nIn case the file doesn't exist, an error is raised.\n\nIf file is a relative, it will be expanded relatively to the\ndirectory the current configuration file is in.","ref":"Config.html#import_config/1"},{"type":"macro","title":"Examples - Config.import_config/1","doc":"This is often used to emulate configuration across environments:\n\n    import_config \"#{config_env()}.exs\"\n\nNote, however, some configuration files, such as `config/runtime.exs`\ndoes not support imports, as they are meant to be copied across\nsystems.","ref":"Config.html#import_config/1-examples"},{"type":"behaviour","title":"Config.Provider","doc":"Specifies a provider API that loads configuration during boot.\n\nConfig providers are typically used during releases to load\nexternal configuration while the system boots. This is done\nby starting the VM with the minimum amount of applications\nrunning, then invoking all of the providers, and then\nrestarting the system. This requires a mutable configuration\nfile on disk, as the results of the providers are written to\nthe file system. For more information on runtime configuration,\nsee `mix release`.","ref":"Config.Provider.html"},{"type":"behaviour","title":"Multiple config files - Config.Provider","doc":"One common use of config providers is to specify multiple\nconfiguration files in a release. Elixir ships with one provider,\ncalled `Config.Reader`, which is capable of handling Elixir's\nbuilt-in config files.\n\nFor example, imagine you want to list some basic configuration\non Mix's built-in `config/runtime.exs` file, but you also want\nto support additional configuration files. To do so, you can add\nthis inside the `def project` portion of  your `mix.exs`:\n\n    releases: [\n      demo: [\n        config_providers: [\n          {Config.Reader, {:system, \"RELEASE_ROOT\", \"/extra_config.exs\"}}\n        ]\n      ]\n    ]\n\nYou can place this `extra_config.exs` file in your release in\nmultiple ways:\n\n  1. If it is available on the host when assembling the release,\n    you can place it on \"rel/overlays/extra_config.exs\" and it\n    will be automatically copied to the release root\n\n  2. If it is available on the target during deployment, you can\n    simply copy it to the release root as a step in your deployment\n\nNow once the system boots, it will load both `config/runtime.exs`\nand `extra_config.exs` early in the boot process. You can learn\nmore options on `Config.Reader`.","ref":"Config.Provider.html#module-multiple-config-files"},{"type":"behaviour","title":"Custom config provider - Config.Provider","doc":"You can also implement custom config providers, similar to how\n`Config.Reader` works. For example, imagine you need to load\nsome configuration from a JSON file and load that into the system.\nSaid configuration provider would look like:\n\n    defmodule JSONConfigProvider do\n      @behaviour Config.Provider\n\n      # Let's pass the path to the JSON file as config\n      @impl true\n      def init(path) when is_binary(path), do: path\n\n      @impl true\n      def load(config, path) do\n        # We need to start any app we may depend on.\n        {:ok, _} = Application.ensure_all_started(:jason)\n\n        json = path |> File.read!() |> Jason.decode!()\n\n        Config.Reader.merge(\n          config,\n          my_app: [\n            some_value: json[\"my_app_some_value\"],\n            another_value: json[\"my_app_another_value\"],\n          ]\n        )\n      end\n    end\n\nThen, when specifying your release, you can specify the provider in\nthe release configuration:\n\n    releases: [\n      demo: [\n        config_providers: [\n          {JSONConfigProvider, \"/etc/config.json\"}\n        ]\n      ]\n    ]","ref":"Config.Provider.html#module-custom-config-provider"},{"type":"type","title":"Config.Provider.config/0","doc":"","ref":"Config.Provider.html#t:config/0"},{"type":"type","title":"Config.Provider.config_path/0","doc":"A path pointing to a configuration file.\n\nSince configuration files are often accessed on target machines,\nit can be expressed either as:\n\n  * a binary representing an absolute path\n\n  * a `{:system, system_var, path}` tuple where the config is the\n    concatenation of the environment variable `system_var` with\n    the given `path`","ref":"Config.Provider.html#t:config_path/0"},{"type":"callback","title":"Config.Provider.init/1","doc":"Invoked when initializing a config provider.\n\nA config provider is typically initialized on the machine\nwhere the system is assembled and not on the target machine.\nThe `c:init/1` callback is useful to verify the arguments\ngiven to the provider and prepare the state that will be\ngiven to `c:load/2`.\n\nFurthermore, because the state returned by `c:init/1` can\nbe written to text-based config files, it should be\nrestricted only to simple data types, such as integers,\nstrings, atoms, tuples, maps, and lists. Entries such as\nPIDs, references, and functions cannot be serialized.","ref":"Config.Provider.html#c:init/1"},{"type":"callback","title":"Config.Provider.load/2","doc":"Loads configuration (typically during system boot).\n\nIt receives the current `config` and the `state` returned by\n`c:init/1`. Then, you typically read the extra configuration\nfrom an external source and merge it into the received `config`.\nMerging should be done with `Config.Reader.merge/2`, as it\nperforms deep merge. It should return the updated config.\n\nNote that `c:load/2` is typically invoked very early in the\nboot process, therefore if you need to use an application\nin the provider, it is your responsibility to start it.","ref":"Config.Provider.html#c:load/2"},{"type":"function","title":"Config.Provider.resolve_config_path!/1","doc":"Resolves a `t:config_path/0` to an actual path.","ref":"Config.Provider.html#resolve_config_path!/1"},{"type":"type","title":"Config.Provider.state/0","doc":"","ref":"Config.Provider.html#t:state/0"},{"type":"function","title":"Config.Provider.validate_config_path!/1","doc":"Validates a `t:config_path/0`.","ref":"Config.Provider.html#validate_config_path!/1"},{"type":"module","title":"Config.Reader","doc":"API for reading config files defined with `Config`.","ref":"Config.Reader.html"},{"type":"module","title":"As a provider - Config.Reader","doc":"`Config.Reader` can also be used as a `Config.Provider`. A config\nprovider is used during releases to customize how applications are\nconfigured. When used as a provider, it expects a single argument:\nthe configuration path (as outlined in `t:Config.Provider.config_path/0`)\nfor the file to be read and loaded during the system boot.\n\nFor example, if you expect the target system to have a config file\nin an absolute path, you can add this inside the `def project` portion\nof  your `mix.exs`:\n\n    releases: [\n      demo: [\n        config_providers: [\n          {Config.Reader, \"/etc/config.exs\"}\n        ]\n      ]\n    ]\n\nOr if you want to read a custom path inside the release:\n\n    config_providers: [{Config.Reader, {:system, \"RELEASE_ROOT\", \"/config.exs\"}}]\n\nYou can also pass a keyword list of options to the reader,\nwhere the `:path` is a required key:\n\n    config_providers: [\n      {Config.Reader,\n       path: \"/etc/config.exs\",\n       env: :prod,\n       imports: :disabled}\n    ]\n\nRemember Mix already loads `config/runtime.exs` by default.\nFor more examples and scenarios, see the `Config.Provider` module.","ref":"Config.Reader.html#module-as-a-provider"},{"type":"function","title":"Config.Reader.eval!/3","doc":"Evaluates the configuration `contents` for the given `file`.\n\nAccepts the same options as `read!/2`.","ref":"Config.Reader.html#eval!/3"},{"type":"function","title":"Config.Reader.merge/2","doc":"Merges two configurations.\n\nThe configurations are merged together with the values in\nthe second one having higher preference than the first in\ncase of conflicts. In case both values are set to keyword\nlists, it deep merges them.","ref":"Config.Reader.html#merge/2"},{"type":"function","title":"Examples - Config.Reader.merge/2","doc":"iex> Config.Reader.merge([app: [k: :v1]], [app: [k: :v2]])\n    [app: [k: :v2]]\n\n    iex> Config.Reader.merge([app: [k: [v1: 1, v2: 2]]], [app: [k: [v2: :a, v3: :b]]])\n    [app: [k: [v1: 1, v2: :a, v3: :b]]]\n\n    iex> Config.Reader.merge([app1: []], [app2: []])\n    [app1: [], app2: []]","ref":"Config.Reader.html#merge/2-examples"},{"type":"function","title":"Config.Reader.read!/2","doc":"Reads the configuration file.","ref":"Config.Reader.html#read!/2"},{"type":"function","title":"Options - Config.Reader.read!/2","doc":"* `:imports` - a list of already imported paths or `:disabled`\n    to disable imports\n\n  * `:env` - the environment the configuration file runs on.\n    See `Config.config_env/0` for sample usage\n\n  * `:target` - the target the configuration file runs on.\n    See `Config.config_target/0` for sample usage","ref":"Config.Reader.html#read!/2-options"},{"type":"function","title":"Config.Reader.read_imports!/2","doc":"Reads the given configuration file and returns the configuration\nwith its imports.\n\nAccepts the same options as `read!/2`. Although note the `:imports`\noption cannot be disabled in `read_imports!/2`.","ref":"Config.Reader.html#read_imports!/2"},{"type":"behaviour","title":"DynamicSupervisor","doc":"A supervisor optimized to only start children dynamically.\n\nThe `Supervisor` module was designed to handle mostly static children\nthat are started in the given order when the supervisor starts. A\n`DynamicSupervisor` starts with no children. Instead, children are\nstarted on demand via `start_child/2` and there is no ordering between\nchildren. This allows the `DynamicSupervisor` to hold millions of\nchildren by using efficient data structures and to execute certain\noperations, such as shutting down, concurrently.","ref":"DynamicSupervisor.html"},{"type":"behaviour","title":"Examples - DynamicSupervisor","doc":"A dynamic supervisor is started with no children and often a name:\n\n    children = [\n      {DynamicSupervisor, name: MyApp.DynamicSupervisor, strategy: :one_for_one}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe options given in the child specification are documented in `start_link/1`.\n\nOnce the dynamic supervisor is running, we can use it to start children\non demand. Given this sample `GenServer`:\n\n    defmodule Counter do\n      use GenServer\n\n      def start_link(initial) do\n        GenServer.start_link(__MODULE__, initial)\n      end\n\n      def inc(pid) do\n        GenServer.call(pid, :inc)\n      end\n\n      def init(initial) do\n        {:ok, initial}\n      end\n\n      def handle_call(:inc, _, count) do\n        {:reply, count, count + 1}\n      end\n    end\n\nWe can use `start_child/2` with a child specification to start a `Counter`\nserver:\n\n    {:ok, counter1} = DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Counter, 0})\n    Counter.inc(counter1)\n    #=> 0\n\n    {:ok, counter2} = DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Counter, 10})\n    Counter.inc(counter2)\n    #=> 10\n\n    DynamicSupervisor.count_children(MyApp.DynamicSupervisor)\n    #=> %{active: 2, specs: 2, supervisors: 0, workers: 2}","ref":"DynamicSupervisor.html#module-examples"},{"type":"behaviour","title":"Scalability and partitioning - DynamicSupervisor","doc":"The `DynamicSupervisor` is a single process responsible for starting\nother processes. In some applications, the `DynamicSupervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `DynamicSupervisor` and then pick a \"random\" instance to start\nthe child on.\n\nInstead of:\n\n    children = [\n      {DynamicSupervisor, name: MyApp.DynamicSupervisor}\n    ]\n\nand:\n\n    DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Counter, 0})\n\nYou can do this:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: DynamicSupervisor,\n       name: MyApp.DynamicSupervisors}\n    ]\n\nand then:\n\n    DynamicSupervisor.start_child(\n      {:via, PartitionSupervisor, {MyApp.DynamicSupervisors, self()}},\n      {Counter, 0}\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `DynamicSupervisor` by name, you call it through the\npartition supervisor, using `self()` as the routing key. This means each\nprocess will be assigned one of the existing dynamic supervisors.\nRead the `PartitionSupervisor` docs for more information.","ref":"DynamicSupervisor.html#module-scalability-and-partitioning"},{"type":"behaviour","title":"Module-based supervisors - DynamicSupervisor","doc":"Similar to `Supervisor`, dynamic supervisors also support module-based\nsupervisors.\n\n    defmodule MyApp.DynamicSupervisor do\n      # Automatically defines child_spec/1\n      use DynamicSupervisor\n\n      def start_link(init_arg) do\n        DynamicSupervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      @impl true\n      def init(_init_arg) do\n        DynamicSupervisor.init(strategy: :one_for_one)\n      end\n    end\n\nSee the `Supervisor` docs for a discussion of when you may want to use\nmodule-based supervisors. A `@doc` annotation immediately preceding\n`use DynamicSupervisor` will be attached to the generated `child_spec/1`\nfunction.\n\n> #### `use DynamicSupervisor` {: .info}\n>\n> When you `use DynamicSupervisor`, the `DynamicSupervisor` module will\n> set `@behaviour DynamicSupervisor` and define a `child_spec/1`\n> function, so your module can be used as a child in a supervision tree.","ref":"DynamicSupervisor.html#module-module-based-supervisors"},{"type":"behaviour","title":"Name registration - DynamicSupervisor","doc":"A supervisor is bound to the same name registration rules as a `GenServer`.\nRead more about these rules in the documentation for `GenServer`.","ref":"DynamicSupervisor.html#module-name-registration"},{"type":"behaviour","title":"Migrating from Supervisor's :simple_one_for_one - DynamicSupervisor","doc":"In case you were using the deprecated `:simple_one_for_one` strategy from\nthe `Supervisor` module, you can migrate to the `DynamicSupervisor` in\nfew steps.\n\nImagine the given \"old\" code:\n\n    defmodule MySupervisor do\n      use Supervisor\n\n      def start_link(init_arg) do\n        Supervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      def start_child(foo, bar, baz) do\n        # This will start child by calling MyWorker.start_link(init_arg, foo, bar, baz)\n        Supervisor.start_child(__MODULE__, [foo, bar, baz])\n      end\n\n      @impl true\n      def init(init_arg) do\n        children = [\n          # Or the deprecated: worker(MyWorker, [init_arg])\n          %{id: MyWorker, start: {MyWorker, :start_link, [init_arg]}}\n        ]\n\n        Supervisor.init(children, strategy: :simple_one_for_one)\n      end\n    end\n\nIt can be upgraded to the DynamicSupervisor like this:\n\n    defmodule MySupervisor do\n      use DynamicSupervisor\n\n      def start_link(init_arg) do\n        DynamicSupervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      def start_child(foo, bar, baz) do\n        # If MyWorker is not using the new child specs, we need to pass a map:\n        # spec = %{id: MyWorker, start: {MyWorker, :start_link, [foo, bar, baz]}}\n        spec = {MyWorker, foo: foo, bar: bar, baz: baz}\n        DynamicSupervisor.start_child(__MODULE__, spec)\n      end\n\n      @impl true\n      def init(init_arg) do\n        DynamicSupervisor.init(\n          strategy: :one_for_one,\n          extra_arguments: [init_arg]\n        )\n      end\n    end\n\nThe difference is that the `DynamicSupervisor` expects the child specification\nat the moment `start_child/2` is called, and no longer on the init callback.\nIf there are any initial arguments given on initialization, such as `[initial_arg]`,\nit can be given in the `:extra_arguments` flag on `DynamicSupervisor.init/1`.","ref":"DynamicSupervisor.html#module-migrating-from-supervisor-s-simple_one_for_one"},{"type":"function","title":"DynamicSupervisor.child_spec/1","doc":"Returns a specification to start a dynamic supervisor under a supervisor.\n\nIt accepts the same options as `start_link/1`.\n\nSee `Supervisor` for more information about child specifications.","ref":"DynamicSupervisor.html#child_spec/1"},{"type":"function","title":"DynamicSupervisor.count_children/1","doc":"Returns a map containing count values for the supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the number of children processes\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not the child\n    process is still alive\n\n  * `:workers` - the count of all workers, whether or not the child process\n    is still alive","ref":"DynamicSupervisor.html#count_children/1"},{"type":"function","title":"DynamicSupervisor.init/1","doc":"Receives a set of `options` that initializes a dynamic supervisor.\n\nThis is typically invoked at the end of the `c:init/1` callback of\nmodule-based supervisors. See the \"Module-based supervisors\" section\nin the module documentation for more information.\n\nIt accepts the same `options` as `start_link/1` (except for `:name`)\nand it returns a tuple containing the supervisor options.","ref":"DynamicSupervisor.html#init/1"},{"type":"function","title":"Examples - DynamicSupervisor.init/1","doc":"def init(_arg) do\n      DynamicSupervisor.init(max_children: 1000)\n    end","ref":"DynamicSupervisor.html#init/1-examples"},{"type":"callback","title":"DynamicSupervisor.init/1","doc":"Callback invoked to start the supervisor and during hot code upgrades.\n\nDevelopers typically invoke `DynamicSupervisor.init/1` at the end of\ntheir init callback to return the proper supervision flags.","ref":"DynamicSupervisor.html#c:init/1"},{"type":"type","title":"DynamicSupervisor.init_option/0","doc":"Options given to `start_link` and `init/1` functions","ref":"DynamicSupervisor.html#t:init_option/0"},{"type":"type","title":"DynamicSupervisor.on_start_child/0","doc":"Return values of `start_child` functions","ref":"DynamicSupervisor.html#t:on_start_child/0"},{"type":"type","title":"DynamicSupervisor.option/0","doc":"Options given to `start_link` functions","ref":"DynamicSupervisor.html#t:option/0"},{"type":"function","title":"DynamicSupervisor.start_child/2","doc":"Dynamically adds a child specification to `supervisor` and starts that child.\n\n`child_spec` should be a valid child specification as detailed in the\n\"Child specification\" section of the documentation for `Supervisor`. The child\nprocess will be started as defined in the child specification. Note that while\nthe `:id` field is still required in the spec, the value is ignored and\ntherefore does not need to be unique.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child,\ninfo}`, then child specification and PID are added to the supervisor and\nthis function returns the same value.\n\nIf the child process start function returns `:ignore`, then no child is added\nto the supervision tree and this function returns `:ignore` too.\n\nIf the child process start function returns an error tuple or an erroneous\nvalue, or if it fails, the child specification is discarded and this function\nreturns `{:error, error}` where `error` is the error or erroneous value\nreturned from child process start function, or failure reason if it fails.\n\nIf the supervisor already has N children in a way that N exceeds the amount\nof `:max_children` set on the supervisor initialization (see `init/1`), then\nthis function returns `{:error, :max_children}`.","ref":"DynamicSupervisor.html#start_child/2"},{"type":"function","title":"DynamicSupervisor.start_link/1","doc":"Starts a supervisor with the given options.\n\nThis function is typically not invoked directly, instead it is invoked\nwhen using a `DynamicSupervisor` as a child of another supervisor:\n\n    children = [\n      {DynamicSupervisor, name: MySupervisor}\n    ]\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.","ref":"DynamicSupervisor.html#start_link/1"},{"type":"function","title":"Options - DynamicSupervisor.start_link/1","doc":"* `:name` - registers the supervisor under the given name.\n    The supported values are described under the \"Name registration\"\n    section in the `GenServer` module docs.\n\n  * `:strategy` - the restart strategy option. The only supported\n    value is `:one_for_one` which means that no other child is\n    terminated if a child process terminates. You can learn more\n    about strategies in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:max_children` - the maximum amount of children to be running\n    under this supervisor at the same time. When `:max_children` is\n    exceeded, `start_child/2` returns `{:error, :max_children}`. Defaults\n    to `:infinity`.\n\n  * `:extra_arguments` - arguments that are prepended to the arguments\n    specified in the child spec given to `start_child/2`. Defaults to\n    an empty list.","ref":"DynamicSupervisor.html#start_link/1-options"},{"type":"function","title":"DynamicSupervisor.start_link/3","doc":"Starts a module-based supervisor process with the given `module` and `init_arg`.\n\nTo start the supervisor, the `c:init/1` callback will be invoked in the given\n`module`, with `init_arg` as its argument. The `c:init/1` callback must return a\nsupervisor specification which can be created with the help of the `init/1`\nfunction.\n\nIf the `c:init/1` callback returns `:ignore`, this function returns\n`:ignore` as well and the supervisor terminates with reason `:normal`.\nIf it fails or returns an incorrect value, this function returns\n`{:error, term}` where `term` is a term with information about the\nerror, and the supervisor terminates with reason `term`.\n\nThe `:name` option can also be given in order to register a supervisor\nname, the supported values are described in the \"Name registration\"\nsection in the `GenServer` module docs.\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.","ref":"DynamicSupervisor.html#start_link/3"},{"type":"function","title":"DynamicSupervisor.stop/3","doc":"Synchronously stops the given supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.","ref":"DynamicSupervisor.html#stop/3"},{"type":"type","title":"DynamicSupervisor.strategy/0","doc":"Supported strategies","ref":"DynamicSupervisor.html#t:strategy/0"},{"type":"type","title":"DynamicSupervisor.sup_flags/0","doc":"The supervisor flags returned on init","ref":"DynamicSupervisor.html#t:sup_flags/0"},{"type":"function","title":"DynamicSupervisor.terminate_child/2","doc":"Terminates the given child identified by `pid`.\n\nIf successful, this function returns `:ok`. If there is no process with\nthe given PID, this function returns `{:error, :not_found}`.","ref":"DynamicSupervisor.html#terminate_child/2"},{"type":"function","title":"DynamicSupervisor.which_children/1","doc":"Returns a list with information about all children.\n\nNote that calling this function when supervising a large number\nof children under low memory conditions can cause an out of memory\nexception.\n\nThis function returns a list of tuples containing:\n\n  * `id` - it is always `:undefined` for dynamic supervisors\n\n  * `child` - the PID of the corresponding child process or the\n    atom `:restarting` if the process is about to be restarted\n\n  * `type` - `:worker` or `:supervisor` as defined in the child\n    specification\n\n  * `modules` - as defined in the child specification","ref":"DynamicSupervisor.html#which_children/1"},{"type":"behaviour","title":"GenServer","doc":"A behaviour module for implementing the server of a client-server relation.\n\nA GenServer is a process like any other Elixir process and it can be used\nto keep state, execute code asynchronously and so on. The advantage of using\na generic server process (GenServer) implemented using this module is that it\nwill have a standard set of interface functions and include functionality for\ntracing and error reporting. It will also fit into a supervision tree.\n\n```mermaid\ngraph BT\n    C(Client #3) ~~~ B(Client #2) ~~~ A(Client #1)\n    A & B & C -->|request| GenServer\n    GenServer -.->|reply| A & B & C\n```","ref":"GenServer.html"},{"type":"behaviour","title":"Example - GenServer","doc":"The GenServer behaviour abstracts the common client-server interaction.\nDevelopers are only required to implement the callbacks and functionality\nthey are interested in.\n\nLet's start with a code example and then explore the available callbacks.\nImagine we want to implement a service with a GenServer that works\nlike a stack, allowing us to push and pop elements. We'll customize a\ngeneric GenServer with our own module by implementing three callbacks.\n\n`c:init/1` transforms our initial argument to the initial state for the\nGenServer. `c:handle_call/3` fires when the server receives a synchronous\n`pop` message, popping an element from the stack and returning it to the\nuser. `c:handle_cast/2` will fire when the server receives an asynchronous\n`push` message, pushing an element onto the stack:\n\n    defmodule Stack do\n      use GenServer\n\n      # Callbacks\n\n      @impl true\n      def init(elements) do\n        initial_state = String.split(elements, \",\", trim: true)\n        {:ok, initial_state}\n      end\n\n      @impl true\n      def handle_call(:pop, _from, state) do\n        [to_caller | new_state] = state\n        {:reply, to_caller, new_state}\n      end\n\n      @impl true\n      def handle_cast({:push, element}, state) do\n        new_state = [element | state]\n        {:noreply, new_state}\n      end\n    end\n\nWe leave the process machinery of startup, message passing, and the message\nloop to the GenServer behaviour and focus only on the stack\nimplementation. We can now use the GenServer API to interact with\nthe service by creating a process and sending it messages:\n\n    # Start the server\n    {:ok, pid} = GenServer.start_link(Stack, \"hello,world\")\n\n    # This is the client\n    GenServer.call(pid, :pop)\n    #=> \"hello\"\n\n    GenServer.cast(pid, {:push, \"elixir\"})\n    #=> :ok\n\n    GenServer.call(pid, :pop)\n    #=> \"elixir\"\n\nWe start our `Stack` by calling `start_link/2`, passing the module\nwith the server implementation and its initial argument with a\ncomma-separated list of elements. The GenServer behaviour calls the\n`c:init/1` callback to establish the initial GenServer state. From\nthis point on, the GenServer has control so we interact with it by\nsending two types of messages on the client. **call** messages expect\na reply from the server (and are therefore synchronous) while **cast**\nmessages do not.\n\nEach call to `GenServer.call/3` results in a message\nthat must be handled by the `c:handle_call/3` callback in the GenServer.\nA `cast/2` message must be handled by `c:handle_cast/2`. `GenServer`\nsupports 8 callbacks, but only `c:init/1` is required.\n\n> #### `use GenServer` {: .info}\n>\n> When you `use GenServer`, the `GenServer` module will\n> set `@behaviour GenServer` and define a `child_spec/1`\n> function, so your module can be used as a child\n> in a supervision tree.","ref":"GenServer.html#module-example"},{"type":"behaviour","title":"Client / Server APIs - GenServer","doc":"Although in the example above we have used `GenServer.start_link/3` and\nfriends to directly start and communicate with the server, most of the\ntime we don't call the `GenServer` functions directly. Instead, we wrap\nthe calls in new functions representing the public API of the server.\nThese thin wrappers are called the **client API**.\n\nHere is a better implementation of our Stack module:\n\n    defmodule Stack do\n      use GenServer\n\n      # Client\n\n      def start_link(default) when is_binary(default) do\n        GenServer.start_link(__MODULE__, default)\n      end\n\n      def push(pid, element) do\n        GenServer.cast(pid, {:push, element})\n      end\n\n      def pop(pid) do\n        GenServer.call(pid, :pop)\n      end\n\n      # Server (callbacks)\n\n      @impl true\n      def init(elements) do\n        initial_state = String.split(elements, \",\", trim: true)\n        {:ok, initial_state}\n      end\n\n      @impl true\n      def handle_call(:pop, _from, state) do\n        [to_caller | new_state] = state\n        {:reply, to_caller, new_state}\n      end\n\n      @impl true\n      def handle_cast({:push, element}, state) do\n        new_state = [element | state]\n        {:noreply, new_state}\n      end\n    end\n\nIn practice, it is common to have both server and client functions in\nthe same module. If the server and/or client implementations are growing\ncomplex, you may want to have them in different modules.\n\nThe following diagram summarizes the interactions between client and server.\nBoth Client and Server are processes and communication happens via messages\n(continuous line). The Server <-> Module interaction happens when the\nGenServer process calls your code (dotted lines):\n\n```mermaid\nsequenceDiagram\n    participant C as Client (Process)\n    participant S as Server (Process)\n    participant M as Module (Code)\n\n    note right of C: Typically started by a supervisor\n    C->>+S: GenServer.start_link(module, arg, options)\n    S-->>+M: init(arg)\n    M-->>-S: {:ok, state} | :ignore | {:error, reason}\n    S->>-C: {:ok, pid} | :ignore | {:error, reason}\n\n    note right of C: call is synchronous\n    C->>+S: GenServer.call(pid, message)\n    S-->>+M: handle_call(message, from, state)\n    M-->>-S: {:reply, reply, state} | {:stop, reason, reply, state}\n    S->>-C: reply\n\n    note right of C: cast is asynchronous\n    C-)S: GenServer.cast(pid, message)\n    S-->>+M: handle_cast(message, state)\n    M-->>-S: {:noreply, state} | {:stop, reason, state}\n\n    note right of C: send is asynchronous\n    C-)S: Kernel.send(pid, message)\n    S-->>+M: handle_info(message, state)\n    M-->>-S: {:noreply, state} | {:stop, reason, state}\n```","ref":"GenServer.html#module-client-server-apis"},{"type":"behaviour","title":"How to supervise - GenServer","doc":"A `GenServer` is most commonly started under a supervision tree.\nWhen we invoke `use GenServer`, it automatically defines a `child_spec/1`\nfunction that allows us to start the `Stack` directly under a supervisor.\nTo start a default stack of `[\"hello\", \"world\"]` under a supervisor,\nwe can do:\n\n    children = [\n      {Stack, \"hello,world\"}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nNote that specifying a module `MyServer` would be the same as specifying\nthe  tuple `{MyServer, []}`.\n\n`use GenServer` also accepts a list of options which configures the\nchild specification and therefore how it runs under a supervisor.\nThe generated `child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:permanent`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nFor example:\n\n    use GenServer, restart: :transient, shutdown: 10_000\n\nSee the \"Child specification\" section in the `Supervisor` module for more\ndetailed information. The `@doc` annotation immediately preceding\n`use GenServer` will be attached to the generated `child_spec/1` function.\n\nWhen stopping the GenServer, for example by returning a `{:stop, reason, new_state}`\ntuple from a callback, the exit reason is used by the supervisor to determine\nwhether the GenServer needs to be restarted. See the \"Exit reasons and restarts\"\nsection in the `Supervisor` module.","ref":"GenServer.html#module-how-to-supervise"},{"type":"behaviour","title":"Name registration - GenServer","doc":"Both `start_link/3` and `start/3` support the `GenServer` to register\na name on start via the `:name` option. Registered names are also\nautomatically cleaned up on termination. The supported values are:\n\n  * an atom - the GenServer is registered locally (to the current node)\n    with the given name using `Process.register/2`.\n\n  * `{:global, term}` - the GenServer is registered globally with the given\n    term using the functions in the [`:global` module](`:global`).\n\n  * `{:via, module, term}` - the GenServer is registered with the given\n    mechanism and name. The `:via` option expects a module that exports\n    `register_name/2`, `unregister_name/1`, `whereis_name/1` and `send/2`.\n    One such example is the [`:global` module](`:global`) which uses these functions\n    for keeping the list of names of processes and their associated PIDs\n    that are available globally for a network of Elixir nodes. Elixir also\n    ships with a local, decentralized and scalable registry called `Registry`\n    for locally storing names that are generated dynamically.\n\nFor example, we could start and register our `Stack` server locally as follows:\n\n    # Start the server and register it locally with name MyStack\n    {:ok, _} = GenServer.start_link(Stack, \"hello\", name: MyStack)\n\n    # Now messages can be sent directly to MyStack\n    GenServer.call(MyStack, :pop)\n    #=> \"hello\"\n\nOnce the server is started, the remaining functions in this module (`call/3`,\n`cast/2`, and friends) will also accept an atom, or any `{:global, ...}` or\n`{:via, ...}` tuples. In general, the following formats are supported:\n\n  * a PID\n  * an atom if the server is locally registered\n  * `{atom, node}` if the server is locally registered at another node\n  * `{:global, term}` if the server is globally registered\n  * `{:via, module, name}` if the server is registered through an alternative\n    registry\n\nIf there is an interest to register dynamic names locally, do not use\natoms, as atoms are never garbage-collected and therefore dynamically\ngenerated atoms won't be garbage-collected. For such cases, you can\nset up your own local registry by using the `Registry` module.","ref":"GenServer.html#module-name-registration"},{"type":"behaviour","title":"Receiving \"regular\" messages - GenServer","doc":"The goal of a `GenServer` is to abstract the \"receive\" loop for developers,\nautomatically handling system messages, supporting code change, synchronous\ncalls and more. Therefore, you should never call your own \"receive\" inside\nthe GenServer callbacks as doing so will cause the GenServer to misbehave.\n\nBesides the synchronous and asynchronous communication provided by `call/3`\nand `cast/2`, \"regular\" messages sent by functions such as `send/2`,\n`Process.send_after/4` and similar, can be handled inside the `c:handle_info/2`\ncallback.\n\n`c:handle_info/2` can be used in many situations, such as handling monitor\nDOWN messages sent by `Process.monitor/1`. Another use case for `c:handle_info/2`\nis to perform periodic work, with the help of `Process.send_after/4`:\n\n    defmodule MyApp.Periodically do\n      use GenServer\n\n      def start_link(_) do\n        GenServer.start_link(__MODULE__, %{})\n      end\n\n      @impl true\n      def init(state) do\n        # Schedule work to be performed on start\n        schedule_work()\n\n        {:ok, state}\n      end\n\n      @impl true\n      def handle_info(:work, state) do\n        # Do the desired work here\n        # ...\n\n        # Reschedule once more\n        schedule_work()\n\n        {:noreply, state}\n      end\n\n      defp schedule_work do\n        # We schedule the work to happen in 2 hours (written in milliseconds).\n        # Alternatively, one might write :timer.hours(2)\n        Process.send_after(self(), :work, 2 * 60 * 60 * 1000)\n      end\n    end","ref":"GenServer.html#module-receiving-regular-messages"},{"type":"behaviour","title":"Timeouts - GenServer","doc":"The return value of `c:init/1` or any of the `handle_*` callbacks may include\na timeout value in milliseconds; if not, `:infinity` is assumed.\nThe timeout can be used to detect a lull in incoming messages.\n\nThe `timeout()` value is used as follows:\n\n  * If the process has any message already waiting when the `timeout()` value\n    is returned, the timeout is ignored and the waiting message is handled as\n    usual. This means that even a timeout of `0` milliseconds is not guaranteed\n    to execute (if you want to take another action immediately and unconditionally,\n    use a `:continue` instruction instead).\n\n  * If any message arrives before the specified number of milliseconds\n    elapse, the timeout is cleared and that message is handled as usual.\n\n  * Otherwise, when the specified number of milliseconds have elapsed with no\n    message arriving, `handle_info/2` is called with `:timeout` as the first\n    argument.","ref":"GenServer.html#module-timeouts"},{"type":"behaviour","title":"When (not) to use a GenServer - GenServer","doc":"So far, we have learned that a `GenServer` can be used as a supervised process\nthat handles sync and async calls. It can also handle system messages, such as\nperiodic messages and monitoring events. GenServer processes may also be named.\n\nA GenServer, or a process in general, must be used to model runtime characteristics\nof your system. A GenServer must never be used for code organization purposes.\n\nIn Elixir, code organization is done by modules and functions, processes are not\nnecessary. For example, imagine you are implementing a calculator and you decide\nto put all the calculator operations behind a GenServer:\n\n    def add(a, b) do\n      GenServer.call(__MODULE__, {:add, a, b})\n    end\n\n    def subtract(a, b) do\n      GenServer.call(__MODULE__, {:subtract, a, b})\n    end\n\n    def handle_call({:add, a, b}, _from, state) do\n      {:reply, a + b, state}\n    end\n\n    def handle_call({:subtract, a, b}, _from, state) do\n      {:reply, a - b, state}\n    end\n\nThis is an anti-pattern not only because it convolutes the calculator logic but\nalso because you put the calculator logic behind a single process that will\npotentially become a bottleneck in your system, especially as the number of\ncalls grow. Instead just define the functions directly:\n\n    def add(a, b) do\n      a + b\n    end\n\n    def subtract(a, b) do\n      a - b\n    end\n\nIf you don't need a process, then you don't need a process. Use processes only to\nmodel runtime properties, such as mutable state, concurrency and failures, never\nfor code organization.","ref":"GenServer.html#module-when-not-to-use-a-genserver"},{"type":"behaviour","title":"Debugging with the :sys module - GenServer","doc":"GenServers, as [special processes](https://www.erlang.org/doc/design_principles/spec_proc.html),\ncan be debugged using the [`:sys` module](`:sys`).\nThrough various hooks, this module allows developers to introspect the state of\nthe process and trace system events that happen during its execution, such as\nreceived messages, sent replies and state changes.\n\nLet's explore the basic functions from the\n[`:sys` module](`:sys`) used for debugging:\n\n  * `:sys.get_state/2` - allows retrieval of the state of the process.\n    In the case of a GenServer process, it will be the callback module state,\n    as passed into the callback functions as last argument.\n  * `:sys.get_status/2` - allows retrieval of the status of the process.\n    This status includes the process dictionary, if the process is running\n    or is suspended, the parent PID, the debugger state, and the state of\n    the behaviour module, which includes the callback module state\n    (as returned by `:sys.get_state/2`). It's possible to change how this\n    status is represented by defining the optional `c:GenServer.format_status/1`\n    callback.\n  * `:sys.trace/3` - prints all the system events to `:stdio`.\n  * `:sys.statistics/3` - manages collection of process statistics.\n  * `:sys.no_debug/2` - turns off all debug handlers for the given process.\n    It is very important to switch off debugging once we're done. Excessive\n    debug handlers or those that should be turned off, but weren't, can\n    seriously damage the performance of the system.\n  * `:sys.suspend/2` - allows to suspend a process so that it only\n    replies to system messages but no other messages. A suspended process\n    can be reactivated via `:sys.resume/2`.\n\nLet's see how we could use those functions for debugging the stack server\nwe defined earlier.\n\n    iex> {:ok, pid} = Stack.start_link([])\n    iex> :sys.statistics(pid, true) # turn on collecting process statistics\n    iex> :sys.trace(pid, true) # turn on event printing\n    iex> Stack.push(pid, 1)\n    *DBG* <0.122.0> got cast {push,1}\n    *DBG* <0.122.0> new state [1]\n    :ok\n\n    iex> :sys.get_state(pid)\n    [1]\n\n    iex> Stack.pop(pid)\n    *DBG* <0.122.0> got call pop from <0.80.0>\n    *DBG* <0.122.0> sent 1 to <0.80.0>, new state []\n    1\n\n    iex> :sys.statistics(pid, :get)\n    {:ok,\n     [\n       start_time: {{2016, 7, 16}, {12, 29, 41}},\n       current_time: {{2016, 7, 16}, {12, 29, 50}},\n       reductions: 117,\n       messages_in: 2,\n       messages_out: 0\n     ]}\n\n    iex> :sys.no_debug(pid) # turn off all debug handlers\n    :ok\n\n    iex> :sys.get_status(pid)\n    {:status, #PID<0.122.0>, {:module, :gen_server},\n     [\n       [\n         \"$initial_call\": {Stack, :init, 1},            # process dictionary\n         \"$ancestors\": [#PID<0.80.0>, #PID<0.51.0>]\n       ],\n       :running,                                        # :running | :suspended\n       #PID<0.80.0>,                                    # parent\n       [],                                              # debugger state\n       [\n         header: 'Status for generic server <0.122.0>', # module status\n         data: [\n           {'Status', :running},\n           {'Parent', #PID<0.80.0>},\n           {'Logged events', []}\n         ],\n         data: [{'State', [1]}]\n       ]\n     ]}","ref":"GenServer.html#module-debugging-with-the-sys-module"},{"type":"behaviour","title":"Learn more - GenServer","doc":"If you wish to find out more about GenServers, the Elixir Getting Started\nguide provides a tutorial-like introduction. The documentation and links\nin Erlang can also provide extra insight.\n\n  * [GenServer - Elixir's Getting Started Guide](genservers.md)\n  * [`:gen_server` module documentation](`:gen_server`)\n  * [gen_server Behaviour - OTP Design Principles](https://www.erlang.org/doc/design_principles/gen_server_concepts.html)\n  * [Clients and Servers - Learn You Some Erlang for Great Good!](http://learnyousomeerlang.com/clients-and-servers)","ref":"GenServer.html#module-learn-more"},{"type":"function","title":"GenServer.abcast/3","doc":"Casts all servers locally registered as `name` at the specified nodes.\n\nThis function returns immediately and ignores nodes that do not exist, or where the\nserver name does not exist.\n\nSee `multi_call/4` for more information.","ref":"GenServer.html#abcast/3"},{"type":"function","title":"GenServer.call/3","doc":"Makes a synchronous call to the `server` and waits for its reply.\n\nThe client sends the given `request` to the server and waits until a reply\narrives or a timeout occurs. `c:handle_call/3` will be called on the server\nto handle the request.\n\n`server` can be any of the values described in the \"Name registration\"\nsection of the documentation for this module.","ref":"GenServer.html#call/3"},{"type":"function","title":"Timeouts - GenServer.call/3","doc":"`timeout` is an integer greater than zero which specifies how many\nmilliseconds to wait for a reply, or the atom `:infinity` to wait\nindefinitely. The default value is `5000`. If no reply is received within\nthe specified time, the function call fails and the caller exits. If the\ncaller catches the failure and continues running, and the server is just late\nwith the reply, it may arrive at any time later into the caller's message\nqueue. The caller must in this case be prepared for this and discard any such\ngarbage messages that are two-element tuples with a reference as the first\nelement.","ref":"GenServer.html#call/3-timeouts"},{"type":"function","title":"GenServer.cast/2","doc":"Casts a request to the `server` without waiting for a response.\n\nThis function always returns `:ok` regardless of whether\nthe destination `server` (or node) exists. Therefore it\nis unknown whether the destination `server` successfully\nhandled the request.\n\n`server` can be any of the values described in the \"Name registration\"\nsection of the documentation for this module.","ref":"GenServer.html#cast/2"},{"type":"callback","title":"GenServer.code_change/3","doc":"Invoked to change the state of the `GenServer` when a different version of a\nmodule is loaded (hot code swapping) and the state's term structure should be\nchanged.\n\n`old_vsn` is the previous version of the module (defined by the `@vsn`\nattribute) when upgrading. When downgrading the previous version is wrapped in\na 2-tuple with first element `:down`. `state` is the current state of the\n`GenServer` and `extra` is any extra data required to change the state.\n\nReturning `{:ok, new_state}` changes the state to `new_state` and the code\nchange is successful.\n\nReturning `{:error, reason}` fails the code change with reason `reason` and\nthe state remains as the previous state.\n\nIf `c:code_change/3` raises the code change fails and the loop will continue\nwith its previous state. Therefore this callback does not usually contain side effects.\n\nThis callback is optional.","ref":"GenServer.html#c:code_change/3"},{"type":"type","title":"GenServer.debug/0","doc":"Debug options supported by the `start*` functions","ref":"GenServer.html#t:debug/0"},{"type":"callback","title":"GenServer.format_status/1","doc":"This function is called by a `GenServer` process in the following situations:\n\n  * [`:sys.get_status/1,2`](`:sys.get_status/1`) is invoked to get the `GenServer` status.\n  * The `GenServer` process terminates abnormally and logs an error.\n\nThis callback is used to limit the status of the process returned by\n[`:sys.get_status/1,2`](`:sys.get_status/1`) or sent to logger.\n\nThe callback gets a map `status` describing the current status and shall return\na map `new_status` with the same keys, but it may transform some values.\n\nTwo possible use cases for this callback is to remove sensitive information\nfrom the state to prevent it from being printed in log files, or to compact\nlarge irrelevant status items that would only clutter the logs.","ref":"GenServer.html#c:format_status/1"},{"type":"callback","title":"Example - GenServer.format_status/1","doc":"@impl GenServer\n    def format_status(status) do\n      Map.new(status, fn\n        {:state, state} -> {:state, Map.delete(state, :private_key)}\n        {:message, {:password, _}} -> {:message, {:password, \"redacted\"}}\n        key_value -> key_value\n      end)\n    end","ref":"GenServer.html#c:format_status/1-example"},{"type":"callback","title":"GenServer.format_status/2","doc":"","ref":"GenServer.html#c:format_status/2"},{"type":"type","title":"GenServer.from/0","doc":"Tuple describing the client of a call request.\n\n`pid` is the PID of the caller and `tag` is a unique term used to identify the\ncall.","ref":"GenServer.html#t:from/0"},{"type":"callback","title":"GenServer.handle_call/3","doc":"Invoked to handle synchronous `call/3` messages. `call/3` will block until a\nreply is received (unless the call times out or nodes are disconnected).\n\n`request` is the request message sent by a `call/3`, `from` is a 2-tuple\ncontaining the caller's PID and a term that uniquely identifies the call, and\n`state` is the current state of the `GenServer`.\n\nReturning `{:reply, reply, new_state}` sends the response `reply` to the\ncaller and continues the loop with new state `new_state`.\n\nReturning `{:reply, reply, new_state, timeout}` is similar to\n`{:reply, reply, new_state}` except that it also sets a timeout.\nSee the \"Timeouts\" section in the module documentation for more information.\n\nReturning `{:reply, reply, new_state, :hibernate}` is similar to\n`{:reply, reply, new_state}` except the process is hibernated and will\ncontinue the loop once a message is in its message queue. However, if a message is\nalready in the message queue, the process will continue the loop immediately.\nHibernating a `GenServer` causes garbage collection and leaves a continuous\nheap that minimises the memory used by the process.\n\nHibernating should not be used aggressively as too much time could be spent\ngarbage collecting, which would delay the processing of incoming messages.\nNormally it should only be used when you are not expecting new messages to\nimmediately arrive and minimising the memory of the process is shown to be\nbeneficial.\n\nReturning `{:reply, reply, new_state, {:continue, continue_arg}}` is similar to\n`{:reply, reply, new_state}` except that `c:handle_continue/2` will be invoked\nimmediately after with `continue_arg` as the first argument and\n`state` as the second one.\n\nReturning `{:noreply, new_state}` does not send a response to the caller and\ncontinues the loop with new state `new_state`. The response must be sent with\n`reply/2`.\n\nThere are three main use cases for not replying using the return value:\n\n  * To reply before returning from the callback because the response is known\n    before calling a slow function.\n  * To reply after returning from the callback because the response is not yet\n    available.\n  * To reply from another process, such as a task.\n\nWhen replying from another process the `GenServer` should exit if the other\nprocess exits without replying as the caller will be blocking awaiting a\nreply.\n\nReturning `{:noreply, new_state, timeout | :hibernate | {:continue, continue_arg}}`\nis similar to `{:noreply, new_state}` except a timeout, hibernation or continue\noccurs as with a `:reply` tuple.\n\nReturning `{:stop, reason, reply, new_state}` stops the loop and `c:terminate/2`\nis called with reason `reason` and state `new_state`. Then, the `reply` is sent\nas the response to call and the process exits with reason `reason`.\n\nReturning `{:stop, reason, new_state}` is similar to\n`{:stop, reason, reply, new_state}` except a reply is not sent.\n\nThis callback is optional. If one is not implemented, the server will fail\nif a call is performed against it.","ref":"GenServer.html#c:handle_call/3"},{"type":"callback","title":"GenServer.handle_cast/2","doc":"Invoked to handle asynchronous `cast/2` messages.\n\n`request` is the request message sent by a `cast/2` and `state` is the current\nstate of the `GenServer`.\n\nReturning `{:noreply, new_state}` continues the loop with new state `new_state`.\n\nReturning `{:noreply, new_state, timeout}` is similar to `{:noreply, new_state}`\nexcept that it also sets a timeout. See the \"Timeouts\" section in the module\ndocumentation for more information.\n\nReturning `{:noreply, new_state, :hibernate}` is similar to\n`{:noreply, new_state}` except the process is hibernated before continuing the\nloop. See `c:handle_call/3` for more information.\n\nReturning `{:noreply, new_state, {:continue, continue_arg}}` is similar to\n`{:noreply, new_state}` except `c:handle_continue/2` will be invoked\nimmediately after with `continue_arg` as the first argument and\n`state` as the second one.\n\nReturning `{:stop, reason, new_state}` stops the loop and `c:terminate/2` is\ncalled with the reason `reason` and state `new_state`. The process exits with\nreason `reason`.\n\nThis callback is optional. If one is not implemented, the server will fail\nif a cast is performed against it.","ref":"GenServer.html#c:handle_cast/2"},{"type":"callback","title":"GenServer.handle_continue/2","doc":"Invoked to handle continue instructions.\n\nIt is useful for performing work after initialization or for splitting the work\nin a callback in multiple steps, updating the process state along the way.\n\nReturn values are the same as `c:handle_cast/2`.\n\nThis callback is optional. If one is not implemented, the server will fail\nif a continue instruction is used.","ref":"GenServer.html#c:handle_continue/2"},{"type":"callback","title":"GenServer.handle_info/2","doc":"Invoked to handle all other messages.\n\n`msg` is the message and `state` is the current state of the `GenServer`. When\na timeout occurs the message is `:timeout`.\n\nReturn values are the same as `c:handle_cast/2`.\n\nThis callback is optional. If one is not implemented, the received message\nwill be logged.","ref":"GenServer.html#c:handle_info/2"},{"type":"callback","title":"GenServer.init/1","doc":"Invoked when the server is started. `start_link/3` or `start/3` will\nblock until it returns.\n\n`init_arg` is the argument term (second argument) passed to `start_link/3`.\n\nReturning `{:ok, state}` will cause `start_link/3` to return\n`{:ok, pid}` and the process to enter its loop.\n\nReturning `{:ok, state, timeout}` is similar to `{:ok, state}`,\nexcept that it also sets a timeout. See the \"Timeouts\" section\nin the module documentation for more information.\n\nReturning `{:ok, state, :hibernate}` is similar to `{:ok, state}`\nexcept the process is hibernated before entering the loop. See\n`c:handle_call/3` for more information on hibernation.\n\nReturning `{:ok, state, {:continue, continue_arg}}` is similar to\n`{:ok, state}` except that immediately after entering the loop,\nthe `c:handle_continue/2` callback will be invoked with `continue_arg`\nas the first argument and `state` as the second one.\n\nReturning `:ignore` will cause `start_link/3` to return `:ignore` and\nthe process will exit normally without entering the loop or calling\n`c:terminate/2`. If used when part of a supervision tree the parent\nsupervisor will not fail to start nor immediately try to restart the\n`GenServer`. The remainder of the supervision tree will be started\nand so the `GenServer` should not be required by other processes.\nIt can be started later with `Supervisor.restart_child/2` as the child\nspecification is saved in the parent supervisor. The main use cases for\nthis are:\n\n  * The `GenServer` is disabled by configuration but might be enabled later.\n  * An error occurred and it will be handled by a different mechanism than the\n   `Supervisor`. Likely this approach involves calling `Supervisor.restart_child/2`\n    after a delay to attempt a restart.\n\nReturning `{:stop, reason}` will cause `start_link/3` to return\n`{:error, reason}` and the process to exit with reason `reason` without\nentering the loop or calling `c:terminate/2`.","ref":"GenServer.html#c:init/1"},{"type":"function","title":"GenServer.multi_call/4","doc":"Calls all servers locally registered as `name` at the specified `nodes`.\n\nFirst, the `request` is sent to every node in `nodes`; then, the caller waits\nfor the replies. This function returns a two-element tuple `{replies,\nbad_nodes}` where:\n\n  * `replies` - is a list of `{node, reply}` tuples where `node` is the node\n    that replied and `reply` is its reply\n  * `bad_nodes` - is a list of nodes that either did not exist or where a\n    server with the given `name` did not exist or did not reply\n\n`nodes` is a list of node names to which the request is sent. The default\nvalue is the list of all known nodes (including this node).","ref":"GenServer.html#multi_call/4"},{"type":"function","title":"Examples - GenServer.multi_call/4","doc":"Assuming the `Stack` GenServer mentioned in the docs for the `GenServer`\nmodule is registered as `Stack` in the `:\"foo@my-machine\"` and\n`:\"bar@my-machine\"` nodes:\n\n    GenServer.multi_call(Stack, :pop)\n    #=> {[{:\"foo@my-machine\", :hello}, {:\"bar@my-machine\", :world}], []}","ref":"GenServer.html#multi_call/4-examples"},{"type":"type","title":"GenServer.name/0","doc":"The GenServer name","ref":"GenServer.html#t:name/0"},{"type":"type","title":"GenServer.on_start/0","doc":"Return values of `start*` functions","ref":"GenServer.html#t:on_start/0"},{"type":"type","title":"GenServer.option/0","doc":"Option values used by the `start*` functions","ref":"GenServer.html#t:option/0"},{"type":"type","title":"GenServer.options/0","doc":"Options used by the `start*` functions","ref":"GenServer.html#t:options/0"},{"type":"function","title":"GenServer.reply/2","doc":"Replies to a client.\n\nThis function can be used to explicitly send a reply to a client that called\n`call/3` or `multi_call/4` when the reply cannot be specified in the return\nvalue of `c:handle_call/3`.\n\n`client` must be the `from` argument (the second argument) accepted by\n`c:handle_call/3` callbacks. `reply` is an arbitrary term which will be given\nback to the client as the return value of the call.\n\nNote that `reply/2` can be called from any process, not just the GenServer\nthat originally received the call (as long as that GenServer communicated the\n`from` argument somehow).\n\nThis function always returns `:ok`.","ref":"GenServer.html#reply/2"},{"type":"function","title":"Examples - GenServer.reply/2","doc":"def handle_call(:reply_in_one_second, from, state) do\n      Process.send_after(self(), {:reply, from}, 1_000)\n      {:noreply, state}\n    end\n\n    def handle_info({:reply, from}, state) do\n      GenServer.reply(from, :one_second_has_passed)\n      {:noreply, state}\n    end","ref":"GenServer.html#reply/2-examples"},{"type":"type","title":"GenServer.server/0","doc":"The server reference.\n\nThis is either a plain PID or a value representing a registered name.\nSee the \"Name registration\" section of this document for more information.","ref":"GenServer.html#t:server/0"},{"type":"function","title":"GenServer.start/3","doc":"Starts a `GenServer` process without links (outside of a supervision tree).\n\nSee `start_link/3` for more information.","ref":"GenServer.html#start/3"},{"type":"function","title":"GenServer.start_link/3","doc":"Starts a `GenServer` process linked to the current process.\n\nThis is often used to start the `GenServer` as part of a supervision tree.\n\nOnce the server is started, the `c:init/1` function of the given `module` is\ncalled with `init_arg` as its argument to initialize the server. To ensure a\nsynchronized start-up procedure, this function does not return until `c:init/1`\nhas returned.\n\nNote that a `GenServer` started with `start_link/3` is linked to the\nparent process and will exit in case of crashes from the parent. The GenServer\nwill also exit due to the `:normal` reasons in case it is configured to trap\nexits in the `c:init/1` callback.","ref":"GenServer.html#start_link/3"},{"type":"function","title":"Options - GenServer.start_link/3","doc":"* `:name` - used for name registration as described in the \"Name\n    registration\" section in the documentation for `GenServer`\n\n  * `:timeout` - if present, the server is allowed to spend the given number of\n    milliseconds initializing or it will be terminated and the start function\n    will return `{:error, :timeout}`\n\n  * `:debug` - if present, the corresponding function in the [`:sys` module](`:sys`) is invoked\n\n  * `:spawn_opt` - if present, its value is passed as options to the\n    underlying process as in `Process.spawn/4`\n\n  * `:hibernate_after` - if present, the GenServer process awaits any message for\n    the given number of milliseconds and if no message is received, the process goes\n    into hibernation automatically (by calling `:proc_lib.hibernate/3`).","ref":"GenServer.html#start_link/3-options"},{"type":"function","title":"Return values - GenServer.start_link/3","doc":"If the server is successfully created and initialized, this function returns\n`{:ok, pid}`, where `pid` is the PID of the server. If a process with the\nspecified server name already exists, this function returns\n`{:error, {:already_started, pid}}` with the PID of that process.\n\nIf the `c:init/1` callback fails with `reason`, this function returns\n`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\nor `:ignore`, the process is terminated and this function returns\n`{:error, reason}` or `:ignore`, respectively.","ref":"GenServer.html#start_link/3-return-values"},{"type":"function","title":"GenServer.stop/3","doc":"Synchronously stops the server with the given `reason`.\n\nThe `c:terminate/2` callback of the given `server` will be invoked before\nexiting. This function returns `:ok` if the server terminates with the\ngiven reason; if it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.","ref":"GenServer.html#stop/3"},{"type":"callback","title":"GenServer.terminate/2","doc":"Invoked when the server is about to exit. It should do any cleanup required.\n\n`reason` is exit reason and `state` is the current state of the `GenServer`.\nThe return value is ignored.\n\n`c:terminate/2` is useful for cleanup that requires access to the\n`GenServer`'s state. However, it is **not guaranteed** that `c:terminate/2`\nis called when a `GenServer` exits. Therefore, important cleanup should be\ndone using process links and/or monitors. A monitoring process will receive the\nsame exit `reason` that would be passed to `c:terminate/2`.\n\n`c:terminate/2` is called if:\n\n  * the `GenServer` traps exits (using `Process.flag/2`) *and* the parent\n  process (the one which called `start_link/1`) sends an exit signal\n\n  * a callback (except `c:init/1`) does one of the following:\n\n    * returns a `:stop` tuple\n\n    * raises (via `raise/2`) or exits (via `exit/1`)\n\n    * returns an invalid value\n\nIf part of a supervision tree, a `GenServer` will receive an exit signal from\nits parent process (its supervisor) when the tree is shutting down. The exit\nsignal is based on the shutdown strategy in the child's specification, where\nthis value can be:\n\n  * `:brutal_kill`: the `GenServer` is killed and so `c:terminate/2` is not called.\n\n  * a timeout value, where the supervisor will send the exit signal `:shutdown` and\n    the `GenServer` will have the duration of the timeout to terminate.\n    If after duration of this timeout the process is still alive, it will be killed\n    immediately.\n\nFor a more in-depth explanation, please read the \"Shutdown values (:shutdown)\"\nsection in the `Supervisor` module.\n\nIf the `GenServer` receives an exit signal (that is not `:normal`) from any\nprocess when it is not trapping exits it will exit abruptly with the same\nreason and so not call `c:terminate/2`. Note that a process does *NOT* trap\nexits by default and an exit signal is sent when a linked process exits or its\nnode is disconnected.\n\n`c:terminate/2` is only called after the `GenServer` finishes processing all\nmessages which arrived in its mailbox prior to the exit signal. If it\nreceives a `:kill` signal before it finishes processing those,\n`c:terminate/2` will not be called. If `c:terminate/2` is called, any\nmessages received after the exit signal will still be in the mailbox.\n\nThere is no cleanup needed when the `GenServer` controls a `port` (for example,\n`:gen_tcp.socket`) or `t:File.io_device/0`, because these will be closed on\nreceiving a `GenServer`'s exit signal and do not need to be closed manually\nin `c:terminate/2`.\n\nIf `reason` is neither `:normal`, `:shutdown`, nor `{:shutdown, term}` an error is\nlogged.\n\nThis callback is optional.","ref":"GenServer.html#c:terminate/2"},{"type":"function","title":"GenServer.whereis/1","doc":"Returns the `pid` or `{name, node}` of a GenServer process, `nil` otherwise.\n\nTo be precise, `nil` is returned whenever a `pid` or `{name, node}` cannot\nbe returned. Note there is no guarantee the returned `pid` or `{name, node}`\nis alive, as a process could terminate immediately after it is looked up.","ref":"GenServer.html#whereis/1"},{"type":"function","title":"Examples - GenServer.whereis/1","doc":"For example, to lookup a server process, monitor it and send a cast to it:\n\n    process = GenServer.whereis(server)\n    monitor = Process.monitor(process)\n    GenServer.cast(process, :hello)","ref":"GenServer.html#whereis/1-examples"},{"type":"module","title":"Node","doc":"Functions related to VM nodes.\n\nSome of the functions in this module are inlined by the compiler,\nsimilar to functions in the `Kernel` module and they are explicitly\nmarked in their docs as \"inlined by the compiler\". For more information\nabout inlined functions, check out the `Kernel` module.","ref":"Node.html"},{"type":"function","title":"Node.alive?/0","doc":"Returns `true` if the local node is alive.\n\nThat is, if the node can be part of a distributed system.","ref":"Node.html#alive?/0"},{"type":"function","title":"Node.connect/1","doc":"Establishes a connection to `node`.\n\nReturns `true` if successful, `false` if not, and the atom\n`:ignored` if the local node is not alive.\n\nFor more information, see `:net_kernel.connect_node/1`.","ref":"Node.html#connect/1"},{"type":"function","title":"Node.disconnect/1","doc":"Forces the disconnection of a node.\n\nThis will appear to the `node` as if the local node has crashed.\nThis function is mainly used in the Erlang network authentication\nprotocols. Returns `true` if disconnection succeeds, otherwise `false`.\nIf the local node is not alive, the function returns `:ignored`.\n\nFor more information, see `:erlang.disconnect_node/1`.","ref":"Node.html#disconnect/1"},{"type":"function","title":"Node.get_cookie/0","doc":"Returns the magic cookie of the local node.\n\nReturns the cookie if the node is alive, otherwise `:nocookie`.","ref":"Node.html#get_cookie/0"},{"type":"function","title":"Node.list/0","doc":"Returns a list of all visible nodes in the system, excluding\nthe local node.\n\nSame as `list(:visible)`.\n\nInlined by the compiler.","ref":"Node.html#list/0"},{"type":"function","title":"Node.list/1","doc":"Returns a list of nodes according to argument given.\n\nThe result returned when the argument is a list, is the list of nodes\nsatisfying the disjunction(s) of the list elements.\n\nFor more information, see `:erlang.nodes/1`.\n\nInlined by the compiler.","ref":"Node.html#list/1"},{"type":"function","title":"Node.monitor/2","doc":"Monitors the status of the node.\n\nIf `flag` is `true`, monitoring is turned on.\nIf `flag` is `false`, monitoring is turned off.\n\nFor more information, see `:erlang.monitor_node/2`.\n\nFor monitoring status changes of all nodes, see `:net_kernel.monitor_nodes/2`.","ref":"Node.html#monitor/2"},{"type":"function","title":"Node.monitor/3","doc":"Behaves as `monitor/2` except that it allows an extra\noption to be given, namely `:allow_passive_connect`.\n\nFor more information, see `:erlang.monitor_node/3`.\n\nFor monitoring status changes of all nodes, see `:net_kernel.monitor_nodes/2`.","ref":"Node.html#monitor/3"},{"type":"function","title":"Node.ping/1","doc":"Tries to set up a connection to node.\n\nReturns `:pang` if it fails, or `:pong` if it is successful.","ref":"Node.html#ping/1"},{"type":"function","title":"Examples - Node.ping/1","doc":"iex> Node.ping(:unknown_node)\n    :pang","ref":"Node.html#ping/1-examples"},{"type":"function","title":"Node.self/0","doc":"Returns the current node.\n\nIt returns the same as the built-in `node()`.","ref":"Node.html#self/0"},{"type":"function","title":"Node.set_cookie/2","doc":"Sets the magic cookie of `node` to the atom `cookie`.\n\nThe default node is `Node.self/0`, the local node. If `node` is the local node,\nthe function also sets the cookie of all other unknown nodes to `cookie`.\n\nThis function will raise `FunctionClauseError` if the given `node` is not alive.","ref":"Node.html#set_cookie/2"},{"type":"function","title":"Node.spawn/2","doc":"Returns the PID of a new process started by the application of `fun`\non `node`. If `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/2`.\n\nInlined by the compiler.","ref":"Node.html#spawn/2"},{"type":"function","title":"Node.spawn/3","doc":"Returns the PID of a new process started by the application of `fun`\non `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn_opt/3`.\n\nInlined by the compiler.","ref":"Node.html#spawn/3"},{"type":"function","title":"Node.spawn/4","doc":"Returns the PID of a new process started by the application of\n`module.function(args)` on `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/4`.\n\nInlined by the compiler.","ref":"Node.html#spawn/4"},{"type":"function","title":"Node.spawn/5","doc":"Returns the PID of a new process started by the application of\n`module.function(args)` on `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn_opt/5`.\n\nInlined by the compiler.","ref":"Node.html#spawn/5"},{"type":"function","title":"Node.spawn_link/2","doc":"Returns the PID of a new linked process started by the application of `fun` on `node`.\n\nA link is created between the calling process and the new process, atomically.\nIf `node` does not exist, a useless PID is returned (and due to the link, an exit\nsignal with exit reason `:noconnection` will be received).\n\nInlined by the compiler.","ref":"Node.html#spawn_link/2"},{"type":"function","title":"Node.spawn_link/4","doc":"Returns the PID of a new linked process started by the application of\n`module.function(args)` on `node`.\n\nA link is created between the calling process and the new process, atomically.\nIf `node` does not exist, a useless PID is returned (and due to the link, an exit\nsignal with exit reason `:noconnection` will be received).\n\nInlined by the compiler.","ref":"Node.html#spawn_link/4"},{"type":"function","title":"Node.spawn_monitor/2","doc":"Spawns the given function on a node, monitors it and returns its PID\nand monitoring reference.\n\nInlined by the compiler.","ref":"Node.html#spawn_monitor/2"},{"type":"function","title":"Node.spawn_monitor/4","doc":"Spawns the given module and function passing the given args on a node,\nmonitors it and returns its PID and monitoring reference.\n\nInlined by the compiler.","ref":"Node.html#spawn_monitor/4"},{"type":"function","title":"Node.start/3","doc":"Turns a non-distributed node into a distributed node.\n\nThis functionality starts the `:net_kernel` and other related\nprocesses.\n\nThis function is rarely invoked in practice. Instead, nodes are\nnamed and started via the command line by using the `--sname` and\n`--name` flags. If you need to use this function to dynamically\nname a node, please make sure the `epmd` operating system process\nis running by calling `epmd -daemon`.\n\nInvoking this function when the distribution has already been started,\neither via the command line interface or dynamically, will return an\nerror.","ref":"Node.html#start/3"},{"type":"function","title":"Examples - Node.start/3","doc":"{:ok, pid} = Node.start(:example, :shortnames, 15000)","ref":"Node.html#start/3-examples"},{"type":"type","title":"Node.state/0","doc":"","ref":"Node.html#t:state/0"},{"type":"function","title":"Node.stop/0","doc":"Turns a distributed node into a non-distributed node.\n\nFor other nodes in the network, this is the same as the node going down.\nOnly possible when the node was started with `Node.start/3`, otherwise\nreturns `{:error, :not_allowed}`. Returns `{:error, :not_found}` if the\nlocal node is not alive.","ref":"Node.html#stop/0"},{"type":"type","title":"Node.t/0","doc":"","ref":"Node.html#t:t/0"},{"type":"module","title":"PartitionSupervisor","doc":"A supervisor that starts multiple partitions of the same child.\n\nCertain processes may become bottlenecks in large systems.\nIf those processes can have their state trivially partitioned,\nin a way there is no dependency between them, then they can use\nthe `PartitionSupervisor` to create multiple isolated and\nindependent partitions.\n\nOnce the `PartitionSupervisor` starts, you can dispatch to its\nchildren using `{:via, PartitionSupervisor, {name, key}}`, where\n`name` is the name of the `PartitionSupervisor` and key is used\nfor routing.\n\nThis module was introduced in Elixir v1.14.0.","ref":"PartitionSupervisor.html"},{"type":"module","title":"Simple Example - PartitionSupervisor","doc":"Let's start with an example which is not useful per se, but shows how the\npartitions are started and how messages are routed to them.\n\nHere's a toy GenServer that simply collects the messages it's given.\nIt prints them for easy illustration.\n\n    defmodule Collector do\n      use GenServer\n\n      def start_link(args) do\n        GenServer.start_link(__MODULE__, args)\n      end\n\n      def init(args) do\n        IO.inspect([__MODULE__, \" got args \", args, \" in \", self()])\n        {:ok, _initial_state = []}\n      end\n\n      def collect(server, msg) do\n        GenServer.call(server, {:collect, msg})\n      end\n\n      def handle_call({:collect, msg}, _from, state) do\n        new_state = [msg | state]\n        IO.inspect([\"current messages:\", new_state, \" in process\", self()])\n        {:reply, :ok, new_state}\n      end\n    end\n\nTo run multiple of these, we can start them under a `PartitionSupervisor` by placing\nthis in our supervision tree:\n\n    {PartitionSupervisor,\n      child_spec: Collector.child_spec([some: :arg]),\n      name: MyApp.PartitionSupervisor\n    }\n\nWe can send messages to them using a \"via tuple\":\n\n    # The key is used to route our message to a particular instance.\n    key = 1\n    Collector.collect({:via, PartitionSupervisor, {MyApp.PartitionSupervisor, key}}, :hi)\n    # [\"current messages:\", [:hi], \" in process\", #PID<0.602.0>]\n    :ok\n    Collector.collect({:via, PartitionSupervisor, {MyApp.PartitionSupervisor, key}}, :ho)\n    # [\"current messages:\", [:ho, :hi], \" in process\", #PID<0.602.0>]\n    :ok\n\n    # With a different key, the message will be routed to a different instance.\n    key = 2\n    Collector.collect({:via, PartitionSupervisor, {MyApp.PartitionSupervisor, key}}, :a)\n    # [\"current messages:\", [:a], \" in process\", #PID<0.603.0>]\n    :ok\n    Collector.collect({:via, PartitionSupervisor, {MyApp.PartitionSupervisor, key}}, :b)\n    # [\"current messages:\", [:b, :a], \" in process\", #PID<0.603.0>]\n    :ok\n\nNow let's move on to a useful example.\n\n## `DynamicSupervisor` Example\n\nThe `DynamicSupervisor` is a single process responsible for starting\nother processes. In some applications, the `DynamicSupervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `DynamicSupervisor` through a `PartitionSupervisor`, and then\npick a \"random\" instance to start the child on.\n\nInstead of starting a single `DynamicSupervisor`:\n\n    children = [\n      {DynamicSupervisor, name: MyApp.DynamicSupervisor}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nand starting children on that dynamic supervisor directly:\n\n    DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Agent, fn -> %{} end})\n\nYou can do start the dynamic supervisors under a `PartitionSupervisor`:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: DynamicSupervisor,\n       name: MyApp.DynamicSupervisors}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nand then:\n\n    DynamicSupervisor.start_child(\n      {:via, PartitionSupervisor, {MyApp.DynamicSupervisors, self()}},\n      {Agent, fn -> %{} end}\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `DynamicSupervisor` by name, you call it through the\npartition supervisor using the `{:via, PartitionSupervisor, {name, key}}`\nformat. We picked `self()` as the routing key, which means each process\nwill be assigned one of the existing dynamic supervisors. See `start_link/1`\nto see all options supported by the `PartitionSupervisor`.","ref":"PartitionSupervisor.html#module-simple-example"},{"type":"module","title":"Implementation notes - PartitionSupervisor","doc":"The `PartitionSupervisor` uses either an ETS table or a `Registry` to\nmanage all of the partitions. Under the hood, the `PartitionSupervisor`\ngenerates a child spec for each partition and then acts as a regular\nsupervisor. The ID of each child spec is the partition number.\n\nFor routing, two strategies are used. If `key` is an integer, it is routed\nusing `rem(abs(key), partitions)` where `partitions` is the number of\npartitions. Otherwise it uses `:erlang.phash2(key, partitions)`.\nThe particular routing may change in the future, and therefore must not\nbe relied on. If you want to retrieve a particular PID for a certain key,\nyou can use `GenServer.whereis({:via, PartitionSupervisor, {name, key}})`.","ref":"PartitionSupervisor.html#module-implementation-notes"},{"type":"function","title":"PartitionSupervisor.count_children/1","doc":"Returns a map containing count values for the supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the number of partitions (children processes)\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not the child\n    process is still alive\n\n  * `:workers` - the count of all workers, whether or not the child process\n    is still alive","ref":"PartitionSupervisor.html#count_children/1"},{"type":"type","title":"PartitionSupervisor.name/0","doc":"The name of the `PartitionSupervisor`.","ref":"PartitionSupervisor.html#t:name/0"},{"type":"function","title":"PartitionSupervisor.partitions/1","doc":"Returns the number of partitions for the partition supervisor.","ref":"PartitionSupervisor.html#partitions/1"},{"type":"function","title":"PartitionSupervisor.start_link/1","doc":"Starts a partition supervisor with the given options.\n\nThis function is typically not invoked directly, instead it is invoked\nwhen using a `PartitionSupervisor` as a child of another supervisor:\n\n    children = [\n      {PartitionSupervisor, child_spec: SomeChild, name: MyPartitionSupervisor}\n    ]\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the given name\nfor the partition supervisor is already assigned to a process,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.","ref":"PartitionSupervisor.html#start_link/1"},{"type":"function","title":"Options - PartitionSupervisor.start_link/1","doc":"* `:name` - an atom or via tuple representing the name of the partition\n    supervisor (see `t:name/0`).\n\n  * `:child_spec` - the child spec to be used when starting the partitions.\n\n  * `:partitions` - a positive integer with the number of partitions.\n    Defaults to `System.schedulers_online()` (typically the number of cores).\n\n  * `:strategy` - the restart strategy option, defaults to `:one_for_one`.\n    You can learn more about strategies in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:with_arguments` - a two-argument anonymous function that allows\n    the partition to be given to the child starting function. See the\n    `:with_arguments` section below.\n\n## `:with_arguments`\n\nSometimes you want each partition to know their partition assigned number.\nThis can be done with the `:with_arguments` option. This function receives\nthe value of the `:child_spec` option and an integer for the partition\nnumber. It must return a new list of arguments that will be used to start the\npartition process.\n\nFor example, most processes are started by calling `start_link(opts)`,\nwhere `opts` is a keyword list. You could inject the partition into the\noptions given to the child:\n\n    with_arguments: fn [opts], partition ->\n      [Keyword.put(opts, :partition, partition)]\n    end","ref":"PartitionSupervisor.html#start_link/1-options"},{"type":"function","title":"PartitionSupervisor.stop/3","doc":"Synchronously stops the given partition supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.","ref":"PartitionSupervisor.html#stop/3"},{"type":"function","title":"PartitionSupervisor.which_children/1","doc":"Returns a list with information about all children.\n\nThis function returns a list of tuples containing:\n\n  * `id` - the partition number\n\n  * `child` - the PID of the corresponding child process or the\n    atom `:restarting` if the process is about to be restarted\n\n  * `type` - `:worker` or `:supervisor` as defined in the child\n    specification\n\n  * `modules` - as defined in the child specification","ref":"PartitionSupervisor.html#which_children/1"},{"type":"module","title":"Process","doc":"Conveniences for working with processes and the process dictionary.\n\nBesides the functions available in this module, the `Kernel` module\nexposes and auto-imports some basic functionality related to processes\navailable through the following functions:\n\n  * `Kernel.spawn/1` and `Kernel.spawn/3`\n  * `Kernel.spawn_link/1` and `Kernel.spawn_link/3`\n  * `Kernel.spawn_monitor/1` and `Kernel.spawn_monitor/3`\n  * `Kernel.self/0`\n  * `Kernel.send/2`\n\nWhile this module provides low-level conveniences to work with processes,\ndevelopers typically use abstractions such as `Agent`, `GenServer`,\n`Registry`, `Supervisor` and `Task` for building their systems and\nresort to this module for gathering information, trapping exits, links\nand monitoring.","ref":"Process.html"},{"type":"module","title":"Aliases - Process","doc":"Aliases are a feature introduced in Erlang/OTP 24. An alias is a way\nto refer to a PID in order to send messages to it. The advantage of using\naliases is that they can be deactivated even if the aliased process is still\nrunning. If you send a message to a deactivated alias, nothing will happen.\nThis makes request/response scenarios easier to implement.\n\nYou can use `alias/0` or `alias/1` to set an alias, and then you can send\nmessages to that alias like you do with PIDs using `send/2`. To deactivate\nan alias, you can use `unalias/1`. If you send a message to a deactivated alias,\nnothing will happen.\n\nFor example, you could have a process that listens for `:ping` messages:\n\n    def server do\n      receive do\n        {:ping, source_alias} ->\n          send(source_alias, :pong)\n          server()\n      end\n    end\n\nNow, another process might ping this process:\n\n    server = spawn(&server/0)\n\n    source_alias = Process.alias()\n    send(server, {:ping, source_alias})\n\n    receive do\n      :pong -> :pong\n    end\n    #=> :pong\n\nIf now you deactivate the `source_alias` and ping the server again, you\nwon't receive any response since the server will `send/2` the `:pong` response\nto a deactivated alias.\n\n    Process.unalias(source_alias)\n    send(server, {:ping, source_alias})\n\n    receive do\n      :pong -> :pong\n    after\n      1000 -> :timeout\n    end\n    #=> :timeout\n\nSee also the [Process Aliases\nsection](https://www.erlang.org/doc/reference_manual/processes.html#process-aliases)\nof the *Erlang reference manual*.","ref":"Process.html#module-aliases"},{"type":"function","title":"Process.alias/0","doc":"Creates a process alias.\n\nThis is the same as calling `alias/1` as `alias([:explicit_unalias])`. See\nalso `:erlang.alias/0`.\n\nInlined by the compiler.","ref":"Process.html#alias/0"},{"type":"function","title":"Examples - Process.alias/0","doc":"alias = Process.alias()","ref":"Process.html#alias/0-examples"},{"type":"type","title":"Process.alias/0","doc":"An alias returned by `alias/0` or `alias/1`.\n\nSee [the module documentation](#module-aliases) for more information about aliases.","ref":"Process.html#t:alias/0"},{"type":"function","title":"Process.alias/1","doc":"Creates a process alias.\n\nSee [the module documentation](#module-aliases) for more information about aliases.\nSee also `:erlang.alias/1`.\n\nInlined by the compiler.","ref":"Process.html#alias/1"},{"type":"function","title":"Examples - Process.alias/1","doc":"alias = Process.alias([:reply])","ref":"Process.html#alias/1-examples"},{"type":"type","title":"Process.alias_opt/0","doc":"","ref":"Process.html#t:alias_opt/0"},{"type":"function","title":"Process.alive?/1","doc":"Tells whether the given process is alive on the local node.\n\nIf the process identified by `pid` is alive (that is, it's not exiting and has\nnot exited yet) than this function returns `true`. Otherwise, it returns\n`false`.\n\n`pid` must refer to a process running on the local node or `ArgumentError` is raised.\n\nInlined by the compiler.","ref":"Process.html#alive?/1"},{"type":"function","title":"Process.cancel_timer/2","doc":"Cancels a timer returned by `send_after/3`.\n\nWhen the result is an integer, it represents the time in milliseconds\nleft until the timer would have expired.\n\nWhen the result is `false`, a timer corresponding to `timer_ref` could not be\nfound. This can happen either because the timer expired, because it has\nalready been canceled, or because `timer_ref` never corresponded to a timer.\n\nEven if the timer had expired and the message was sent, this function does not\ntell you if the timeout message has arrived at its destination yet.\n\nInlined by the compiler.","ref":"Process.html#cancel_timer/2"},{"type":"function","title":"Options - Process.cancel_timer/2","doc":"* `:async` - (boolean) when `false`, the request for cancellation is\n    synchronous. When `true`, the request for cancellation is asynchronous,\n    meaning that the request to cancel the timer is issued and `:ok` is\n    returned right away. Defaults to `false`.\n\n  * `:info` - (boolean) whether to return information about the timer being\n    cancelled. When the `:async` option is `false` and `:info` is `true`, then\n    either an integer or `false` (like described above) is returned. If\n    `:async` is `false` and `:info` is `false`, `:ok` is returned. If `:async`\n    is `true` and `:info` is `true`, a message in the form `{:cancel_timer,\n    timer_ref, result}` (where `result` is an integer or `false` like\n    described above) is sent to the caller of this function when the\n    cancellation has been performed. If `:async` is `true` and `:info` is\n    `false`, no message is sent. Defaults to `true`.","ref":"Process.html#cancel_timer/2-options"},{"type":"function","title":"Process.delete/1","doc":"Deletes the given `key` from the process dictionary.\n\nReturns the value that was under `key` in the process dictionary,\nor `nil` if `key` was not stored in the process dictionary.","ref":"Process.html#delete/1"},{"type":"function","title":"Examples - Process.delete/1","doc":"iex> Process.put(:comments, [\"comment\", \"other comment\"])\n    iex> Process.delete(:comments)\n    [\"comment\", \"other comment\"]\n    iex> Process.delete(:comments)\n    nil","ref":"Process.html#delete/1-examples"},{"type":"function","title":"Process.demonitor/2","doc":"Demonitors the monitor identified by the given `reference`.\n\nIf `monitor_ref` is a reference which the calling process\nobtained by calling `monitor/1`, that monitoring is turned off.\nIf the monitoring is already turned off, nothing happens.\n\nSee `:erlang.demonitor/2` for more information.\n\nInlined by the compiler.","ref":"Process.html#demonitor/2"},{"type":"function","title":"Examples - Process.demonitor/2","doc":"pid = spawn(fn -> 1 + 2 end)\n    ref = Process.monitor(pid)\n    Process.demonitor(ref)\n    #=> true","ref":"Process.html#demonitor/2-examples"},{"type":"type","title":"Process.dest/0","doc":"A process destination.\n\nA remote or local PID, a local port, a locally registered name, or a tuple in\nthe form of `{registered_name, node}` for a registered name at another node.","ref":"Process.html#t:dest/0"},{"type":"function","title":"Process.exit/2","doc":"Sends an exit signal with the given `reason` to `pid`.\n\nThe following behavior applies if `reason` is any term except `:normal`\nor `:kill`:\n\n  1. If `pid` is not trapping exits, `pid` will exit with the given\n     `reason`.\n\n  2. If `pid` is trapping exits, the exit signal is transformed into a\n     message `{:EXIT, from, reason}` and delivered to the message queue\n     of `pid`.\n\nIf `reason` is the atom `:normal`, `pid` will not exit (unless `pid` is\nthe calling process, in which case it will exit with the reason `:normal`).\nIf it is trapping exits, the exit signal is transformed into a message\n`{:EXIT, from, :normal}` and delivered to its message queue.\n\nIf `reason` is the atom `:kill`, that is if `Process.exit(pid, :kill)` is called,\nan untrappable exit signal is sent to `pid` which will unconditionally exit\nwith reason `:killed`.\n\nInlined by the compiler.","ref":"Process.html#exit/2"},{"type":"function","title":"Examples - Process.exit/2","doc":"Process.exit(pid, :kill)\n    #=> true","ref":"Process.html#exit/2-examples"},{"type":"function","title":"Process.flag/2","doc":"Sets the given `flag` to `value` for the calling process.\n\nReturns the old value of `flag`.\n\nSee `:erlang.process_flag/2` for more information.\n\nInlined by the compiler.","ref":"Process.html#flag/2"},{"type":"function","title":"Process.flag/3","doc":"Sets the given `flag` to `value` for the given process `pid`.\n\nReturns the old value of `flag`.\n\nIt raises `ArgumentError` if `pid` is not a local process.\n\nThe allowed values for `flag` are only a subset of those allowed in `flag/2`,\nnamely `:save_calls`.\n\nSee `:erlang.process_flag/3` for more information.\n\nInlined by the compiler.","ref":"Process.html#flag/3"},{"type":"function","title":"Process.get/0","doc":"Returns all key-value pairs in the process dictionary.\n\nInlined by the compiler.","ref":"Process.html#get/0"},{"type":"function","title":"Process.get/2","doc":"Returns the value for the given `key` in the process dictionary,\nor `default` if `key` is not set.","ref":"Process.html#get/2"},{"type":"function","title":"Examples - Process.get/2","doc":"# Assuming :locale was not set\n    iex> Process.get(:locale, \"pt\")\n    \"pt\"\n    iex> Process.put(:locale, \"fr\")\n    nil\n    iex> Process.get(:locale, \"pt\")\n    \"fr\"","ref":"Process.html#get/2-examples"},{"type":"function","title":"Process.get_keys/0","doc":"Returns all keys in the process dictionary.\n\nInlined by the compiler.","ref":"Process.html#get_keys/0"},{"type":"function","title":"Examples - Process.get_keys/0","doc":"# Assuming :locale was not set\n    iex> :locale in Process.get_keys()\n    false\n    iex> Process.put(:locale, \"pt\")\n    nil\n    iex> :locale in Process.get_keys()\n    true","ref":"Process.html#get_keys/0-examples"},{"type":"function","title":"Process.get_keys/1","doc":"Returns all keys in the process dictionary that have the given `value`.\n\nInlined by the compiler.","ref":"Process.html#get_keys/1"},{"type":"function","title":"Process.group_leader/0","doc":"Returns the PID of the group leader for the calling process.\n\nInlined by the compiler.","ref":"Process.html#group_leader/0"},{"type":"function","title":"Examples - Process.group_leader/0","doc":"Process.group_leader()\n    #=> #PID<0.53.0>","ref":"Process.html#group_leader/0-examples"},{"type":"function","title":"Process.group_leader/2","doc":"Sets the group leader of the given `pid` to `leader`.\n\nTypically, this is used when a process started from a certain shell should\nhave a group leader other than `:init`.\n\nInlined by the compiler.","ref":"Process.html#group_leader/2"},{"type":"function","title":"Process.hibernate/3","doc":"Puts the calling process into a \"hibernation\" state.\n\nThe calling process is put into a waiting state\nwhere its memory allocation has been reduced as much as possible,\nwhich is useful if the process does not expect to receive any messages\nin the near future.\n\nSee `:erlang.hibernate/3` for more information.\n\nInlined by the compiler.","ref":"Process.html#hibernate/3"},{"type":"function","title":"Process.info/1","doc":"Returns information about the process identified by `pid`, or returns `nil` if the process\nis not alive.\n\nUse this only for debugging information.\n\nSee `:erlang.process_info/1` for more information.","ref":"Process.html#info/1"},{"type":"function","title":"Process.info/2","doc":"Returns information about the process identified by `pid`,\nor returns `nil` if the process is not alive.\n\nSee `:erlang.process_info/2` for more information.","ref":"Process.html#info/2"},{"type":"function","title":"Process.link/1","doc":"Creates a link between the calling process and the given item (process or\nport).\n\nLinks are bidirectional. Linked processes can be unlinked by using `unlink/1`.\n\nIf such a link exists already, this function does nothing since there can only\nbe one link between two given processes. If a process tries to create a link\nto itself, nothing will happen.\n\nWhen two processes are linked, each one receives exit signals from the other\n(see also `exit/2`). Let's assume `pid1` and `pid2` are linked. If `pid2`\nexits with a reason other than `:normal` (which is also the exit reason used\nwhen a process finishes its job) and `pid1` is not trapping exits (see\n`flag/2`), then `pid1` will exit with the same reason as `pid2` and in turn\nemit an exit signal to all its other linked processes. The behavior when\n`pid1` is trapping exits is described in `exit/2`.\n\nSee `:erlang.link/1` for more information.\n\nInlined by the compiler.","ref":"Process.html#link/1"},{"type":"function","title":"Process.list/0","doc":"Returns a list of PIDs corresponding to all the\nprocesses currently existing on the local node.\n\nNote that if a process is exiting, it is considered to exist but not be\nalive. This means that for such process, `alive?/1` will return `false` but\nits PID will be part of the list of PIDs returned by this function.\n\nSee `:erlang.processes/0` for more information.\n\nInlined by the compiler.","ref":"Process.html#list/0"},{"type":"function","title":"Examples - Process.list/0","doc":"Process.list()\n    #=> [#PID<0.0.0>, #PID<0.1.0>, #PID<0.2.0>, #PID<0.3.0>, ...]","ref":"Process.html#list/0-examples"},{"type":"function","title":"Process.monitor/1","doc":"Starts monitoring the given `item` from the calling process.\n\nOnce the monitored process dies, a message is delivered to the\nmonitoring process in the shape of:\n\n    {:DOWN, ref, :process, object, reason}\n\nwhere:\n\n  * `ref` is a monitor reference returned by this function;\n  * `object` is either a `pid` of the monitored process (if monitoring\n    a PID) or `{name, node}` (if monitoring a remote or local name);\n  * `reason` is the exit reason.\n\nIf the process is already dead when calling `Process.monitor/1`, a\n`:DOWN` message is delivered immediately.\n\nSee [\"The need for monitoring\"](genservers.md#the-need-for-monitoring)\nfor an example. See `:erlang.monitor/2` for more information.\n\nInlined by the compiler.","ref":"Process.html#monitor/1"},{"type":"function","title":"Examples - Process.monitor/1","doc":"pid = spawn(fn -> 1 + 2 end)\n    #=> #PID<0.118.0>\n    Process.monitor(pid)\n    #=> #Reference<0.906660723.3006791681.40191>\n    Process.exit(pid, :kill)\n    #=> true\n    receive do\n      msg -> msg\n    end\n    #=> {:DOWN, #Reference<0.906660723.3006791681.40191>, :process, #PID<0.118.0>, :noproc}","ref":"Process.html#monitor/1-examples"},{"type":"function","title":"Process.monitor/2","doc":"Starts monitoring the given `item` from the calling process.\n\nThis function is similar to `monitor/1`, but accepts options to customize how\n`item` is monitored. See `:erlang.monitor/3` for documentation on those\noptions.\n\nInlined by the compiler.","ref":"Process.html#monitor/2"},{"type":"function","title":"Examples - Process.monitor/2","doc":"pid =\n      spawn(fn ->\n        receive do\n          {:ping, source_alias} -> send(source_alias, :pong)\n        end\n      end)\n    #=> #PID<0.118.0>\n\n    ref_and_alias = Process.monitor(pid, alias: :reply_demonitor)\n    #=> #Reference<0.906660723.3006791681.40191>\n\n    send(pid, {:ping, ref_and_alias})\n\n    receive do: msg -> msg\n    #=> :pong\n\n    receive do: msg -> msg\n    #=> {:DOWN, #Reference<0.906660723.3006791681.40191>, :process, #PID<0.118.0>, :noproc}","ref":"Process.html#monitor/2-examples"},{"type":"type","title":"Process.process_info_item/0","doc":"","ref":"Process.html#t:process_info_item/0"},{"type":"type","title":"Process.process_info_result_item/0","doc":"","ref":"Process.html#t:process_info_result_item/0"},{"type":"function","title":"Process.put/2","doc":"Stores the given `key`-`value` pair in the process dictionary.\n\nThe return value of this function is the value that was previously stored\nunder `key`, or `nil` in case no value was stored under it.","ref":"Process.html#put/2"},{"type":"function","title":"Examples - Process.put/2","doc":"# Assuming :locale was not set\n    iex> Process.put(:locale, \"en\")\n    nil\n    iex> Process.put(:locale, \"fr\")\n    \"en\"","ref":"Process.html#put/2-examples"},{"type":"function","title":"Process.read_timer/1","doc":"Reads a timer created by `send_after/3`.\n\nWhen the result is an integer, it represents the time in milliseconds\nleft until the timer will expire.\n\nWhen the result is `false`, a timer corresponding to `timer_ref` could not be\nfound. This can be either because the timer expired, because it has already\nbeen canceled, or because `timer_ref` never corresponded to a timer.\n\nEven if the timer had expired and the message was sent, this function does not\ntell you if the timeout message has arrived at its destination yet.\n\nInlined by the compiler.","ref":"Process.html#read_timer/1"},{"type":"function","title":"Process.register/2","doc":"Registers the given `pid_or_port` under the given `name` on the local node.\n\n`name` must be an atom and can then be used instead of the\nPID/port identifier when sending messages with `Kernel.send/2`.\n\n`register/2` will fail with `ArgumentError` in any of the following cases:\n\n  * the PID/Port is not existing locally and alive\n  * the name is already registered\n  * the `pid_or_port` is already registered under a different `name`\n\nThe following names are reserved and cannot be assigned to\nprocesses nor ports:\n\n  * `nil`\n  * `false`\n  * `true`\n  * `:undefined`","ref":"Process.html#register/2"},{"type":"function","title":"Examples - Process.register/2","doc":"Process.register(self(), :test)\n    #=> true\n    send(:test, :hello)\n    #=> :hello\n    send(:wrong_name, :hello)\n    ** (ArgumentError) argument error","ref":"Process.html#register/2-examples"},{"type":"function","title":"Process.registered/0","doc":"Returns a list of names which have been registered using `register/2`.\n\nInlined by the compiler.","ref":"Process.html#registered/0"},{"type":"function","title":"Examples - Process.registered/0","doc":"Process.register(self(), :test)\n    Process.registered()\n    #=> [:test, :elixir_config, :inet_db, ...]","ref":"Process.html#registered/0-examples"},{"type":"function","title":"Process.send/3","doc":"Sends a message to the given `dest`.\n\n`dest` may be a remote or local PID, a local port, a locally\nregistered name, or a tuple in the form of `{registered_name, node}` for a\nregistered name at another node.\n\nInlined by the compiler.","ref":"Process.html#send/3"},{"type":"function","title":"Options - Process.send/3","doc":"* `:noconnect` - when used, if sending the message would require an\n    auto-connection to another node the message is not sent and `:noconnect` is\n    returned.\n\n  * `:nosuspend` - when used, if sending the message would cause the sender to\n    be suspended the message is not sent and `:nosuspend` is returned.\n\nOtherwise the message is sent and `:ok` is returned.","ref":"Process.html#send/3-options"},{"type":"function","title":"Examples - Process.send/3","doc":"iex> Process.send({:name, :node_that_does_not_exist}, :hi, [:noconnect])\n    :noconnect","ref":"Process.html#send/3-examples"},{"type":"function","title":"Process.send_after/4","doc":"Sends `msg` to `dest` after `time` milliseconds.\n\nIf `dest` is a PID, it must be the PID of a local process, dead or alive.\nIf `dest` is an atom, it must be the name of a registered process\nwhich is looked up at the time of delivery. No error is produced if the name does\nnot refer to a process.\n\nThe message is not sent immediately. Therefore, `dest` can receive other messages\nin-between even when `time` is `0`.\n\nThis function returns a timer reference, which can be read with `read_timer/1`\nor canceled with `cancel_timer/1`.\n\nThe timer will be automatically canceled if the given `dest` is a PID\nwhich is not alive or when the given PID exits. Note that timers will not be\nautomatically canceled when `dest` is an atom (as the atom resolution is done\non delivery).\n\nInlined by the compiler.","ref":"Process.html#send_after/4"},{"type":"function","title":"Options - Process.send_after/4","doc":"* `:abs` - (boolean) when `false`, `time` is treated as relative to the\n  current monotonic time. When `true`, `time` is the absolute value of the\n  Erlang monotonic time at which `msg` should be delivered to `dest`.\n  To read more about Erlang monotonic time and other time-related concepts,\n  look at the documentation for the `System` module. Defaults to `false`.","ref":"Process.html#send_after/4-options"},{"type":"function","title":"Examples - Process.send_after/4","doc":"timer_ref = Process.send_after(pid, :hi, 1000)","ref":"Process.html#send_after/4-examples"},{"type":"function","title":"Process.set_label/1","doc":"Add a descriptive term to the current process.\n\nThe term does not need to be unique, and in Erlang/OTP 27+ will be shown in\nObserver and in crash logs.\nThis label may be useful for identifying a process as one of multiple in a\ngiven role, such as `:queue_worker` or `{:live_chat, user_id}`.","ref":"Process.html#set_label/1"},{"type":"function","title":"Examples - Process.set_label/1","doc":"Process.set_label(:worker)\n    #=> :ok\n\n    Process.set_label({:any, \"term\"})\n    #=> :ok","ref":"Process.html#set_label/1-examples"},{"type":"function","title":"Process.sleep/1","doc":"Sleeps the current process for the given `timeout`.\n\n`timeout` is either the number of milliseconds to sleep as an\ninteger or the atom `:infinity`. When `:infinity` is given,\nthe current process will sleep forever, and not\nconsume or reply to messages.\n\n**Use this function with extreme care**. For almost all situations\nwhere you would use `sleep/1` in Elixir, there is likely a\nmore correct, faster and precise way of achieving the same with\nmessage passing.\n\nFor example, if you are waiting for a process to perform some\naction, it is better to communicate the progress of such action\nwith messages.\n\nIn other words, **do not**:\n\n    Task.start_link(fn ->\n      do_something()\n      ...\n    end)\n\n    # Wait until work is done\n    Process.sleep(2000)\n\nBut **do**:\n\n    parent = self()\n\n    Task.start_link(fn ->\n      do_something()\n      send(parent, :work_is_done)\n      ...\n    end)\n\n    receive do\n      :work_is_done -> :ok\n    after\n      # Optional timeout\n      30_000 -> :timeout\n    end\n\nFor cases like the one above, `Task.async/1` and `Task.await/2` are\npreferred.\n\nSimilarly, if you are waiting for a process to terminate,\nmonitor that process instead of sleeping. **Do not**:\n\n    Task.start_link(fn ->\n      ...\n    end)\n\n    # Wait until task terminates\n    Process.sleep(2000)\n\nInstead **do**:\n\n    {:ok, pid} =\n      Task.start_link(fn ->\n        ...\n      end)\n\n    ref = Process.monitor(pid)\n\n    receive do\n      {:DOWN, ^ref, _, _, _} -> :task_is_down\n    after\n      # Optional timeout\n      30_000 -> :timeout\n    end","ref":"Process.html#sleep/1"},{"type":"function","title":"Process.spawn/2","doc":"Spawns the given function according to the given options.\n\nThe result depends on the given options. In particular,\nif `:monitor` is given as an option, it will return a tuple\ncontaining the PID and the monitoring reference, otherwise\njust the spawned process PID.\n\nMore options are available; for the comprehensive list of available options\ncheck `:erlang.spawn_opt/4`.\n\nInlined by the compiler.","ref":"Process.html#spawn/2"},{"type":"function","title":"Examples - Process.spawn/2","doc":"Process.spawn(fn -> 1 + 2 end, [:monitor])\n    #=> {#PID<0.93.0>, #Reference<0.18808174.1939079169.202418>}\n    Process.spawn(fn -> 1 + 2 end, [:link])\n    #=> #PID<0.95.0>","ref":"Process.html#spawn/2-examples"},{"type":"function","title":"Process.spawn/4","doc":"Spawns the given function `fun` from module `mod`, passing the given `args`\naccording to the given options.\n\nThe result depends on the given options. In particular,\nif `:monitor` is given as an option, it will return a tuple\ncontaining the PID and the monitoring reference, otherwise\njust the spawned process PID.\n\nIt also accepts extra options, for the list of available options\ncheck `:erlang.spawn_opt/4`.\n\nInlined by the compiler.","ref":"Process.html#spawn/4"},{"type":"type","title":"Process.spawn_opt/0","doc":"","ref":"Process.html#t:spawn_opt/0"},{"type":"type","title":"Process.spawn_opts/0","doc":"","ref":"Process.html#t:spawn_opts/0"},{"type":"function","title":"Process.unalias/1","doc":"Explicitly deactivates a process alias.\n\nReturns `true` if `alias` was a currently-active alias for current processes,\nor `false` otherwise.\n\nSee [the module documentation](#module-aliases) for more information about aliases.\nSee also `:erlang.unalias/1`.\n\nInlined by the compiler.","ref":"Process.html#unalias/1"},{"type":"function","title":"Examples - Process.unalias/1","doc":"alias = Process.alias()\n    Process.unalias(alias)\n    #=> true","ref":"Process.html#unalias/1-examples"},{"type":"function","title":"Process.unlink/1","doc":"Removes the link between the calling process and the given item (process or\nport).\n\nIf there is no such link, this function does nothing. If `pid_or_port` does\nnot exist, this function does not produce any errors and simply does nothing.\n\nThe return value of this function is always `true`.\n\nSee `:erlang.unlink/1` for more information.\n\nInlined by the compiler.","ref":"Process.html#unlink/1"},{"type":"function","title":"Process.unregister/1","doc":"Removes the registered `name`, associated with a PID\nor a port identifier.\n\nFails with `ArgumentError` if the name is not registered\nto any PID or port.\n\nInlined by the compiler.","ref":"Process.html#unregister/1"},{"type":"function","title":"Examples - Process.unregister/1","doc":"Process.register(self(), :test)\n    #=> true\n    Process.unregister(:test)\n    #=> true\n    Process.unregister(:wrong_name)\n    ** (ArgumentError) argument error","ref":"Process.html#unregister/1-examples"},{"type":"function","title":"Process.whereis/1","doc":"Returns the PID or port identifier registered under `name` or `nil` if the\nname is not registered.\n\nSee `:erlang.whereis/1` for more information.","ref":"Process.html#whereis/1"},{"type":"function","title":"Examples - Process.whereis/1","doc":"Process.register(self(), :test)\n    Process.whereis(:test)\n    #=> #PID<0.84.0>\n    Process.whereis(:wrong_name)\n    #=> nil","ref":"Process.html#whereis/1-examples"},{"type":"module","title":"Registry","doc":"A local, decentralized and scalable key-value process storage.\n\nIt allows developers to lookup one or more processes with a given key.\nIf the registry has `:unique` keys, a key points to 0 or 1 process.\nIf the registry allows `:duplicate` keys, a single key may point to any\nnumber of processes. In both cases, different keys could identify the\nsame process.\n\nEach entry in the registry is associated to the process that has\nregistered the key. If the process crashes, the keys associated to that\nprocess are automatically removed. All key comparisons in the registry\nare done using the match operation (`===/2`).\n\nThe registry can be used for different purposes, such as name lookups (using\nthe `:via` option), storing properties, custom dispatching rules, or a pubsub\nimplementation. We explore some of those use cases below.\n\nThe registry may also be transparently partitioned, which provides\nmore scalable behavior for running registries on highly concurrent\nenvironments with thousands or millions of entries.","ref":"Registry.html"},{"type":"module","title":"Using in `:via` - Registry","doc":"Once the registry is started with a given name using\n`Registry.start_link/1`, it can be used to register and access named\nprocesses using the `{:via, Registry, {registry, key}}` tuple:\n\n    {:ok, _} = Registry.start_link(keys: :unique, name: MyApp.Registry)\n    name = {:via, Registry, {MyApp.Registry, \"agent\"}}\n    {:ok, _} = Agent.start_link(fn -> 0 end, name: name)\n    Agent.get(name, & &1)\n    #=> 0\n    Agent.update(name, &(&1 + 1))\n    Agent.get(name, & &1)\n    #=> 1\n\nIn the previous example, we were not interested in associating a value to the\nprocess:\n\n    Registry.lookup(MyApp.Registry, \"agent\")\n    #=> [{self(), nil}]\n\nHowever, in some cases it may be desired to associate a value to the process\nusing the alternate `{:via, Registry, {registry, key, value}}` tuple:\n\n    {:ok, _} = Registry.start_link(keys: :unique, name: MyApp.Registry)\n    name = {:via, Registry, {MyApp.Registry, \"agent\", :hello}}\n    {:ok, agent_pid} = Agent.start_link(fn -> 0 end, name: name)\n    Registry.lookup(MyApp.Registry, \"agent\")\n    #=> [{agent_pid, :hello}]\n\nTo this point, we have been starting `Registry` using `start_link/1`.\nTypically the registry is started as part of a supervision tree though:\n\n    {Registry, keys: :unique, name: MyApp.Registry}\n\nOnly registries with unique keys can be used in `:via`. If the name is\nalready taken, the case-specific `start_link` function (`Agent.start_link/2`\nin the example above) will return `{:error, {:already_started, current_pid}}`.","ref":"Registry.html#module-using-in-via"},{"type":"module","title":"Using as a dispatcher - Registry","doc":"`Registry` has a dispatch mechanism that allows developers to implement custom\ndispatch logic triggered from the caller. For example, let's say we have a\nduplicate registry started as so:\n\n    {:ok, _} = Registry.start_link(keys: :duplicate, name: Registry.DispatcherTest)\n\nBy calling `register/3`, different processes can register under a given key\nand associate any value under that key. In this case, let's register the\ncurrent process under the key `\"hello\"` and attach the `{IO, :inspect}` tuple\nto it:\n\n    {:ok, _} = Registry.register(Registry.DispatcherTest, \"hello\", {IO, :inspect})\n\nNow, an entity interested in dispatching events for a given key may call\n`dispatch/3` passing in the key and a callback. This callback will be invoked\nwith a list of all the values registered under the requested key, alongside\nthe PID of the process that registered each value, in the form of `{pid,\nvalue}` tuples. In our example, `value` will be the `{module, function}` tuple\nin the code above:\n\n    Registry.dispatch(Registry.DispatcherTest, \"hello\", fn entries ->\n      for {pid, {module, function}} <- entries, do: apply(module, function, [pid])\n    end)\n    # Prints #PID<...> where the PID is for the process that called register/3 above\n    #=> :ok\n\nDispatching happens in the process that calls `dispatch/3` either serially or\nconcurrently in case of multiple partitions (via spawned tasks). The\nregistered processes are not involved in dispatching unless involving them is\ndone explicitly (for example, by sending them a message in the callback).\n\nFurthermore, if there is a failure when dispatching, due to a bad\nregistration, dispatching will always fail and the registered process will not\nbe notified. Therefore let's make sure we at least wrap and report those\nerrors:\n\n    require Logger\n\n    Registry.dispatch(Registry.DispatcherTest, \"hello\", fn entries ->\n      for {pid, {module, function}} <- entries do\n        try do\n          apply(module, function, [pid])\n        catch\n          kind, reason ->\n            formatted = Exception.format(kind, reason, __STACKTRACE__)\n            Logger.error(\"Registry.dispatch/3 failed with #{formatted}\")\n        end\n      end\n    end)\n    # Prints #PID<...>\n    #=> :ok\n\nYou could also replace the whole `apply` system by explicitly sending\nmessages. That's the example we will see next.","ref":"Registry.html#module-using-as-a-dispatcher"},{"type":"module","title":"Using as a PubSub - Registry","doc":"Registries can also be used to implement a local, non-distributed, scalable\nPubSub by relying on the `dispatch/3` function, similarly to the previous\nsection: in this case, however, we will send messages to each associated\nprocess, instead of invoking a given module-function.\n\nIn this example, we will also set the number of partitions to the number of\nschedulers online, which will make the registry more performant on highly\nconcurrent environments:\n\n    {:ok, _} =\n      Registry.start_link(\n        keys: :duplicate,\n        name: Registry.PubSubTest,\n        partitions: System.schedulers_online()\n      )\n\n    {:ok, _} = Registry.register(Registry.PubSubTest, \"hello\", [])\n\n    Registry.dispatch(Registry.PubSubTest, \"hello\", fn entries ->\n      for {pid, _} <- entries, do: send(pid, {:broadcast, \"world\"})\n    end)\n    #=> :ok\n\nThe example above broadcasted the message `{:broadcast, \"world\"}` to all\nprocesses registered under the \"topic\" (or \"key\" as we called it until now)\n`\"hello\"`.\n\nThe third argument given to `register/3` is a value associated to the\ncurrent process. While in the previous section we used it when dispatching,\nin this particular example we are not interested in it, so we have set it\nto an empty list. You could store a more meaningful value if necessary.","ref":"Registry.html#module-using-as-a-pubsub"},{"type":"module","title":"Registrations - Registry","doc":"Looking up, dispatching and registering are efficient and immediate at\nthe cost of delayed unsubscription. For example, if a process crashes,\nits keys are automatically removed from the registry but the change may\nnot propagate immediately. This means certain operations may return processes\nthat are already dead. When such may happen, it will be explicitly stated\nin the function documentation.\n\nHowever, keep in mind those cases are typically not an issue. After all, a\nprocess referenced by a PID may crash at any time, including between getting\nthe value from the registry and sending it a message. Many parts of the standard\nlibrary are designed to cope with that, such as `Process.monitor/1` which will\ndeliver the `:DOWN` message immediately if the monitored process is already dead\nand `send/2` which acts as a no-op for dead processes.","ref":"Registry.html#module-registrations"},{"type":"module","title":"ETS - Registry","doc":"Note that the registry uses one ETS table plus two ETS tables per partition.","ref":"Registry.html#module-ets"},{"type":"type","title":"Registry.body/0","doc":"A pattern used to representing the output format part of a match spec","ref":"Registry.html#t:body/0"},{"type":"function","title":"Registry.child_spec/1","doc":"Returns a specification to start a registry under a supervisor.\n\nSee `Supervisor`.","ref":"Registry.html#child_spec/1"},{"type":"function","title":"Registry.count/1","doc":"Returns the number of registered keys in a registry.\nIt runs in constant time.","ref":"Registry.html#count/1"},{"type":"function","title":"Examples - Registry.count/1","doc":"In the example below we register the current process and ask for the\nnumber of keys in the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueCountTest)\n    iex> Registry.count(Registry.UniqueCountTest)\n    0\n    iex> {:ok, _} = Registry.register(Registry.UniqueCountTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.UniqueCountTest, \"world\", :world)\n    iex> Registry.count(Registry.UniqueCountTest)\n    2\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateCountTest)\n    iex> Registry.count(Registry.DuplicateCountTest)\n    0\n    iex> {:ok, _} = Registry.register(Registry.DuplicateCountTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateCountTest, \"hello\", :world)\n    iex> Registry.count(Registry.DuplicateCountTest)\n    2","ref":"Registry.html#count/1-examples"},{"type":"function","title":"Registry.count_match/4","doc":"Returns the number of `{pid, value}` pairs under the given `key` in `registry`\nthat match `pattern`.\n\nPattern must be an atom or a tuple that will match the structure of the\nvalue stored in the registry. The atom `:_` can be used to ignore a given\nvalue or tuple element, while the atom `:\"$1\"` can be used to temporarily assign part\nof pattern to a variable for a subsequent comparison.\n\nOptionally, it is possible to pass a list of guard conditions for more precise matching.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\nAvoid usage of special match variables `:\"$_\"` and `:\"$$\"`, because it might not work as expected.\n\nZero will be returned if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.","ref":"Registry.html#count_match/4"},{"type":"function","title":"Examples - Registry.count_match/4","doc":"In the example below we register the current process under the same\nkey in a duplicate registry but with different values:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.CountMatchTest)\n    iex> {:ok, _} = Registry.register(Registry.CountMatchTest, \"hello\", {1, :atom, 1})\n    iex> {:ok, _} = Registry.register(Registry.CountMatchTest, \"hello\", {2, :atom, 2})\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {1, :_, :_})\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {2, :_, :_})\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :atom, :_})\n    2\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:\"$1\", :_, :\"$1\"})\n    2\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :_, :\"$1\"}, [{:>, :\"$1\", 1}])\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :\"$1\", :_}, [{:is_atom, :\"$1\"}])\n    2","ref":"Registry.html#count_match/4-examples"},{"type":"function","title":"Registry.count_select/2","doc":"Works like `select/2`, but only returns the number of matching records.","ref":"Registry.html#count_select/2"},{"type":"function","title":"Examples - Registry.count_select/2","doc":"In the example below we register the current process under different\nkeys in a unique registry but with the same value:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.CountSelectTest)\n    iex> {:ok, _} = Registry.register(Registry.CountSelectTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.CountSelectTest, \"world\", :value)\n    iex> Registry.count_select(Registry.CountSelectTest, [{{:_, :_, :value}, [], [true]}])\n    2","ref":"Registry.html#count_select/2-examples"},{"type":"function","title":"Registry.delete_meta/2","doc":"Deletes registry metadata for the given `key` in `registry`.","ref":"Registry.html#delete_meta/2"},{"type":"function","title":"Examples - Registry.delete_meta/2","doc":"iex> Registry.start_link(keys: :unique, name: Registry.DeleteMetaTest)\n    iex> Registry.put_meta(Registry.DeleteMetaTest, :custom_key, \"custom_value\")\n    :ok\n    iex> Registry.meta(Registry.DeleteMetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.delete_meta(Registry.DeleteMetaTest, :custom_key)\n    :ok\n    iex> Registry.meta(Registry.DeleteMetaTest, :custom_key)\n    :error","ref":"Registry.html#delete_meta/2-examples"},{"type":"function","title":"Registry.dispatch/4","doc":"Invokes the callback with all entries under `key` in each partition\nfor the given `registry`.\n\nThe list of `entries` is a non-empty list of two-element tuples where\nthe first element is the PID and the second element is the value\nassociated to the PID. If there are no entries for the given key,\nthe callback is never invoked.\n\nIf the registry is partitioned, the callback is invoked multiple times\nper partition. If the registry is partitioned and `parallel: true` is\ngiven as an option, the dispatching happens in parallel. In both cases,\nthe callback is only invoked if there are entries for that partition.\n\nSee the module documentation for examples of using the `dispatch/3`\nfunction for building custom dispatching or a pubsub system.","ref":"Registry.html#dispatch/4"},{"type":"type","title":"Registry.guard/0","doc":"A guard to be evaluated when matching on objects in a registry","ref":"Registry.html#t:guard/0"},{"type":"type","title":"Registry.guards/0","doc":"A list of guards to be evaluated when matching on objects in a registry","ref":"Registry.html#t:guards/0"},{"type":"type","title":"Registry.key/0","doc":"The type of keys allowed on registration","ref":"Registry.html#t:key/0"},{"type":"type","title":"Registry.keys/0","doc":"The type of the registry","ref":"Registry.html#t:keys/0"},{"type":"function","title":"Registry.keys/2","doc":"Returns the known keys for the given `pid` in `registry` in no particular order.\n\nIf the registry is unique, the keys are unique. Otherwise\nthey may contain duplicates if the process was registered\nunder the same key multiple times. The list will be empty\nif the process is dead or it has no keys in this registry.","ref":"Registry.html#keys/2"},{"type":"function","title":"Examples - Registry.keys/2","doc":"Registering under a unique registry does not allow multiple entries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueKeysTest)\n    iex> Registry.keys(Registry.UniqueKeysTest, self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueKeysTest, \"hello\", :world)\n    iex> Registry.register(Registry.UniqueKeysTest, \"hello\", :later) # registry is :unique\n    {:error, {:already_registered, self()}}\n    iex> Registry.keys(Registry.UniqueKeysTest, self())\n    [\"hello\"]\n\nSuch is possible for duplicate registries though:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateKeysTest)\n    iex> Registry.keys(Registry.DuplicateKeysTest, self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateKeysTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateKeysTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateKeysTest, self())\n    [\"hello\", \"hello\"]","ref":"Registry.html#keys/2-examples"},{"type":"type","title":"Registry.listener_message/0","doc":"The message that the registry sends to listeners when a process registers or unregisters.\n\nSee the `:listeners` option in `start_link/1`.","ref":"Registry.html#t:listener_message/0"},{"type":"function","title":"Registry.lookup/2","doc":"Finds the `{pid, value}` pair for the given `key` in `registry` in no particular order.\n\nAn empty list if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.","ref":"Registry.html#lookup/2"},{"type":"function","title":"Examples - Registry.lookup/2","doc":"In the example below we register the current process and look it up\nboth from itself and other processes:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueLookupTest)\n    iex> Registry.lookup(Registry.UniqueLookupTest, \"hello\")\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueLookupTest, \"hello\", :world)\n    iex> Registry.lookup(Registry.UniqueLookupTest, \"hello\")\n    [{self(), :world}]\n    iex> Task.async(fn -> Registry.lookup(Registry.UniqueLookupTest, \"hello\") end) |> Task.await()\n    [{self(), :world}]\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateLookupTest)\n    iex> Registry.lookup(Registry.DuplicateLookupTest, \"hello\")\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :world)\n    iex> Registry.lookup(Registry.DuplicateLookupTest, \"hello\")\n    [{self(), :world}]\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :another)\n    iex> Enum.sort(Registry.lookup(Registry.DuplicateLookupTest, \"hello\"))\n    [{self(), :another}, {self(), :world}]","ref":"Registry.html#lookup/2-examples"},{"type":"function","title":"Registry.match/4","doc":"Returns `{pid, value}` pairs under the given `key` in `registry` that match `pattern`.\n\nPattern must be an atom or a tuple that will match the structure of the\nvalue stored in the registry. The atom `:_` can be used to ignore a given\nvalue or tuple element, while the atom `:\"$1\"` can be used to temporarily assign part\nof pattern to a variable for a subsequent comparison.\n\nOptionally, it is possible to pass a list of guard conditions for more precise matching.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\nAvoid usage of special match variables `:\"$_\"` and `:\"$$\"`, because it might not work as expected.\n\nAn empty list will be returned if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.","ref":"Registry.html#match/4"},{"type":"function","title":"Examples - Registry.match/4","doc":"In the example below we register the current process under the same\nkey in a duplicate registry but with different values:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.MatchTest)\n    iex> {:ok, _} = Registry.register(Registry.MatchTest, \"hello\", {1, :atom, 1})\n    iex> {:ok, _} = Registry.register(Registry.MatchTest, \"hello\", {2, :atom, 2})\n    iex> Registry.match(Registry.MatchTest, \"hello\", {1, :_, :_})\n    [{self(), {1, :atom, 1}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {2, :_, :_})\n    [{self(), {2, :atom, 2}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :atom, :_}) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:\"$1\", :_, :\"$1\"}) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n    iex> guards = [{:>, :\"$1\", 1}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :_, :\"$1\"}, guards)\n    [{self(), {2, :atom, 2}}]\n    iex> guards = [{:is_atom, :\"$1\"}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :\"$1\", :_}, guards) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]","ref":"Registry.html#match/4-examples"},{"type":"type","title":"Registry.match_pattern/0","doc":"A pattern to match on objects in a registry","ref":"Registry.html#t:match_pattern/0"},{"type":"function","title":"Registry.meta/2","doc":"Reads registry metadata given on `start_link/1`.\n\nAtoms and tuples are allowed as keys.","ref":"Registry.html#meta/2"},{"type":"function","title":"Examples - Registry.meta/2","doc":"iex> Registry.start_link(keys: :unique, name: Registry.MetaTest, meta: [custom_key: \"custom_value\"])\n    iex> Registry.meta(Registry.MetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.meta(Registry.MetaTest, :unknown_key)\n    :error","ref":"Registry.html#meta/2-examples"},{"type":"type","title":"Registry.meta_key/0","doc":"The type of registry metadata keys","ref":"Registry.html#t:meta_key/0"},{"type":"type","title":"Registry.meta_value/0","doc":"The type of registry metadata values","ref":"Registry.html#t:meta_value/0"},{"type":"function","title":"Registry.put_meta/3","doc":"Stores registry metadata.\n\nAtoms and tuples are allowed as keys.","ref":"Registry.html#put_meta/3"},{"type":"function","title":"Examples - Registry.put_meta/3","doc":"iex> Registry.start_link(keys: :unique, name: Registry.PutMetaTest)\n    iex> Registry.put_meta(Registry.PutMetaTest, :custom_key, \"custom_value\")\n    :ok\n    iex> Registry.meta(Registry.PutMetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.put_meta(Registry.PutMetaTest, {:tuple, :key}, \"tuple_value\")\n    :ok\n    iex> Registry.meta(Registry.PutMetaTest, {:tuple, :key})\n    {:ok, \"tuple_value\"}","ref":"Registry.html#put_meta/3-examples"},{"type":"function","title":"Registry.register/3","doc":"Registers the current process under the given `key` in `registry`.\n\nA value to be associated with this registration must also be given.\nThis value will be retrieved whenever dispatching or doing a key\nlookup.\n\nThis function returns `{:ok, owner}` or `{:error, reason}`.\nThe `owner` is the PID in the registry partition responsible for\nthe PID. The owner is automatically linked to the caller.\n\nIf the registry has unique keys, it will return `{:ok, owner}` unless\nthe key is already associated to a PID, in which case it returns\n`{:error, {:already_registered, pid}}`.\n\nIf the registry has duplicate keys, multiple registrations from the\ncurrent process under the same key are allowed.\n\nIf the registry has listeners specified via the `:listeners` option in `start_link/1`,\nthose listeners will be notified of the registration and will receive a\nmessage of type `t:listener_message/0`.","ref":"Registry.html#register/3"},{"type":"function","title":"Examples - Registry.register/3","doc":"Registering under a unique registry does not allow multiple entries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueRegisterTest)\n    iex> {:ok, _} = Registry.register(Registry.UniqueRegisterTest, \"hello\", :world)\n    iex> Registry.register(Registry.UniqueRegisterTest, \"hello\", :later)\n    {:error, {:already_registered, self()}}\n    iex> Registry.keys(Registry.UniqueRegisterTest, self())\n    [\"hello\"]\n\nSuch is possible for duplicate registries though:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateRegisterTest)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateRegisterTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateRegisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateRegisterTest, self())\n    [\"hello\", \"hello\"]","ref":"Registry.html#register/3-examples"},{"type":"type","title":"Registry.registry/0","doc":"The registry identifier","ref":"Registry.html#t:registry/0"},{"type":"function","title":"Registry.select/2","doc":"Select key, pid, and values registered using full match specs.\n\nThe `spec` consists of a list of three part tuples, in the shape of `[{match_pattern, guards, body}]`.\n\nThe first part, the match pattern, must be a tuple that will match the structure of the\nthe data stored in the registry, which is `{key, pid, value}`. The atom `:_` can be used to\nignore a given value or tuple element, while the atom `:\"$1\"` can be used to temporarily\nassign part of pattern to a variable for a subsequent comparison. This can be combined\nlike `{:\"$1\", :_, :_}`.\n\nThe second part, the guards, is a list of conditions that allow filtering the results.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\n\nThe third part, the body, is a list of shapes of the returned entries. Like guards, you have access to\nassigned variables like `:\"$1\"`, which you can combine with hard-coded values to freely shape entries\nNote that tuples have to be wrapped in an additional tuple. To get a result format like\n`%{key: key, pid: pid, value: value}`, assuming you bound those variables in order in the match part,\nyou would provide a body like `[%{key: :\"$1\", pid: :\"$2\", value: :\"$3\"}]`. Like guards, you can use\nsome operations like `:element` to modify the output format.\n\nDo not use special match variables `:\"$_\"` and `:\"$$\"`, because they might not work as expected.\n\nNote that for large registries with many partitions this will be costly as it builds the result by\nconcatenating all the partitions.","ref":"Registry.html#select/2"},{"type":"function","title":"Examples - Registry.select/2","doc":"This example shows how to get everything from the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.SelectAllTest)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"world\", :value)\n    iex> Registry.select(Registry.SelectAllTest, [{{:\"$1\", :\"$2\", :\"$3\"}, [], [{{:\"$1\", :\"$2\", :\"$3\"}}]}]) |> Enum.sort()\n    [{\"hello\", self(), :value}, {\"world\", self(), :value}]\n\nGet all keys in the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.SelectAllTest)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"world\", :value)\n    iex> Registry.select(Registry.SelectAllTest, [{{:\"$1\", :_, :_}, [], [:\"$1\"]}]) |> Enum.sort()\n    [\"hello\", \"world\"]","ref":"Registry.html#select/2-examples"},{"type":"type","title":"Registry.spec/0","doc":"A full match spec used when selecting objects in the registry","ref":"Registry.html#t:spec/0"},{"type":"function","title":"Registry.start_link/1","doc":"Starts the registry as a supervisor process.\n\nManually it can be started as:\n\n    Registry.start_link(keys: :unique, name: MyApp.Registry)\n\nIn your supervisor tree, you would write:\n\n    Supervisor.start_link([\n      {Registry, keys: :unique, name: MyApp.Registry}\n    ], strategy: :one_for_one)\n\nFor intensive workloads, the registry may also be partitioned (by specifying\nthe `:partitions` option). If partitioning is required then a good default is to\nset the number of partitions to the number of schedulers available:\n\n    Registry.start_link(\n      keys: :unique,\n      name: MyApp.Registry,\n      partitions: System.schedulers_online()\n    )\n\nor:\n\n    Supervisor.start_link([\n      {Registry, keys: :unique, name: MyApp.Registry, partitions: System.schedulers_online()}\n    ], strategy: :one_for_one)","ref":"Registry.html#start_link/1"},{"type":"function","title":"Options - Registry.start_link/1","doc":"The registry requires the following keys:\n\n  * `:keys` - chooses if keys are `:unique` or `:duplicate`\n  * `:name` - the name of the registry and its tables\n\nThe following keys are optional:\n\n  * `:partitions` - the number of partitions in the registry. Defaults to `1`.\n  * `:listeners` - a list of named processes which are notified of register\n    and unregister events. The registered process must be monitored by the\n    listener if the listener wants to be notified if the registered process\n    crashes. Messages sent to listeners are of type `t:listener_message/0`.\n  * `:meta` - a keyword list of metadata to be attached to the registry.","ref":"Registry.html#start_link/1-options"},{"type":"type","title":"Registry.start_option/0","doc":"Options used for `child_spec/1` and `start_link/1`","ref":"Registry.html#t:start_option/0"},{"type":"function","title":"Registry.unregister/2","doc":"Unregisters all entries for the given `key` associated to the current\nprocess in `registry`.\n\nAlways returns `:ok` and automatically unlinks the current process from\nthe owner if there are no more keys associated to the current process. See\nalso `register/3` to read more about the \"owner\".\n\nIf the registry has listeners specified via the `:listeners` option in `start_link/1`,\nthose listeners will be notified of the unregistration and will receive a\nmessage of type `t:listener_message/0`.","ref":"Registry.html#unregister/2"},{"type":"function","title":"Examples - Registry.unregister/2","doc":"For unique registries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueUnregisterTest)\n    iex> Registry.register(Registry.UniqueUnregisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.UniqueUnregisterTest, self())\n    [\"hello\"]\n    iex> Registry.unregister(Registry.UniqueUnregisterTest, \"hello\")\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterTest, self())\n    []\n\nFor duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateUnregisterTest)\n    iex> Registry.register(Registry.DuplicateUnregisterTest, \"hello\", :world)\n    iex> Registry.register(Registry.DuplicateUnregisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateUnregisterTest, self())\n    [\"hello\", \"hello\"]\n    iex> Registry.unregister(Registry.DuplicateUnregisterTest, \"hello\")\n    :ok\n    iex> Registry.keys(Registry.DuplicateUnregisterTest, self())\n    []","ref":"Registry.html#unregister/2-examples"},{"type":"function","title":"Registry.unregister_match/4","doc":"Unregisters entries for keys matching a pattern associated to the current\nprocess in `registry`.","ref":"Registry.html#unregister_match/4"},{"type":"function","title":"Examples - Registry.unregister_match/4","doc":"For unique registries it can be used to conditionally unregister a key on\nthe basis of whether or not it matches a particular value.\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueUnregisterMatchTest)\n    iex> Registry.register(Registry.UniqueUnregisterMatchTest, \"hello\", :world)\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    [\"hello\"]\n    iex> Registry.unregister_match(Registry.UniqueUnregisterMatchTest, \"hello\", :foo)\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    [\"hello\"]\n    iex> Registry.unregister_match(Registry.UniqueUnregisterMatchTest, \"hello\", :world)\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    []\n\nFor duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateUnregisterMatchTest)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_a)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_b)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_c)\n    iex> Registry.keys(Registry.DuplicateUnregisterMatchTest, self())\n    [\"hello\", \"hello\", \"hello\"]\n    iex> Registry.unregister_match(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_a)\n    :ok\n    iex> Registry.keys(Registry.DuplicateUnregisterMatchTest, self())\n    [\"hello\", \"hello\"]\n    iex> Registry.lookup(Registry.DuplicateUnregisterMatchTest, \"hello\")\n    [{self(), :world_b}, {self(), :world_c}]","ref":"Registry.html#unregister_match/4-examples"},{"type":"function","title":"Registry.update_value/3","doc":"Updates the value for `key` for the current process in the unique `registry`.\n\nReturns a `{new_value, old_value}` tuple or `:error` if there\nis no such key assigned to the current process.\n\nIf a non-unique registry is given, an error is raised.","ref":"Registry.html#update_value/3"},{"type":"function","title":"Examples - Registry.update_value/3","doc":"iex> Registry.start_link(keys: :unique, name: Registry.UpdateTest)\n    iex> {:ok, _} = Registry.register(Registry.UpdateTest, \"hello\", 1)\n    iex> Registry.lookup(Registry.UpdateTest, \"hello\")\n    [{self(), 1}]\n    iex> Registry.update_value(Registry.UpdateTest, \"hello\", &(&1 + 1))\n    {2, 1}\n    iex> Registry.lookup(Registry.UpdateTest, \"hello\")\n    [{self(), 2}]","ref":"Registry.html#update_value/3-examples"},{"type":"type","title":"Registry.value/0","doc":"The type of values allowed on registration","ref":"Registry.html#t:value/0"},{"type":"function","title":"Registry.values/3","doc":"Reads the values for the given `key` for `pid` in `registry`.\n\nFor unique registries, it is either an empty list or a list\nwith a single element. For duplicate registries, it is a list\nwith zero, one, or multiple elements.","ref":"Registry.html#values/3"},{"type":"function","title":"Examples - Registry.values/3","doc":"In the example below we register the current process and look it up\nboth from itself and other processes:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueValuesTest)\n    iex> Registry.values(Registry.UniqueValuesTest, \"hello\", self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueValuesTest, \"hello\", :world)\n    iex> Registry.values(Registry.UniqueValuesTest, \"hello\", self())\n    [:world]\n    iex> Task.async(fn -> Registry.values(Registry.UniqueValuesTest, \"hello\", self()) end) |> Task.await()\n    []\n    iex> parent = self()\n    iex> Task.async(fn -> Registry.values(Registry.UniqueValuesTest, \"hello\", parent) end) |> Task.await()\n    [:world]\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateValuesTest)\n    iex> Registry.values(Registry.DuplicateValuesTest, \"hello\", self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateValuesTest, \"hello\", :world)\n    iex> Registry.values(Registry.DuplicateValuesTest, \"hello\", self())\n    [:world]\n    iex> {:ok, _} = Registry.register(Registry.DuplicateValuesTest, \"hello\", :another)\n    iex> Enum.sort(Registry.values(Registry.DuplicateValuesTest, \"hello\", self()))\n    [:another, :world]","ref":"Registry.html#values/3-examples"},{"type":"behaviour","title":"Supervisor","doc":"A behaviour module for implementing supervisors.\n\nA supervisor is a process which supervises other processes, which we\nrefer to as *child processes*. Supervisors are used to build a hierarchical\nprocess structure called a *supervision tree*. Supervision trees provide\nfault-tolerance and encapsulate how our applications start and shutdown.\n\nA supervisor may be started directly with a list of child specifications via\n`start_link/2` or you may define a module-based supervisor that implements\nthe required callbacks. The sections below use `start_link/2` to start\nsupervisors in most examples, but it also includes a specific section\non module-based ones.","ref":"Supervisor.html"},{"type":"behaviour","title":"Examples - Supervisor","doc":"In order to start a supervisor, we need to first define a child process\nthat will be supervised. As an example, we will define a `GenServer`,\na generic server, that keeps a counter. Other processes can then send\nmessages to this process to read the counter and bump its value.\n\n> #### Disclaimer {: .neutral}\n>\n> In practice you would not define a counter as a GenServer. Instead,\n> if you need a counter, you would pass it around as inputs and outputs to\n> the functions that need it. The reason we picked a counter in this example\n> is due to its simplicity, as it allows us to focus on how supervisors work.\n\n    defmodule Counter do\n      use GenServer\n\n      def start_link(arg) when is_integer(arg) do\n        GenServer.start_link(__MODULE__, arg, name: __MODULE__)\n      end","ref":"Supervisor.html#module-examples"},{"type":"behaviour","title":"Callbacks - Supervisor","doc":"@impl true\n      def init(counter) do\n        {:ok, counter}\n      end\n\n      @impl true\n      def handle_call(:get, _from, counter) do\n        {:reply, counter, counter}\n      end\n\n      def handle_call({:bump, value}, _from, counter) do\n        {:reply, counter, counter + value}\n      end\n    end\n\nThe `Counter` receives an argument on `start_link`. This argument\nis passed to the `init/1` callback which becomes the initial value\nof the counter. Our counter handles two operations (known as calls):\n`:get`, to get the current counter value, and `:bump`, that bumps\nthe counter by the given `value` and returns the old counter.\n\nWe can now start a supervisor that will start and supervise our\ncounter process. The first step is to define a list of **child\nspecifications** that control how each child behaves. Each child\nspecification is a map, as shown below:\n\n    children = [\n      # The Counter is a child started via Counter.start_link(0)\n      %{\n        id: Counter,\n        start: {Counter, :start_link, [0]}\n      }\n    ]\n\n    # Now we start the supervisor with the children and a strategy\n    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n\n    # After started, we can query the supervisor for information\n    Supervisor.count_children(pid)\n    #=> %{active: 1, specs: 1, supervisors: 0, workers: 1}\n\nNote that when starting the GenServer, we are registering it\nwith name `Counter` via the `name: __MODULE__` option. This allows\nus to call it directly and get its value:\n\n    GenServer.call(Counter, :get)\n    #=> 0\n\n    GenServer.call(Counter, {:bump, 3})\n    #=> 0\n\n    GenServer.call(Counter, :get)\n    #=> 3\n\nHowever, there is a bug in our counter server. If we call `:bump` with\na non-numeric value, it is going to crash:\n\n    GenServer.call(Counter, {:bump, \"oops\"})\n    ** (exit) exited in: GenServer.call(Counter, {:bump, \"oops\"}, 5000)\n\nLuckily, since the server is being supervised by a supervisor, the\nsupervisor will automatically start a new one, reset back to its initial\nvalue of `0`:\n\n    GenServer.call(Counter, :get)\n    #=> 0\n\nSupervisors support different strategies; in the example above, we\nhave chosen `:one_for_one`. Furthermore, each supervisor can have many\nworkers and/or supervisors as children, with each one having its own\nconfiguration (as outlined in the \"Child specification\" section).\n\nThe rest of this document will cover how child processes are specified,\nhow they can be started and stopped, different supervision strategies\nand more.","ref":"Supervisor.html#module-callbacks"},{"type":"behaviour","title":"Child specification - Supervisor","doc":"The child specification describes how the supervisor starts, shuts down,\nand restarts child processes.\n\nThe child specification is a map containing up to 6 elements. The first two keys\nin the following list are required, and the remaining ones are optional:\n\n  * `:id` - any term used to identify the child specification internally by\n    the supervisor; defaults to the given module. This key is required.\n    For supervisors, in the case of conflicting `:id` values, the supervisor\n    will refuse to initialize and require explicit IDs. This is not the case\n    for [dynamic supervisors](`DynamicSupervisor`) though.\n\n  * `:start` - a tuple with the module-function-args to be invoked\n    to start the child process. This key is required.\n\n  * `:restart` - an atom that defines when a terminated child process\n     should be restarted (see the \"Restart values\" section below).\n     This key is optional and defaults to `:permanent`.\n\n  * `:shutdown` - an integer or atom that defines how a child process should\n    be terminated (see the \"Shutdown values\" section below). This key\n    is optional and defaults to `5_000` if the type is `:worker` or\n    `:infinity` if the type is `:supervisor`.\n\n  * `:type` - specifies that the child process is a `:worker` or a\n    `:supervisor`. This key is optional and defaults to `:worker`.\n\n  * `:modules` - a list of modules used by hot code upgrade mechanisms\n    to determine which processes are using certain modules. It is typically\n    set to the callback module of behaviours like `GenServer`, `Supervisor`,\n    and such. It is set automatically based on the `:start` value and it is rarely\n    changed in practice.\n\n  * `:significant` - a boolean indicating if the child process should be\n    considered significant with regard to automatic shutdown.  Only `:transient`\n    and `:temporary` child processes can be marked as significant. This key is\n    optional and defaults to `false`. See section \"Automatic shutdown\" below\n    for more details.\n\nLet's understand what the `:shutdown` and `:restart` options control.","ref":"Supervisor.html#module-child-specification"},{"type":"behaviour","title":"Shutdown values (:shutdown) - Supervisor","doc":"The following shutdown values are supported in the `:shutdown` option:\n\n  * `:brutal_kill` - the child process is unconditionally and immediately\n    terminated using `Process.exit(child, :kill)`.\n\n  * any integer >= 0 - the amount of time in milliseconds that the\n    supervisor will wait for its children to terminate after emitting a\n    `Process.exit(child, :shutdown)` signal. If the child process is\n    not trapping exits, the initial `:shutdown` signal will terminate\n    the child process immediately. If the child process is trapping\n    exits, it has the given amount of time to terminate.\n    If it doesn't terminate within the specified time, the child process\n    is unconditionally terminated by the supervisor via\n    `Process.exit(child, :kill)`.\n\n  * `:infinity` - works as an integer except the supervisor will wait\n    indefinitely for the child to terminate. If the child process is a\n    supervisor, the recommended value is `:infinity` to give the supervisor\n    and its children enough time to shut down. This option can be used with\n    regular workers but doing so is discouraged and requires extreme care.\n    If not used carefully, the child process will never terminate,\n    preventing your application from terminating as well.","ref":"Supervisor.html#module-shutdown-values-shutdown"},{"type":"behaviour","title":"Restart values (:restart) - Supervisor","doc":"The `:restart` option controls what the supervisor should consider to\nbe a successful termination or not. If the termination is successful,\nthe supervisor won't restart the child. If the child process crashed,\nthe supervisor will start a new one.\n\nThe following restart values are supported in the `:restart` option:\n\n  * `:permanent` - the child process is always restarted.\n\n  * `:temporary` - the child process is never restarted, regardless\n    of the supervision strategy: any termination (even abnormal) is\n    considered successful.\n\n  * `:transient` - the child process is restarted only if it\n    terminates abnormally, i.e., with an exit reason other than\n    `:normal`, `:shutdown`, or `{:shutdown, term}`.\n\nFor a more complete understanding of the exit reasons and their\nimpact, see the \"Exit reasons and restarts\" section.\n\n## `child_spec/1` function\n\nWhen starting a supervisor, we may pass a list of child specifications. Those\nspecifications are maps that tell how the supervisor should start, stop and\nrestart each of its children:\n\n    %{\n      id: Counter,\n      start: {Counter, :start_link, [0]}\n    }\n\nThe map above defines a child with `:id` of `Counter` that is started\nby calling `Counter.start_link(0)`.\n\nHowever, defining the child specification for each child as a map can be\nquite error prone, as we may change the `Counter` implementation and forget\nto update its specification. That's why Elixir allows you to pass a tuple with\nthe module name and the `start_link` argument instead of the specification:\n\n    children = [\n      {Counter, 0}\n    ]\n\nThe supervisor will then invoke `Counter.child_spec(0)` to retrieve a child\nspecification. Now the `Counter` module is responsible for building its own\nspecification, for example, we could write:\n\n    def child_spec(arg) do\n      %{\n        id: Counter,\n        start: {Counter, :start_link, [arg]}\n      }\n    end\n\nThen the supervisor will call `Counter.start_link(arg)` to start the child\nprocess. This flow is summarized in the diagram below. Caller is a process\nwhich spawns the Supervisor process. The Supervisor then proceeds to call\nyour code (Module) to spawn its child process:\n\n```mermaid\nsequenceDiagram\n    participant C as Caller (Process)\n    participant S as Supervisor (Process)\n    participant M as Module (Code)\n\n    note right of C: child is a {module, arg} specification\n    C->>+S: Supervisor.start_link([child])\n    S-->>+M: module.child_spec(arg)\n    M-->>-S: %{id: term, start: {module, :start_link, [arg]}}\n    S-->>+M: module.start_link(arg)\n    M->>M: Spawns child process (child_pid)\n    M-->>-S: {:ok, child_pid} | :ignore | {:error, reason}\n    S->>-C: {:ok, supervisor_pid} | {:error, reason}\n```\n\nLuckily for us, `use GenServer` already defines a `Counter.child_spec/1`\nexactly like above, so you don't need to write the definition above yourself.\nIf you want to customize the automatically generated `child_spec/1` function,\nyou can pass the options directly to `use GenServer`:\n\n    use GenServer, restart: :transient\n\nFinally, note it is also possible to simply pass the `Counter` module as\na child:\n\n    children = [\n      Counter\n    ]\n\nWhen only the module name is given, it is equivalent to `{Counter, []}`,\nwhich in our case would be invalid, which is why we always pass the initial\ncounter explicitly.\n\nBy replacing the child specification with `{Counter, 0}`, we keep it\nencapsulated in the `Counter` module. We could now share our\n`Counter` implementation with other developers and they can add it directly\nto their supervision tree without worrying about the low-level details of\nthe counter.\n\nOverall, a child specification can be one of the following:\n\n  * a map representing the child specification itself - as outlined in the\n    \"Child specification\" section\n\n  * a tuple with a module as first element and the start argument as second -\n    such as `{Counter, 0}`. In this case, `Counter.child_spec(0)` is called\n    to retrieve the child specification\n\n  * a module - such as `Counter`. In this case, `Counter.child_spec([])`\n    would be called, which is invalid for the counter, but it is useful in\n    many other cases, especially when you want to pass a list of options\n    to the child process\n\nIf you need to convert a `{module, arg}` tuple or a module child specification to a\n[child specification](`t:child_spec/0`) or modify a child specification itself,\nyou can use the `Supervisor.child_spec/2` function.\nFor example, to run the counter with a different `:id` and a `:shutdown` value of\n10 seconds (10_000 milliseconds):\n\n    children = [\n      Supervisor.child_spec({Counter, 0}, id: MyCounter, shutdown: 10_000)\n    ]","ref":"Supervisor.html#module-restart-values-restart"},{"type":"behaviour","title":"Supervisor strategies and options - Supervisor","doc":"So far we have started the supervisor passing a single child as a tuple\nas well as a strategy called `:one_for_one`:\n\n    children = [\n      {Counter, 0}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe first argument given to `start_link/2` is a list of child\nspecifications as defined in the \"child_spec/1\" section above.\n\nThe second argument is a keyword list of options:\n\n  * `:strategy` - the supervision strategy option. It can be either\n    `:one_for_one`, `:rest_for_one` or `:one_for_all`. Required.\n    See the \"Strategies\" section.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:auto_shutdown` - the automatic shutdown option. It can be\n    `:never`, `:any_significant`, or `:all_significant`. Optional.\n    See the \"Automatic shutdown\" section.\n\n  * `:name` - a name to register the supervisor process. Supported values are\n    explained in the \"Name registration\" section in the documentation for\n    `GenServer`. Optional.","ref":"Supervisor.html#module-supervisor-strategies-and-options"},{"type":"behaviour","title":"Strategies - Supervisor","doc":"Supervisors support different supervision strategies (through the\n`:strategy` option, as seen above):\n\n  * `:one_for_one` - if a child process terminates, only that\n    process is restarted.\n\n  * `:one_for_all` - if a child process terminates, all other child\n    processes are terminated and then all child processes (including\n    the terminated one) are restarted.\n\n  * `:rest_for_one` - if a child process terminates, the terminated child\n    process and the rest of the children started after it, are terminated and\n    restarted.\n\nIn the above, process termination refers to unsuccessful termination, which\nis determined by the `:restart` option.\n\nTo efficiently supervise children started dynamically, see `DynamicSupervisor`.","ref":"Supervisor.html#module-strategies"},{"type":"behaviour","title":"Automatic shutdown - Supervisor","doc":"Supervisors have the ability to automatically shut themselves down when child\nprocesses marked as `:significant` exit.\n\nSupervisors support different automatic shutdown options (through\nthe `:auto_shutdown` option, as seen above):\n\n  * `:never` - this is the default, automatic shutdown is disabled.\n\n  * `:any_significant` - if any significant child process exits, the supervisor\n  will automatically shut down its children, then itself.\n\n  * `:all_significant` - when all significant child processes have exited,\n  the supervisor will automatically shut down its children, then itself.\n\nOnly `:transient` and `:temporary` child processes can be marked as significant,\nand this configuration affects the behavior. Significant `:transient` child\nprocesses must exit normally for automatic shutdown to be considered, where\n`:temporary` child processes may exit for any reason.","ref":"Supervisor.html#module-automatic-shutdown"},{"type":"behaviour","title":"Name registration - Supervisor","doc":"A supervisor is bound to the same name registration rules as a `GenServer`.\nRead more about these rules in the documentation for `GenServer`.","ref":"Supervisor.html#module-name-registration"},{"type":"behaviour","title":"Module-based supervisors - Supervisor","doc":"In the example so far, the supervisor was started by passing the supervision\nstructure to `start_link/2`. However, supervisors can also be created by\nexplicitly defining a supervision module:\n\n    defmodule MyApp.Supervisor do\n      # Automatically defines child_spec/1\n      use Supervisor\n\n      def start_link(init_arg) do\n        Supervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      @impl true\n      def init(_init_arg) do\n        children = [\n          {Counter, 0}\n        ]\n\n        Supervisor.init(children, strategy: :one_for_one)\n      end\n    end\n\nThe difference between the two approaches is that a module-based\nsupervisor gives you more direct control over how the supervisor\nis initialized. Instead of calling `Supervisor.start_link/2` with\na list of child specifications that are implicitly initialized for us,\nwe must explicitly initialize the children by calling `Supervisor.init/2`\ninside its `c:init/1` callback. `Supervisor.init/2` accepts the same\n`:strategy`, `:max_restarts`, and `:max_seconds` options as `start_link/2`.\n\n> #### `use Supervisor` {: .info}\n>\n> When you `use Supervisor`, the `Supervisor` module will\n> set `@behaviour Supervisor` and define a `child_spec/1`\n> function, so your module can be used as a child\n> in a supervision tree.\n\n`use Supervisor` also defines a `child_spec/1` function which allows\nus to run `MyApp.Supervisor` as a child of another supervisor or\nat the top of your supervision tree as:\n\n    children = [\n      MyApp.Supervisor\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nA general guideline is to use the supervisor without a callback\nmodule only at the top of your supervision tree, generally in the\n`c:Application.start/2` callback. We recommend using module-based\nsupervisors for any other supervisor in your application, so they\ncan run as a child of another supervisor in the tree. The `child_spec/1`\ngenerated automatically by `Supervisor` can be customized with the\nfollowing options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the supervisor should be restarted, defaults to `:permanent`\n\nThe `@doc` annotation immediately preceding `use Supervisor` will be\nattached to the generated `child_spec/1` function.","ref":"Supervisor.html#module-module-based-supervisors"},{"type":"behaviour","title":"Start and shutdown - Supervisor","doc":"When the supervisor starts, it traverses all child specifications and\nthen starts each child in the order they are defined. This is done by\ncalling the function defined under the `:start` key in the child\nspecification and typically defaults to `start_link/1`.\n\nThe `start_link/1` (or a custom) is then called for each child process.\nThe `start_link/1` function must return `{:ok, pid}` where `pid` is the\nprocess identifier of a new process that is linked to the supervisor.\nThe child process usually starts its work by executing the `c:init/1`\ncallback. Generally speaking, the `init` callback is where we initialize\nand configure the child process.\n\nThe shutdown process happens in reverse order.\n\nWhen a supervisor shuts down, it terminates all children in the opposite\norder they are listed. The termination happens by sending a shutdown exit\nsignal, via `Process.exit(child_pid, :shutdown)`, to the child process and\nthen awaiting for a time interval for the child process to terminate. This\ninterval defaults to 5000 milliseconds. If the child process does not\nterminate in this interval, the supervisor abruptly terminates the child\nwith reason `:kill`. The shutdown time can be configured in the child\nspecification which is fully detailed in the next section.\n\nIf the child process is not trapping exits, it will shutdown immediately\nwhen it receives the first exit signal. If the child process is trapping\nexits, then the `terminate` callback is invoked, and the child process\nmust terminate in a reasonable time interval before being abruptly\nterminated by the supervisor.\n\nIn other words, if it is important that a process cleans after itself\nwhen your application or the supervision tree is shutting down, then\nthis process must trap exits and its child specification should specify\nthe proper `:shutdown` value, ensuring it terminates within a reasonable\ninterval.","ref":"Supervisor.html#module-start-and-shutdown"},{"type":"behaviour","title":"Exit reasons and restarts - Supervisor","doc":"A supervisor restarts a child process depending on its `:restart` configuration.\nFor example, when `:restart` is set to `:transient`, the supervisor does not\nrestart the child in case it exits with reason `:normal`, `:shutdown` or\n`{:shutdown, term}`.\n\nThose exits also impact logging. By default, behaviours such as GenServers\ndo not emit error logs when the exit reason is `:normal`, `:shutdown` or\n`{:shutdown, term}`.\n\nSo one may ask: which exit reason should I choose? There are three options:\n\n  * `:normal` - in such cases, the exit won't be logged, there is no restart\n    in transient mode, and linked processes do not exit\n\n  * `:shutdown` or `{:shutdown, term}` - in such cases, the exit won't be\n    logged, there is no restart in transient mode, and linked processes exit\n    with the same reason unless they're trapping exits\n\n  * any other term - in such cases, the exit will be logged, there are\n    restarts in transient mode, and linked processes exit with the same\n    reason unless they're trapping exits\n\nGenerally speaking, if you are exiting for expected reasons, you want to use\n`:shutdown` or `{:shutdown, term}`.\n\nNote that the supervisor that reaches maximum restart intensity will exit with\n`:shutdown` reason. In this case the supervisor will only be restarted if its\nchild specification was defined with the `:restart` option set to `:permanent`\n(the default).","ref":"Supervisor.html#module-exit-reasons-and-restarts"},{"type":"type","title":"Supervisor.auto_shutdown/0","doc":"Supported automatic shutdown options.","ref":"Supervisor.html#t:auto_shutdown/0"},{"type":"type","title":"Supervisor.child/0","doc":"A child process.\n\nIt can be a PID when the child process was started, or `:undefined` when\nthe child was created by a [dynamic supervisor](`DynamicSupervisor`).","ref":"Supervisor.html#t:child/0"},{"type":"type","title":"Supervisor.child_spec/0","doc":"The supervisor child specification.\n\nIt defines how the supervisor should start, stop and restart each of its children.","ref":"Supervisor.html#t:child_spec/0"},{"type":"function","title":"Supervisor.child_spec/2","doc":"Builds and overrides a child specification.\n\nSimilar to `start_link/2` and `init/2`, it expects a module, `{module, arg}`,\nor a [child specification](`t:child_spec/0`).\n\nIf a two-element tuple in the shape of `{module, arg}` is given,\nthe child specification is retrieved by calling `module.child_spec(arg)`.\n\nIf a module is given, the child specification is retrieved by calling\n`module.child_spec([])`.\n\nAfter the child specification is retrieved, the fields on `overrides`\nare directly applied to the child spec. If `overrides` has keys that\ndo not map to any child specification field, an error is raised.\n\nSee the \"Child specification\" section in the module documentation\nfor all of the available keys for overriding.","ref":"Supervisor.html#child_spec/2"},{"type":"function","title":"Examples - Supervisor.child_spec/2","doc":"This function is often used to set an `:id` option when\nthe same module needs to be started multiple times in the\nsupervision tree:\n\n    Supervisor.child_spec({Agent, fn -> :ok end}, id: {Agent, 1})\n    #=> %{id: {Agent, 1},\n    #=>   start: {Agent, :start_link, [fn -> :ok end]}}","ref":"Supervisor.html#child_spec/2-examples"},{"type":"function","title":"Supervisor.count_children/1","doc":"Returns a map containing count values for the given supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the total count of children, dead or alive\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not these\n    child supervisors are still alive\n\n  * `:workers` - the count of all workers, whether or not these child workers\n    are still alive","ref":"Supervisor.html#count_children/1"},{"type":"function","title":"Supervisor.delete_child/2","doc":"Deletes the child specification identified by `child_id`.\n\nThe corresponding child process must not be running; use `terminate_child/2`\nto terminate it if it's running.\n\nIf successful, this function returns `:ok`. This function may return an error\nwith an appropriate error tuple if the `child_id` is not found, or if the\ncurrent process is running or being restarted.","ref":"Supervisor.html#delete_child/2"},{"type":"callback","title":"Supervisor.init/1","doc":"Callback invoked to start the supervisor and during hot code upgrades.\n\nDevelopers typically invoke `Supervisor.init/2` at the end of their\ninit callback to return the proper supervision flags.","ref":"Supervisor.html#c:init/1"},{"type":"function","title":"Supervisor.init/2","doc":"Receives a list of child specifications to initialize and a set of `options`.\n\nThis is typically invoked at the end of the `c:init/1` callback of\nmodule-based supervisors. See the sections \"Supervisor strategies and options\" and\n\"Module-based supervisors\" in the module documentation for more information.\n\nThis function returns a tuple containing the supervisor\nflags and child specifications.","ref":"Supervisor.html#init/2"},{"type":"function","title":"Examples - Supervisor.init/2","doc":"def init(_init_arg) do\n      children = [\n        {Counter, 0}\n      ]\n\n      Supervisor.init(children, strategy: :one_for_one)\n    end","ref":"Supervisor.html#init/2-examples"},{"type":"function","title":"Options - Supervisor.init/2","doc":"* `:strategy` - the supervision strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, or `:one_for_all`\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in seconds in which `:max_restarts`\n    applies. Defaults to `5`.\n\n  * `:auto_shutdown` - the automatic shutdown option. It can be either\n    `:never`, `:any_significant`, or `:all_significant`\n\nThe `:strategy` option is required and by default a maximum of 3 restarts\nis allowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies.","ref":"Supervisor.html#init/2-options"},{"type":"type","title":"Supervisor.init_option/0","doc":"Options given to `start_link/2` and `c:init/1`.","ref":"Supervisor.html#t:init_option/0"},{"type":"type","title":"Supervisor.module_spec/0","doc":"A module-based child spec.\n\nThis is a form of child spec that you can pass to functions such as `child_spec/2`,\n`start_child/2`, and `start_link/2`, in addition to the normalized `t:child_spec/0`.\n\nA module-based child spec can be:\n\n  * a **module** — the supervisor calls `module.child_spec([])` to retrieve the\n    child specification\n\n  * a **two-element tuple** in the shape of `{module, arg}` — the supervisor\n    calls `module.child_spec(arg)` to retrieve the child specification","ref":"Supervisor.html#t:module_spec/0"},{"type":"type","title":"Supervisor.name/0","doc":"The supervisor name.","ref":"Supervisor.html#t:name/0"},{"type":"type","title":"Supervisor.on_start/0","doc":"Return values of `start_link/2` and `start_link/3`.","ref":"Supervisor.html#t:on_start/0"},{"type":"type","title":"Supervisor.on_start_child/0","doc":"Return values of `start_child/2`.","ref":"Supervisor.html#t:on_start_child/0"},{"type":"type","title":"Supervisor.option/0","doc":"Option values used by the `start_link/2` and `start_link/3` functions.","ref":"Supervisor.html#t:option/0"},{"type":"type","title":"Supervisor.restart/0","doc":"Supported restart options.","ref":"Supervisor.html#t:restart/0"},{"type":"function","title":"Supervisor.restart_child/2","doc":"Restarts a child process identified by `child_id`.\n\nThe child specification must exist and the corresponding child process must not\nbe running.\n\nNote that for temporary children, the child specification is automatically deleted\nwhen the child terminates, and thus it is not possible to restart such children.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child, info}`,\nthe PID is added to the supervisor and this function returns the same value.\n\nIf the child process start function returns `:ignore`, the PID remains set to\n`:undefined` and this function returns `{:ok, :undefined}`.\n\nThis function may return an error with an appropriate error tuple if the\n`child_id` is not found, or if the current process is running or being\nrestarted.\n\nIf the child process start function returns an error tuple or an erroneous value,\nor if it fails, this function returns `{:error, error}`.","ref":"Supervisor.html#restart_child/2"},{"type":"type","title":"Supervisor.shutdown/0","doc":"Supported shutdown options.","ref":"Supervisor.html#t:shutdown/0"},{"type":"function","title":"Supervisor.start_child/2","doc":"Adds a child specification to `supervisor` and starts that child.\n\n`child_spec` should be a valid child specification. The child process will\nbe started as defined in the child specification.\n\nIf a child specification with the specified ID already exists, `child_spec` is\ndiscarded and this function returns an error with `:already_started` or\n`:already_present` if the corresponding child process is running or not,\nrespectively.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child,\ninfo}`, then child specification and PID are added to the supervisor and\nthis function returns the same value.\n\nIf the child process start function returns `:ignore`, the child specification\nis added to the supervisor, the PID is set to `:undefined` and this function\nreturns `{:ok, :undefined}`.\n\nIf the child process start function returns an error tuple or an erroneous\nvalue, or if it fails, the child specification is discarded and this function\nreturns `{:error, error}` where `error` is a term containing information about\nthe error and child specification.","ref":"Supervisor.html#start_child/2"},{"type":"function","title":"Supervisor.start_link/2","doc":"Starts a supervisor with the given children.\n\n`children` is a list of the following forms:\n\n  * a child specification (see `t:child_spec/0`)\n\n  * a module, where the supervisor calls `module.child_spec([])`\n    to retrieve the child specification (see `t:module_spec/0`)\n\n  * a `{module, arg}` tuple, where the supervisor calls `module.child_spec(arg)`\n    to retrieve the child specification (see `t:module_spec/0`)\n\n  * a (old) Erlang-style child specification (see\n    [`:supervisor.child_spec()`](`t::supervisor.child_spec/0`))\n\nA strategy is required to be provided through the `:strategy` option. See\n\"Supervisor strategies and options\" for examples and other options.\n\nThe options can also be used to register a supervisor name.\nThe supported values are described under the \"Name registration\"\nsection in the `GenServer` module docs.\n\nIf the supervisor and all child processes are successfully spawned\n(if the start function of each child process returns `{:ok, child}`,\n`{:ok, child, info}`, or `:ignore`), this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nIf the start function of any of the child processes fails or returns an error\ntuple or an erroneous value, the supervisor first terminates with reason\n`:shutdown` all the child processes that have already been started, and then\nterminates itself and returns `{:error, {:shutdown, reason}}`.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.","ref":"Supervisor.html#start_link/2"},{"type":"function","title":"Supervisor.start_link/3","doc":"Starts a module-based supervisor process with the given `module` and `init_arg`.\n\nTo start the supervisor, the `c:init/1` callback will be invoked in the given\n`module`, with `init_arg` as its argument. The `c:init/1` callback must return a\nsupervisor specification which can be created with the help of the `init/2`\nfunction.\n\nIf the `c:init/1` callback returns `:ignore`, this function returns\n`:ignore` as well and the supervisor terminates with reason `:normal`.\nIf it fails or returns an incorrect value, this function returns\n`{:error, term}` where `term` is a term with information about the\nerror, and the supervisor terminates with reason `term`.\n\nThe `:name` option can also be given in order to register a supervisor\nname, the supported values are described in the \"Name registration\"\nsection in the `GenServer` module docs.","ref":"Supervisor.html#start_link/3"},{"type":"function","title":"Supervisor.stop/3","doc":"Synchronously stops the given supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.","ref":"Supervisor.html#stop/3"},{"type":"type","title":"Supervisor.strategy/0","doc":"Supported strategies.","ref":"Supervisor.html#t:strategy/0"},{"type":"type","title":"Supervisor.sup_flags/0","doc":"The supervisor flags returned on init.","ref":"Supervisor.html#t:sup_flags/0"},{"type":"type","title":"Supervisor.supervisor/0","doc":"The supervisor reference.","ref":"Supervisor.html#t:supervisor/0"},{"type":"function","title":"Supervisor.terminate_child/2","doc":"Terminates the given child identified by `child_id`.\n\nThe process is terminated, if there's one. The child specification is\nkept unless the child is temporary.\n\nA non-temporary child process may later be restarted by the supervisor.\nThe child process can also be restarted explicitly by calling `restart_child/2`.\nUse `delete_child/2` to remove the child specification.\n\nIf successful, this function returns `:ok`. If there is no child\nspecification for the given child ID, this function returns\n`{:error, :not_found}`.","ref":"Supervisor.html#terminate_child/2"},{"type":"type","title":"Supervisor.type/0","doc":"Type of a supervised child.\n\nWhether the supervised child is a worker or a supervisor.","ref":"Supervisor.html#t:type/0"},{"type":"function","title":"Supervisor.which_children/1","doc":"Returns a list with information about all children of the given supervisor.\n\nNote that calling this function when supervising a large number of children\nunder low memory conditions can cause an out of memory exception.\n\nThis function returns a list of `{id, child, type, modules}` tuples, where:\n\n  * `id` - as defined in the child specification\n\n  * `child` - the PID of the corresponding child process, `:restarting` if the\n    process is about to be restarted, or `:undefined` if there is no such\n    process\n\n  * `type` - `:worker` or `:supervisor`, as specified by the child specification\n\n  * `modules` - as specified by the child specification","ref":"Supervisor.html#which_children/1"},{"type":"module","title":"Task","doc":"Conveniences for spawning and awaiting tasks.\n\nTasks are processes meant to execute one particular\naction throughout their lifetime, often with little or no\ncommunication with other processes. The most common use case\nfor tasks is to convert sequential code into concurrent code\nby computing a value asynchronously:\n\n    task = Task.async(fn -> do_some_work() end)\n    res = do_some_other_work()\n    res + Task.await(task)\n\nTasks spawned with `async` can be awaited on by their caller\nprocess (and only their caller) as shown in the example above.\nThey are implemented by spawning a process that sends a message\nto the caller once the given computation is performed.\n\nCompared to plain processes, started with `spawn/1`, tasks\ninclude monitoring metadata and logging in case of errors.\n\nBesides `async/1` and `await/2`, tasks can also be\nstarted as part of a supervision tree and dynamically spawned\non remote nodes. We will explore these scenarios next.","ref":"Task.html"},{"type":"module","title":"async and await - Task","doc":"One of the common uses of tasks is to convert sequential code\ninto concurrent code with `Task.async/1` while keeping its semantics.\nWhen invoked, a new process will be created, linked and monitored\nby the caller. Once the task action finishes, a message will be sent\nto the caller with the result.\n\n`Task.await/2` is used to read the message sent by the task.\n\nThere are two important things to consider when using `async`:\n\n  1. If you are using async tasks, you **must await** a reply\n     as they are *always* sent. If you are not expecting a reply,\n     consider using `Task.start_link/1` as detailed below.\n\n  2. Async tasks link the caller and the spawned process. This\n     means that, if the caller crashes, the task will crash\n     too and vice-versa. This is on purpose: if the process\n     meant to receive the result no longer exists, there is\n     no purpose in completing the computation. If this is not\n     desired, you will want to use supervised tasks, described\n     in a subsequent section.","ref":"Task.html#module-async-and-await"},{"type":"module","title":"Tasks are processes - Task","doc":"Tasks are processes and so data will need to be completely copied\nto them. Take the following code as an example:\n\n    large_data = fetch_large_data()\n    task = Task.async(fn -> do_some_work(large_data) end)\n    res = do_some_other_work()\n    res + Task.await(task)\n\nThe code above copies over all of `large_data`, which can be\nresource intensive depending on the size of the data.\nThere are two ways to address this.\n\nFirst, if you need to access only part of `large_data`,\nconsider extracting it before the task:\n\n    large_data = fetch_large_data()\n    subset_data = large_data.some_field\n    task = Task.async(fn -> do_some_work(subset_data) end)\n\nAlternatively, if you can move the data loading altogether\nto the task, it may be even better:\n\n    task = Task.async(fn ->\n      large_data = fetch_large_data()\n      do_some_work(large_data)\n    end)","ref":"Task.html#module-tasks-are-processes"},{"type":"module","title":"Dynamically supervised tasks - Task","doc":"The `Task.Supervisor` module allows developers to dynamically\ncreate multiple supervised tasks.\n\nA short example is:\n\n    {:ok, pid} = Task.Supervisor.start_link()\n\n    task =\n      Task.Supervisor.async(pid, fn ->\n        # Do something\n      end)\n\n    Task.await(task)\n\nHowever, in the majority of cases, you want to add the task supervisor\nto your supervision tree:\n\n    Supervisor.start_link([\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ], strategy: :one_for_one)\n\nAnd now you can use async/await by passing the name of\nthe supervisor instead of the pid:\n\n    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n      # Do something\n    end)\n    |> Task.await()\n\nWe encourage developers to rely on supervised tasks as much as possible.\nSupervised tasks improve the visibility of how many tasks are running\nat a given moment and enable a variety of patterns that give you\nexplicit control on how to handle the results, errors, and timeouts.\nHere is a summary:\n\n  * Using `Task.Supervisor.start_child/2` allows you to start a fire-and-forget\n    task when you don't care about its results or if it completes successfully or not.\n\n  * Using `Task.Supervisor.async/2` + `Task.await/2` allows you to execute\n    tasks concurrently and retrieve its result. If the task fails,\n    the caller will also fail.\n\n  * Using `Task.Supervisor.async_nolink/2` + `Task.yield/2` + `Task.shutdown/2`\n    allows you to execute tasks concurrently and retrieve their results\n    or the reason they failed within a given time frame. If the task fails,\n    the caller won't fail. You will receive the error reason either on\n    `yield` or `shutdown`.\n\nFurthermore, the supervisor guarantees all tasks terminate within a\nconfigurable shutdown period when your application shuts down. See the\n`Task.Supervisor` module for details on the supported operations.","ref":"Task.html#module-dynamically-supervised-tasks"},{"type":"module","title":"Distributed tasks - Task","doc":"With `Task.Supervisor`, it is easy to dynamically start tasks across nodes:\n\n    # First on the remote node named :remote@local\n    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n\n    # Then on the local client node\n    supervisor = {MyApp.DistSupervisor, :remote@local}\n    Task.Supervisor.async(supervisor, MyMod, :my_fun, [arg1, arg2, arg3])\n\nNote that, as above, when working with distributed tasks, one should use the\n`Task.Supervisor.async/5` function that expects explicit module, function,\nand arguments, instead of `Task.Supervisor.async/3` that works with anonymous\nfunctions. That's because anonymous functions expect the same module version\nto exist on all involved nodes. Check the `Agent` module documentation for\nmore information on distributed processes as the limitations described there\napply to the whole ecosystem.","ref":"Task.html#module-distributed-tasks"},{"type":"module","title":"Statically supervised tasks - Task","doc":"The `Task` module implements the `child_spec/1` function, which\nallows it to be started directly under a regular `Supervisor` -\ninstead of a `Task.Supervisor` - by passing a tuple with a function\nto run:\n\n    Supervisor.start_link([\n      {Task, fn -> :some_work end}\n    ], strategy: :one_for_one)\n\nThis is often useful when you need to execute some steps while\nsetting up your supervision tree. For example: to warm up caches,\nlog the initialization status, and such.\n\nIf you don't want to put the Task code directly under the `Supervisor`,\nyou can wrap the `Task` in its own module, similar to how you would\ndo with a `GenServer` or an `Agent`:\n\n    defmodule MyTask do\n      use Task\n\n      def start_link(arg) do\n        Task.start_link(__MODULE__, :run, [arg])\n      end\n\n      def run(arg) do\n        # ...\n      end\n    end\n\nAnd then passing it to the supervisor:\n\n    Supervisor.start_link([\n      {MyTask, arg}\n    ], strategy: :one_for_one)\n\nSince these tasks are supervised and not directly linked to the caller,\nthey cannot be awaited on. By default, the functions `Task.start/1`\nand `Task.start_link/1` are for fire-and-forget tasks, where you don't\ncare about the results or if it completes successfully or not.\n\n> #### `use Task` {: .info}\n>\n> When you `use Task`, the `Task` module will define a\n> `child_spec/1` function, so your module can be used\n> as a child in a supervision tree.\n\n`use Task` defines a `child_spec/1` function, allowing the\ndefined module to be put under a supervision tree. The generated\n`child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:temporary`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nOpposite to `GenServer`, `Agent` and `Supervisor`, a Task has\na default `:restart` of `:temporary`. This means the task will\nnot be restarted even if it crashes. If you desire the task to\nbe restarted for non-successful exits, do:\n\n    use Task, restart: :transient\n\nIf you want the task to always be restarted:\n\n    use Task, restart: :permanent\n\nSee the \"Child specification\" section in the `Supervisor` module\nfor more detailed information. The `@doc` annotation immediately\npreceding `use Task` will be attached to the generated `child_spec/1`\nfunction.","ref":"Task.html#module-statically-supervised-tasks"},{"type":"module","title":"Ancestor and Caller Tracking - Task","doc":"Whenever you start a new process, Elixir annotates the parent of that process\nthrough the `$ancestors` key in the process dictionary. This is often used to\ntrack the hierarchy inside a supervision tree.\n\nFor example, we recommend developers to always start tasks under a supervisor.\nThis provides more visibility and allows you to control how those tasks are\nterminated when a node shuts down. That might look something like\n`Task.Supervisor.start_child(MySupervisor, task_function)`. This means\nthat, although your code is the one invoking the task, the actual ancestor of\nthe task is the supervisor, as the supervisor is the one effectively starting it.\n\nTo track the relationship between your code and the task, we use the `$callers`\nkey in the process dictionary. Therefore, assuming the `Task.Supervisor` call\nabove, we have:\n\n    [your code] -- calls --> [supervisor] ---- spawns --> [task]\n\nWhich means we store the following relationships:\n\n    [your code]              [supervisor] <-- ancestor -- [task]\n        ^                                                  |\n        |--------------------- caller ---------------------|\n\nThe list of callers of the current process can be retrieved from the Process\ndictionary with `Process.get(:\"$callers\")`. This will return either `nil` or\na list `[pid_n, ..., pid2, pid1]` with at least one entry where `pid_n` is\nthe PID that called the current process, `pid2` called `pid_n`, and `pid2` was\ncalled by `pid1`.\n\nIf a task crashes, the callers field is included as part of the log message\nmetadata under the `:callers` key.","ref":"Task.html#module-ancestor-and-caller-tracking"},{"type":"function","title":"Task.__struct__/0","doc":"The Task struct.\n\nIt contains these fields:\n\n  * `:mfa` - a three-element tuple containing the module, function name,\n    and arity invoked to start the task in `async/1` and `async/3`\n\n  * `:owner` - the PID of the process that started the task\n\n  * `:pid` - the PID of the task process; `nil` if there is no process\n    specifically assigned for the task\n\n  * `:ref` - an opaque term used as the task monitor reference","ref":"Task.html#__struct__/0"},{"type":"function","title":"Task.async/1","doc":"Starts a task that must be awaited on.\n\n`fun` must be a zero-arity anonymous function. This function\nspawns a process that is linked to and monitored by the caller\nprocess. A `Task` struct is returned containing the relevant\ninformation.\n\nIf you start an `async`, you **must await**. This is either done\nby calling `Task.await/2` or `Task.yield/2` followed by\n`Task.shutdown/2` on the returned task. Alternatively, if you\nspawn a task inside a `GenServer`, then the `GenServer` will\nautomatically await for you and call `c:GenServer.handle_info/2`\nwith the task response and associated `:DOWN` message.\n\nRead the `Task` module documentation for more information about\nthe general usage of async tasks.","ref":"Task.html#async/1"},{"type":"function","title":"Linking - Task.async/1","doc":"This function spawns a process that is linked to and monitored\nby the caller process. The linking part is important because it\naborts the task if the parent process dies. It also guarantees\nthe code before async/await has the same properties after you\nadd the async call. For example, imagine you have this:\n\n    x = heavy_fun()\n    y = some_fun()\n    x + y\n\nNow you want to make the `heavy_fun()` async:\n\n    x = Task.async(&heavy_fun/0)\n    y = some_fun()\n    Task.await(x) + y\n\nAs before, if `heavy_fun/0` fails, the whole computation will\nfail, including the caller process. If you don't want the task\nto fail then you must change the `heavy_fun/0` code in the\nsame way you would achieve it if you didn't have the async call.\nFor example, to either return `{:ok, val} | :error` results or,\nin more extreme cases, by using `try/rescue`. In other words,\nan asynchronous task should be thought of as an extension of the\ncaller process rather than a mechanism to isolate it from all errors.\n\nIf you don't want to link the caller to the task, then you\nmust use a supervised task with `Task.Supervisor` and call\n`Task.Supervisor.async_nolink/2`.\n\nIn any case, avoid any of the following:\n\n  * Setting `:trap_exit` to `true` - trapping exits should be\n    used only in special circumstances as it would make your\n    process immune to not only exits from the task but from\n    any other processes.\n\n    Moreover, even when trapping exits, calling `await` will\n    still exit if the task has terminated without sending its\n    result back.\n\n  * Unlinking the task process started with `async`/`await`.\n    If you unlink the processes and the task does not belong\n    to any supervisor, you may leave dangling tasks in case\n    the caller process dies.","ref":"Task.html#async/1-linking"},{"type":"function","title":"Metadata - Task.async/1","doc":"The task created with this function stores `:erlang.apply/2` in\nits `:mfa` metadata field, which is used internally to apply\nthe anonymous function. Use `async/3` if you want another function\nto be used as metadata.","ref":"Task.html#async/1-metadata"},{"type":"function","title":"Task.async/3","doc":"Starts a task that must be awaited on.\n\nSimilar to `async/1` except the function to be started is\nspecified by the given `module`, `function_name`, and `args`.\nThe `module`, `function_name`, and its arity are stored as\na tuple in the `:mfa` field for reflection purposes.","ref":"Task.html#async/3"},{"type":"function","title":"Task.async_stream/3","doc":"Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nWorks the same as `async_stream/5` but with an anonymous function instead of a\nmodule-function-arguments tuple. `fun` must be a one-arity anonymous function.\n\nEach `enumerable` element is passed as argument to the given function `fun` and\nprocessed by its own task. The tasks will be linked to the caller process, similarly\nto `async/1`.","ref":"Task.html#async_stream/3"},{"type":"function","title":"Example - Task.async_stream/3","doc":"Count the code points in each string asynchronously, then add the counts together using reduce.\n\n    iex> strings = [\"long string\", \"longer string\", \"there are many of these\"]\n    iex> stream = Task.async_stream(strings, fn text -> text |> String.codepoints() |> Enum.count() end)\n    iex> Enum.reduce(stream, 0, fn {:ok, num}, acc -> num + acc end)\n    47\n\nSee `async_stream/5` for discussion, options, and more examples.","ref":"Task.html#async_stream/3-example"},{"type":"function","title":"Task.async_stream/5","doc":"Returns a stream where the given function (`module` and `function_name`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element of `enumerable` will be prepended to the given `args` and\nprocessed by its own task. Those tasks will be linked to an intermediate\nprocess that is then linked to the caller process. This means a failure\nin a task terminates the caller process and a failure in the caller\nprocess terminates all tasks.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nIt's possible to have `{:exit, {element, reason}}` for exits\nusing the `:zip_input_on_exit` option. The order of results depends\non the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nConsider using `Task.Supervisor.async_stream/6` to start tasks\nunder a supervisor. If you find yourself trapping exits to ensure\nerrors in the tasks do not terminate the caller process, consider\nusing `Task.Supervisor.async_stream_nolink/6` to start tasks that\nare not linked to the caller process.","ref":"Task.html#async_stream/5"},{"type":"function","title":"Options - Task.async_stream/5","doc":"* `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. When the output is ordered, Elixir may need to\n    buffer results to emit them in the original order. Setting this option\n    to false disables the need to buffer at the cost of removing ordering.\n    This is also useful when you're using the tasks only for the side effects.\n    Note that regardless of what `:ordered` is set to, the tasks will\n    process asynchronously. If you need to process elements in order,\n    consider using `Enum.map/2` or `Enum.each/2` instead. Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time (in milliseconds or `:infinity`)\n    each task is allowed to execute for. Defaults to `5000`.\n\n  * `:on_timeout` - what to do when a task times out. The possible\n    values are:\n    * `:exit` (default) - the caller (the process that spawned the tasks) exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:zip_input_on_exit` - (since v1.14.0) adds the original\n    input to `:exit` tuples. The value emitted for that task is\n    `{:exit, {input, reason}}`, where `input` is the collection element\n    that caused an exited during processing. Defaults to `false`.","ref":"Task.html#async_stream/5-options"},{"type":"function","title":"Example - Task.async_stream/5","doc":"Let's build a stream and then enumerate it:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)\n\nThe concurrency can be increased or decreased using the `:max_concurrency`\noption. For example, if the tasks are IO heavy, the value can be increased:\n\n    max_concurrency = System.schedulers_online() * 2\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], max_concurrency: max_concurrency)\n    Enum.to_list(stream)\n\nIf you do not care about the results of the computation, you can run\nthe stream with `Stream.run/1`. Also set `ordered: false`, as you don't\ncare about the order of the results either:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], ordered: false)\n    Stream.run(stream)","ref":"Task.html#async_stream/5-example"},{"type":"function","title":"First async tasks to complete - Task.async_stream/5","doc":"You can also use `async_stream/3` to execute M tasks and find the N tasks\nto complete. For example:\n\n    [\n      &heavy_call_1/0,\n      &heavy_call_2/0,\n      &heavy_call_3/0\n    ]\n    |> Task.async_stream(fn fun -> fun.() end, ordered: false, max_concurrency: 3)\n    |> Stream.filter(&match?({:ok, _}, &1))\n    |> Enum.take(2)\n\nIn the example above, we are executing three tasks and waiting for the\nfirst 2 to complete. We use `Stream.filter/2` to restrict ourselves only\nto successfully completed tasks, and then use `Enum.take/2` to retrieve\nN items. Note it is important to set both `ordered: false` and\n`max_concurrency: M`, where M is the number of tasks, to make sure all\ncalls execute concurrently.","ref":"Task.html#async_stream/5-first-async-tasks-to-complete"},{"type":"function","title":"Attention: unbound async + take - Task.async_stream/5","doc":"If you want to potentially process a high number of items and keep only\npart of the results, you may end-up processing more items than desired.\nLet's see an example:\n\n    1..100\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.take(10)\n\nRunning the example above in a machine with 8 cores will process 16 items,\neven though you want only 10 elements, since `async_stream/3` process items\nconcurrently. That's because it will process 8 elements at once. Then all 8\nelements complete at roughly the same time, causing 8 elements to be kicked\noff for processing. Out of these extra 8, only 2 will be used, and the rest\nwill be terminated.\n\nDepending on the problem, you can filter or limit the number of elements\nupfront:\n\n    1..100\n    |> Stream.take(10)\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.to_list()\n\nIn other cases, you likely want to tweak `:max_concurrency` to limit how\nmany elements may be over processed at the cost of reducing concurrency.\nYou can also set the number of elements to take to be a multiple of\n`:max_concurrency`. For instance, setting `max_concurrency: 5` in the\nexample above.","ref":"Task.html#async_stream/5-attention-unbound-async-take"},{"type":"type","title":"Task.async_stream_option/0","doc":"Options given to `async_stream` functions.","ref":"Task.html#t:async_stream_option/0"},{"type":"function","title":"Task.await/2","doc":"Awaits a task reply and returns it.\n\nIn case the task process dies, the caller process will exit with the same\nreason as the task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nIf the task process is linked to the caller process which is the case when\na task is started with `async`, then the task process will also exit. If the\ntask process is trapping exits or not linked to the caller process, then it\nwill continue to run.\n\nThis function assumes the task's monitor is still active or the monitor's\n`:DOWN` message is in the message queue. If it has been demonitored, or the\nmessage already received, this function will wait for the duration of the\ntimeout awaiting the message.\n\nThis function can only be called once for any given task. If you want\nto be able to check multiple times if a long-running task has finished\nits computation, use `yield/2` instead.","ref":"Task.html#await/2"},{"type":"function","title":"Examples - Task.await/2","doc":"iex> task = Task.async(fn -> 1 + 1 end)\n    iex> Task.await(task)\n    2","ref":"Task.html#await/2-examples"},{"type":"function","title":"Compatibility with OTP behaviours - Task.await/2","doc":"It is not recommended to `await` a long-running task inside an OTP\nbehaviour such as `GenServer`. Instead, you should match on the message\ncoming from a task inside your `c:GenServer.handle_info/2` callback.\n\nA GenServer will receive two messages on `handle_info/2`:\n\n  * `{ref, result}` - the reply message where `ref` is the monitor\n    reference returned by the `task.ref` and `result` is the task\n    result\n\n  * `{:DOWN, ref, :process, pid, reason}` - since all tasks are also\n    monitored, you will also receive the `:DOWN` message delivered by\n    `Process.monitor/1`. If you receive the `:DOWN` message without a\n    a reply, it means the task crashed\n\nAnother consideration to have in mind is that tasks started by `Task.async/1`\nare always linked to their callers and you may not want the GenServer to\ncrash if the task crashes. Therefore, it is preferable to instead use\n`Task.Supervisor.async_nolink/3` inside OTP behaviours. For completeness, here\nis an example of a GenServer that start tasks and handles their results:\n\n    defmodule GenServerTaskExample do\n      use GenServer\n\n      def start_link(opts) do\n        GenServer.start_link(__MODULE__, :ok, opts)\n      end\n\n      def init(_opts) do\n        # We will keep all running tasks in a map\n        {:ok, %{tasks: %{}}}\n      end\n\n      # Imagine we invoke a task from the GenServer to access a URL...\n      def handle_call(:some_message, _from, state) do\n        url = ...\n        task = Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn -> fetch_url(url) end)\n\n        # After we start the task, we store its reference and the url it is fetching\n        state = put_in(state.tasks[task.ref], url)\n\n        {:reply, :ok, state}\n      end\n\n      # If the task succeeds...\n      def handle_info({ref, result}, state) do\n        # The task succeed so we can demonitor its reference\n        Process.demonitor(ref, [:flush])\n\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"Got #{inspect(result)} for URL #{inspect url}\"\n        {:noreply, state}\n      end\n\n      # If the task fails...\n      def handle_info({:DOWN, ref, _, _, reason}, state) do\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"URL #{inspect url} failed with reason #{inspect(reason)}\"\n        {:noreply, state}\n      end\n    end\n\nWith the server defined, you will want to start the task supervisor\nabove and the GenServer in your supervision tree:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor},\n      {GenServerTaskExample, name: MyApp.GenServerTaskExample}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)","ref":"Task.html#await/2-compatibility-with-otp-behaviours"},{"type":"function","title":"Task.await_many/2","doc":"Awaits replies from multiple tasks and returns them.\n\nThis function receives a list of tasks and waits for their replies in the\ngiven time interval. It returns a list of the results, in the same order as\nthe tasks supplied in the `tasks` input argument.\n\nIf any of the task processes dies, the caller process will exit with the same\nreason as that task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nAny task processes that are linked to the caller process (which is the case\nwhen a task is started with `async`) will also exit. Any task processes that\nare trapping exits or not linked to the caller process will continue to run.\n\nThis function assumes the tasks' monitors are still active or the monitor's\n`:DOWN` message is in the message queue. If any tasks have been demonitored,\nor the message already received, this function will wait for the duration of\nthe timeout.\n\nThis function can only be called once for any given task. If you want to be\nable to check multiple times if a long-running task has finished its\ncomputation, use `yield_many/2` instead.","ref":"Task.html#await_many/2"},{"type":"function","title":"Compatibility with OTP behaviours - Task.await_many/2","doc":"It is not recommended to `await` long-running tasks inside an OTP behaviour\nsuch as `GenServer`. See `await/2` for more information.","ref":"Task.html#await_many/2-compatibility-with-otp-behaviours"},{"type":"function","title":"Examples - Task.await_many/2","doc":"iex> tasks = [\n    ...>   Task.async(fn -> 1 + 1 end),\n    ...>   Task.async(fn -> 2 + 3 end)\n    ...> ]\n    iex> Task.await_many(tasks)\n    [2, 5]","ref":"Task.html#await_many/2-examples"},{"type":"function","title":"Task.child_spec/1","doc":"Returns a specification to start a task under a supervisor.\n\n`arg` is passed as the argument to `Task.start_link/1` in the `:start` field\nof the spec.\n\nFor more information, see the `Supervisor` module,\nthe `Supervisor.child_spec/2` function and the `t:Supervisor.child_spec/0` type.","ref":"Task.html#child_spec/1"},{"type":"function","title":"Task.completed/1","doc":"Starts a task that immediately completes with the given `result`.\n\nUnlike `async/1`, this task does not spawn a linked process. It can\nbe awaited or yielded like any other task.","ref":"Task.html#completed/1"},{"type":"function","title":"Usage - Task.completed/1","doc":"In some cases, it is useful to create a \"completed\" task that represents\na task that has already run and generated a result. For example, when\nprocessing data you may be able to determine that certain inputs are\ninvalid before dispatching them for further processing:\n\n    def process(data) do\n      tasks =\n        for entry <- data do\n          if invalid_input?(entry) do\n            Task.completed({:error, :invalid_input})\n          else\n            Task.async(fn -> further_process(entry) end)\n          end\n        end\n\n      Task.await_many(tasks)\n    end\n\nIn many cases, `Task.completed/1` may be avoided in favor of returning the\nresult directly.  You should generally only require this variant when working\nwith mixed asynchrony, when a group of inputs will be handled partially\nsynchronously and partially asynchronously.","ref":"Task.html#completed/1-usage"},{"type":"function","title":"Task.ignore/1","doc":"Ignores an existing task.\n\nThis means the task will continue running, but it will be unlinked\nand you can no longer yield, await or shut it down.\n\nReturns `{:ok, reply}` if the reply is received before ignoring the task,\n`{:exit, reason}` if the task died before ignoring it, otherwise `nil`.\n\nImportant: avoid using [`Task.async/1,3`](`async/1`) and then immediately ignoring\nthe task. If you want to start tasks you don't care about their\nresults, use `Task.Supervisor.start_child/2` instead.","ref":"Task.html#ignore/1"},{"type":"opaque","title":"Task.ref/0","doc":"The task opaque reference.","ref":"Task.html#t:ref/0"},{"type":"function","title":"Task.shutdown/2","doc":"Unlinks and shuts down the task, and then checks for a reply.\n\nReturns `{:ok, reply}` if the reply is received while shutting down the task,\n`{:exit, reason}` if the task died, otherwise `nil`. Once shut down,\nyou can no longer await or yield it.\n\nThe second argument is either a timeout or `:brutal_kill`. In case\nof a timeout, a `:shutdown` exit signal is sent to the task process\nand if it does not exit within the timeout, it is killed. With `:brutal_kill`\nthe task is killed straight away. In case the task terminates abnormally\n(possibly killed by another process), this function will exit with the same reason.\n\nIt is not required to call this function when terminating the caller, unless\nexiting with reason `:normal` or if the task is trapping exits. If the caller is\nexiting with a reason other than `:normal` and the task is not trapping exits, the\ncaller's exit signal will stop the task. The caller can exit with reason\n`:shutdown` to shut down all of its linked processes, including tasks, that\nare not trapping exits without generating any log messages.\n\nIf there is no process linked to the task, such as tasks started by\n`Task.completed/1`, we check for a response or error accordingly, but without\nshutting a process down.\n\nIf a task's monitor has already been demonitored or received and there is not\na response waiting in the message queue this function will return\n`{:exit, :noproc}` as the result or exit reason can not be determined.","ref":"Task.html#shutdown/2"},{"type":"function","title":"Task.start/1","doc":"Starts a task.\n\n`fun` must be a zero-arity anonymous function.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option.","ref":"Task.html#start/1"},{"type":"function","title":"Task.start/3","doc":"Starts a task.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option.","ref":"Task.html#start/3"},{"type":"function","title":"Task.start_link/1","doc":"Starts a task as part of a supervision tree with the given `fun`.\n\n`fun` must be a zero-arity anonymous function.\n\nThis is used to start a statically supervised task under a supervision tree.","ref":"Task.html#start_link/1"},{"type":"function","title":"Task.start_link/3","doc":"Starts a task as part of a supervision tree with the given\n`module`, `function`, and `args`.\n\nThis is used to start a statically supervised task under a supervision tree.","ref":"Task.html#start_link/3"},{"type":"type","title":"Task.t/0","doc":"The Task type.\n\nSee [`%Task{}`](`__struct__/0`) for information about each field of the structure.","ref":"Task.html#t:t/0"},{"type":"function","title":"Task.yield/2","doc":"Temporarily blocks the caller process waiting for a task reply.\n\nReturns `{:ok, reply}` if the reply is received, `nil` if\nno reply has arrived, or `{:exit, reason}` if the task has already\nexited. Keep in mind that normally a task failure also causes\nthe process owning the task to exit. Therefore this function can\nreturn `{:exit, reason}` if at least one of the conditions below apply:\n\n  * the task process exited with the reason `:normal`\n  * the task isn't linked to the caller (the task was started\n    with `Task.Supervisor.async_nolink/2` or `Task.Supervisor.async_nolink/4`)\n  * the caller is trapping exits\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the time runs out before a message from the task is received,\nthis function will return `nil` and the monitor will remain active. Therefore\n`yield/2` can be called multiple times on the same task.\n\nThis function assumes the task's monitor is still active or the\nmonitor's `:DOWN` message is in the message queue. If it has been\ndemonitored or the message already received, this function will wait\nfor the duration of the timeout awaiting the message.\n\nIf you intend to shut the task down if it has not responded within `timeout`\nmilliseconds, you should chain this together with `shutdown/1`, like so:\n\n    case Task.yield(task, timeout) || Task.shutdown(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warning(\"Failed to get a result in #{timeout}ms\")\n        nil\n    end\n\nIf you intend to check on the task but leave it running after the timeout,\nyou can chain this together with `ignore/1`, like so:\n\n    case Task.yield(task, timeout) || Task.ignore(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warning(\"Failed to get a result in #{timeout}ms\")\n        nil\n    end\n\nThat ensures that if the task completes after the `timeout` but before `shutdown/1`\nhas been called, you will still get the result, since `shutdown/1` is designed to\nhandle this case and return the result.","ref":"Task.html#yield/2"},{"type":"function","title":"Task.yield_many/2","doc":"Yields to multiple tasks in the given time interval.\n\nThis function receives a list of tasks and waits for their\nreplies in the given time interval. It returns a list\nof two-element tuples, with the task as the first element\nand the yielded result as the second. The tasks in the returned\nlist will be in the same order as the tasks supplied in the `tasks`\ninput argument.\n\nSimilarly to `yield/2`, each task's result will be\n\n  * `{:ok, term}` if the task has successfully reported its\n    result back in the given time interval\n  * `{:exit, reason}` if the task has died\n  * `nil` if the task keeps running, either because a limit\n    has been reached or past the timeout\n\nCheck `yield/2` for more information.","ref":"Task.html#yield_many/2"},{"type":"function","title":"Example - Task.yield_many/2","doc":"`Task.yield_many/2` allows developers to spawn multiple tasks\nand retrieve the results received in a given time frame.\nIf we combine it with `Task.shutdown/2` (or `Task.ignore/1`),\nit allows us to gather those results and cancel (or ignore)\nthe tasks that have not replied in time.\n\nLet's see an example.\n\n    tasks =\n      for i <- 1..10 do\n        Task.async(fn ->\n          Process.sleep(i * 1000)\n          i\n        end)\n      end\n\n    tasks_with_results = Task.yield_many(tasks, timeout: 5000)\n\n    results =\n      Enum.map(tasks_with_results, fn {task, res} ->\n        # Shut down the tasks that did not reply nor exit\n        res || Task.shutdown(task, :brutal_kill)\n      end)\n\n    # Here we are matching only on {:ok, value} and\n    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n    for {:ok, value} <- results do\n      IO.inspect(value)\n    end\n\nIn the example above, we create tasks that sleep from 1\nup to 10 seconds and return the number of seconds they slept for.\nIf you execute the code all at once, you should see 1 up to 5\nprinted, as those were the tasks that have replied in the\ngiven time. All other tasks will have been shut down using\nthe `Task.shutdown/2` call.\n\nAs a convenience, you can achieve a similar behavior to above\nby specifying the `:on_timeout` option to be `:kill_task` (or\n`:ignore`). See `Task.await_many/2` if you would rather exit\nthe caller process on timeout.","ref":"Task.html#yield_many/2-example"},{"type":"function","title":"Options - Task.yield_many/2","doc":"The second argument is either a timeout or options, which defaults\nto this:\n\n  * `:limit` - the maximum amount of tasks to wait for.\n    If the limit is reached before the timeout, this function\n    returns immediately without triggering the `:on_timeout` behaviour\n\n  * `:timeout` - the maximum amount of time (in milliseconds or `:infinity`)\n    each task is allowed to execute for. Defaults to `5000`.\n\n  * `:on_timeout` - what to do when a task times out. The possible\n    values are:\n    * `:nothing` - do nothing (default). The tasks can still be\n      awaited on, yielded on, ignored, or shut down later.\n    * `:ignore` - the results of the task will be ignored.\n    * `:kill_task` - the task that timed out is killed.","ref":"Task.html#yield_many/2-options"},{"type":"module","title":"Task.Supervisor","doc":"A task supervisor.\n\nThis module defines a supervisor which can be used to dynamically\nsupervise tasks.\n\nA task supervisor is started with no children, often under a\nsupervisor and a name:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe options given in the child specification are documented in `start_link/1`.\n\nOnce started, you can start tasks directly under the supervisor, for example:\n\n    task = Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n      :do_some_work\n    end)\n\nSee the `Task` module for more examples.","ref":"Task.Supervisor.html"},{"type":"module","title":"Scalability and partitioning - Task.Supervisor","doc":"The `Task.Supervisor` is a single process responsible for starting\nother processes. In some applications, the `Task.Supervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `Task.Supervisor` and then pick a random instance to start\nthe task on.\n\nInstead of:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ]\n\nand:\n\n    Task.Supervisor.async(MyApp.TaskSupervisor, fn -> :do_some_work end)\n\nYou can do this:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: Task.Supervisor,\n       name: MyApp.TaskSupervisors}\n    ]\n\nand then:\n\n    Task.Supervisor.async(\n      {:via, PartitionSupervisor, {MyApp.TaskSupervisors, self()}},\n      fn -> :do_some_work end\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `Task.Supervisor` by name, you call it through the\npartition supervisor using the `{:via, PartitionSupervisor, {name, key}}`\nformat, where `name` is the name of the partition supervisor and `key`\nis the routing key. We picked `self()` as the routing key, which means\neach process will be assigned one of the existing task supervisors.\nRead the `PartitionSupervisor` docs for more information.","ref":"Task.Supervisor.html#module-scalability-and-partitioning"},{"type":"module","title":"Name registration - Task.Supervisor","doc":"A `Task.Supervisor` is bound to the same name registration rules as a\n`GenServer`. Read more about them in the `GenServer` docs.","ref":"Task.Supervisor.html#module-name-registration"},{"type":"function","title":"Task.Supervisor.async/3","doc":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/1` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.","ref":"Task.Supervisor.html#async/3"},{"type":"function","title":"Options - Task.Supervisor.async/3","doc":"* `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n    The tasks must trap exits for the timeout to have an effect.","ref":"Task.Supervisor.html#async/3-options"},{"type":"function","title":"Task.Supervisor.async/5","doc":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/1` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.","ref":"Task.Supervisor.html#async/5"},{"type":"function","title":"Options - Task.Supervisor.async/5","doc":"* `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n    The tasks must trap exits for the timeout to have an effect.","ref":"Task.Supervisor.html#async/5-options"},{"type":"function","title":"Task.Supervisor.async_nolink/3","doc":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/1` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\nNote this function requires the task supervisor to have `:temporary`\nas the `:restart` option (the default), as `async_nolink/3` keeps a\ndirect reference to the task which is lost if the task is restarted.","ref":"Task.Supervisor.html#async_nolink/3"},{"type":"function","title":"Options - Task.Supervisor.async_nolink/3","doc":"* `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n    The tasks must trap exits for the timeout to have an effect.","ref":"Task.Supervisor.html#async_nolink/3-options"},{"type":"function","title":"Compatibility with OTP behaviours - Task.Supervisor.async_nolink/3","doc":"If you create a task using `async_nolink` inside an OTP behaviour\nlike `GenServer`, you should match on the message coming from the\ntask inside your `c:GenServer.handle_info/2` callback.\n\nThe reply sent by the task will be in the format `{ref, result}`,\nwhere `ref` is the monitor reference held by the task struct\nand `result` is the return value of the task function.\n\nKeep in mind that, regardless of how the task created with `async_nolink`\nterminates, the caller's process will always receive a `:DOWN` message\nwith the same `ref` value that is held by the task struct. If the task\nterminates normally, the reason in the `:DOWN` message will be `:normal`.","ref":"Task.Supervisor.html#async_nolink/3-compatibility-with-otp-behaviours"},{"type":"function","title":"Examples - Task.Supervisor.async_nolink/3","doc":"Typically, you use `async_nolink/3` when there is a reasonable expectation that\nthe task may fail, and you don't want it to take down the caller. Let's see an\nexample where a `GenServer` is meant to run a single task and track its status:\n\n    defmodule MyApp.Server do\n      use GenServer\n\n      # ...\n\n      def start_task do\n        GenServer.call(__MODULE__, :start_task)\n      end\n\n      # In this case the task is already running, so we just return :ok.\n      def handle_call(:start_task, _from, %{ref: ref} = state) when is_reference(ref) do\n        {:reply, :ok, state}\n      end\n\n      # The task is not running yet, so let's start it.\n      def handle_call(:start_task, _from, %{ref: nil} = state) do\n        task =\n          Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn ->\n            ...\n          end)\n\n        # We return :ok and the server will continue running\n        {:reply, :ok, %{state | ref: task.ref}}\n      end\n\n      # The task completed successfully\n      def handle_info({ref, answer}, %{ref: ref} = state) do\n        # We don't care about the DOWN message now, so let's demonitor and flush it\n        Process.demonitor(ref, [:flush])\n        # Do something with the result and then return\n        {:noreply, %{state | ref: nil}}\n      end\n\n      # The task failed\n      def handle_info({:DOWN, ref, :process, _pid, _reason}, %{ref: ref} = state) do\n        # Log and possibly restart the task...\n        {:noreply, %{state | ref: nil}}\n      end\n    end","ref":"Task.Supervisor.html#async_nolink/3-examples"},{"type":"function","title":"Task.Supervisor.async_nolink/5","doc":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/1` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\nNote this function requires the task supervisor to have `:temporary`\nas the `:restart` option (the default), as `async_nolink/5` keeps a\ndirect reference to the task which is lost if the task is restarted.","ref":"Task.Supervisor.html#async_nolink/5"},{"type":"function","title":"Task.Supervisor.async_stream/4","doc":"Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and linked to the caller process, similarly to `async/3`.\n\nSee `async_stream/6` for discussion, options, and examples.","ref":"Task.Supervisor.html#async_stream/4"},{"type":"function","title":"Task.Supervisor.async_stream/6","doc":"Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element will be prepended to the given `args` and processed by its\nown task. The tasks will be spawned under the given `supervisor` and\nlinked to the caller process, similarly to `async/5`.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nThe order of results depends on the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nIf you find yourself trapping exits to handle exits inside\nthe async stream, consider using `async_stream_nolink/6` to start tasks\nthat are not linked to the calling process.","ref":"Task.Supervisor.html#async_stream/6"},{"type":"function","title":"Options - Task.Supervisor.async_stream/6","doc":"* `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. This option is useful when you have large\n    streams and don't want to buffer results before they are delivered.\n    This is also useful when you're using the tasks for side effects.\n    Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time to wait (in milliseconds)\n    without receiving a task reply (across all running tasks).\n    Defaults to `5000`.\n\n  * `:on_timeout` - what do to when a task times out. The possible\n    values are:\n    * `:exit` (default) - the process that spawned the tasks exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:zip_input_on_exit` - (since v1.14.0) adds the original\n    input to `:exit` tuples. The value emitted for that task is\n    `{:exit, {input, reason}}`, where `input` is the collection element\n    that caused an exited during processing. Defaults to `false`.\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value. Defaults to `5000` milliseconds.\n    The tasks must trap exits for the timeout to have an effect.","ref":"Task.Supervisor.html#async_stream/6-options"},{"type":"function","title":"Examples - Task.Supervisor.async_stream/6","doc":"Let's build a stream and then enumerate it:\n\n    stream = Task.Supervisor.async_stream(MySupervisor, collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)","ref":"Task.Supervisor.html#async_stream/6-examples"},{"type":"function","title":"Task.Supervisor.async_stream_nolink/4","doc":"Returns a stream that runs the given `function` concurrently on each\nelement in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and will not be linked to the caller process, similarly\nto `async_nolink/3`.\n\nSee `async_stream/6` for discussion and examples.","ref":"Task.Supervisor.html#async_stream_nolink/4"},{"type":"function","title":"Error handling and cleanup - Task.Supervisor.async_stream_nolink/4","doc":"Even if tasks are not linked to the caller, there is no risk of leaving dangling tasks\nrunning after the stream halts.\n\nConsider the following example:\n\n    Task.Supervisor.async_stream_nolink(MySupervisor, collection, fun, on_timeout: :kill_task, ordered: false)\n    |> Enum.each(fn\n      {:ok, _} -> :ok\n      {:exit, reason} -> raise \"Task exited: #{Exception.format_exit(reason)}\"\n    end)\n\nIf one task raises or times out:\n\n  1. the second clause gets called\n  2. an exception is raised\n  3. the stream halts\n  4. all ongoing tasks will be shut down\n\nHere is another example:\n\n    Task.Supervisor.async_stream_nolink(MySupervisor, collection, fun, on_timeout: :kill_task, ordered: false)\n    |> Stream.filter(&match?({:ok, _}, &1))\n    |> Enum.take(3)\n\nThis will return the three first tasks to succeed, ignoring timeouts and errors, and shut down\nevery ongoing task.\n\nJust running the stream with `Stream.run/1` on the other hand would ignore errors and process the whole stream.","ref":"Task.Supervisor.html#async_stream_nolink/4-error-handling-and-cleanup"},{"type":"function","title":"Task.Supervisor.async_stream_nolink/6","doc":"Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element in `enumerable` will be prepended to the given `args` and processed\nby its own task. The tasks will be spawned under the given `supervisor` and\nwill not be linked to the caller process, similarly to `async_nolink/5`.\n\nSee `async_stream/6` for discussion, options, and examples.","ref":"Task.Supervisor.html#async_stream_nolink/6"},{"type":"type","title":"Task.Supervisor.async_stream_option/0","doc":"Options given to `async_stream` and `async_stream_nolink` functions.","ref":"Task.Supervisor.html#t:async_stream_option/0"},{"type":"function","title":"Task.Supervisor.children/1","doc":"Returns all children PIDs except those that are restarting.\n\nNote that calling this function when supervising a large number\nof children under low memory conditions can cause an out of memory\nexception.","ref":"Task.Supervisor.html#children/1"},{"type":"type","title":"Task.Supervisor.option/0","doc":"Option values used by `start_link`","ref":"Task.Supervisor.html#t:option/0"},{"type":"function","title":"Task.Supervisor.start_child/3","doc":"Starts a task as a child of the given `supervisor`.\n\n    Task.Supervisor.start_child(MyTaskSupervisor, fn ->\n      IO.puts \"I am running in a task\"\n    end)\n\nNote that the spawned process is not linked to the caller, but\nonly to the supervisor. This command is useful in case the\ntask needs to perform side-effects (like I/O) and you have no\ninterest in its results nor if it completes successfully.","ref":"Task.Supervisor.html#start_child/3"},{"type":"function","title":"Options - Task.Supervisor.start_child/3","doc":"* `:restart` - the restart strategy, may be `:temporary` (the default),\n    `:transient` or `:permanent`. `:temporary` means the task is never\n    restarted, `:transient` means it is restarted if the exit is not\n    `:normal`, `:shutdown` or `{:shutdown, reason}`. A `:permanent` restart\n    strategy means it is always restarted.\n\n  * `:shutdown` - `:brutal_kill` if the task must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n    The task must trap exits for the timeout to have an effect.","ref":"Task.Supervisor.html#start_child/3-options"},{"type":"function","title":"Task.Supervisor.start_child/5","doc":"Starts a task as a child of the given `supervisor`.\n\nSimilar to `start_child/3` except the task is specified\nby the given `module`, `fun` and `args`.","ref":"Task.Supervisor.html#start_child/5"},{"type":"function","title":"Task.Supervisor.start_link/1","doc":"Starts a new supervisor.","ref":"Task.Supervisor.html#start_link/1"},{"type":"function","title":"Examples - Task.Supervisor.start_link/1","doc":"A task supervisor is typically started under a supervision tree using\nthe tuple format:\n\n    {Task.Supervisor, name: MyApp.TaskSupervisor}\n\nYou can also start it by calling `start_link/1` directly:\n\n    Task.Supervisor.start_link(name: MyApp.TaskSupervisor)\n\nBut this is recommended only for scripting and should be avoided in\nproduction code. Generally speaking, processes should always be started\ninside supervision trees.","ref":"Task.Supervisor.html#start_link/1-examples"},{"type":"function","title":"Options - Task.Supervisor.start_link/1","doc":"* `:name` - used to register a supervisor name, the supported values are\n    described under the `Name Registration` section in the `GenServer` module\n    docs;\n\n  * `:max_restarts`, `:max_seconds`, and `:max_children` - as specified in\n    `DynamicSupervisor`;\n\nThis function could also receive `:restart` and `:shutdown` as options\nbut those two options have been deprecated and it is now preferred to\ngive them directly to `start_child`.","ref":"Task.Supervisor.html#start_link/1-options"},{"type":"function","title":"Task.Supervisor.terminate_child/2","doc":"Terminates the child with the given `pid`.","ref":"Task.Supervisor.html#terminate_child/2"},{"type":"protocol","title":"Collectable","doc":"A protocol to traverse data structures.\n\nThe `Enum.into/2` function uses this protocol to insert an\nenumerable into a collection:\n\n    iex> Enum.into([a: 1, b: 2], %{})\n    %{a: 1, b: 2}","ref":"Collectable.html"},{"type":"protocol","title":"Why Collectable? - Collectable","doc":"The `Enumerable` protocol is useful to take values out of a collection.\nIn order to support a wide range of values, the functions provided by\nthe `Enumerable` protocol do not keep shape. For example, passing a\nmap to `Enum.map/2` always returns a list.\n\nThis design is intentional. `Enumerable` was designed to support infinite\ncollections, resources and other structures with fixed shape. For example,\nit doesn't make sense to insert values into a `Range`, as it has a\nfixed shape where only the range limits and step are stored.\n\nThe `Collectable` module was designed to fill the gap left by the\n`Enumerable` protocol. `Collectable.into/1` can be seen as the opposite of\n`Enumerable.reduce/3`. If the functions in `Enumerable` are about taking values out,\nthen `Collectable.into/1` is about collecting those values into a structure.","ref":"Collectable.html#module-why-collectable"},{"type":"protocol","title":"Examples - Collectable","doc":"To show how to manually use the `Collectable` protocol, let's play with a\nsimplified implementation for `MapSet`.\n\n    iex> {initial_acc, collector_fun} = Collectable.into(MapSet.new())\n    iex> updated_acc = Enum.reduce([1, 2, 3], initial_acc, fn elem, acc ->\n    ...>   collector_fun.(acc, {:cont, elem})\n    ...> end)\n    iex> collector_fun.(updated_acc, :done)\n    MapSet.new([1, 2, 3])\n\nTo show how the protocol can be implemented, we can again look at the\nsimplified implementation for `MapSet`. In this implementation \"collecting\" elements\nsimply means inserting them in the set through `MapSet.put/2`.\n\n    defimpl Collectable, for: MapSet do\n      def into(map_set) do\n        collector_fun = fn\n          map_set_acc, {:cont, elem} ->\n            MapSet.put(map_set_acc, elem)\n\n          map_set_acc, :done ->\n            map_set_acc\n\n          _map_set_acc, :halt ->\n            :ok\n        end\n\n        initial_acc = map_set\n\n        {initial_acc, collector_fun}\n      end\n    end\n\nSo now we can call `Enum.into/2`:\n\n    iex> Enum.into([1, 2, 3], MapSet.new())\n    MapSet.new([1, 2, 3])","ref":"Collectable.html#module-examples"},{"type":"type","title":"Collectable.command/0","doc":"","ref":"Collectable.html#t:command/0"},{"type":"function","title":"Collectable.into/1","doc":"Returns an initial accumulator and a \"collector\" function.\n\nReceives a `collectable` which can be used as the initial accumulator that will\nbe passed to the function.\n\nThe collector function receives a term and a command and injects the term into\nthe collectable accumulator on every `{:cont, term}` command.\n\n`:done` is passed as a command when no further values will be injected. This\nis useful when there's a need to close resources or normalizing values. A\ncollectable must be returned when the command is `:done`.\n\nIf injection is suddenly interrupted, `:halt` is passed and the function\ncan return any value as it won't be used.\n\nFor examples on how to use the `Collectable` protocol and `into/1` see the\nmodule documentation.","ref":"Collectable.html#into/1"},{"type":"type","title":"Collectable.t/0","doc":"All the types that implement this protocol.","ref":"Collectable.html#t:t/0"},{"type":"protocol","title":"Enumerable","doc":"Enumerable protocol used by `Enum` and `Stream` modules.\n\nWhen you invoke a function in the `Enum` module, the first argument\nis usually a collection that must implement this protocol.\nFor example, the expression `Enum.map([1, 2, 3], &(&1 * 2))`\ninvokes `Enumerable.reduce/3` to perform the reducing operation that\nbuilds a mapped list by calling the mapping function `&(&1 * 2)` on\nevery element in the collection and consuming the element with an\naccumulated list.\n\nInternally, `Enum.map/2` is implemented as follows:\n\n    def map(enumerable, fun) do\n      reducer = fn x, acc -> {:cont, [fun.(x) | acc]} end\n      Enumerable.reduce(enumerable, {:cont, []}, reducer) |> elem(1) |> :lists.reverse()\n    end\n\nNote that the user-supplied function is wrapped into a `t:reducer/0` function.\nThe `t:reducer/0` function must return a tagged tuple after each step,\nas described in the `t:acc/0` type. At the end, `Enumerable.reduce/3`\nreturns `t:result/0`.\n\nThis protocol uses tagged tuples to exchange information between the\nreducer function and the data type that implements the protocol. This\nallows enumeration of resources, such as files, to be done efficiently\nwhile also guaranteeing the resource will be closed at the end of the\nenumeration. This protocol also allows suspension of the enumeration,\nwhich is useful when interleaving between many enumerables is required\n(as in the `zip/1` and `zip/2` functions).\n\nThis protocol requires four functions to be implemented, `reduce/3`,\n`count/1`, `member?/2`, and `slice/1`. The core of the protocol is the\n`reduce/3` function. All other functions exist as optimizations paths\nfor data structures that can implement certain properties in better\nthan linear time.","ref":"Enumerable.html"},{"type":"type","title":"Enumerable.acc/0","doc":"The accumulator value for each step.\n\nIt must be a tagged tuple with one of the following \"tags\":\n\n  * `:cont`    - the enumeration should continue\n  * `:halt`    - the enumeration should halt immediately\n  * `:suspend` - the enumeration should be suspended immediately\n\nDepending on the accumulator value, the result returned by\n`Enumerable.reduce/3` will change. Please check the `t:result/0`\ntype documentation for more information.\n\nIn case a `t:reducer/0` function returns a `:suspend` accumulator,\nit must be explicitly handled by the caller and never leak.","ref":"Enumerable.html#t:acc/0"},{"type":"type","title":"Enumerable.continuation/0","doc":"A partially applied reduce function.\n\nThe continuation is the closure returned as a result when\nthe enumeration is suspended. When invoked, it expects\na new accumulator and it returns the result.\n\nA continuation can be trivially implemented as long as the reduce\nfunction is defined in a tail recursive fashion. If the function\nis tail recursive, all the state is passed as arguments, so\nthe continuation is the reducing function partially applied.","ref":"Enumerable.html#t:continuation/0"},{"type":"function","title":"Enumerable.count/1","doc":"Retrieves the number of elements in the `enumerable`.\n\nIt should return `{:ok, count}` if you can count the number of elements\nin `enumerable` in a faster way than fully traversing it.\n\nOtherwise it should return `{:error, __MODULE__}` and a default algorithm\nbuilt on top of `reduce/3` that runs in linear time will be used.","ref":"Enumerable.html#count/1"},{"type":"function","title":"Enumerable.member?/2","doc":"Checks if an `element` exists within the `enumerable`.\n\nIt should return `{:ok, boolean}` if you can check the membership of a\ngiven element in `enumerable` with `===/2` without traversing the whole\nof it.\n\nOtherwise it should return `{:error, __MODULE__}` and a default algorithm\nbuilt on top of `reduce/3` that runs in linear time will be used.\n\nWhen called outside guards, the [`in`](`in/2`) and [`not in`](`in/2`)\noperators work by using this function.","ref":"Enumerable.html#member?/2"},{"type":"function","title":"Enumerable.reduce/3","doc":"Reduces the `enumerable` into an element.\n\nMost of the operations in `Enum` are implemented in terms of reduce.\nThis function should apply the given `t:reducer/0` function to each\nelement in the `enumerable` and proceed as expected by the returned\naccumulator.\n\nSee the documentation of the types `t:result/0` and `t:acc/0` for\nmore information.","ref":"Enumerable.html#reduce/3"},{"type":"function","title":"Examples - Enumerable.reduce/3","doc":"As an example, here is the implementation of `reduce` for lists:\n\n    def reduce(_list, {:halt, acc}, _fun), do: {:halted, acc}\n    def reduce(list, {:suspend, acc}, fun), do: {:suspended, acc, &reduce(list, &1, fun)}\n    def reduce([], {:cont, acc}, _fun), do: {:done, acc}\n    def reduce([head | tail], {:cont, acc}, fun), do: reduce(tail, fun.(head, acc), fun)","ref":"Enumerable.html#reduce/3-examples"},{"type":"type","title":"Enumerable.reducer/0","doc":"The reducer function.\n\nShould be called with the `enumerable` element and the\naccumulator contents.\n\nReturns the accumulator for the next enumeration step.","ref":"Enumerable.html#t:reducer/0"},{"type":"type","title":"Enumerable.result/0","doc":"The result of the reduce operation.\n\nIt may be *done* when the enumeration is finished by reaching\nits end, or *halted*/*suspended* when the enumeration was halted\nor suspended by the tagged accumulator.\n\nIn case the tagged `:halt` accumulator is given, the `:halted` tuple\nwith the accumulator must be returned. Functions like `Enum.take_while/2`\nuse `:halt` underneath and can be used to test halting enumerables.\n\nIn case the tagged `:suspend` accumulator is given, the caller must\nreturn the `:suspended` tuple with the accumulator and a continuation.\nThe caller is then responsible of managing the continuation and the\ncaller must always call the continuation, eventually halting or continuing\nuntil the end. `Enum.zip/2` uses suspension, so it can be used to test\nwhether your implementation handles suspension correctly. You can also use\n`Stream.zip/2` with `Enum.take_while/2` to test the combination of\n`:suspend` with `:halt`.","ref":"Enumerable.html#t:result/0"},{"type":"function","title":"Enumerable.slice/1","doc":"Returns a function that slices the data structure contiguously.\n\nIt should return either:\n\n  * `{:ok, size, slicing_fun}` - if the `enumerable` has a known\n    bound and can access a position in the `enumerable` without\n    traversing all previous elements. The `slicing_fun` will receive\n    a `start` position, the `amount` of elements to fetch, and a\n    `step`.\n\n  * `{:ok, size, to_list_fun}` - if the `enumerable` has a known bound\n    and can access a position in the `enumerable` by first converting\n    it to a list via `to_list_fun`.\n\n  * `{:error, __MODULE__}` - the enumerable cannot be sliced efficiently\n    and a default algorithm built on top of `reduce/3` that runs in\n    linear time will be used.","ref":"Enumerable.html#slice/1"},{"type":"function","title":"Differences to `count/1` - Enumerable.slice/1","doc":"The `size` value returned by this function is used for boundary checks,\ntherefore it is extremely important that this function only returns `:ok`\nif retrieving the `size` of the `enumerable` is cheap, fast, and takes\nconstant time. Otherwise the simplest of operations, such as\n`Enum.at(enumerable, 0)`, will become too expensive.\n\nOn the other hand, the `count/1` function in this protocol should be\nimplemented whenever you can count the number of elements in the collection\nwithout traversing it.","ref":"Enumerable.html#slice/1-differences-to-count-1"},{"type":"type","title":"Enumerable.slicing_fun/0","doc":"A slicing function that receives the initial position,\nthe number of elements in the slice, and the step.\n\nThe `start` position is a number `>= 0` and guaranteed to\nexist in the `enumerable`. The length is a number `>= 1`\nin a way that `start + length * step <= count`, where\n`count` is the maximum amount of elements in the enumerable.\n\nThe function should return a non empty list where\nthe amount of elements is equal to `length`.","ref":"Enumerable.html#t:slicing_fun/0"},{"type":"type","title":"Enumerable.t/0","doc":"All the types that implement this protocol.","ref":"Enumerable.html#t:t/0"},{"type":"type","title":"Enumerable.t/1","doc":"An enumerable of elements of type `element`.\n\nThis type is equivalent to `t:t/0` but is especially useful for documentation.\n\nFor example, imagine you define a function that expects an enumerable of\nintegers and returns an enumerable of strings:\n\n    @spec integers_to_strings(Enumerable.t(integer())) :: Enumerable.t(String.t())\n    def integers_to_strings(integers) do\n      Stream.map(integers, &Integer.to_string/1)\n    end","ref":"Enumerable.html#t:t/1"},{"type":"type","title":"Enumerable.to_list_fun/0","doc":"Receives an enumerable and returns a list.","ref":"Enumerable.html#t:to_list_fun/0"},{"type":"protocol","title":"Inspect","doc":"The `Inspect` protocol converts an Elixir data structure into an\nalgebra document.\n\nThis is typically done when you want to customize how your own\nstructs are inspected in logs and the terminal.\n\nThis documentation refers to implementing the `Inspect` protocol\nfor your own data structures. To learn more about using inspect,\nsee `Kernel.inspect/2` and `IO.inspect/2`.","ref":"Inspect.html"},{"type":"protocol","title":"Inspect representation - Inspect","doc":"There are typically three choices of inspect representation. In order\nto understand them, let's imagine we have the following `User` struct:\n\n    defmodule User do\n      defstruct [:id, :name, :address]\n    end\n\nOur choices are:\n\n  1. Print the struct using Elixir's struct syntax, for example:\n     `%User{address: \"Earth\", id: 13, name: \"Jane\"}`. This is the\n     default representation and best choice if all struct fields\n     are public.\n\n  2. Print using the `#User<...>` notation, for example: `#User `.\n     This notation does not emit valid Elixir code and is typically\n     used when the struct has private fields (for example, you may want\n     to hide the field `:address` to redact person identifiable information).\n\n  3. Print the struct using the expression syntax, for example:\n     `User.new(13, \"Jane\", \"Earth\")`. This assumes there is a `User.new/3`\n     function. This option is mostly used as an alternative to option 2\n     for representing custom data structures, such as `MapSet`, `Date.Range`,\n     and others.\n\nYou can implement the Inspect protocol for your own structs while\nadhering to the conventions above. Option 1 is the default representation\nand you can quickly achieve option 2 by deriving the `Inspect` protocol.\nFor option 3, you need your custom implementation.","ref":"Inspect.html#module-inspect-representation"},{"type":"protocol","title":"Deriving - Inspect","doc":"The `Inspect` protocol can be derived to customize the order of fields\n(the default is alphabetical) and hide certain fields from structs,\nso they don't show up in logs, inspects and similar. The latter is\nespecially useful for fields containing private information.\n\nThe supported options are:\n\n  * `:only` - only include the given fields when inspecting.\n\n  * `:except` - remove the given fields when inspecting.\n\n  * `:optional` - (since v1.14.0) do not include a field if it\n    matches its default value. This can be used to simplify the\n    struct representation at the cost of hiding information.\n\nWhenever `:only` or `:except` are used to restrict fields,\nthe struct will be printed using the `#User<...>` notation,\nas the struct can no longer be copy and pasted as valid Elixir\ncode. Let's see an example:\n\n    defmodule User do\n      @derive {Inspect, only: [:id, :name]}\n      defstruct [:id, :name, :address]\n    end\n\n    inspect(%User{id: 1, name: \"Jane\", address: \"Earth\"})\n    #=> #User \n\nIf you use only the `:optional` option, the struct will still be\nprinted as `%User{...}`.","ref":"Inspect.html#module-deriving"},{"type":"protocol","title":"Custom implementation - Inspect","doc":"You can also define your custom protocol implementation by\ndefining the `inspect/2` function. The function receives the\nentity to be inspected followed by the inspecting options,\nrepresented by the struct `Inspect.Opts`. Building of the\nalgebra document is done with `Inspect.Algebra`.\n\nMany times, inspecting a structure can be implemented in function\nof existing entities. For example, here is `MapSet`'s `inspect/2`\nimplementation:\n\n    defimpl Inspect, for: MapSet do\n      import Inspect.Algebra\n\n      def inspect(map_set, opts) do\n        concat([\"MapSet.new(\", Inspect.List.inspect(MapSet.to_list(map_set), opts), \")\"])\n      end\n    end\n\nThe [`concat/1`](`Inspect.Algebra.concat/1`) function comes from\n`Inspect.Algebra` and it concatenates algebra documents together.\nIn the example above it is concatenating the string `\"MapSet.new(\"`,\nthe document returned by `Inspect.Algebra.to_doc/2`, and the final\nstring `\")\"`. Therefore, the MapSet with the numbers 1, 2, and 3\nwill be printed as:\n\n    iex> MapSet.new([1, 2, 3], fn x -> x * 2 end)\n    MapSet.new([2, 4, 6])\n\nIn other words, `MapSet`'s inspect representation returns an expression\nthat, when evaluated, builds the `MapSet` itself.","ref":"Inspect.html#module-custom-implementation"},{"type":"protocol","title":"Error handling - Inspect","doc":"In case there is an error while your structure is being inspected,\nElixir will raise an `ArgumentError` error and will automatically fall back\nto a raw representation for printing the structure. Furthermore, you\nmust be careful when debugging your own Inspect implementation, as calls\nto `IO.inspect/2` or `dbg/1` may trigger an infinite loop (as in order to\ninspect/debug the data structure, you must call `inspect` itself).\n\nHere are some tips:\n\n  * For debugging, use `IO.inspect/2` with the `structs: false` option,\n    which disables custom printing and avoids calling the Inspect\n    implementation recursively\n\n  * To access the underlying error on your custom `Inspect` implementation,\n    you may invoke the protocol directly. For example, we could invoke the\n    `Inspect.MapSet` implementation above as:\n\n        Inspect.MapSet.inspect(MapSet.new(), %Inspect.Opts{})","ref":"Inspect.html#module-error-handling"},{"type":"function","title":"Inspect.inspect/2","doc":"Converts `term` into an algebra document.\n\nThis function shouldn't be invoked directly, unless when implementing\na custom `inspect_fun` to be given to `Inspect.Opts`. Everywhere else,\n`Inspect.Algebra.to_doc/2` should be preferred as it handles structs\nand exceptions.","ref":"Inspect.html#inspect/2"},{"type":"type","title":"Inspect.t/0","doc":"All the types that implement this protocol.","ref":"Inspect.html#t:t/0"},{"type":"module","title":"Inspect.Algebra","doc":"A set of functions for creating and manipulating algebra\ndocuments.\n\nThis module implements the functionality described in\n[\"Strictly Pretty\" (2000) by Christian Lindig][0] with small\nadditions, like support for binary nodes and a break mode that\nmaximises use of horizontal space.\n\n    iex> Inspect.Algebra.empty()\n    :doc_nil\n\n    iex> \"foo\"\n    \"foo\"\n\nWith the functions in this module, we can concatenate different\nelements together and render them:\n\n    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty(), \"foo\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"foo\"]\n\nThe functions `nest/2`, `space/2` and `line/2` help you put the\ndocument together into a rigid structure. However, the document\nalgebra gets interesting when using functions like `glue/3` and\n`group/1`. A glue inserts a break between two documents. A group\nindicates a document that must fit the current line, otherwise\nbreaks are rendered as new lines. Let's glue two docs together\nwith a break, group it and then render it:\n\n    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \" \", \"b\"]\n\nNote that the break was represented as is, because we haven't reached\na line limit. Once we do, it is replaced by a newline:\n\n    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 10)\n    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n\nThis module uses the byte size to compute how much space there is\nleft. If your document contains strings, then those need to be\nwrapped in `string/1`, which then relies on `String.length/1` to\nprecompute the document size.\n\nFinally, this module also contains Elixir related functions, a bit\ntied to Elixir formatting, such as `to_doc/2`.","ref":"Inspect.Algebra.html"},{"type":"module","title":"Implementation details - Inspect.Algebra","doc":"The implementation of `Inspect.Algebra` is based on the Strictly Pretty\npaper by [Lindig][0] which builds on top of previous pretty printing\nalgorithms but is tailored to strict languages, such as Elixir.\nThe core idea in the paper is the use of explicit document groups which\nare rendered as flat (breaks as spaces) or as break (breaks as newlines).\n\nThis implementation provides two types of breaks: `:strict` and `:flex`.\nWhen a group does not fit, all strict breaks are treated as newlines.\nFlex breaks, however, are re-evaluated on every occurrence and may still\nbe rendered flat. See `break/1` and `flex_break/1` for more information.\n\nThis implementation also adds `force_unfit/1` and `next_break_fits/2` which\ngive more control over the document fitting.\n\n  [0]: https://lindig.github.io/papers/strictly-pretty-2000.pdf","ref":"Inspect.Algebra.html#module-implementation-details"},{"type":"function","title":"Inspect.Algebra.break/1","doc":"Returns a break document based on the given `string`.\n\nThis break can be rendered as a linebreak or as the given `string`,\ndepending on the `mode` of the chosen layout.","ref":"Inspect.Algebra.html#break/1"},{"type":"function","title":"Examples - Inspect.Algebra.break/1","doc":"Let's create a document by concatenating two strings with a break between\nthem:\n\n    iex> doc = Inspect.Algebra.concat([\"a\", Inspect.Algebra.break(\"\\t\"), \"b\"])\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \"\\t\", \"b\"]\n\nNote that the break was represented with the given string, because we didn't\nreach a line limit. Once we do, it is replaced by a newline:\n\n    iex> break = Inspect.Algebra.break(\"\\t\")\n    iex> doc = Inspect.Algebra.concat([String.duplicate(\"a\", 20), break, \"b\"])\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 10)\n    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]","ref":"Inspect.Algebra.html#break/1-examples"},{"type":"function","title":"Inspect.Algebra.collapse_lines/1","doc":"Collapse any new lines and whitespace following this\nnode, emitting up to `max` new lines.","ref":"Inspect.Algebra.html#collapse_lines/1"},{"type":"function","title":"Inspect.Algebra.color/3","doc":"Colors a document if the `color_key` has a color in the options.","ref":"Inspect.Algebra.html#color/3"},{"type":"function","title":"Inspect.Algebra.concat/1","doc":"Concatenates a list of documents returning a new document.","ref":"Inspect.Algebra.html#concat/1"},{"type":"function","title":"Examples - Inspect.Algebra.concat/1","doc":"iex> doc = Inspect.Algebra.concat([\"a\", \"b\", \"c\"])\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \"b\", \"c\"]","ref":"Inspect.Algebra.html#concat/1-examples"},{"type":"function","title":"Inspect.Algebra.concat/2","doc":"Concatenates two document entities returning a new document.","ref":"Inspect.Algebra.html#concat/2"},{"type":"function","title":"Examples - Inspect.Algebra.concat/2","doc":"iex> doc = Inspect.Algebra.concat(\"hello\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \"world\"]","ref":"Inspect.Algebra.html#concat/2-examples"},{"type":"function","title":"Inspect.Algebra.container_doc/6","doc":"Wraps `collection` in `left` and `right` according to limit and contents.\n\nIt uses the given `left` and `right` documents as surrounding and the\nseparator document `separator` to separate items in `docs`. If all entries\nin the collection are simple documents (texts or strings), then this function\nattempts to put as much as possible on the same line. If they are not simple,\nonly one entry is shown per line if they do not fit.\n\nThe limit in the given `inspect_opts` is respected and when reached this\nfunction stops processing and outputs `\"...\"` instead.","ref":"Inspect.Algebra.html#container_doc/6"},{"type":"function","title":"Options - Inspect.Algebra.container_doc/6","doc":"* `:separator` - the separator used between each doc\n  * `:break` - If `:strict`, always break between each element. If `:flex`,\n    breaks only when necessary. If `:maybe`, chooses `:flex` only if all\n    elements are text-based, otherwise is `:strict`","ref":"Inspect.Algebra.html#container_doc/6-options"},{"type":"function","title":"Examples - Inspect.Algebra.container_doc/6","doc":"iex> inspect_opts = %Inspect.Opts{limit: :infinity}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun)\n    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary()\n    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n\n    iex> inspect_opts = %Inspect.Opts{limit: 3}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun)\n    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary()\n    \"[1, 2, 3, ...]\"\n\n    iex> inspect_opts = %Inspect.Opts{limit: 3}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> opts = [separator: \"!\"]\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun, opts)\n    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary()\n    \"[1! 2! 3! ...]\"","ref":"Inspect.Algebra.html#container_doc/6-examples"},{"type":"function","title":"Inspect.Algebra.empty/0","doc":"Returns a document entity used to represent nothingness.","ref":"Inspect.Algebra.html#empty/0"},{"type":"function","title":"Examples - Inspect.Algebra.empty/0","doc":"iex> Inspect.Algebra.empty()\n    :doc_nil","ref":"Inspect.Algebra.html#empty/0-examples"},{"type":"function","title":"Inspect.Algebra.flex_break/1","doc":"Returns a flex break document based on the given `string`.\n\nA flex break still causes a group to break, like `break/1`,\nbut it is re-evaluated when the documented is rendered.\n\nFor example, take a group document represented as `[1, 2, 3]`\nwhere the space after every comma is a break. When the document\nabove does not fit a single line, all breaks are enabled,\ncausing the document to be rendered as:\n\n    [1,\n     2,\n     3]\n\nHowever, if flex breaks are used, then each break is re-evaluated\nwhen rendered, so the document could be possible rendered as:\n\n    [1, 2,\n     3]\n\nHence the name \"flex\". they are more flexible when it comes\nto the document fitting. On the other hand, they are more expensive\nsince each break needs to be re-evaluated.\n\nThis function is used by `container_doc/6` and friends to the\nmaximum number of entries on the same line.","ref":"Inspect.Algebra.html#flex_break/1"},{"type":"function","title":"Inspect.Algebra.flex_glue/3","doc":"Glues two documents (`doc1` and `doc2`) inserting a\n`flex_break/1` given by `break_string` between them.\n\nThis function is used by `container_doc/6` and friends\nto the maximum number of entries on the same line.","ref":"Inspect.Algebra.html#flex_glue/3"},{"type":"function","title":"Inspect.Algebra.fold_doc/2","doc":"Folds a list of documents into a document using the given folder function.\n\nThe list of documents is folded \"from the right\"; in that, this function is\nsimilar to `List.foldr/3`, except that it doesn't expect an initial\naccumulator and uses the last element of `docs` as the initial accumulator.","ref":"Inspect.Algebra.html#fold_doc/2"},{"type":"function","title":"Examples - Inspect.Algebra.fold_doc/2","doc":"iex> docs = [\"A\", \"B\", \"C\"]\n    iex> docs =\n    ...>   Inspect.Algebra.fold_doc(docs, fn doc, acc ->\n    ...>     Inspect.Algebra.concat([doc, \"!\", acc])\n    ...>   end)\n    iex> Inspect.Algebra.format(docs, 80)\n    [\"A\", \"!\", \"B\", \"!\", \"C\"]","ref":"Inspect.Algebra.html#fold_doc/2-examples"},{"type":"function","title":"Inspect.Algebra.force_unfit/1","doc":"Forces the current group to be unfit.","ref":"Inspect.Algebra.html#force_unfit/1"},{"type":"function","title":"Inspect.Algebra.format/2","doc":"Formats a given document for a given width.\n\nTakes the maximum width and a document to print as its arguments\nand returns an IO data representation of the best layout for the\ndocument to fit in the given width.\n\nThe document starts flat (without breaks) until a group is found.","ref":"Inspect.Algebra.html#format/2"},{"type":"function","title":"Examples - Inspect.Algebra.format/2","doc":"iex> doc = Inspect.Algebra.glue(\"hello\", \" \", \"world\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> doc |> Inspect.Algebra.format(30) |> IO.iodata_to_binary()\n    \"hello world\"\n    iex> doc |> Inspect.Algebra.format(10) |> IO.iodata_to_binary()\n    \"hello\\nworld\"","ref":"Inspect.Algebra.html#format/2-examples"},{"type":"function","title":"Inspect.Algebra.glue/3","doc":"Glues two documents (`doc1` and `doc2`) inserting the given\nbreak `break_string` between them.\n\nFor more information on how the break is inserted, see `break/1`.","ref":"Inspect.Algebra.html#glue/3"},{"type":"function","title":"Examples - Inspect.Algebra.glue/3","doc":"iex> doc = Inspect.Algebra.glue(\"hello\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \" \", \"world\"]\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \"\\t\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \"\\t\", \"world\"]","ref":"Inspect.Algebra.html#glue/3-examples"},{"type":"function","title":"Inspect.Algebra.group/2","doc":"Returns a group containing the specified document `doc`.\n\nDocuments in a group are attempted to be rendered together\nto the best of the renderer ability.\n\nThe group mode can also be set to `:inherit`, which means it\nautomatically breaks if the parent group has broken too.","ref":"Inspect.Algebra.html#group/2"},{"type":"function","title":"Examples - Inspect.Algebra.group/2","doc":"iex> doc =\n    ...>   Inspect.Algebra.group(\n    ...>     Inspect.Algebra.concat(\n    ...>       Inspect.Algebra.group(\n    ...>         Inspect.Algebra.concat(\n    ...>           \"Hello,\",\n    ...>           Inspect.Algebra.concat(\n    ...>             Inspect.Algebra.break(),\n    ...>             \"A\"\n    ...>           )\n    ...>         )\n    ...>       ),\n    ...>       Inspect.Algebra.concat(\n    ...>         Inspect.Algebra.break(),\n    ...>         \"B\"\n    ...>       )\n    ...>     )\n    ...>   )\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n    iex> Inspect.Algebra.format(doc, 6)\n    [\"Hello,\", \"\\n\", \"A\", \"\\n\", \"B\"]","ref":"Inspect.Algebra.html#group/2-examples"},{"type":"macro","title":"Inspect.Algebra.is_doc/1","doc":"","ref":"Inspect.Algebra.html#is_doc/1"},{"type":"function","title":"Inspect.Algebra.line/0","doc":"A mandatory linebreak.\n\nA group with linebreaks will fit if all lines in the group fit.","ref":"Inspect.Algebra.html#line/0"},{"type":"function","title":"Examples - Inspect.Algebra.line/0","doc":"iex> doc =\n    ...>   Inspect.Algebra.concat(\n    ...>     Inspect.Algebra.concat(\n    ...>       \"Hughes\",\n    ...>       Inspect.Algebra.line()\n    ...>     ),\n    ...>     \"Wadler\"\n    ...>   )\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hughes\", \"\\n\", \"Wadler\"]","ref":"Inspect.Algebra.html#line/0-examples"},{"type":"function","title":"Inspect.Algebra.line/2","doc":"Inserts a mandatory linebreak between two documents.\n\nSee `line/0`.","ref":"Inspect.Algebra.html#line/2"},{"type":"function","title":"Examples - Inspect.Algebra.line/2","doc":"iex> doc = Inspect.Algebra.line(\"Hughes\", \"Wadler\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hughes\", \"\\n\", \"Wadler\"]","ref":"Inspect.Algebra.html#line/2-examples"},{"type":"function","title":"Inspect.Algebra.nest/3","doc":"Nests the given document at the given `level`.\n\nIf `level` is an integer, that's the indentation appended\nto line breaks whenever they occur. If the level is `:cursor`,\nthe current position of the \"cursor\" in the document becomes\nthe nesting. If the level is `:reset`, it is set back to 0.\n\n`mode` can be `:always`, which means nesting always happen,\nor `:break`, which means nesting only happens inside a group\nthat has been broken.","ref":"Inspect.Algebra.html#nest/3"},{"type":"function","title":"Examples - Inspect.Algebra.nest/3","doc":"iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world\"), 5)\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 5)\n    [\"hello\", \"\\n     \", \"world\"]","ref":"Inspect.Algebra.html#nest/3-examples"},{"type":"function","title":"Inspect.Algebra.next_break_fits/2","doc":"Considers the next break as fit.\n\n`mode` can be `:enabled` or `:disabled`. When `:enabled`,\nit will consider the document as fit as soon as it finds\nthe next break, effectively cancelling the break. It will\nalso ignore any `force_unfit/1` in search of the next break.\n\nWhen disabled, it behaves as usual and it will ignore\nany further `next_break_fits/2` instruction.","ref":"Inspect.Algebra.html#next_break_fits/2"},{"type":"function","title":"Examples - Inspect.Algebra.next_break_fits/2","doc":"This is used by Elixir's code formatter to avoid breaking\ncode at some specific locations. For example, consider this\ncode:\n\n    some_function_call(%{..., key: value, ...})\n\nNow imagine that this code does not fit its line. The code\nformatter introduces breaks inside `(` and `)` and inside\n`%{` and `}`. Therefore the document would break as:\n\n    some_function_call(\n      %{\n        ...,\n        key: value,\n        ...\n      }\n    )\n\nThe formatter wraps the algebra document representing the\nmap in `next_break_fits/1` so the code is formatted as:\n\n    some_function_call(%{\n      ...,\n      key: value,\n      ...\n    })","ref":"Inspect.Algebra.html#next_break_fits/2-examples"},{"type":"function","title":"Inspect.Algebra.no_limit/1","doc":"","ref":"Inspect.Algebra.html#no_limit/1"},{"type":"function","title":"Inspect.Algebra.space/2","doc":"Inserts a mandatory single space between two documents.","ref":"Inspect.Algebra.html#space/2"},{"type":"function","title":"Examples - Inspect.Algebra.space/2","doc":"iex> doc = Inspect.Algebra.space(\"Hughes\", \"Wadler\")\n    iex> Inspect.Algebra.format(doc, 5)\n    [\"Hughes\", \" \", \"Wadler\"]","ref":"Inspect.Algebra.html#space/2-examples"},{"type":"function","title":"Inspect.Algebra.string/1","doc":"Creates a document represented by string.\n\nWhile `Inspect.Algebra` accepts binaries as documents,\nthose are counted by binary size. On the other hand,\n`string` documents are measured in terms of graphemes\ntowards the document size.","ref":"Inspect.Algebra.html#string/1"},{"type":"function","title":"Examples - Inspect.Algebra.string/1","doc":"The following document has 10 bytes and therefore it\ndoes not format to width 9 without breaks:\n\n    iex> doc = Inspect.Algebra.glue(\"olá\", \" \", \"mundo\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 9)\n    [\"olá\", \"\\n\", \"mundo\"]\n\nHowever, if we use `string`, then the string length is\nused, instead of byte size, correctly fitting:\n\n    iex> string = Inspect.Algebra.string(\"olá\")\n    iex> doc = Inspect.Algebra.glue(string, \" \", \"mundo\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 9)\n    [\"olá\", \" \", \"mundo\"]","ref":"Inspect.Algebra.html#string/1-examples"},{"type":"type","title":"Inspect.Algebra.t/0","doc":"","ref":"Inspect.Algebra.html#t:t/0"},{"type":"function","title":"Inspect.Algebra.to_doc/2","doc":"Converts an Elixir term to an algebra document\naccording to the `Inspect` protocol.","ref":"Inspect.Algebra.html#to_doc/2"},{"type":"module","title":"Inspect.Opts","doc":"Defines the options used by the `Inspect` protocol.\n\nThe following fields are available:\n\n  * `:base` - prints integers and binaries as `:binary`, `:octal`, `:decimal`,\n    or `:hex`. Defaults to `:decimal`.\n\n  * `:binaries` - when `:as_binaries` all binaries will be printed in bit\n    syntax.\n\n    When `:as_strings` all binaries will be printed as strings, non-printable\n    bytes will be escaped.\n\n    When the default `:infer`, the binary will be printed as a string if `:base`\n    is `:decimal` and if it is printable, otherwise in bit syntax. See\n    `String.printable?/1` to learn when a string is printable.\n\n  * `:charlists` - when `:as_charlists` all lists will be printed as charlists,\n    non-printable elements will be escaped.\n\n    When `:as_lists` all lists will be printed as lists.\n\n    When the default `:infer`, the list will be printed as a charlist if it\n    is printable, otherwise as list. See `List.ascii_printable?/1` to learn\n    when a charlist is printable.\n\n  * `:custom_options` (since v1.9.0) - a keyword list storing custom user-defined\n    options. Useful when implementing the `Inspect` protocol for nested structs\n    to pass the custom options through.\n\n    It supports some pre-defined keys:\n\n    - `:sort_maps` (since v1.14.4) - if set to `true`, sorts key-value pairs\n      in maps. This can be helpful to make map inspection deterministic for\n      testing, given maps key order is random.\n\n  * `:inspect_fun` (since v1.9.0) - a function to build algebra documents.\n    Defaults to `Inspect.Opts.default_inspect_fun/0`.\n\n  * `:limit` - limits the number of items that are inspected for tuples,\n    bitstrings, maps, lists and any other collection of items, with the exception of\n    printable strings and printable charlists which use the `:printable_limit` option.\n    If you don't want to limit the number of items to a particular number,\n    use `:infinity`. It accepts a positive integer or `:infinity`.\n    Defaults to `50`.\n\n  * `:pretty` - if set to `true` enables pretty printing. Defaults to `false`.\n\n  * `:printable_limit` - limits the number of characters that are inspected\n    on printable strings and printable charlists. You can use `String.printable?/1`\n    and `List.ascii_printable?/1` to check if a given string or charlist is\n    printable. If you don't want to limit the number of characters to a particular\n    number, use `:infinity`. It accepts a positive integer or `:infinity`.\n    Defaults to `4096`.\n\n  * `:safe` - when `false`, failures while inspecting structs will be raised\n    as errors instead of being wrapped in the `Inspect.Error` exception. This\n    is useful when debugging failures and crashes for custom inspect\n    implementations. Defaults to `true`.\n\n  * `:structs` - when `false`, structs are not formatted by the inspect\n    protocol, they are instead printed as maps. Defaults to `true`.\n\n  * `:syntax_colors` - when set to a keyword list of colors the output is\n    colorized. The keys are types and the values are the colors to use for\n    each type (for example, `[number: :red, atom: :blue]`). Types can include\n    `:atom`, `:binary`, `:boolean`, `:list`, `:map`, `:number`, `:regex`,\n    `:string`, `:tuple`, or some types to represent AST like `:variable`,\n    `:call`, and `:operator`.\n    Custom data types may provide their own options.\n    Colors can be any `t:IO.ANSI.ansidata/0` as accepted by `IO.ANSI.format/1`.\n    A default list of colors can be retrieved from `IO.ANSI.syntax_colors/0`.\n\n  * `:width` - number of characters per line used when pretty is `true` or when\n    printing to IO devices. Set to `0` to force each item to be printed on its\n    own line. If you don't want to limit the number of items to a particular\n    number, use `:infinity`. Defaults to `80`.","ref":"Inspect.Opts.html"},{"type":"type","title":"Inspect.Opts.color_key/0","doc":"","ref":"Inspect.Opts.html#t:color_key/0"},{"type":"function","title":"Inspect.Opts.default_inspect_fun/0","doc":"Returns the default inspect function.","ref":"Inspect.Opts.html#default_inspect_fun/0"},{"type":"function","title":"Inspect.Opts.default_inspect_fun/1","doc":"Sets the default inspect function.\n\nSet this option with care as it will change how all values\nin the system are inspected. The main use of this functionality\nis to provide an entry point to filter inspected values,\nin order for entities to comply with rules and legislations\non data security and data privacy.\n\nIt is **extremely discouraged** for libraries to set their own\nfunction as this must be controlled by applications. Libraries\nshould instead define their own structs with custom inspect\nimplementations. If a library must change the default inspect\nfunction, then it is best to ask users of your library to explicitly\ncall `default_inspect_fun/1` with your function of choice.\n\nThe default is `Inspect.inspect/2`.","ref":"Inspect.Opts.html#default_inspect_fun/1"},{"type":"function","title":"Examples - Inspect.Opts.default_inspect_fun/1","doc":"previous_fun = Inspect.Opts.default_inspect_fun()\n\n    Inspect.Opts.default_inspect_fun(fn\n      %{address: _} = map, opts ->\n        previous_fun.(%{map | address: \"[REDACTED]\"}, opts)\n\n      value, opts ->\n        previous_fun.(value, opts)\n    end)","ref":"Inspect.Opts.html#default_inspect_fun/1-examples"},{"type":"function","title":"Inspect.Opts.new/1","doc":"Builds an `Inspect.Opts` struct.","ref":"Inspect.Opts.html#new/1"},{"type":"type","title":"Inspect.Opts.t/0","doc":"","ref":"Inspect.Opts.html#t:t/0"},{"type":"protocol","title":"List.Chars","doc":"The `List.Chars` protocol is responsible for\nconverting a structure to a charlist (only if applicable).\n\nThe only function that must be implemented is\n`to_charlist/1` which does the conversion.\n\nThe `to_charlist/1` function automatically imported\nby `Kernel` invokes this protocol.","ref":"List.Chars.html"},{"type":"type","title":"List.Chars.t/0","doc":"All the types that implement this protocol.","ref":"List.Chars.html#t:t/0"},{"type":"function","title":"List.Chars.to_charlist/1","doc":"Converts `term` to a charlist.","ref":"List.Chars.html#to_charlist/1"},{"type":"module","title":"Protocol","doc":"Reference and functions for working with protocols.\n\nA protocol specifies an API that should be defined by its\nimplementations. A protocol is defined with `Kernel.defprotocol/2`\nand its implementations with `Kernel.defimpl/3`.","ref":"Protocol.html"},{"type":"module","title":"A real case - Protocol","doc":"In Elixir, we have two nouns for checking how many items there\nare in a data structure: `length` and `size`.  `length` means the\ninformation must be computed. For example, `length(list)` needs to\ntraverse the whole list to calculate its length. On the other hand,\n`tuple_size(tuple)` and `byte_size(binary)` do not depend on the\ntuple and binary size as the size information is precomputed in\nthe data structure.\n\nAlthough Elixir includes specific functions such as `tuple_size`,\n`binary_size` and `map_size`, sometimes we want to be able to\nretrieve the size of a data structure regardless of its type.\nIn Elixir we can write polymorphic code, i.e. code that works\nwith different shapes/types, by using protocols. A size protocol\ncould be implemented as follows:\n\n    defprotocol Size do\n      @doc \"Calculates the size (and not the length!) of a data structure\"\n      def size(data)\n    end\n\nNow that the protocol can be implemented for every data structure\nthe protocol may have a compliant implementation for:\n\n    defimpl Size, for: BitString do\n      def size(binary), do: byte_size(binary)\n    end\n\n    defimpl Size, for: Map do\n      def size(map), do: map_size(map)\n    end\n\n    defimpl Size, for: Tuple do\n      def size(tuple), do: tuple_size(tuple)\n    end\n\nFinally, we can use the `Size` protocol to call the correct implementation:\n\n    Size.size({1, 2})\n    # => 2\n    Size.size(%{key: :value})\n    # => 1\n\nNote that we didn't implement it for lists as we don't have the\n`size` information on lists, rather its value needs to be\ncomputed with `length`.\n\nThe data structure you are implementing the protocol for\nmust be the first argument to all functions defined in the\nprotocol.\n\nIt is possible to implement protocols for all Elixir types:\n\n  * Structs (see the \"Protocols and Structs\" section below)\n  * `Tuple`\n  * `Atom`\n  * `List`\n  * `BitString`\n  * `Integer`\n  * `Float`\n  * `Function`\n  * `PID`\n  * `Map`\n  * `Port`\n  * `Reference`\n  * `Any` (see the \"Fallback to `Any`\" section below)","ref":"Protocol.html#module-a-real-case"},{"type":"module","title":"Protocols and Structs - Protocol","doc":"The real benefit of protocols comes when mixed with structs.\nFor instance, Elixir ships with many data types implemented as\nstructs, like `MapSet`. We can implement the `Size` protocol\nfor those types as well:\n\n    defimpl Size, for: MapSet do\n      def size(map_set), do: MapSet.size(map_set)\n    end\n\nWhen implementing a protocol for a struct, the `:for` option can\nbe omitted if the `defimpl/3` call is inside the module that defines\nthe struct:\n\n    defmodule User do\n      defstruct [:email, :name]\n\n      defimpl Size do\n        # two fields\n        def size(%User{}), do: 2\n      end\n    end\n\nIf a protocol implementation is not found for a given type,\ninvoking the protocol will raise unless it is configured to\nfall back to `Any`. Conveniences for building implementations\non top of existing ones are also available, look at `defstruct/1`\nfor more information about deriving\nprotocols.","ref":"Protocol.html#module-protocols-and-structs"},{"type":"module","title":"Fallback to `Any` - Protocol","doc":"In some cases, it may be convenient to provide a default\nimplementation for all types. This can be achieved by setting\nthe `@fallback_to_any` attribute to `true` in the protocol\ndefinition:\n\n    defprotocol Size do\n      @fallback_to_any true\n      def size(data)\n    end\n\nThe `Size` protocol can now be implemented for `Any`:\n\n    defimpl Size, for: Any do\n      def size(_), do: 0\n    end\n\nAlthough the implementation above is arguably not a reasonable\none. For example, it makes no sense to say a PID or an integer\nhave a size of `0`. That's one of the reasons why `@fallback_to_any`\nis an opt-in behavior. For the majority of protocols, raising\nan error when a protocol is not implemented is the proper behavior.","ref":"Protocol.html#module-fallback-to-any"},{"type":"module","title":"Multiple implementations - Protocol","doc":"Protocols can also be implemented for multiple types at once:\n\n    defprotocol Reversible do\n      def reverse(term)\n    end\n\n    defimpl Reversible, for: [Map, List] do\n      def reverse(term), do: Enum.reverse(term)\n    end\n\nInside `defimpl/3`, you can use `@protocol` to access the protocol\nbeing implemented and `@for` to access the module it is being\ndefined for.","ref":"Protocol.html#module-multiple-implementations"},{"type":"module","title":"Types - Protocol","doc":"Defining a protocol automatically defines a zero-arity type named `t`, which\ncan be used as follows:\n\n    @spec print_size(Size.t()) :: :ok\n    def print_size(data) do\n      result =\n        case Size.size(data) do\n          0 -> \"data has no items\"\n          1 -> \"data has one item\"\n          n -> \"data has #{n} items\"\n        end\n\n      IO.puts(result)\n    end\n\nThe `@spec` above expresses that all types allowed to implement the\ngiven protocol are valid argument types for the given function.","ref":"Protocol.html#module-types"},{"type":"module","title":"Reflection - Protocol","doc":"Any protocol module contains three extra functions:\n\n  * `__protocol__/1` - returns the protocol information. The function takes\n    one of the following atoms:\n\n    * `:consolidated?` - returns whether the protocol is consolidated\n\n    * `:functions` - returns a keyword list of protocol functions and their arities\n\n    * `:impls` - if consolidated, returns `{:consolidated, modules}` with the list of modules\n      implementing the protocol, otherwise `:not_consolidated`\n\n    * `:module` - the protocol module atom name\n\n  * `impl_for/1` - returns the module that implements the protocol for the given argument,\n    `nil` otherwise\n\n  * `impl_for!/1` - same as above but raises `Protocol.UndefinedError` if an implementation is\n    not found\n\nFor example, for the `Enumerable` protocol we have:\n\n    iex> Enumerable.__protocol__(:functions)\n    [count: 1, member?: 2, reduce: 3, slice: 1]\n\n    iex> Enumerable.impl_for([])\n    Enumerable.List\n\n    iex> Enumerable.impl_for(42)\n    nil\n\nIn addition, every protocol implementation module contains the `__impl__/1`\nfunction. The function takes one of the following atoms:\n\n  * `:for` - returns the module responsible for the data structure of the\n    protocol implementation\n\n  * `:protocol` - returns the protocol module for which this implementation\n  is provided\n\nFor example, the module implementing the `Enumerable` protocol for lists is\n`Enumerable.List`. Therefore, we can invoke `__impl__/1` on this module:\n\n    iex(1)> Enumerable.List.__impl__(:for)\n    List\n\n    iex(2)> Enumerable.List.__impl__(:protocol)\n    Enumerable","ref":"Protocol.html#module-reflection"},{"type":"module","title":"Consolidation - Protocol","doc":"In order to speed up protocol dispatching, whenever all protocol implementations\nare known up-front, typically after all Elixir code in a project is compiled,\nElixir provides a feature called *protocol consolidation*. Consolidation directly\nlinks protocols to their implementations in a way that invoking a function from a\nconsolidated protocol is equivalent to invoking two remote functions.\n\nProtocol consolidation is applied by default to all Mix projects during compilation.\nThis may be an issue during test. For instance, if you want to implement a protocol\nduring test, the implementation will have no effect, as the protocol has already been\nconsolidated. One possible solution is to include compilation directories that are\nspecific to your test environment in your mix.exs:\n\n    def project do\n      ...\n      elixirc_paths: elixirc_paths(Mix.env())\n      ...\n    end\n\n    defp elixirc_paths(:test), do: [\"lib\", \"test/support\"]\n    defp elixirc_paths(_), do: [\"lib\"]\n\nAnd then you can define the implementations specific to the test environment\ninside `test/support/some_file.ex`.\n\nAnother approach is to disable protocol consolidation during tests in your\nmix.exs:\n\n    def project do\n      ...\n      consolidate_protocols: Mix.env() != :test\n      ...\n    end\n\nIf you are using `Mix.install/2`, you can do by passing the `consolidate_protocols`\noption:\n\n    Mix.install(\n      deps,\n      consolidate_protocols: false\n    )\n\nAlthough doing so is not recommended as it may affect the performance of\nyour code.\n\nFinally, note all protocols are compiled with `debug_info` set to `true`,\nregardless of the option set by the `elixirc` compiler. The debug info is\nused for consolidation and it is removed after consolidation unless\nglobally set.","ref":"Protocol.html#module-consolidation"},{"type":"function","title":"Protocol.assert_impl!/2","doc":"Checks if the given module is loaded and is an implementation\nof the given protocol.\n\nReturns `:ok` if so, otherwise raises `ArgumentError`.","ref":"Protocol.html#assert_impl!/2"},{"type":"function","title":"Protocol.assert_protocol!/1","doc":"Checks if the given module is loaded and is protocol.\n\nReturns `:ok` if so, otherwise raises `ArgumentError`.","ref":"Protocol.html#assert_protocol!/1"},{"type":"function","title":"Protocol.consolidate/2","doc":"Receives a protocol and a list of implementations and\nconsolidates the given protocol.\n\nConsolidation happens by changing the protocol `impl_for`\nin the abstract format to have fast lookup rules. Usually\nthe list of implementations to use during consolidation\nare retrieved with the help of `extract_impls/2`.\n\nIt returns the updated version of the protocol bytecode.\nIf the first element of the tuple is `:ok`, it means\nthe protocol was consolidated.\n\nA given bytecode or protocol implementation can be checked\nto be consolidated or not by analyzing the protocol\nattribute:\n\n    Protocol.consolidated?(Enumerable)\n\nThis function does not load the protocol at any point\nnor loads the new bytecode for the compiled module.\nHowever, each implementation must be available and\nit will be loaded.","ref":"Protocol.html#consolidate/2"},{"type":"function","title":"Protocol.consolidated?/1","doc":"Returns `true` if the protocol was consolidated.","ref":"Protocol.html#consolidated?/1"},{"type":"macro","title":"Protocol.derive/3","doc":"Derives the `protocol` for `module` with the given options.\n\nIf your implementation passes options or if you are generating\ncustom code based on the struct, you will also need to implement\na macro defined as `__deriving__(module, struct, options)`\nto get the options that were passed.","ref":"Protocol.html#derive/3"},{"type":"macro","title":"Examples - Protocol.derive/3","doc":"defprotocol Derivable do\n      def ok(arg)\n    end\n\n    defimpl Derivable, for: Any do\n      defmacro __deriving__(module, struct, options) do\n        quote do\n          defimpl Derivable, for: unquote(module) do\n            def ok(arg) do\n              {:ok, arg, unquote(Macro.escape(struct)), unquote(options)}\n            end\n          end\n        end\n      end\n\n      def ok(arg) do\n        {:ok, arg}\n      end\n    end\n\n    defmodule ImplStruct do\n      @derive [Derivable]\n      defstruct a: 0, b: 0\n    end\n\n    Derivable.ok(%ImplStruct{})\n    #=> {:ok, %ImplStruct{a: 0, b: 0}, %ImplStruct{a: 0, b: 0}, []}\n\nExplicit derivations can now be called via `__deriving__/3`:\n\n    # Explicitly derived via `__deriving__/3`\n    Derivable.ok(%ImplStruct{a: 1, b: 1})\n    #=> {:ok, %ImplStruct{a: 1, b: 1}, %ImplStruct{a: 0, b: 0}, []}\n\n    # Explicitly derived by API via `__deriving__/3`\n    require Protocol\n    Protocol.derive(Derivable, ImplStruct, :oops)\n    Derivable.ok(%ImplStruct{a: 1, b: 1})\n    #=> {:ok, %ImplStruct{a: 1, b: 1}, %ImplStruct{a: 0, b: 0}, :oops}","ref":"Protocol.html#derive/3-examples"},{"type":"function","title":"Protocol.extract_impls/2","doc":"Extracts all types implemented for the given protocol from\nthe given paths.\n\nThe paths can be either a charlist or a string. Internally\nthey are worked on as charlists, so passing them as lists\navoid extra conversion.\n\nDoes not load any of the implementations.","ref":"Protocol.html#extract_impls/2"},{"type":"function","title":"Examples - Protocol.extract_impls/2","doc":"# Get Elixir's ebin directory path and retrieve all protocols\n    iex> path = Application.app_dir(:elixir, \"ebin\")\n    iex> mods = Protocol.extract_impls(Enumerable, [path])\n    iex> List in mods\n    true","ref":"Protocol.html#extract_impls/2-examples"},{"type":"function","title":"Protocol.extract_protocols/1","doc":"Extracts all protocols from the given paths.\n\nThe paths can be either a charlist or a string. Internally\nthey are worked on as charlists, so passing them as lists\navoid extra conversion.\n\nDoes not load any of the protocols.","ref":"Protocol.html#extract_protocols/1"},{"type":"function","title":"Examples - Protocol.extract_protocols/1","doc":"# Get Elixir's ebin directory path and retrieve all protocols\n    iex> path = Application.app_dir(:elixir, \"ebin\")\n    iex> mods = Protocol.extract_protocols([path])\n    iex> Enumerable in mods\n    true","ref":"Protocol.html#extract_protocols/1-examples"},{"type":"protocol","title":"String.Chars","doc":"The `String.Chars` protocol is responsible for\nconverting a structure to a binary (only if applicable).\n\nThe only function required to be implemented is\n`to_string/1`, which does the conversion.\n\nThe `to_string/1` function automatically imported\nby `Kernel` invokes this protocol. String\ninterpolation also invokes `to_string/1` in its\narguments. For example, `\"foo#{bar}\"` is the same\nas `\"foo\" <> to_string(bar)`.","ref":"String.Chars.html"},{"type":"type","title":"String.Chars.t/0","doc":"All the types that implement this protocol.","ref":"String.Chars.html#t:t/0"},{"type":"function","title":"String.Chars.to_string/1","doc":"Converts `term` to a string.","ref":"String.Chars.html#to_string/1"},{"type":"module","title":"Code","doc":"Utilities for managing code compilation, code evaluation, and code loading.\n\nThis module complements Erlang's [`:code` module](`:code`)\nto add behavior which is specific to Elixir. For functions to\nmanipulate Elixir's AST (rather than evaluating it), see the\n`Macro` module.","ref":"Code.html"},{"type":"module","title":"Working with files - Code","doc":"This module contains three functions for compiling and evaluating files.\nHere is a summary of them and their behavior:\n\n  * `require_file/2` - compiles a file and tracks its name. It does not\n    compile the file again if it has been previously required.\n\n  * `compile_file/2` - compiles a file without tracking its name. Compiles the\n    file multiple times when invoked multiple times.\n\n  * `eval_file/2` - evaluates the file contents without tracking its name. It\n    returns the result of the last expression in the file, instead of the modules\n    defined in it. Evaluated files do not trigger the compilation tracers described\n    in the next section.\n\nIn a nutshell, the first must be used when you want to keep track of the files\nhandled by the system, to avoid the same file from being compiled multiple\ntimes. This is common in scripts.\n\n`compile_file/2` must be used when you are interested in the modules defined in a\nfile, without tracking. `eval_file/2` should be used when you are interested in\nthe result of evaluating the file rather than the modules it defines.\n\nThe functions above work with Elixir source. If you want to work\nwith modules compiled to bytecode, which have the `.beam` extension\nand are typically found below the _build directory of a Mix project,\nsee the functions in Erlang's [`:code`](`:code`) module.","ref":"Code.html#module-working-with-files"},{"type":"module","title":"Code loading on the Erlang VM - Code","doc":"Erlang has two modes to load code: interactive and embedded.\n\nBy default, the Erlang VM runs in interactive mode, where modules\nare loaded as needed. In embedded mode the opposite happens, as all\nmodules need to be loaded upfront or explicitly.\n\nYou can use `ensure_loaded/1` (as well as `ensure_loaded?/1` and\n`ensure_loaded!/1`) to check if a module is loaded before using it and\nact.\n\n## `ensure_compiled/1` and `ensure_compiled!/1`\n\nElixir also includes `ensure_compiled/1` and `ensure_compiled!/1`\nfunctions that are a superset of `ensure_loaded/1`.\n\nSince Elixir's compilation happens in parallel, in some situations\nyou may need to use a module that was not yet compiled, therefore\nit can't even be loaded.\n\nWhen invoked, `ensure_compiled/1` and `ensure_compiled!/1` halt the\ncompilation of the caller until the module becomes available. Note that\nthe distinction between `ensure_compiled/1` and `ensure_compiled!/1`\nis important: if you are using `ensure_compiled!/1`, you are\nindicating to the compiler that you can only continue if said module\nis available.\n\nIf you are using `Code.ensure_compiled/1`, you are implying you may\ncontinue without the module and therefore Elixir may return\n`{:error, :unavailable}` for cases where the module is not yet available\n(but may be available later on).\n\nFor those reasons, developers must typically use `Code.ensure_compiled!/1`.\nIn particular, do not do this:\n\n    case Code.ensure_compiled(module) do\n      {:module, _} -> module\n      {:error, _} -> raise ...\n    end\n\nFinally, note you only need `ensure_compiled!/1` to check for modules\nbeing defined within the same project. It does not apply to modules from\ndependencies as dependencies are always compiled upfront.\n\nIn most cases, `ensure_loaded/1` is enough. `ensure_compiled!/1`\nmust be used in rare cases, usually involving macros that need to\ninvoke a module for callback information. The use of `ensure_compiled/1`\nis even less likely.","ref":"Code.html#module-code-loading-on-the-erlang-vm"},{"type":"module","title":"Compilation tracers - Code","doc":"Elixir supports compilation tracers, which allow modules to observe constructs\nhandled by the Elixir compiler when compiling files. A tracer is a module\nthat implements the `trace/2` function. The function receives the event name\nas first argument and `Macro.Env` as second and it must return `:ok`. It is\nvery important for a tracer to do as little work as possible synchronously\nand dispatch the bulk of the work to a separate process. **Slow tracers will\nslow down compilation**.\n\nYou can configure your list of tracers via `put_compiler_option/2`. The\nfollowing events are available to tracers:\n\n  * `:start` - (since v1.11.0) invoked whenever the compiler starts to trace\n    a new lexical context. A lexical context is started when compiling a new\n    file or when defining a module within a function. Note evaluated code\n    does not start a new lexical context (because they don't track unused\n    aliases, imports, etc) but defining a module inside evaluated code will.\n\n    Note this event may be emitted in parallel, where multiple files/modules\n    invoke `:start` and run at the same time. The value of the `lexical_tracker`\n    of the macro environment, albeit opaque, can be used to uniquely identify\n    the environment.\n\n  * `:stop` - (since v1.11.0) invoked whenever the compiler stops tracing a\n    new lexical context, such as a new file.\n\n  * `{:import, meta, module, opts}` - traced whenever `module` is imported.\n    `meta` is the import AST metadata and `opts` are the import options.\n\n  * `{:imported_function, meta, module, name, arity}` and\n    `{:imported_macro, meta, module, name, arity}` - traced whenever an\n    imported function or macro is invoked. `meta` is the call AST metadata,\n    `module` is the module the import is from, followed by the `name` and `arity`\n    of the imported function/macro. A :remote_function/:remote_macro event\n    may still be emitted for the imported module/name/arity.\n\n  * `{:alias, meta, alias, as, opts}` - traced whenever `alias` is aliased\n    to `as`. `meta` is the alias AST metadata and `opts` are the alias options.\n\n  * `{:alias_expansion, meta, as, alias}` traced whenever there is an alias\n    expansion for a previously defined `alias`, i.e. when the user writes `as`\n    which is expanded to `alias`. `meta` is the alias expansion AST metadata.\n\n  * `{:alias_reference, meta, module}` - traced whenever there is an alias\n    in the code, i.e. whenever the user writes `MyModule.Foo.Bar` in the code,\n    regardless if it was expanded or not.\n\n  * `{:require, meta, module, opts}` - traced whenever `module` is required.\n    `meta` is the require AST metadata and `opts` are the require options.\n    If the `meta` option contains the `:from_macro`, then module was called\n    from within a macro and therefore must be treated as a compile-time dependency.\n\n  * `{:struct_expansion, meta, module, keys}` - traced whenever `module`'s struct\n    is expanded. `meta` is the struct AST metadata and `keys` are the keys being\n    used by expansion\n\n  * `{:remote_function, meta, module, name, arity}` and\n    `{:remote_macro, meta, module, name, arity}` - traced whenever a remote\n    function or macro is referenced. `meta` is the call AST metadata, `module`\n    is the invoked module, followed by the `name` and `arity`.\n\n  * `{:local_function, meta, name, arity}` and\n    `{:local_macro, meta, name, arity}` - traced whenever a local\n    function or macro is referenced. `meta` is the call AST metadata, followed by\n    the `name` and `arity`.\n\n  * `{:compile_env, app, path, return}` - traced whenever `Application.compile_env/3`\n    or `Application.compile_env!/2` are called. `app` is an atom, `path` is a list\n    of keys to traverse in the application environment and `return` is either\n    `{:ok, value}` or `:error`.\n\n  * `:defmodule` - (since v1.16.2) traced as soon as the definition of a module\n    starts. This is invoked early on in the module life cycle, `Module.open?/1`\n    still returns `false` for such traces\n\n  * `{:on_module, bytecode, _ignore}` - (since v1.13.0) traced whenever a module\n    is defined. This is equivalent to the `@after_compile` callback and invoked\n    after any `@after_compile` in the given module. The third element is currently\n    `:none` but it may provide more metadata in the future. It is best to ignore\n    it at the moment. Note that `Module` functions expecting not yet compiled modules\n    (such as `Module.definitions_in/1`) are still available at the time this event\n    is emitted.\n\nThe `:tracers` compiler option can be combined with the `:parser_options`\ncompiler option to enrich the metadata of the traced events above.\n\nNew events may be added at any time in the future, therefore it is advised\nfor the `trace/2` function to have a \"catch-all\" clause.\n\nBelow is an example tracer that prints all remote function invocations:\n\n    defmodule MyTracer do\n      def trace({:remote_function, _meta, module, name, arity}, env) do\n        IO.puts \"#{env.file}:#{env.line} #{inspect(module)}.#{name}/#{arity}\"\n        :ok\n      end\n\n      def trace(_event, _env) do\n        :ok\n      end\n    end","ref":"Code.html#module-compilation-tracers"},{"type":"function","title":"Code.append_path/2","doc":"Appends a path to the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for\nfinding module code. The list of files is managed per Erlang\nVM node.\n\nThe path is expanded with `Path.expand/1` before being appended.\nIt requires the path to exist. Returns a boolean indicating if\nthe path was successfully added.","ref":"Code.html#append_path/2"},{"type":"function","title":"Examples - Code.append_path/2","doc":"Code.append_path(\".\")\n    #=> true\n\n    Code.append_path(\"/does_not_exist\")\n    #=> false","ref":"Code.html#append_path/2-examples"},{"type":"function","title":"Options - Code.append_path/2","doc":"* `:cache` - (since v1.15.0) when true, the code path is cached\n    the first time it is traversed in order to reduce file system\n    operations. It requires Erlang/OTP 26, otherwise it is a no-op.","ref":"Code.html#append_path/2-options"},{"type":"function","title":"Code.append_paths/2","doc":"Appends a list of `paths` to the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for\nfinding module code. The list of files is managed per Erlang\nVM node.\n\nAll paths are expanded with `Path.expand/1` before being appended.\nOnly existing paths are appended. This function always returns `:ok`,\nregardless of how many paths were appended. Use `append_path/1`\nif you need more control.","ref":"Code.html#append_paths/2"},{"type":"function","title":"Examples - Code.append_paths/2","doc":"Code.append_paths([\".\", \"/does_not_exist\"])\n    #=> :ok","ref":"Code.html#append_paths/2-examples"},{"type":"function","title":"Options - Code.append_paths/2","doc":"* `:cache` - when true, the code path is cached the first time\n    it is traversed in order to reduce file system operations.\n    It requires Erlang/OTP 26, otherwise it is a no-op.","ref":"Code.html#append_paths/2-options"},{"type":"function","title":"Code.available_compiler_options/0","doc":"Returns a list with all available compiler options.\n\nFor a description of all options, see `put_compiler_option/2`.","ref":"Code.html#available_compiler_options/0"},{"type":"function","title":"Examples - Code.available_compiler_options/0","doc":"Code.available_compiler_options()\n    #=> [:docs, :debug_info, ...]","ref":"Code.html#available_compiler_options/0-examples"},{"type":"type","title":"Code.binding/0","doc":"A list with all variables and their values.\n\nThe binding keys are usually atoms, but they may be a tuple for variables\ndefined in a different context.","ref":"Code.html#t:binding/0"},{"type":"function","title":"Code.can_await_module_compilation?/0","doc":"Returns `true` if the current process can await for module compilation.\n\nWhen compiling Elixir code via `Kernel.ParallelCompiler`, which is\nused by Mix and `elixirc`, calling a module that has not yet been\ncompiled will block the caller until the module becomes available.\nExecuting Elixir scripts, such as passing a filename to `elixir`,\ndoes not await.","ref":"Code.html#can_await_module_compilation?/0"},{"type":"function","title":"Code.compile_file/2","doc":"Compiles the given file.\n\nAccepts `relative_to` as an argument to tell where the file is located.\n\nReturns a list of tuples where the first element is the module name and\nthe second one is its bytecode (as a binary). Opposite to `require_file/2`,\nit does not track the filename of the compiled file.\n\nIf you would like to get the result of evaluating file rather than the\nmodules defined in it, see `eval_file/2`.\n\nFor compiling many files concurrently, see `Kernel.ParallelCompiler.compile/2`.","ref":"Code.html#compile_file/2"},{"type":"function","title":"Code.compile_quoted/2","doc":"Compiles the quoted expression.\n\nReturns a list of tuples where the first element is the module name and\nthe second one is its bytecode (as a binary). A `file` can be\ngiven as second argument which will be used for reporting warnings\nand errors.","ref":"Code.html#compile_quoted/2"},{"type":"function","title":"Code.compile_string/2","doc":"Compiles the given string.\n\nReturns a list of tuples where the first element is the module name\nand the second one is its bytecode (as a binary). A `file` can be\ngiven as a second argument which will be used for reporting warnings\nand errors.\n\n**Warning**: `string` can be any Elixir code and code can be executed with\nthe same privileges as the Erlang VM: this means that such code could\ncompromise the machine (for example by executing system commands).\nDon't use `compile_string/2` with untrusted input (such as strings coming\nfrom the network).","ref":"Code.html#compile_string/2"},{"type":"function","title":"Code.compiler_options/0","doc":"Gets all compilation options from the code server.\n\nTo get individual options, see `get_compiler_option/1`.\nFor a description of all options, see `put_compiler_option/2`.","ref":"Code.html#compiler_options/0"},{"type":"function","title":"Examples - Code.compiler_options/0","doc":"Code.compiler_options()\n    #=> %{debug_info: true, docs: true, ...}","ref":"Code.html#compiler_options/0-examples"},{"type":"function","title":"Code.compiler_options/1","doc":"Stores all given compilation options.\n\nChanging the compilation options affect all processes\nrunning in a given Erlang VM node. To store individual\noptions and for a description of all options, see\n`put_compiler_option/2`.\n\nReturns a map with previous values.","ref":"Code.html#compiler_options/1"},{"type":"function","title":"Examples - Code.compiler_options/1","doc":"Code.compiler_options(warnings_as_errors: true)\n    #=> %{warnings_as_errors: false}","ref":"Code.html#compiler_options/1-examples"},{"type":"function","title":"Code.delete_path/1","doc":"Deletes a path from the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for finding\nmodule code. The list of files is managed per Erlang VM node.\n\nThe path is expanded with `Path.expand/1` before being deleted. If the\npath does not exist, this function returns `false`.","ref":"Code.html#delete_path/1"},{"type":"function","title":"Examples - Code.delete_path/1","doc":"Code.prepend_path(\".\")\n    Code.delete_path(\".\")\n    #=> true\n\n    Code.delete_path(\"/does_not_exist\")\n    #=> false","ref":"Code.html#delete_path/1-examples"},{"type":"function","title":"Code.delete_paths/1","doc":"Deletes a list of paths from the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for finding\nmodule code. The list of files is managed per Erlang VM node.\n\nThe path is expanded with `Path.expand/1` before being deleted. If the\npath does not exist, this function returns `false`.","ref":"Code.html#delete_paths/1"},{"type":"type","title":"Code.diagnostic/1","doc":"Diagnostics returned by the compiler and code evaluation.\n\nThe file and position relate to where the diagnostic should be shown.\nIf there is a file and position, then the diagnostic is precise\nand you can use the given file and position for generating snippets,\nIDEs annotations, and so on. An optional span is available with\nthe line and column the diagnostic ends.\n\nOtherwise, a stacktrace may be given, which you can place your own\nheuristics to provide better reporting.\n\nThe source field points to the source file the compiler tracked\nthe error to. For example, a file `lib/foo.ex` may embed `.eex`\ntemplates from `lib/foo/bar.eex`. A syntax error on the EEx template\nwill point to file `lib/foo/bar.eex` but the source is `lib/foo.ex`.","ref":"Code.html#t:diagnostic/1"},{"type":"function","title":"Code.ensure_all_loaded/1","doc":"Ensures the given modules are loaded.\n\nSimilar to `ensure_loaded/1`, but accepts a list of modules instead of a single\nmodule, and loads all of them.\n\nIf all modules load successfully, returns `:ok`. Otherwise, returns `{:error, errors}`\nwhere `errors` is a list of tuples made of the module and the reason it failed to load.","ref":"Code.html#ensure_all_loaded/1"},{"type":"function","title":"Examples - Code.ensure_all_loaded/1","doc":"iex> Code.ensure_all_loaded([Atom, String])\n    :ok\n\n    iex> Code.ensure_all_loaded([Atom, DoesNotExist])\n    {:error, [{DoesNotExist, :nofile}]}","ref":"Code.html#ensure_all_loaded/1-examples"},{"type":"function","title":"Code.ensure_all_loaded!/1","doc":"Same as `ensure_all_loaded/1` but raises if any of the modules cannot be loaded.","ref":"Code.html#ensure_all_loaded!/1"},{"type":"function","title":"Code.ensure_compiled/1","doc":"Similar to `ensure_compiled!/1` but indicates you can continue without said module.\n\nWhile `ensure_compiled!/1` indicates to the Elixir compiler you can\nonly continue when said module is available, this function indicates\nyou may continue compilation without said module.\n\nIf it succeeds in loading the module, it returns `{:module, module}`.\nIf not, returns `{:error, reason}` with the error reason.\nIf the module being checked is currently in a compiler deadlock,\nthis function returns `{:error, :unavailable}`. Unavailable doesn't\nnecessarily mean the module doesn't exist, just that it is not currently\navailable, but it (or may not) become available in the future.\n\nTherefore, if you can only continue if the module is available, use\n`ensure_compiled!/1` instead. In particular, do not do this:\n\n    case Code.ensure_compiled(module) do\n      {:module, _} -> module\n      {:error, _} -> raise ...\n    end\n\nSee the module documentation for more information on code loading.","ref":"Code.html#ensure_compiled/1"},{"type":"function","title":"Code.ensure_compiled!/1","doc":"Ensures the given module is compiled and loaded.\n\nIf the module is already loaded, it works as no-op. If the module was\nnot compiled yet, `ensure_compiled!/1` halts the compilation of the caller\nuntil the module given to `ensure_compiled!/1` becomes available or\nall files for the current project have been compiled. If compilation\nfinishes and the module is not available or is in a deadlock, an error\nis raised.\n\nGiven this function halts compilation, use it carefully. In particular,\navoid using it to guess which modules are in the system. Overuse of this\nfunction can also lead to deadlocks, where two modules check at the same time\nif the other is compiled. This returns a specific unavailable error code,\nwhere we cannot successfully verify a module is available or not.\n\nSee the module documentation for more information on code loading.","ref":"Code.html#ensure_compiled!/1"},{"type":"function","title":"Code.ensure_loaded/1","doc":"Ensures the given module is loaded.\n\nIf the module is already loaded, this works as no-op. If the module\nwas not yet loaded, it tries to load it.\n\nIf it succeeds in loading the module, it returns `{:module, module}`.\nIf not, returns `{:error, reason}` with the error reason.\n\nSee the module documentation for more information on code loading.","ref":"Code.html#ensure_loaded/1"},{"type":"function","title":"Examples - Code.ensure_loaded/1","doc":"iex> Code.ensure_loaded(Atom)\n    {:module, Atom}\n\n    iex> Code.ensure_loaded(DoesNotExist)\n    {:error, :nofile}","ref":"Code.html#ensure_loaded/1-examples"},{"type":"function","title":"Code.ensure_loaded!/1","doc":"Same as `ensure_loaded/1` but raises if the module cannot be loaded.","ref":"Code.html#ensure_loaded!/1"},{"type":"function","title":"Code.ensure_loaded?/1","doc":"Ensures the given module is loaded.\n\nSimilar to `ensure_loaded/1`, but returns `true` if the module\nis already loaded or was successfully loaded. Returns `false`\notherwise.","ref":"Code.html#ensure_loaded?/1"},{"type":"function","title":"Examples - Code.ensure_loaded?/1","doc":"iex> Code.ensure_loaded?(String)\n    true","ref":"Code.html#ensure_loaded?/1-examples"},{"type":"function","title":"Code.env_for_eval/1","doc":"Returns an environment for evaluation.\n\nIt accepts either a `Macro.Env`, that is then pruned and prepared,\nor a list of options. It returns an environment that is ready for\nevaluation.\n\nMost functions in this module will automatically prepare the given\nenvironment for evaluation, so you don't need to explicitly call\nthis function, with the exception of `eval_quoted_with_env/3`,\nwhich was designed precisely to be called in a loop, to implement\nfeatures such as interactive shells or anything else with multiple\nevaluations.","ref":"Code.html#env_for_eval/1"},{"type":"function","title":"Options - Code.env_for_eval/1","doc":"If an env is not given, the options can be:\n\n  * `:file` - the file to be considered in the evaluation\n\n  * `:line` - the line on which the script starts","ref":"Code.html#env_for_eval/1-options"},{"type":"function","title":"Code.eval_file/2","doc":"Evaluates the given file.\n\nAccepts `relative_to` as an argument to tell where the file is located.\n\nWhile `require_file/2` and `compile_file/2` return the loaded modules and their\nbytecode, `eval_file/2` simply evaluates the file contents and returns the\nevaluation result and its binding (exactly the same return value as `eval_string/3`).","ref":"Code.html#eval_file/2"},{"type":"function","title":"Code.eval_quoted/3","doc":"Evaluates the quoted contents.\n\n**Warning**: Calling this function inside a macro is considered bad\npractice as it will attempt to evaluate runtime values at compile time.\nMacro arguments are typically transformed by unquoting them into the\nreturned quoted expressions (instead of evaluated).\n\nSee `eval_string/3` for a description of `binding` and `opts`.","ref":"Code.html#eval_quoted/3"},{"type":"function","title":"Examples - Code.eval_quoted/3","doc":"iex> contents = quote(do: var!(a) + var!(b))\n    iex> {result, binding} = Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\nFor convenience, you can pass `__ENV__/0` as the `opts` argument and\nall options will be automatically extracted from the current environment:\n\n    iex> contents = quote(do: var!(a) + var!(b))\n    iex> {result, binding} = Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]","ref":"Code.html#eval_quoted/3-examples"},{"type":"function","title":"Code.eval_quoted_with_env/4","doc":"Evaluates the given `quoted` contents with `binding` and `env`.\n\nThis function is meant to be called in a loop, to implement features\nsuch as interactive shells or anything else with multiple evaluations.\nTherefore, the first time you call this function, you must compute\nthe initial environment with `env_for_eval/1`. The remaining calls\nmust pass the environment that was returned by this function.","ref":"Code.html#eval_quoted_with_env/4"},{"type":"function","title":"Options - Code.eval_quoted_with_env/4","doc":"* `:prune_binding` - (since v1.14.2) prune binding to keep only\n    variables read or written by the evaluated code. Note that\n    variables used by modules are always pruned, even if later used\n    by the modules. You can submit to the `:on_module` tracer event\n    and access the variables used by the module from its environment.","ref":"Code.html#eval_quoted_with_env/4-options"},{"type":"function","title":"Code.eval_string/3","doc":"Evaluates the contents given by `string`.\n\nThe `binding` argument is a list of all variables and their values.\nThe `opts` argument is a keyword list of environment options.\n\n**Warning**: `string` can be any Elixir code and will be executed with\nthe same privileges as the Erlang VM: this means that such code could\ncompromise the machine (for example by executing system commands).\nDon't use `eval_string/3` with untrusted input (such as strings coming\nfrom the network).","ref":"Code.html#eval_string/3"},{"type":"function","title":"Options - Code.eval_string/3","doc":"Options can be:\n\n  * `:file` - the file to be considered in the evaluation\n\n  * `:line` - the line on which the script starts\n\nAdditionally, you may also pass an environment as second argument,\nso the evaluation happens within that environment.\n\nReturns a tuple of the form `{value, binding}`, where `value` is the value\nreturned from evaluating `string`. If an error occurs while evaluating\n`string`, an exception will be raised.\n\n`binding` is a list with all variable names and their values after evaluating\n`string`. The binding keys are usually atoms, but they may be a tuple for variables\ndefined in a different context. The names are in no particular order.","ref":"Code.html#eval_string/3-options"},{"type":"function","title":"Examples - Code.eval_string/3","doc":"iex> {result, binding} = Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\n    iex> {result, binding} = Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2, c: 3]\n\n    iex> {result, binding} = Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 3, b: 2]\n\nFor convenience, you can pass `__ENV__/0` as the `opts` argument and\nall imports, requires and aliases defined in the current environment\nwill be automatically carried over:\n\n    iex> {result, binding} = Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]","ref":"Code.html#eval_string/3-examples"},{"type":"function","title":"Code.fetch_docs/1","doc":"Returns the docs for the given module or path to `.beam` file.\n\nWhen given a module name, it finds its BEAM code and reads the docs from it.\n\nWhen given a path to a `.beam` file, it will load the docs directly from that\nfile.\n\nIt returns the term stored in the documentation chunk in the format defined by\n[EEP 48](https://www.erlang.org/eeps/eep-0048.html) or `{:error, reason}` if\nthe chunk is not available.","ref":"Code.html#fetch_docs/1"},{"type":"function","title":"Examples - Code.fetch_docs/1","doc":"# Module documentation of an existing module\n    iex> {:docs_v1, _, :elixir, _, %{\"en\" => module_doc}, _, _} = Code.fetch_docs(Atom)\n    iex> module_doc |> String.split(\"\\n\") |> Enum.at(0)\n    \"Atoms are constants whose values are their own name.\"\n\n    # A module that doesn't exist\n    iex> Code.fetch_docs(ModuleNotGood)\n    {:error, :module_not_found}","ref":"Code.html#fetch_docs/1-examples"},{"type":"function","title":"Code.format_file!/2","doc":"Formats a file.\n\nSee `format_string!/2` for more information on code formatting and\navailable options.","ref":"Code.html#format_file!/2"},{"type":"function","title":"Code.format_string!/2","doc":"Formats the given code `string`.\n\nThe formatter receives a string representing Elixir code and\nreturns iodata representing the formatted code according to\npre-defined rules.","ref":"Code.html#format_string!/2"},{"type":"function","title":"Options - Code.format_string!/2","doc":"* `:file` - the file which contains the string, used for error\n    reporting\n\n  * `:line` - the line the string starts, used for error reporting\n\n  * `:line_length` - the line length to aim for when formatting\n    the document. Defaults to 98. This value indicates when an expression\n    should be broken over multiple lines but it is not guaranteed\n    to do so. See the \"Line length\" section below for more information\n\n  * `:locals_without_parens` - a keyword list of name and arity\n    pairs that should be kept without parens whenever possible.\n    The arity may be the atom `:*`, which implies all arities of\n    that name. The formatter already includes a list of functions\n    and this option augments this list.\n\n  * `:force_do_end_blocks` (since v1.9.0) - when `true`, converts all\n    inline usages of `do: ...`,  `else: ...` and friends into `do`-`end`\n    blocks. Defaults to `false`. Note that this option is convergent:\n    once you set it to `true`, **all keywords** will be converted.\n    If you set it to `false` later on, `do`-`end` blocks won't be\n    converted back to keywords.\n\n  * `:normalize_bitstring_modifiers` (since v1.14.0) - when `true`,\n    removes unnecessary parentheses in known bitstring\n    [modifiers](`<<>>/1`), for example `< >`\n    becomes `< >`, or adds parentheses for custom\n    modifiers, where `< >` becomes `< >`.\n    Defaults to `true`. This option changes the AST.\n\n  * `:normalize_charlists_as_sigils` (since v1.15.0) - when `true`,\n    formats charlists as [`~c`](`Kernel.sigil_c/2`) sigils, for example\n    `'foo'` becomes `~c\"foo\"`.\n    Defaults to `true`. This option changes the AST.","ref":"Code.html#format_string!/2-options"},{"type":"function","title":"Design principles - Code.format_string!/2","doc":"The formatter was designed under three principles.\n\nFirst, the formatter never changes the semantics of the code.\nThis means the input AST and the output AST are almost always equivalent.\nThe only cases where the formatter will change the AST is when the input AST\nwould cause *compiler warnings* and the output AST won't. The cases where\nthe formatter changes the AST can be disabled through formatting options\nif desired.\n\nThe second principle is to provide as little configuration as possible.\nThis eases the formatter adoption by removing contention points while\nmaking sure a single style is followed consistently by the community as\na whole.\n\nThe formatter does not hard code names. The formatter will not behave\nspecially because a function is named `defmodule`, `def`, or the like. This\nprinciple mirrors Elixir's goal of being an extensible language where\ndevelopers can extend the language with new constructs as if they were\npart of the language. When it is absolutely necessary to change behavior\nbased on the name, this behavior should be configurable, such as the\n`:locals_without_parens` option.","ref":"Code.html#format_string!/2-design-principles"},{"type":"function","title":"Running the formatter - Code.format_string!/2","doc":"The formatter attempts to fit the most it can on a single line and\nintroduces line breaks wherever possible when it cannot.\n\nIn some cases, this may lead to undesired formatting. Therefore, **some\ncode generated by the formatter may not be aesthetically pleasing and\nmay require explicit intervention from the developer**. That's why we\ndo not recommend to run the formatter blindly in an existing codebase.\nInstead you should format and sanity check each formatted file.\n\nFor example, the formatter may break a long function definition over\nmultiple clauses:\n\n    def my_function(\n      %User{name: name, age: age, ...},\n      arg1,\n      arg2\n    ) do\n      ...\n    end\n\nWhile the code above is completely valid, you may prefer to match on\nthe struct variables inside the function body in order to keep the\ndefinition on a single line:\n\n    def my_function(%User{} = user, arg1, arg2) do\n      %{name: name, age: age, ...} = user\n      ...\n    end\n\nIn some situations, you can use the fact the formatter does not generate\nelegant code as a hint for refactoring. Take this code:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        required_permissions == Enum.to_list(MapSet.intersection(MapSet.new(required_permissions), MapSet.new(available_permissions)))\n    end\n\nThe code above has very long lines and running the formatter is not going\nto address this issue. In fact, the formatter may make it more obvious that\nyou have complex expressions:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        required_permissions ==\n          Enum.to_list(\n            MapSet.intersection(\n              MapSet.new(required_permissions),\n              MapSet.new(available_permissions)\n            )\n          )\n    end\n\nTake such cases as a suggestion that your code should be refactored:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        matching_permissions?(required_permissions, available_permissions)\n    end\n\n    defp matching_permissions?(required_permissions, available_permissions) do\n      intersection =\n        required_permissions\n        |> MapSet.new()\n        |> MapSet.intersection(MapSet.new(available_permissions))\n        |> Enum.to_list()\n\n      required_permissions == intersection\n    end\n\nTo sum it up: since the formatter cannot change the semantics of your\ncode, sometimes it is necessary to tweak or refactor the code to get\noptimal formatting. To help better understand how to control the formatter,\nwe describe in the next sections the cases where the formatter keeps the\nuser encoding and how to control multiline expressions.","ref":"Code.html#format_string!/2-running-the-formatter"},{"type":"function","title":"Line length - Code.format_string!/2","doc":"Another point about the formatter is that the `:line_length` configuration\nindicates when an expression should be broken over multiple lines but it is\nnot guaranteed to do so. In many cases, it is not possible for the formatter\nto break your code apart, which means it will go over the line length.\nFor example, if you have a long string:\n\n    \"this is a very long string that will go over the line length\"\n\nThe formatter doesn't know how to break it apart without changing the\ncode underlying syntax representation, so it is up to you to step in:\n\n    \"this is a very long string \" <>\n       \"that will go over the line length\"\n\nThe string concatenation makes the code fit on a single line and also\ngives more options to the formatter.\n\nThis may also appear in keywords such as do/end blocks and operators,\nwhere the `do` keyword may go over the line length because there is no\nopportunity for the formatter to introduce a line break in a readable way.\nFor example, if you do:\n\n    case very_long_expression() do\n    end\n\nAnd only the `do` keyword is beyond the line length, Elixir **will not**\nemit this:\n\n    case very_long_expression()\n    do\n    end\n\nSo it prefers to not touch the line at all and leave `do` above the\nline limit.","ref":"Code.html#format_string!/2-line-length"},{"type":"function","title":"Keeping user's formatting - Code.format_string!/2","doc":"The formatter respects the input format in some cases. Those are\nlisted below:\n\n  * Insignificant digits in numbers are kept as is. The formatter,\n    however, always inserts underscores for decimal numbers with more\n    than 5 digits and converts hexadecimal digits to uppercase\n\n  * Strings, charlists, atoms and sigils are kept as is. No character\n    is automatically escaped or unescaped. The choice of delimiter is\n    also respected from the input\n\n  * Newlines inside blocks are kept as in the input except for:\n    1) expressions that take multiple lines will always have an empty\n    line before and after and 2) empty lines are always squeezed\n    together into a single empty line\n\n  * The choice between `:do` keyword and `do`-`end` blocks is left\n    to the user\n\n  * Lists, tuples, bitstrings, maps, structs and function calls will be\n    broken into multiple lines if they are followed by a newline in the\n    opening bracket and preceded by a new line in the closing bracket\n\n  * Newlines before certain operators (such as the pipeline operators)\n    and before other operators (such as comparison operators)\n\nThe behaviors above are not guaranteed. We may remove or add new\nrules in the future. The goal of documenting them is to provide better\nunderstanding on what to expect from the formatter.","ref":"Code.html#format_string!/2-keeping-user-s-formatting"},{"type":"function","title":"Multi-line lists, maps, tuples, and the like - Code.format_string!/2","doc":"You can force lists, tuples, bitstrings, maps, structs and function\ncalls to have one entry per line by adding a newline after the opening\nbracket and a new line before the closing bracket lines. For example:\n\n    [\n      foo,\n      bar\n    ]\n\nIf there are no newlines around the brackets, then the formatter will\ntry to fit everything on a single line, such that the snippet below\n\n    [foo,\n     bar]\n\nwill be formatted as\n\n    [foo, bar]\n\nYou can also force function calls and keywords to be rendered on multiple\nlines by having each entry on its own line:\n\n    defstruct name: nil,\n              age: 0\n\nThe code above will be kept with one keyword entry per line by the\nformatter. To avoid that, just squash everything into a single line.","ref":"Code.html#format_string!/2-multi-line-lists-maps-tuples-and-the-like"},{"type":"function","title":"Parens and no parens in function calls - Code.format_string!/2","doc":"Elixir has two syntaxes for function calls. With parens and no parens.\nBy default, Elixir will add parens to all calls except for:\n\n  1. calls that have `do`-`end` blocks\n  2. local calls without parens where the name and arity of the local\n     call is also listed under `:locals_without_parens` (except for\n     calls with arity 0, where the compiler always require parens)\n\nThe choice of parens and no parens also affects indentation. When a\nfunction call with parens doesn't fit on the same line, the formatter\nintroduces a newline around parens and indents the arguments with two\nspaces:\n\n    some_call(\n      arg1,\n      arg2,\n      arg3\n    )\n\nOn the other hand, function calls without parens are always indented\nby the function call length itself, like this:\n\n    some_call arg1,\n              arg2,\n              arg3\n\nIf the last argument is a data structure, such as maps and lists, and\nthe beginning of the data structure fits on the same line as the function\ncall, then no indentation happens, this allows code like this:\n\n    Enum.reduce(some_collection, initial_value, fn element, acc ->\n      # code\n    end)\n\n    some_function_without_parens %{\n      foo: :bar,\n      baz: :bat\n    }","ref":"Code.html#format_string!/2-parens-and-no-parens-in-function-calls"},{"type":"function","title":"Code comments - Code.format_string!/2","doc":"The formatter also handles code comments in a way to guarantee a space\nis always added between the beginning of the comment (#) and the next\ncharacter.\n\nThe formatter also extracts all trailing comments to their previous line.\nFor example, the code below\n\n    hello #world\n\nwill be rewritten to\n\n    # world\n    hello\n\nBecause code comments are handled apart from the code representation (AST),\nthere are some situations where code comments are seen as ambiguous by the\ncode formatter. For example, the comment in the anonymous function below\n\n    fn\n      arg1 ->\n        body1\n        # comment\n\n      arg2 ->\n        body2\n    end\n\nand in this one\n\n    fn\n      arg1 ->\n        body1\n\n      # comment\n      arg2 ->\n        body2\n    end\n\nare considered equivalent (the nesting is discarded alongside most of\nuser formatting). In such cases, the code formatter will always format to\nthe latter.","ref":"Code.html#format_string!/2-code-comments"},{"type":"function","title":"Newlines - Code.format_string!/2","doc":"The formatter converts all newlines in code from `\\r\\n` to `\\n`.","ref":"Code.html#format_string!/2-newlines"},{"type":"function","title":"Code.get_compiler_option/1","doc":"Returns the value of a given compiler option.\n\nFor a description of all options, see `put_compiler_option/2`.","ref":"Code.html#get_compiler_option/1"},{"type":"function","title":"Examples - Code.get_compiler_option/1","doc":"Code.get_compiler_option(:debug_info)\n    #=> true","ref":"Code.html#get_compiler_option/1-examples"},{"type":"type","title":"Code.line/0","doc":"The line. 0 indicates no line.","ref":"Code.html#t:line/0"},{"type":"function","title":"Code.loaded?/1","doc":"Returns `true` if the module is loaded.\n\nThis function doesn't attempt to load the module. For such behavior,\n`ensure_loaded?/1` can be used.","ref":"Code.html#loaded?/1"},{"type":"function","title":"Examples - Code.loaded?/1","doc":"iex> Code.loaded?(Atom)\n    true\n\n    iex> Code.loaded?(NotYetLoaded)\n    false","ref":"Code.html#loaded?/1-examples"},{"type":"type","title":"Code.position/0","doc":"The position of the diagnostic.\n\nCan be either a line number or a `{line, column}`.\nLine and columns numbers are one-based.\nA position of `0` represents unknown.","ref":"Code.html#t:position/0"},{"type":"function","title":"Code.prepend_path/2","doc":"Prepends a path to the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for\nfinding module code. The list of files is managed per Erlang\nVM node.\n\nThe path is expanded with `Path.expand/1` before being prepended.\nIt requires the path to exist. Returns a boolean indicating if\nthe path was successfully added.","ref":"Code.html#prepend_path/2"},{"type":"function","title":"Examples - Code.prepend_path/2","doc":"Code.prepend_path(\".\")\n    #=> true\n\n    Code.prepend_path(\"/does_not_exist\")\n    #=> false","ref":"Code.html#prepend_path/2-examples"},{"type":"function","title":"Options - Code.prepend_path/2","doc":"* `:cache` - (since v1.15.0) when true, the code path is cached\n    the first time it is traversed in order to reduce file system\n    operations. It requires Erlang/OTP 26, otherwise it is a no-op.","ref":"Code.html#prepend_path/2-options"},{"type":"function","title":"Code.prepend_paths/2","doc":"Prepends a list of `paths` to the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for\nfinding module code. The list of files is managed per Erlang\nVM node.\n\nAll paths are expanded with `Path.expand/1` before being prepended.\nOnly existing paths are prepended. This function always returns `:ok`,\nregardless of how many paths were prepended. Use `prepend_path/1`\nif you need more control.","ref":"Code.html#prepend_paths/2"},{"type":"function","title":"Examples - Code.prepend_paths/2","doc":"Code.prepend_paths([\".\", \"/does_not_exist\"])\n    #=> :ok","ref":"Code.html#prepend_paths/2-examples"},{"type":"function","title":"Options - Code.prepend_paths/2","doc":"* `:cache` - when true, the code path is cached the first time\n    it is traversed in order to reduce file system operations.\n    It requires Erlang/OTP 26, otherwise it is a no-op.","ref":"Code.html#prepend_paths/2-options"},{"type":"function","title":"Code.print_diagnostic/2","doc":"Prints a diagnostic into the standard error.\n\nA diagnostic is either returned by `Kernel.ParallelCompiler`\nor by `Code.with_diagnostics/2`.","ref":"Code.html#print_diagnostic/2"},{"type":"function","title":"Options - Code.print_diagnostic/2","doc":"* `:snippet` - whether to read the code snippet in the diagnostic location.\n    As it may impact performance, it is not recommended to be used in runtime.\n    Defaults to `true`.","ref":"Code.html#print_diagnostic/2-options"},{"type":"function","title":"Code.purge_compiler_modules/0","doc":"Purge compiler modules.\n\nThe compiler utilizes temporary modules to compile code. For example,\n`elixir_compiler_1`, `elixir_compiler_2`, and so on. In case the compiled code\nstores references to anonymous functions or similar, the Elixir compiler\nmay be unable to reclaim those modules, keeping an unnecessary amount of\ncode in memory and eventually leading to modules such as `elixir_compiler_12345`.\n\nThis function purges all modules currently kept by the compiler, allowing\nold compiler module names to be reused. If there are any processes running\nany code from such modules, they will be terminated too.\n\nThis function is only meant to be called if you have a long running node\nthat is constantly evaluating code.\n\nIt returns `{:ok, number_of_modules_purged}`.","ref":"Code.html#purge_compiler_modules/0"},{"type":"function","title":"Code.put_compiler_option/2","doc":"Stores a compilation option.\n\nChanging the compilation options affect all processes running in a\ngiven Erlang VM node.\n\nAvailable options are:\n\n  * `:docs` - when `true`, retains documentation in the compiled module.\n    Defaults to `true`.\n\n  * `:debug_info` - when `true`, retains debug information in the compiled\n    module. Defaults to `true`.\n    This enables static analysis tools as it allows developers to\n    partially reconstruct the original source code. Therefore, disabling\n    `:debug_info` is not recommended as it removes the ability of the\n    Elixir compiler and other tools to provide feedback. If you want to\n    remove the `:debug_info` while deploying, tools like `mix release`\n    already do such by default.\n    Additionally, `mix test` disables it via the `:test_elixirc_options`\n    project configuration option.\n    This option can also be overridden per module using the `@compile` directive.\n\n  * `:ignore_already_consolidated` (since v1.10.0) - when `true`, does not warn\n    when a protocol has already been consolidated and a new implementation is added.\n    Defaults to `false`.\n\n  * `:ignore_module_conflict` - when `true`, does not warn when a module has\n    already been defined. Defaults to `false`.\n\n  * `:relative_paths` - when `true`, uses relative paths in quoted nodes,\n    warnings, and errors generated by the compiler. Note disabling this option\n    won't affect runtime warnings and errors. Defaults to `true`.\n\n  * `:warnings_as_errors` - causes compilation to fail when warnings are\n    generated. Defaults to `false`.\n\n  * `:no_warn_undefined` (since v1.10.0) - list of modules and `{Mod, fun, arity}`\n    tuples that will not emit warnings that the module or function does not exist\n    at compilation time. Pass atom `:all` to skip warning for all undefined\n    functions. This can be useful when doing dynamic compilation. Defaults to `[]`.\n\n  * `:tracers` (since v1.10.0) - a list of tracers (modules) to be used during\n    compilation. See the module docs for more information. Defaults to `[]`.\n\n  * `:parser_options` (since v1.10.0) - a keyword list of options to be given\n    to the parser when compiling files. It accepts the same options as\n    `string_to_quoted/2` (except by the options that change the AST itself).\n    This can be used in combination with the tracer to retrieve localized\n    information about events happening during compilation. Defaults to `[columns: true]`.\n    This option only affects code compilation functions, such as `compile_string/2`\n    and `compile_file/2` but not `string_to_quoted/2` and friends, as the\n    latter is used for other purposes beyond compilation.\n\n  * `:on_undefined_variable` (since v1.15.0) - either `:raise` or `:warn`.\n    When `:raise` (the default), undefined variables will trigger a compilation\n    error. You may be set it to `:warn` if you want undefined variables to\n    emit a warning and expand as to a local call to the zero-arity function\n    of the same name (for example, `node` would be expanded as `node()`).\n    This `:warn` behavior only exists for compatibility reasons when working\n    with old dependencies, its usage is discouraged and it will be removed\n    in future releases.\n\nIt always returns `:ok`. Raises an error for invalid options.","ref":"Code.html#put_compiler_option/2"},{"type":"function","title":"Examples - Code.put_compiler_option/2","doc":"Code.put_compiler_option(:debug_info, true)\n    #=> :ok","ref":"Code.html#put_compiler_option/2-examples"},{"type":"function","title":"Code.quoted_to_algebra/2","doc":"Converts a quoted expression to an algebra document using Elixir's formatter rules.\n\nThe algebra document can be converted into a string by calling:\n\n    doc\n    |> Inspect.Algebra.format(:infinity)\n    |> IO.iodata_to_binary()\n\nFor a high-level function that does the same, see `Macro.to_string/1`.","ref":"Code.html#quoted_to_algebra/2"},{"type":"function","title":"Formatting considerations - Code.quoted_to_algebra/2","doc":"The Elixir AST does not contain metadata for literals like strings, lists, or\ntuples with two elements, which means that the produced algebra document will\nnot respect all of the user preferences and comments may be misplaced.\nTo get better results, you can use the `:token_metadata`, `:unescape` and\n`:literal_encoder` options to `string_to_quoted/2` to provide additional\ninformation to the formatter:\n\n    [\n      literal_encoder: &{:ok, {:__block__, &2, [&1]}},\n      token_metadata: true,\n      unescape: false\n    ]\n\nThis will produce an AST that contains information such as `do` blocks start\nand end lines or sigil delimiters, and by wrapping literals in blocks they can\nnow hold metadata like line number, string delimiter and escaped sequences, or\ninteger formatting (such as `0x2a` instead of `47`). However, **note this AST is\nnot valid**. If you evaluate it, it won't have the same semantics as the regular\nElixir AST due to the `:unescape` and `:literal_encoder` options. However,\nthose options are useful if you're doing source code manipulation, where it's\nimportant to preserve user choices and comments placing.","ref":"Code.html#quoted_to_algebra/2-formatting-considerations"},{"type":"function","title":"Options - Code.quoted_to_algebra/2","doc":"* `:comments` - the list of comments associated with the quoted expression.\n    Defaults to `[]`. It is recommended that both `:token_metadata` and\n    `:literal_encoder` options are given to `string_to_quoted_with_comments/2`\n    in order to get proper placement for comments\n\n  * `:escape` - when `true`, escaped sequences like `\\n` will be escaped into\n    `\\\\n`. If the `:unescape` option was set to `false` when using\n    `string_to_quoted/2`, setting this option to `false` will prevent it from\n    escaping the sequences twice. Defaults to `true`.\n\n  * `:locals_without_parens` - a keyword list of name and arity\n    pairs that should be kept without parens whenever possible.\n    The arity may be the atom `:*`, which implies all arities of\n    that name. The formatter already includes a list of functions\n    and this option augments this list.\n\n  * `:syntax_colors` - a keyword list of colors the output is colorized.\n    See `Inspect.Opts` for more information.","ref":"Code.html#quoted_to_algebra/2-options"},{"type":"function","title":"Code.require_file/2","doc":"Requires the given `file`.\n\nAccepts `relative_to` as an argument to tell where the file is located.\nIf the file was already required, `require_file/2` doesn't do anything and\nreturns `nil`.\n\nNote that if `require_file/2` is invoked by different processes concurrently,\nthe first process to invoke `require_file/2` acquires a lock and the remaining\nones will block until the file is available. This means that if `require_file/2`\nis called more than once with a given file, that file will be compiled only once.\nThe first process to call `require_file/2` will get the list of loaded modules,\nothers will get `nil`. The list of required files is managed per Erlang VM node.\n\nSee `compile_file/2` if you would like to compile a file without tracking its\nfilenames. Finally, if you would like to get the result of evaluating a file rather\nthan the modules defined in it, see `eval_file/2`.","ref":"Code.html#require_file/2"},{"type":"function","title":"Examples - Code.require_file/2","doc":"If the file has not been required, it returns the list of modules:\n\n    modules = Code.require_file(\"eex_test.exs\", \"../eex/test\")\n    List.first(modules)\n    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n\nIf the file has been required, it returns `nil`:\n\n    Code.require_file(\"eex_test.exs\", \"../eex/test\")\n    #=> nil","ref":"Code.html#require_file/2-examples"},{"type":"function","title":"Code.required_files/0","doc":"Lists all required files.","ref":"Code.html#required_files/0"},{"type":"function","title":"Examples - Code.required_files/0","doc":"Code.require_file(\"../eex/test/eex_test.exs\")\n    List.first(Code.required_files()) =~ \"eex_test.exs\"\n    #=> true","ref":"Code.html#required_files/0-examples"},{"type":"function","title":"Code.string_to_quoted/2","doc":"Converts the given string to its quoted form.\n\nReturns `{:ok, quoted_form}` if it succeeds,\n`{:error, {meta, message_info, token}}` otherwise.","ref":"Code.html#string_to_quoted/2"},{"type":"function","title":"Options - Code.string_to_quoted/2","doc":"* `:file` - the filename to be reported in case of parsing errors.\n    Defaults to `\"nofile\"`.\n\n  * `:line` - the starting line of the string being parsed.\n    Defaults to 1.\n\n  * `:column` - (since v1.11.0) the starting column of the string being parsed.\n    Defaults to 1.\n\n  * `:columns` - when `true`, attach a `:column` key to the quoted\n    metadata. Defaults to `false`.\n\n  * `:unescape` (since v1.10.0) - when `false`, preserves escaped sequences.\n    For example, `\"null byte\\\\t\\\\x00\"` will be kept as is instead of being\n    converted to a bitstring literal. Note if you set this option to false, the\n    resulting AST is no longer valid, but it can be useful to analyze/transform\n    source code, typically in combination with `quoted_to_algebra/2`.\n    Defaults to `true`.\n\n  * `:existing_atoms_only` - when `true`, raises an error\n    when non-existing atoms are found by the tokenizer.\n    Defaults to `false`.\n\n  * `:token_metadata` (since v1.10.0) - when `true`, includes token-related\n    metadata in the expression AST, such as metadata for `do` and `end`\n    tokens, for closing tokens, end of expressions, as well as delimiters\n    for sigils. See `t:Macro.metadata/0`. Defaults to `false`.\n\n  * `:literal_encoder` (since v1.10.0) - how to encode literals in the AST.\n    It must be a function that receives two arguments, the literal and its\n    metadata, and it must return `{:ok, ast :: Macro.t}` or\n    `{:error, reason :: binary}`. If you return anything than the literal\n    itself as the `term`, then the AST is no longer valid. This option\n    may still useful for textual analysis of the source code.\n\n  * `:static_atoms_encoder` - the static atom encoder function, see\n    \"The `:static_atoms_encoder` function\" section below. Note this\n    option overrides the `:existing_atoms_only` behavior for static\n    atoms but `:existing_atoms_only` is still used for dynamic atoms,\n    such as atoms with interpolations.\n\n  * `:emit_warnings` (since v1.16.0) - when `false`, does not emit\n    tokenizing/parsing related warnings. Defaults to `true`.\n\n## `Macro.to_string/2`\n\nThe opposite of converting a string to its quoted form is\n`Macro.to_string/2`, which converts a quoted form to a string/binary\nrepresentation.","ref":"Code.html#string_to_quoted/2-options"},{"type":"function","title":"The `:static_atoms_encoder` function - Code.string_to_quoted/2","doc":"When `static_atoms_encoder: &my_encoder/2` is passed as an argument,\n`my_encoder/2` is called every time the tokenizer needs to create a\n\"static\" atom. Static atoms are atoms in the AST that function as\naliases, remote calls, local calls, variable names, regular atoms\nand keyword lists.\n\nThe encoder function will receive the atom name (as a binary) and a\nkeyword list with the current file, line and column. It must return\n`{:ok, token :: term} | {:error, reason :: binary}`.\n\nThe encoder function is supposed to create an atom from the given\nstring. To produce a valid AST, it is required to return `{:ok, term}`,\nwhere `term` is an atom. It is possible to return something other than an atom,\nhowever, in that case the AST is no longer \"valid\" in that it cannot\nbe used to compile or evaluate Elixir code. A use case for this is\nif you want to use the Elixir parser in a user-facing situation, but\nyou don't want to exhaust the atom table.\n\nThe atom encoder is not called for *all* atoms that are present in\nthe AST. It won't be invoked for the following atoms:\n\n  * operators (`:+`, `:-`, and so on)\n\n  * syntax keywords (`fn`, `do`, `else`, and so on)\n\n  * atoms containing interpolation (`:\"#{1 + 1} is two\"`), as these\n    atoms are constructed at runtime\n\n  * atoms used to represent single-letter sigils like `:sigil_X`\n    (but multi-letter sigils like `:sigil_XYZ` are encoded).","ref":"Code.html#string_to_quoted/2-the-static_atoms_encoder-function"},{"type":"function","title":"Code.string_to_quoted!/2","doc":"Converts the given string to its quoted form.\n\nIt returns the AST if it succeeds,\nraises an exception otherwise. The exception is a `TokenMissingError`\nin case a token is missing (usually because the expression is incomplete),\n`MismatchedDelimiterError` (in case of mismatched opening and closing delimiters) and\n`SyntaxError` otherwise.\n\nCheck `string_to_quoted/2` for options information.","ref":"Code.html#string_to_quoted!/2"},{"type":"function","title":"Code.string_to_quoted_with_comments/2","doc":"Converts the given string to its quoted form and a list of comments.\n\nThis function is useful when performing textual changes to the source code,\nwhile preserving information like comments and literals position.\n\nReturns `{:ok, quoted_form, comments}` if it succeeds,\n`{:error, {line, error, token}}` otherwise.\n\nComments are maps with the following fields:\n\n  * `:line` - The line number of the source code\n\n  * `:text` - The full text of the comment, including the leading `#`\n\n  * `:previous_eol_count` - How many end of lines there are between the comment and the previous AST node or comment\n\n  * `:next_eol_count` - How many end of lines there are between the comment and the next AST node or comment\n\nCheck `string_to_quoted/2` for options information.","ref":"Code.html#string_to_quoted_with_comments/2"},{"type":"function","title":"Examples - Code.string_to_quoted_with_comments/2","doc":"iex> Code.string_to_quoted_with_comments(\"\"\"\n    ...> :foo\n    ...>\n    ...> # Hello, world!\n    ...>\n    ...>\n    ...> # Some more comments!\n    ...> \"\"\")\n    {:ok, :foo, [\n      %{line: 3, column: 1, previous_eol_count: 2, next_eol_count: 3, text: \"# Hello, world!\"},\n      %{line: 6, column: 1, previous_eol_count: 3, next_eol_count: 1, text: \"# Some more comments!\"},\n    ]}\n\n    iex> Code.string_to_quoted_with_comments(\":foo # :bar\")\n    {:ok, :foo, [\n      %{line: 1, column: 6, previous_eol_count: 0, next_eol_count: 0, text: \"# :bar\"}\n    ]}","ref":"Code.html#string_to_quoted_with_comments/2-examples"},{"type":"function","title":"Code.string_to_quoted_with_comments!/2","doc":"Converts the given string to its quoted form and a list of comments.\n\nReturns the AST and a list of comments if it succeeds, raises an exception\notherwise. The exception is a `TokenMissingError` in case a token is missing\n(usually because the expression is incomplete), `SyntaxError` otherwise.\n\nCheck `string_to_quoted/2` for options information.","ref":"Code.html#string_to_quoted_with_comments!/2"},{"type":"function","title":"Code.unrequire_files/1","doc":"Removes files from the required files list.\n\nThe modules defined in the file are not removed;\ncalling this function only removes them from the list,\nallowing them to be required again.\n\nThe list of files is managed per Erlang VM node.","ref":"Code.html#unrequire_files/1"},{"type":"function","title":"Examples - Code.unrequire_files/1","doc":"# Require EEx test code\n    Code.require_file(\"../eex/test/eex_test.exs\")\n\n    # Now unrequire all files\n    Code.unrequire_files(Code.required_files())\n\n    # Note that modules are still available\n    function_exported?(EExTest.Compiled, :before_compile, 0)\n    #=> true","ref":"Code.html#unrequire_files/1-examples"},{"type":"function","title":"Code.with_diagnostics/2","doc":"Executes the given `fun` and capture all diagnostics.\n\nDiagnostics are warnings and errors emitted during code\nevaluation or single-file compilation and by functions\nsuch as `IO.warn/2`.\n\nIf using `mix compile` or `Kernel.ParallelCompiler`,\nnote they already capture and return diagnostics.","ref":"Code.html#with_diagnostics/2"},{"type":"function","title":"Options - Code.with_diagnostics/2","doc":"* `:log` - if the diagnostics should be logged as they happen.\n    Defaults to `false`.\n\n> #### Rescuing errors {: .info}\n>\n> `with_diagnostics/2` does not automatically handle exceptions.\n> You may capture them by adding a `try/1` in `fun`:\n>\n>     {result, all_errors_and_warnings} =\n>       Code.with_diagnostics(fn ->\n>         try do\n>           {:ok, Code.compile_quoted(quoted)}\n>         rescue\n>           err -> {:error, err}\n>         end\n>       end)","ref":"Code.html#with_diagnostics/2-options"},{"type":"module","title":"Code.Fragment","doc":"This module provides conveniences for analyzing fragments of\ntextual code and extract available information whenever possible.\n\nThis module should be considered experimental.","ref":"Code.Fragment.html"},{"type":"function","title":"Code.Fragment.container_cursor_to_quoted/2","doc":"Receives a string and returns a quoted expression\nwith the cursor AST position within its parent expression.\n\nThis function receives a string with an Elixir code fragment,\nrepresenting a cursor position, and converts such string to\nAST with the inclusion of special `__cursor__()` node representing\nthe cursor position within its container (i.e. its parent).\n\nFor example, take this code, which would be given as input:\n\n    max(some_value,\n\nThis function will return the AST equivalent to:\n\n    max(some_value, __cursor__())\n\nIn other words, this function is capable of closing any open\nbrackets and insert the cursor position. Other content at the\ncursor position which is not a parent is discarded.\nFor example, if this is given as input:\n\n    max(some_value, another_val\n\nIt will return the same AST:\n\n    max(some_value, __cursor__())\n\nSimilarly, if only this is given:\n\n    max(some_va\n\nThen it returns:\n\n    max(__cursor__())\n\nCalls without parenthesis are also supported, as we assume the\nbrackets are implicit.\n\nTuples, lists, maps, and binaries all retain the cursor position:\n\n    max(some_value, [1, 2,\n\nReturns the following AST:\n\n    max(some_value, [1, 2, __cursor__()])\n\nKeyword lists (and do-end blocks) are also retained. The following:\n\n    if(some_value, do:\n    if(some_value, do: :token\n    if(some_value, do: 1 + val\n\nall return:\n\n    if(some_value, do: __cursor__())\n\nFor multi-line blocks, all previous lines are preserved.\n\nThe AST returned by this function is not safe to evaluate but\nit can be analyzed and expanded.","ref":"Code.Fragment.html#container_cursor_to_quoted/2"},{"type":"function","title":"Examples - Code.Fragment.container_cursor_to_quoted/2","doc":"Function call:\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"max(some_value, \")\n    {:ok, {:max, [line: 1], [{:some_value, [line: 1], nil}, {:__cursor__, [line: 1], []}]}}\n\nContainers (for example, a list):\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"[some, value\")\n    {:ok, [{:some, [line: 1], nil}, {:__cursor__, [line: 1], []}]}\n\nIf an expression is complete, then the whole expression is discarded\nand only the parent is returned:\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"if(is_atom(var)\")\n    {:ok, {:if, [line: 1], [{:__cursor__, [line: 1], []}]}}\n\nthis means complete expressions themselves return only the cursor:\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"if(is_atom(var))\")\n    {:ok, {:__cursor__, [line: 1], []}}\n\nOperators are also included from Elixir v1.15:\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"foo +\")\n    {:ok, {:+, [line: 1], [{:foo, [line: 1], nil}, {:__cursor__, [line: 1], []}]}}","ref":"Code.Fragment.html#container_cursor_to_quoted/2-examples"},{"type":"function","title":"Options - Code.Fragment.container_cursor_to_quoted/2","doc":"* `:file` - the filename to be reported in case of parsing errors.\n    Defaults to `\"nofile\"`.\n\n  * `:line` - the starting line of the string being parsed.\n    Defaults to 1.\n\n  * `:column` - the starting column of the string being parsed.\n    Defaults to 1.\n\n  * `:columns` - when `true`, attach a `:column` key to the quoted\n    metadata. Defaults to `false`.\n\n  * `:token_metadata` - when `true`, includes token-related\n    metadata in the expression AST, such as metadata for `do` and `end`\n    tokens, for closing tokens, end of expressions, as well as delimiters\n    for sigils. See `t:Macro.metadata/0`. Defaults to `false`.\n\n  * `:literal_encoder` - a function to encode literals in the AST.\n    See the documentation for `Code.string_to_quoted/2` for more information.","ref":"Code.Fragment.html#container_cursor_to_quoted/2-options"},{"type":"function","title":"Code.Fragment.cursor_context/2","doc":"Receives a string and returns the cursor context.\n\nThis function receives a string with an Elixir code fragment,\nrepresenting a cursor position, and based on the string, it\nprovides contextual information about the latest token.\nThe return of this function can then be used to provide tips,\nsuggestions, and autocompletion functionality.\n\nThis function performs its analyses on tokens. This means\nit does not understand how constructs are nested within each\nother. See the \"Limitations\" section below.\n\nConsider adding a catch-all clause when handling the return\ntype of this function as new cursor information may be added\nin future releases.","ref":"Code.Fragment.html#cursor_context/2"},{"type":"function","title":"Examples - Code.Fragment.cursor_context/2","doc":"iex> Code.Fragment.cursor_context(\"\")\n    :expr\n\n    iex> Code.Fragment.cursor_context(\"hello_wor\")\n    {:local_or_var, ~c\"hello_wor\"}","ref":"Code.Fragment.html#cursor_context/2-examples"},{"type":"function","title":"Return values - Code.Fragment.cursor_context/2","doc":"* `{:alias, charlist}` - the context is an alias, potentially\n    a nested one, such as `Hello.Wor` or `HelloWor`\n\n  * `{:alias, inside_alias, charlist}` - the context is an alias, potentially\n    a nested one, where `inside_alias` is an expression `{:module_attribute, charlist}`\n    or `{:local_or_var, charlist}` and `charlist` is a static part\n    Examples are `__MODULE__.Submodule` or `@hello.Submodule`\n\n  * `{:dot, inside_dot, charlist}` - the context is a dot\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, this may either be a remote call or a map\n    field access. Examples are `Hello.wor`, `:hello.wor`, `hello.wor`,\n    `Hello.nested.wor`, `hello.nested.wor`, and `@hello.world`. If `charlist`\n    is empty and `inside_dot` is an alias, then the autocompletion may either\n    be an alias or a remote call.\n\n  * `{:dot_arity, inside_dot, charlist}` - the context is a dot arity\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, it must be a remote arity. Examples are\n    `Hello.world/`, `:hello.world/`, `hello.world/2`, and `@hello.world/2`\n\n  * `{:dot_call, inside_dot, charlist}` - the context is a dot\n    call. This means parentheses or space have been added after the expression.\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, it must be a remote call. Examples are\n    `Hello.world(`, `:hello.world(`, `Hello.world `, `hello.world(`, `hello.world `,\n    and `@hello.world(`\n\n  * `:expr` - may be any expression. Autocompletion may suggest an alias,\n    local or var\n\n  * `{:local_or_var, charlist}` - the context is a variable or a local\n    (import or local) call, such as `hello_wor`\n\n  * `{:local_arity, charlist}` - the context is a local (import or local)\n    arity, such as `hello_world/`\n\n  * `{:local_call, charlist}` - the context is a local (import or local)\n    call, such as `hello_world(` and `hello_world `\n\n  * `{:anonymous_call, inside_caller}` - the context is an anonymous\n    call, such as `fun.(` and `@fun.(`.\n\n  * `{:module_attribute, charlist}` - the context is a module attribute,\n    such as `@hello_wor`\n\n  * `{:operator, charlist}` - the context is an operator, such as `+` or\n    `==`. Note textual operators, such as `when` do not appear as operators\n    but rather as `:local_or_var`. `@` is never an `:operator` and always a\n    `:module_attribute`\n\n  * `{:operator_arity, charlist}` - the context is an operator arity, which\n    is an operator followed by /, such as `+/`, `not/` or `when/`\n\n  * `{:operator_call, charlist}` - the context is an operator call, which is\n    an operator followed by space, such as `left + `, `not ` or `x when `\n\n  * `:none` - no context possible\n\n  * `{:sigil, charlist}` - the context is a sigil. It may be either the beginning\n    of a sigil, such as `~` or `~s`, or an operator starting with `~`, such as\n    `~>` and `~>>`\n\n  * `{:struct, inside_struct}` - the context is a struct, such as `%`, `%UR` or `%URI`.\n    `inside_struct` can either be a `charlist` in case of a static alias or an\n    expression `{:alias, inside_alias, charlist}`, `{:module_attribute, charlist}`,\n    `{:local_or_var, charlist}`, `{:dot, inside_dot, charlist}`\n\n  * `{:unquoted_atom, charlist}` - the context is an unquoted atom. This\n    can be any atom or an atom representing a module\n\nWe recommend looking at the test suite of this function for a complete list\nof examples and their return values.","ref":"Code.Fragment.html#cursor_context/2-return-values"},{"type":"function","title":"Limitations - Code.Fragment.cursor_context/2","doc":"The analysis is based on the current token, by analysing the last line of\nthe input. For example, this code:\n\n    iex> Code.Fragment.cursor_context(\"%URI{\")\n    :expr\n\nreturns `:expr`, which suggests any variable, local function or alias\ncould be used. However, given we are inside a struct, the best suggestion\nwould be a struct field. In such cases, you can use\n`container_cursor_to_quoted`, which will return the container of the AST\nthe cursor is currently within. You can then analyse this AST to provide\ncompletion of field names.\n\nAs a consequence of its token-based implementation, this function considers\nonly the last line of the input. This means it will show suggestions inside\nstrings, heredocs, etc, which is intentional as it helps with doctests,\nreferences, and more.","ref":"Code.Fragment.html#cursor_context/2-limitations"},{"type":"type","title":"Code.Fragment.position/0","doc":"","ref":"Code.Fragment.html#t:position/0"},{"type":"function","title":"Code.Fragment.surround_context/3","doc":"Receives a string and returns the surround context.\n\nThis function receives a string with an Elixir code fragment\nand a `position`. It returns a map containing the beginning\nand ending of the identifier alongside its context, or `:none`\nif there is nothing with a known context. This is useful to\nprovide mouse-over and highlight functionality in editors.\n\nThe difference between `cursor_context/2` and `surround_context/3`\nis that the former assumes the expression in the code fragment\nis incomplete. For example, `do` in `cursor_context/2` may be\na keyword or a variable or a local call, while `surround_context/3`\nassumes the expression in the code fragment is complete, therefore\n`do` would always be a keyword.\n\nThe `position` contains both the `line` and `column`, both starting\nwith the index of 1. The column must precede the surrounding expression.\nFor example, the expression `foo`, will return something for the columns\n1, 2, and 3, but not 4:\n\n    foo\n    ^ column 1\n\n    foo\n     ^ column 2\n\n    foo\n      ^ column 3\n\n    foo\n       ^ column 4\n\nThe returned map contains the column the expression starts and the\nfirst column after the expression ends.\n\nSimilar to `cursor_context/2`, this function is also token-based\nand may not be accurate under all circumstances. See the\n\"Return values\" and \"Limitations\" section under `cursor_context/2`\nfor more information.","ref":"Code.Fragment.html#surround_context/3"},{"type":"function","title":"Examples - Code.Fragment.surround_context/3","doc":"iex> Code.Fragment.surround_context(\"foo\", {1, 1})\n    %{begin: {1, 1}, context: {:local_or_var, ~c\"foo\"}, end: {1, 4}}","ref":"Code.Fragment.html#surround_context/3-examples"},{"type":"function","title":"Differences to `cursor_context/2` - Code.Fragment.surround_context/3","doc":"Because `surround_context/3` attempts to capture complex expressions,\nit has some differences to `cursor_context/2`:\n\n  * `dot_call`/`dot_arity` and `operator_call`/`operator_arity`\n    are collapsed into `dot` and `operator` contexts respectively\n    as there aren't any meaningful distinctions between them\n\n  * On the other hand, this function still makes a distinction between\n    `local_call`/`local_arity` and `local_or_var`, since the latter can\n    be a local or variable\n\n  * `@` when not followed by any identifier is returned as `{:operator, '@'}`\n    (in contrast to `{:module_attribute, ''}` in `cursor_context/2`\n\n  * This function never returns empty sigils `{:sigil, ''}` or empty structs\n    `{:struct, ''}` as context\n\n  * This function returns keywords as `{:keyword, 'do'}`\n\n  * This function never returns `:expr`\n\nWe recommend looking at the test suite of this function for a complete list\nof examples and their return values.","ref":"Code.Fragment.html#surround_context/3-differences-to-cursor_context-2"},{"type":"module","title":"Kernel.ParallelCompiler","doc":"A module responsible for compiling and requiring files in parallel.","ref":"Kernel.ParallelCompiler.html"},{"type":"function","title":"Kernel.ParallelCompiler.async/1","doc":"Starts a task for parallel compilation.","ref":"Kernel.ParallelCompiler.html#async/1"},{"type":"function","title":"Kernel.ParallelCompiler.compile/2","doc":"Compiles the given files.\n\nThose files are compiled in parallel and can automatically\ndetect dependencies between them. Once a dependency is found,\nthe current file stops being compiled until the dependency is\nresolved.\n\nIt returns `{:ok, modules, warnings}` or `{:error, errors, warnings}`\nby default but we recommend using `return_diagnostics: true` so it returns\ndiagnostics as maps as well as a map of compilation information.\nThe map has the shape of:\n\n    %{\n      runtime_warnings: [warning],\n      compile_warnings: [warning]\n    }","ref":"Kernel.ParallelCompiler.html#compile/2"},{"type":"function","title":"Options - Kernel.ParallelCompiler.compile/2","doc":"* `:each_file` - for each file compiled, invokes the callback passing the\n    file\n\n  * `:each_long_compilation` - for each file that takes more than a given\n    timeout (see the `:long_compilation_threshold` option) to compile, invoke\n    this callback passing the file as its argument\n\n  * `:each_module` - for each module compiled, invokes the callback passing\n    the file, module and the module bytecode\n\n  * `:each_cycle` - after the given files are compiled, invokes this function\n    that should return the following values:\n    * `{:compile, modules, warnings}` - to continue compilation with a list of\n      further modules to compile\n    * `{:runtime, modules, warnings}` - to stop compilation and verify the list\n      of modules because dependent modules have changed\n\n  * `:long_compilation_threshold` - the timeout (in seconds) to check for modules\n    taking too long to compile. For each file that exceeds the threshold, the\n    `:each_long_compilation` callback is invoked. From Elixir v1.11, only the time\n    spent compiling the actual module is taken into account by the threshold, the\n    time spent waiting is not considered. Defaults to `10` seconds.\n\n  * `:profile` - if set to `:time` measure the compilation time of each compilation cycle\n     and group pass checker\n\n  * `:dest` - the destination directory for the BEAM files. When using `compile/2`,\n    this information is only used to properly annotate the BEAM files before\n    they are loaded into memory. If you want a file to actually be written to\n    `dest`, use `compile_to_path/3` instead.\n\n  * `:beam_timestamp` - the modification timestamp to give all BEAM files\n\n  * `:return_diagnostics` (since v1.15.0) - returns maps with information instead of\n    a list of warnings and returns diagnostics as maps instead of tuples","ref":"Kernel.ParallelCompiler.html#compile/2-options"},{"type":"function","title":"Kernel.ParallelCompiler.compile_to_path/3","doc":"Compiles the given files and writes resulting BEAM files into path.\n\nSee `compile/2` for more information.","ref":"Kernel.ParallelCompiler.html#compile_to_path/3"},{"type":"type","title":"Kernel.ParallelCompiler.error/0","doc":"","ref":"Kernel.ParallelCompiler.html#t:error/0"},{"type":"type","title":"Kernel.ParallelCompiler.info/0","doc":"","ref":"Kernel.ParallelCompiler.html#t:info/0"},{"type":"function","title":"Kernel.ParallelCompiler.pmap/2","doc":"Perform parallel compilation of `collection` with `fun`.\n\nIf you have a file that needs to compile other modules in parallel,\nthe spawned processes need to be aware of the compiler environment.\nThis function allows a developer to perform such tasks.","ref":"Kernel.ParallelCompiler.html#pmap/2"},{"type":"function","title":"Kernel.ParallelCompiler.require/2","doc":"Requires the given files in parallel.\n\nOpposite to compile, dependencies are not attempted to be\nautomatically solved between files.\n\nIt returns `{:ok, modules, warnings}` or `{:error, errors, warnings}`\nby default but we recommend using `return_diagnostics: true` so it returns\ndiagnostics as maps as well as a map of compilation information.\nThe map has the shape of:\n\n    %{\n      runtime_warnings: [warning],\n      compile_warnings: [warning]\n    }","ref":"Kernel.ParallelCompiler.html#require/2"},{"type":"function","title":"Options - Kernel.ParallelCompiler.require/2","doc":"* `:each_file` - for each file compiled, invokes the callback passing the\n    file\n\n  * `:each_module` - for each module compiled, invokes the callback passing\n    the file, module and the module bytecode","ref":"Kernel.ParallelCompiler.html#require/2-options"},{"type":"type","title":"Kernel.ParallelCompiler.warning/0","doc":"","ref":"Kernel.ParallelCompiler.html#t:warning/0"},{"type":"module","title":"Macro","doc":"Functions for manipulating AST and implementing macros.\n\nMacros are compile-time constructs that receive Elixir's AST as input\nand return Elixir's AST as output.\n\nMany of the functions in this module exist precisely to work with Elixir\nAST, to traverse, query, and transform it.\n\nLet's see a simple example that shows the difference between functions\nand macros:\n\n    defmodule Example do\n      defmacro macro_inspect(value) do\n        IO.inspect(value)\n        value\n      end\n\n      def fun_inspect(value) do\n        IO.inspect(value)\n        value\n      end\n    end\n\nNow let's give it a try:\n\n    import Example\n\n    macro_inspect(1)\n    #=> 1\n    #=> 1\n\n    fun_inspect(1)\n    #=> 1\n    #=> 1\n\nSo far they behave the same, as we are passing an integer as argument.\nBut let's see what happens when we pass an expression:\n\n    macro_inspect(1 + 2)\n    #=> {:+, [line: 3], [1, 2]}\n    #=> 3\n\n    fun_inspect(1 + 2)\n    #=> 3\n    #=> 3\n\nThe macro receives the representation of the code given as argument,\nwhile a function receives the result of the code given as argument.\nA macro must return a superset of the code representation. See\n`t:input/0` and `t:output/0` for more information.\n\nTo learn more about Elixir's AST and how to build them programmatically,\nsee `quote/2`.\n\n> #### Evaluating code {: .tip}\n>\n> The functions in this module do not evaluate code. In fact,\n> evaluating code from macros is often an anti-pattern. For code\n> evaluation, see the `Code` module.","ref":"Macro.html"},{"type":"function","title":"Macro.camelize/1","doc":"Converts the given string to CamelCase format.\n\nThis function was designed to camelize language identifiers/tokens,\nthat's why it belongs to the `Macro` module. Do not use it as a general\nmechanism for camelizing strings as it does not support Unicode or\ncharacters that are not valid in Elixir identifiers.","ref":"Macro.html#camelize/1"},{"type":"function","title":"Examples - Macro.camelize/1","doc":"iex> Macro.camelize(\"foo_bar\")\n    \"FooBar\"\n\n    iex> Macro.camelize(\"foo/bar\")\n    \"Foo.Bar\"\n\nIf uppercase characters are present, they are not modified in any way\nas a mechanism to preserve acronyms:\n\n    iex> Macro.camelize(\"API.V1\")\n    \"API.V1\"\n    iex> Macro.camelize(\"API_SPEC\")\n    \"API_SPEC\"","ref":"Macro.html#camelize/1-examples"},{"type":"type","title":"Macro.captured_remote_function/0","doc":"A captured remote function in the format of &Mod.fun/arity","ref":"Macro.html#t:captured_remote_function/0"},{"type":"function","title":"Macro.classify_atom/1","doc":"Classifies an `atom` based on its possible AST placement.\n\nIt returns one of the following atoms:\n\n  * `:alias` - the atom represents an alias\n\n  * `:identifier` - the atom can be used as a variable or local function\n    call (as well as be an unquoted atom)\n\n  * `:unquoted` - the atom can be used in its unquoted form,\n    includes operators and atoms with `@` in them\n\n  * `:quoted` - all other atoms which can only be used in their quoted form\n\nMost operators are going to be `:unquoted`, such as `:+`, with\nsome exceptions returning `:quoted` due to ambiguity, such as\n`:\"::\"`. Use `operator?/2` to check if a given atom is an operator.","ref":"Macro.html#classify_atom/1"},{"type":"function","title":"Examples - Macro.classify_atom/1","doc":"iex> Macro.classify_atom(:foo)\n    :identifier\n    iex> Macro.classify_atom(Foo)\n    :alias\n    iex> Macro.classify_atom(:foo@bar)\n    :unquoted\n    iex> Macro.classify_atom(:+)\n    :unquoted\n    iex> Macro.classify_atom(:Foo)\n    :unquoted\n    iex> Macro.classify_atom(:\"with spaces\")\n    :quoted","ref":"Macro.html#classify_atom/1-examples"},{"type":"function","title":"Macro.compile_apply/4","doc":"Applies a `mod`, `function`, and `args` at compile-time in `caller`.\n\nThis is used when you want to programmatically invoke a macro at\ncompile-time.","ref":"Macro.html#compile_apply/4"},{"type":"function","title":"Macro.dbg/3","doc":"Default backend for `Kernel.dbg/2`.\n\nThis function provides a default backend for `Kernel.dbg/2`. See the\n`Kernel.dbg/2` documentation for more information.\n\nThis function:\n\n  * prints information about the given `env`\n  * prints information about `code` and its returned value (using `opts` to inspect terms)\n  * returns the value returned by evaluating `code`\n\nYou can call this function directly to build `Kernel.dbg/2` backends that fall back\nto this function.\n\nThis function raises if the context of the given `env` is `:match` or `:guard`.","ref":"Macro.html#dbg/3"},{"type":"function","title":"Macro.decompose_call/1","doc":"Decomposes a local or remote call into its remote part (when provided),\nfunction name and argument list.\n\nReturns `:error` when an invalid call syntax is provided.","ref":"Macro.html#decompose_call/1"},{"type":"function","title":"Examples - Macro.decompose_call/1","doc":"iex> Macro.decompose_call(quote(do: foo))\n    {:foo, []}\n\n    iex> Macro.decompose_call(quote(do: foo()))\n    {:foo, []}\n\n    iex> Macro.decompose_call(quote(do: foo(1, 2, 3)))\n    {:foo, [1, 2, 3]}\n\n    iex> Macro.decompose_call(quote(do: Elixir.M.foo(1, 2, 3)))\n    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n\n    iex> Macro.decompose_call(quote(do: 42))\n    :error\n\n    iex> Macro.decompose_call(quote(do: {:foo, [], []}))\n    :error","ref":"Macro.html#decompose_call/1-examples"},{"type":"function","title":"Macro.escape/2","doc":"Recursively escapes a value so it can be inserted into a syntax tree.","ref":"Macro.html#escape/2"},{"type":"function","title":"Examples - Macro.escape/2","doc":"iex> Macro.escape(:foo)\n    :foo\n\n    iex> Macro.escape({:a, :b, :c})\n    {:{}, [], [:a, :b, :c]}\n\n    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n    1","ref":"Macro.html#escape/2-examples"},{"type":"function","title":"Options - Macro.escape/2","doc":"* `:unquote` - when true, this function leaves `unquote/1` and\n    `unquote_splicing/1` statements unescaped, effectively unquoting\n    the contents on escape. This option is useful only when escaping\n    ASTs which may have quoted fragments in them. Defaults to false.\n\n  * `:prune_metadata` - when true, removes metadata from escaped AST\n    nodes. Note this option changes the semantics of escaped code and\n    it should only be used when escaping ASTs. Defaults to false.\n\n    As an example, `ExUnit` stores the AST of every assertion, so when\n    an assertion fails we can show code snippets to users. Without this\n    option, each time the test module is compiled, we get a different\n    MD5 of the module bytecode, because the AST contains metadata,\n    such as counters, specific to the compilation environment. By pruning\n    the metadata, we ensure that the module is deterministic and reduce\n    the amount of data `ExUnit` needs to keep around. Only the minimal\n    amount of metadata is kept, such as `:line` and `:no_parens`.","ref":"Macro.html#escape/2-options"},{"type":"function","title":"Comparison to `quote/2` - Macro.escape/2","doc":"The `escape/2` function is sometimes confused with `quote/2`,\nbecause the above examples behave the same with both. The key difference is\nbest illustrated when the value to escape is stored in a variable.\n\n    iex> Macro.escape({:a, :b, :c})\n    {:{}, [], [:a, :b, :c]}\n    iex> quote do: {:a, :b, :c}\n    {:{}, [], [:a, :b, :c]}\n\n    iex> value = {:a, :b, :c}\n    iex> Macro.escape(value)\n    {:{}, [], [:a, :b, :c]}\n\n    iex> quote do: value\n    {:value, [], __MODULE__}\n\n    iex> value = {:a, :b, :c}\n    iex> quote do: unquote(value)\n    {:a, :b, :c}\n\n`escape/2` is used to escape *values* (either directly passed or variable\nbound), while `quote/2` produces syntax trees for\nexpressions.","ref":"Macro.html#escape/2-comparison-to-quote-2"},{"type":"function","title":"Macro.expand/2","doc":"Receives an AST node and expands it until it can no longer\nbe expanded.\n\nNote this function does not traverse the AST, only the root\nnode is expanded.\n\nThis function uses `expand_once/2` under the hood. Check\nit out for more information and examples.","ref":"Macro.html#expand/2"},{"type":"function","title":"Macro.expand_literals/2","doc":"Expands all literals in `ast` with the given `env`.\n\nThis function is mostly used to remove compile-time dependencies\nfrom AST nodes. In such cases, the given environment is usually\nmanipulated to represent a function:\n\n    Macro.expand_literals(ast, %{env | function: {:my_code, 1}})\n\nAt the moment, the only expandable literal nodes in an AST are\naliases, so this function only expands aliases (and it does so\nanywhere in a literal).\n\nHowever, be careful when removing compile-time dependencies between\nmodules. If you remove them but you still invoke the module at\ncompile-time, Elixir will be unable to properly recompile modules\nwhen they change.","ref":"Macro.html#expand_literals/2"},{"type":"function","title":"Macro.expand_literals/3","doc":"Expands all literals in `ast` with the given `acc` and `fun`.\n\n`fun` will be invoked with an expandable AST node and `acc` and\nmust return a new node with `acc`. This is a general version of\n`expand_literals/2` which supports a custom expansion function.\nPlease check `expand_literals/2` for use cases and pitfalls.","ref":"Macro.html#expand_literals/3"},{"type":"function","title":"Macro.expand_once/2","doc":"Receives an AST node and expands it once.\n\nThe following contents are expanded:\n\n  * Macros (local or remote)\n  * Aliases are expanded (if possible) and return atoms\n  * Compilation environment macros (`__CALLER__/0`, `__DIR__/0`, `__ENV__/0` and `__MODULE__/0`)\n  * Module attributes reader (`@foo`)\n\nIf the expression cannot be expanded, it returns the expression\nitself. This function does not traverse the AST, only the root\nnode is expanded. The expansion happens as if it was expanded by\nthe Elixir compiler and therefore compilation tracers will be invoked\nand deprecation warnings will be emitted during the expansion.\n\n`expand_once/2` performs the expansion just once. Check `expand/2`\nto perform expansion until the node can no longer be expanded.","ref":"Macro.html#expand_once/2"},{"type":"function","title":"Examples - Macro.expand_once/2","doc":"In the example below, we have a macro that generates a module\nwith a function named `name_length` that returns the length\nof the module name. The value of this function will be calculated\nat compilation time and not at runtime.\n\nConsider the implementation below:\n\n    defmacro defmodule_with_length(name, do: block) do\n      length = length(Atom.to_charlist(name))\n\n      quote do\n        defmodule unquote(name) do\n          def name_length, do: unquote(length)\n          unquote(block)\n        end\n      end\n    end\n\nWhen invoked like this:\n\n    defmodule_with_length My.Module do\n      def other_function, do: ...\n    end\n\nThe compilation will fail because `My.Module` when quoted\nis not an atom, but a syntax tree as follows:\n\n    {:__aliases__, [], [:My, :Module]}\n\nThat said, we need to expand the aliases node above to an\natom, so we can retrieve its length. Expanding the node is\nnot straightforward because we also need to expand the\ncaller aliases. For example:\n\n    alias MyHelpers, as: My\n\n    defmodule_with_length My.Module do\n      def other_function, do: ...\n    end\n\nThe final module name will be `MyHelpers.Module` and not\n`My.Module`. With `Macro.expand/2`, such aliases are taken\ninto consideration. Local and remote macros are also\nexpanded. We could rewrite our macro above to use this\nfunction as:\n\n    defmacro defmodule_with_length(name, do: block) do\n      expanded = Macro.expand(name, __CALLER__)\n      length = length(Atom.to_charlist(expanded))\n\n      quote do\n        defmodule unquote(name) do\n          def name_length, do: unquote(length)\n          unquote(block)\n        end\n      end\n    end","ref":"Macro.html#expand_once/2-examples"},{"type":"function","title":"Macro.generate_arguments/2","doc":"Generates AST nodes for a given number of required argument\nvariables using `Macro.var/2`.\n\nNote the arguments are not unique. If you later on want\nto access the same variables, you can invoke this function\nwith the same inputs. Use `generate_unique_arguments/2` to\ngenerate unique arguments that can't be overridden.","ref":"Macro.html#generate_arguments/2"},{"type":"function","title":"Examples - Macro.generate_arguments/2","doc":"iex> Macro.generate_arguments(2, __MODULE__)\n    [{:arg1, [], __MODULE__}, {:arg2, [], __MODULE__}]","ref":"Macro.html#generate_arguments/2-examples"},{"type":"function","title":"Macro.generate_unique_arguments/2","doc":"Generates AST nodes for a given number of required argument\nvariables using `Macro.unique_var/2`.","ref":"Macro.html#generate_unique_arguments/2"},{"type":"function","title":"Examples - Macro.generate_unique_arguments/2","doc":"iex> [var1, var2] = Macro.generate_unique_arguments(2, __MODULE__)\n    iex> {:arg1, [counter: c1], __MODULE__} = var1\n    iex> {:arg2, [counter: c2], __MODULE__} = var2\n    iex> is_integer(c1) and is_integer(c2)\n    true","ref":"Macro.html#generate_unique_arguments/2-examples"},{"type":"type","title":"Macro.input/0","doc":"The inputs of a macro","ref":"Macro.html#t:input/0"},{"type":"function","title":"Macro.inspect_atom/2","doc":"Inspects `atom` according to different source formats.\n\nThe atom can be inspected according to the three different\nformats it appears in the AST: as a literal (`:literal`),\nas a key (`:key`), or as the function name of a remote call\n(`:remote_call`).","ref":"Macro.html#inspect_atom/2"},{"type":"function","title":"Examples - Macro.inspect_atom/2","doc":"","ref":"Macro.html#inspect_atom/2-examples"},{"type":"function","title":"As a literal - Macro.inspect_atom/2","doc":"Literals include regular atoms, quoted atoms, operators,\naliases, and the special `nil`, `true`, and `false` atoms.\n\n    iex> Macro.inspect_atom(:literal, nil)\n    \"nil\"\n    iex> Macro.inspect_atom(:literal, :foo)\n    \":foo\"\n    iex> Macro.inspect_atom(:literal, :<>)\n    \":<>\"\n    iex> Macro.inspect_atom(:literal, :Foo)\n    \":Foo\"\n    iex> Macro.inspect_atom(:literal, Foo.Bar)\n    \"Foo.Bar\"\n    iex> Macro.inspect_atom(:literal, :\"with spaces\")\n    \":\\\"with spaces\\\"\"","ref":"Macro.html#inspect_atom/2-as-a-literal"},{"type":"function","title":"As a key - Macro.inspect_atom/2","doc":"Inspect an atom as a key of a keyword list or a map.\n\n    iex> Macro.inspect_atom(:key, :foo)\n    \"foo:\"\n    iex> Macro.inspect_atom(:key, :<>)\n    \"<>:\"\n    iex> Macro.inspect_atom(:key, :Foo)\n    \"Foo:\"\n    iex> Macro.inspect_atom(:key, :\"with spaces\")\n    \"\\\"with spaces\\\":\"","ref":"Macro.html#inspect_atom/2-as-a-key"},{"type":"function","title":"As a remote call - Macro.inspect_atom/2","doc":"Inspect an atom the function name of a remote call.\n\n    iex> Macro.inspect_atom(:remote_call, :foo)\n    \"foo\"\n    iex> Macro.inspect_atom(:remote_call, :<>)\n    \"<>\"\n    iex> Macro.inspect_atom(:remote_call, :Foo)\n    \"\\\"Foo\\\"\"\n    iex> Macro.inspect_atom(:remote_call, :\"with spaces\")\n    \"\\\"with spaces\\\"\"","ref":"Macro.html#inspect_atom/2-as-a-remote-call"},{"type":"type","title":"Macro.metadata/0","doc":"A keyword list of AST metadata.\n\nThe metadata in Elixir AST is a keyword list of values. Any key can be used\nand different parts of the compiler may use different keys. For example,\nthe AST received by a macro will always include the `:line` annotation,\nwhile the AST emitted by `quote/2` will only have the `:line` annotation if\nthe `:line` option is provided.\n\nThe following metadata keys are public:\n\n  * `:context` - Defines the context in which the AST was generated.\n    For example, `quote/2` will include the module calling `quote/2`\n    as the context. This is often used to distinguish regular code from code\n    generated by a macro or by `quote/2`.\n\n  * `:counter` - The variable counter used for variable hygiene. In terms of\n    the compiler, each variable is identified by the combination of either\n    `name` and `metadata[:counter]`, or `name` and `context`.\n\n  * `:from_brackets` - Used to determine whether a call to `Access.get/3` is from\n    bracket syntax.\n\n  * `:from_interpolation` - Used to determine whether a call to `Kernel.to_string/1` is\n    from interpolation.\n\n  * `:generated` - Whether the code should be considered as generated by\n    the compiler or not. This means the compiler and tools like Dialyzer may not\n    emit certain warnings.\n\n  * `:if_undefined` - How to expand a variable that is undefined. Set it to\n    `:apply` if you want a variable to become a nullary call without warning\n    or `:raise`\n\n  * `:keep` - Used by `quote/2` with the option `location: :keep` to annotate\n    the file and the line number of the quoted source.\n\n  * `:line` - The line number of the AST node. Note line information is discarded\n    from quoted code but can be enabled back via the `:line` option.\n\nThe following metadata keys are enabled by `Code.string_to_quoted/2`:\n\n  * `:closing` - contains metadata about the closing pair, such as a `}`\n    in a tuple or in a map, or such as the closing `)` in a function call\n    with parens (when `:token_metadata` is true). If the function call\n    has a do-end block attached to it, its metadata is found under the\n    `:do` and `:end` metadata\n\n  * `:column` - the column number of the AST node (when `:columns` is true).\n    Note column information is always discarded from quoted code.\n\n  * `:delimiter` - contains the opening delimiter for sigils, strings,\n    and charlists as a string (such as `\"{\"`, `\"/\"`, `\"'\"`, and the like)\n\n  * `:format` - set to `:keyword` when an atom is defined as a keyword\n\n  * `:do` - contains metadata about the `do` location in a function call with\n    `do`-`end` blocks (when `:token_metadata` is true)\n\n  * `:end` - contains metadata about the `end` location in a function call with\n    `do`-`end` blocks (when `:token_metadata` is true)\n\n  * `:end_of_expression` - denotes when the end of expression effectively\n    happens (when `:token_metadata` is true). This is only available for\n    expressions inside \"blocks of code\", which are either direct children\n    of a `__block__` or the right side of `->`. The last expression of the\n    block does not have metadata if it is not followed by an end of line\n    character (either a newline or `;`)\n\n  * `:indentation` - indentation of a sigil heredoc\n\nThe following metadata keys are private:\n\n  * `:alias` - Used for alias hygiene.\n  * `:ambiguous_op` - Used for improved error messages in the compiler.\n  * `:imports` - Used for import hygiene.\n  * `:var` - Used for improved error messages on undefined variables.\n\nDo not rely on them as they may change or be fully removed in future versions\nof the language. They are often used by `quote/2` and the compiler to provide\nfeatures like hygiene, better error messages, and so forth.\n\nIf you introduce custom keys into the AST metadata, please make sure to prefix\nthem with the name of your library or application, so that they will not conflict\nwith keys that could potentially be introduced by the compiler in the future.","ref":"Macro.html#t:metadata/0"},{"type":"function","title":"Macro.operator?/2","doc":"Returns `true` if the given name and arity is an operator.","ref":"Macro.html#operator?/2"},{"type":"function","title":"Examples - Macro.operator?/2","doc":"iex> Macro.operator?(:not_an_operator, 3)\n    false\n    iex> Macro.operator?(:.., 0)\n    true\n    iex> Macro.operator?(:+, 1)\n    true\n    iex> Macro.operator?(:++, 2)\n    true\n    iex> Macro.operator?(:..//, 3)\n    true","ref":"Macro.html#operator?/2-examples"},{"type":"type","title":"Macro.output/0","doc":"The output of a macro","ref":"Macro.html#t:output/0"},{"type":"function","title":"Macro.path/2","doc":"Returns the path to the node in `ast` for which `fun` returns a truthy value.\n\nThe path is a list, starting with the node in which `fun` returns\na truthy value, followed by all of its parents.\n\nReturns `nil` if `fun` returns only falsy values.\n\nComputing the path can be an efficient operation when you want\nto find a particular node in the AST within its context and then\nassert something about it.","ref":"Macro.html#path/2"},{"type":"function","title":"Examples - Macro.path/2","doc":"iex> Macro.path(quote(do: [1, 2, 3]), & &1 == 3)\n    [3, [1, 2, 3]]\n\n    iex> Macro.path(quote(do: [1, 2]), & &1 == 5)\n    nil\n\n    iex> Macro.path(quote(do: Foo.bar(3)), & &1 == 3)\n    [3, quote(do: Foo.bar(3))]\n\n    iex> Macro.path(quote(do: %{foo: [bar: :baz]}), & &1 == :baz)\n    [\n      :baz,\n      {:bar, :baz},\n      [bar: :baz],\n      {:foo, [bar: :baz]},\n      {:%{}, [], [foo: [bar: :baz]]}\n    ]","ref":"Macro.html#path/2-examples"},{"type":"function","title":"Macro.pipe/3","doc":"Pipes `expr` into the `call_args` at the given `position`.\n\nThis function can be used to implement `|>` like functionality. For example,\n`|>` itself is implemented as:\n\n    defmacro left |> right do\n      Macro.pipe(left, right, 0)\n    end\n\n`expr` is the AST of an expression. `call_args` must be the AST *of a call*,\notherwise this function will raise an error. As an example, consider the pipe\noperator `|>/2`, which uses this function to build pipelines.\n\nEven if the expression is piped into the AST, it doesn't necessarily mean that\nthe AST is valid. For example, you could pipe an argument to `div/2`, effectively\nturning it into a call to `div/3`, which is a function that doesn't exist by\ndefault. The code will raise unless a `div/3` function is locally defined.","ref":"Macro.html#pipe/3"},{"type":"function","title":"Macro.postwalk/2","doc":"This function behaves like `prewalk/2`, but performs a depth-first,\npost-order traversal of quoted expressions.","ref":"Macro.html#postwalk/2"},{"type":"function","title":"Macro.postwalk/3","doc":"This functions behaves like `prewalk/3`, but performs a depth-first,\npost-order traversal of quoted expressions using an accumulator.","ref":"Macro.html#postwalk/3"},{"type":"function","title":"Macro.postwalker/1","doc":"Returns an enumerable that traverses the  `ast` in depth-first,\npost-order traversal.","ref":"Macro.html#postwalker/1"},{"type":"function","title":"Examples - Macro.postwalker/1","doc":"iex> ast = quote do: foo(1, \"abc\")\n    iex> Enum.map(Macro.postwalker(ast), & &1)\n    [1, \"abc\", {:foo, [], [1, \"abc\"]}]","ref":"Macro.html#postwalker/1-examples"},{"type":"function","title":"Macro.prewalk/2","doc":"Performs a depth-first, pre-order traversal of quoted expressions.\n\nReturns a new AST where each node is the result of invoking `fun` on each\ncorresponding node of `ast`.","ref":"Macro.html#prewalk/2"},{"type":"function","title":"Examples - Macro.prewalk/2","doc":"iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> new_ast = Macro.prewalk(ast, fn\n    ...>   {:+, meta, children} -> {:*, meta, children}\n    ...>   {:*, meta, children} -> {:+, meta, children}\n    ...>   other -> other\n    ...> end)\n    iex> {:*, _, [5, {:+, _, [3, 7]}]} = new_ast\n    iex> Code.eval_quoted(ast)\n    {26, []}\n    iex> Code.eval_quoted(new_ast)\n    {50, []}","ref":"Macro.html#prewalk/2-examples"},{"type":"function","title":"Macro.prewalk/3","doc":"Performs a depth-first, pre-order traversal of quoted expressions\nusing an accumulator.\n\nReturns a tuple where the first element is a new AST where each node is the\nresult of invoking `fun` on each corresponding node and the second one is the\nfinal accumulator.","ref":"Macro.html#prewalk/3"},{"type":"function","title":"Examples - Macro.prewalk/3","doc":"iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> {new_ast, acc} = Macro.prewalk(ast, [], fn\n    ...>   {:+, meta, children}, acc -> {{:*, meta, children}, [:+ | acc]}\n    ...>   {:*, meta, children}, acc -> {{:+, meta, children}, [:* | acc]}\n    ...>   other, acc -> {other, acc}\n    ...> end)\n    iex> {{:*, _, [5, {:+, _, [3, 7]}]}, [:*, :+]} = {new_ast, acc}\n    iex> Code.eval_quoted(ast)\n    {26, []}\n    iex> Code.eval_quoted(new_ast)\n    {50, []}","ref":"Macro.html#prewalk/3-examples"},{"type":"function","title":"Macro.prewalker/1","doc":"Returns an enumerable that traverses the  `ast` in depth-first,\npre-order traversal.","ref":"Macro.html#prewalker/1"},{"type":"function","title":"Examples - Macro.prewalker/1","doc":"iex> ast = quote do: foo(1, \"abc\")\n    iex> Enum.map(Macro.prewalker(ast), & &1)\n    [{:foo, [], [1, \"abc\"]}, 1, \"abc\"]","ref":"Macro.html#prewalker/1-examples"},{"type":"function","title":"Macro.quoted_literal?/1","doc":"Returns `true` if the given quoted expression represents a quoted literal.\n\nAtoms and numbers are always literals. Binaries, lists, tuples,\nmaps, and structs are only literals if all of their terms are also literals.","ref":"Macro.html#quoted_literal?/1"},{"type":"function","title":"Examples - Macro.quoted_literal?/1","doc":"iex> Macro.quoted_literal?(quote(do: \"foo\"))\n    true\n    iex> Macro.quoted_literal?(quote(do: {\"foo\", 1}))\n    true\n    iex> Macro.quoted_literal?(quote(do: {\"foo\", 1, :baz}))\n    true\n    iex> Macro.quoted_literal?(quote(do: %{foo: \"bar\"}))\n    true\n    iex> Macro.quoted_literal?(quote(do: %URI{path: \"/\"}))\n    true\n    iex> Macro.quoted_literal?(quote(do: URI.parse(\"/\")))\n    false\n    iex> Macro.quoted_literal?(quote(do: {foo, var}))\n    false","ref":"Macro.html#quoted_literal?/1-examples"},{"type":"function","title":"Macro.special_form?/2","doc":"Returns `true` if the given name and arity is a special form.","ref":"Macro.html#special_form?/2"},{"type":"function","title":"Macro.struct!/2","doc":"Expands the struct given by `module` in the given `env`.\n\nThis is useful when a struct needs to be expanded at\ncompilation time and the struct being expanded may or may\nnot have been compiled. This function is also capable of\nexpanding structs defined under the module being compiled.\n\nIt will raise `CompileError` if the struct is not available.\nFrom Elixir v1.12, calling this function also adds an export\ndependency on the given struct.","ref":"Macro.html#struct!/2"},{"type":"type","title":"Macro.t/0","doc":"Abstract Syntax Tree (AST)","ref":"Macro.html#t:t/0"},{"type":"function","title":"Macro.to_string/1","doc":"Converts the given expression AST to a string.\n\nThis is a convenience function for converting AST into\na string, which discards all formatting of the original\ncode and wraps newlines around 98 characters. See\n`Code.quoted_to_algebra/2` as a lower level function\nwith more control around formatting.","ref":"Macro.html#to_string/1"},{"type":"function","title":"Examples - Macro.to_string/1","doc":"iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))\n    \"foo.bar(1, 2, 3)\"","ref":"Macro.html#to_string/1-examples"},{"type":"function","title":"Macro.to_string/2","doc":"Converts the given expression AST to a string.\n\nThe given `fun` is called for every node in the AST with two arguments: the\nAST of the node being printed and the string representation of that same\nnode. The return value of this function is used as the final string\nrepresentation for that AST node.\n\nThis function discards all formatting of the original code.","ref":"Macro.html#to_string/2"},{"type":"function","title":"Examples - Macro.to_string/2","doc":"Macro.to_string(quote(do: 1 + 2), fn\n      1, _string -> \"one\"\n      2, _string -> \"two\"\n      _ast, string -> string\n    end)\n    #=> \"one + two\"","ref":"Macro.html#to_string/2-examples"},{"type":"function","title":"Macro.traverse/4","doc":"Performs a depth-first traversal of quoted expressions\nusing an accumulator.\n\nReturns a tuple where the first element is a new AST and the second one is\nthe final accumulator. The new AST is the result of invoking `pre` on each\nnode of `ast` during the pre-order phase and `post` during the post-order\nphase.","ref":"Macro.html#traverse/4"},{"type":"function","title":"Examples - Macro.traverse/4","doc":"iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> {new_ast, acc} =\n    ...>  Macro.traverse(\n    ...>    ast,\n    ...>    [],\n    ...>    fn\n    ...>      {:+, meta, children}, acc -> {{:-, meta, children}, [:- | acc]}\n    ...>      {:*, meta, children}, acc -> {{:/, meta, children}, [:/ | acc]}\n    ...>      other, acc -> {other, acc}\n    ...>    end,\n    ...>    fn\n    ...>      {:-, meta, children}, acc -> {{:min, meta, children}, [:min | acc]}\n    ...>      {:/, meta, children}, acc -> {{:max, meta, children}, [:max | acc]}\n    ...>      other, acc -> {other, acc}\n    ...>    end\n    ...>  )\n    iex> {:min, _, [5, {:max, _, [3, 7]}]} = new_ast\n    iex> [:min, :max, :/, :-] = acc\n    iex> Code.eval_quoted(new_ast)\n    {5, []}","ref":"Macro.html#traverse/4-examples"},{"type":"function","title":"Macro.underscore/1","doc":"Converts the given argument to a string with the underscore-slash format.\n\nThe argument must either be an atom or a string.\nIf an atom is given, it is assumed to be an Elixir module,\nso it is converted to a string and then processed.\n\nThis function was designed to format language identifiers/tokens with the underscore-slash format,\nthat's why it belongs to the `Macro` module. Do not use it as a general\nmechanism for underscoring strings as it does not support Unicode or\ncharacters that are not valid in Elixir identifiers.","ref":"Macro.html#underscore/1"},{"type":"function","title":"Examples - Macro.underscore/1","doc":"iex> Macro.underscore(\"FooBar\")\n    \"foo_bar\"\n\n    iex> Macro.underscore(\"Foo.Bar\")\n    \"foo/bar\"\n\n    iex> Macro.underscore(Foo.Bar)\n    \"foo/bar\"\n\nIn general, `underscore` can be thought of as the reverse of\n`camelize`, however, in some cases formatting may be lost:\n\n    iex> Macro.underscore(\"SAPExample\")\n    \"sap_example\"\n\n    iex> Macro.camelize(\"sap_example\")\n    \"SapExample\"\n\n    iex> Macro.camelize(\"hello_10\")\n    \"Hello10\"\n\n    iex> Macro.camelize(\"foo/bar\")\n    \"Foo.Bar\"","ref":"Macro.html#underscore/1-examples"},{"type":"function","title":"Macro.unescape_string/1","doc":"Unescapes characters in a string.\n\nThis is the unescaping behaviour used by default in Elixir\nsingle- and double-quoted strings. Check `unescape_string/2`\nfor information on how to customize the escaping map.\n\nIn this setup, Elixir will escape the following: `\\0`, `\\a`, `\\b`,\n`\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` and `\\v`. Bytes can be\ngiven as hexadecimals via `\\xNN` and Unicode code points as\n`\\uNNNN` escapes.\n\nThis function is commonly used on sigil implementations\n(like `~r`, `~s` and others), which receive a raw, unescaped\nstring, and it can be used anywhere that needs to mimic how\nElixir parses strings.","ref":"Macro.html#unescape_string/1"},{"type":"function","title":"Examples - Macro.unescape_string/1","doc":"iex> Macro.unescape_string(\"example\\\\n\")\n    \"example\\n\"\n\nIn the example above, we pass a string with `\\n` escaped\nand return a version with it unescaped.","ref":"Macro.html#unescape_string/1-examples"},{"type":"function","title":"Macro.unescape_string/2","doc":"Unescapes characters in a string according to the given mapping.\n\nCheck `unescape_string/1` if you want to use the same mapping\nas Elixir single- and double-quoted strings.","ref":"Macro.html#unescape_string/2"},{"type":"function","title":"Mapping function - Macro.unescape_string/2","doc":"The mapping function receives an integer representing the code point\nof the character it wants to unescape. There are also the special atoms\n`:newline`, `:unicode`, and `:hex`, which control newline, unicode,\nand escaping respectively.\n\nHere is the default mapping function implemented by Elixir:\n\n    def unescape_map(:newline), do: true\n    def unescape_map(:unicode), do: true\n    def unescape_map(:hex), do: true\n    def unescape_map(?0), do: ?0\n    def unescape_map(?a), do: ?\\a\n    def unescape_map(?b), do: ?\\b\n    def unescape_map(?d), do: ?\\d\n    def unescape_map(?e), do: ?\\e\n    def unescape_map(?f), do: ?\\f\n    def unescape_map(?n), do: ?\\n\n    def unescape_map(?r), do: ?\\r\n    def unescape_map(?s), do: ?\\s\n    def unescape_map(?t), do: ?\\t\n    def unescape_map(?v), do: ?\\v\n    def unescape_map(e), do: e\n\nIf the `unescape_map/1` function returns `false`, the char is\nnot escaped and the backslash is kept in the string.","ref":"Macro.html#unescape_string/2-mapping-function"},{"type":"function","title":"Examples - Macro.unescape_string/2","doc":"Using the `unescape_map/1` function defined above is easy:\n\n    Macro.unescape_string(\"example\\\\n\", &unescape_map(&1))","ref":"Macro.html#unescape_string/2-examples"},{"type":"function","title":"Macro.unique_var/2","doc":"Generates an AST node representing a unique variable\ngiven by the atoms `var` and `context`.\n\nCalling this function with the same arguments will\ngenerate another variable, with its own unique counter.\nSee `var/2` for an alternative.","ref":"Macro.html#unique_var/2"},{"type":"function","title":"Examples - Macro.unique_var/2","doc":"iex> {:foo, [counter: c], __MODULE__} = Macro.unique_var(:foo, __MODULE__)\n    iex> is_integer(c)\n    true","ref":"Macro.html#unique_var/2-examples"},{"type":"function","title":"Macro.unpipe/1","doc":"Breaks a pipeline expression into a list.\n\nThe AST for a pipeline (a sequence of applications of `|>/2`) is similar to the\nAST of a sequence of binary operators or function applications: the top-level\nexpression is the right-most `:|>` (which is the last one to be executed), and\nits left-hand and right-hand sides are its arguments:\n\n    quote do: 100 |> div(5) |> div(2)\n    #=> {:|>, _, [arg1, arg2]}\n\nIn the example above, the `|>/2` pipe is the right-most pipe; `arg1` is the AST\nfor `100 |> div(5)`, and `arg2` is the AST for `div(2)`.\n\nIt's often useful to have the AST for such a pipeline as a list of function\napplications. This function does exactly that:\n\n    Macro.unpipe(quote do: 100 |> div(5) |> div(2))\n    #=> [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}]\n\nWe get a list that follows the pipeline directly: first the `100`, then the\n`div(5)` (more precisely, its AST), then `div(2)`. The `0` as the second\nelement of the tuples is the position of the previous element in the pipeline\ninside the current function application: `{{:div, [], [5]}, 0}` means that the\nprevious element (`100`) will be inserted as the 0th (first) argument to the\n`div/2` function, so that the AST for that function will become `{:div, [],\n[100, 5]}` (`div(100, 5)`).","ref":"Macro.html#unpipe/1"},{"type":"function","title":"Macro.update_meta/2","doc":"Applies the given function to the node metadata if it contains one.\n\nThis is often useful when used with `Macro.prewalk/2` to remove\ninformation like lines and hygienic counters from the expression\nfor either storage or comparison.","ref":"Macro.html#update_meta/2"},{"type":"function","title":"Examples - Macro.update_meta/2","doc":"iex> quoted = quote line: 10, do: sample()\n    {:sample, [line: 10], []}\n    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n    {:sample, [], []}","ref":"Macro.html#update_meta/2-examples"},{"type":"function","title":"Macro.validate/1","doc":"Validates the given expressions are valid quoted expressions.\n\nCheck the type `t:Macro.t/0` for a complete specification of a\nvalid quoted expression.\n\nIt returns `:ok` if the expression is valid. Otherwise it returns\na tuple in the form of `{:error, remainder}` where `remainder` is\nthe invalid part of the quoted expression.","ref":"Macro.html#validate/1"},{"type":"function","title":"Examples - Macro.validate/1","doc":"iex> Macro.validate({:two_element, :tuple})\n    :ok\n    iex> Macro.validate({:three, :element, :tuple})\n    {:error, {:three, :element, :tuple}}\n\n    iex> Macro.validate([1, 2, 3])\n    :ok\n    iex> Macro.validate([1, 2, 3, {4}])\n    {:error, {4}}","ref":"Macro.html#validate/1-examples"},{"type":"function","title":"Macro.var/2","doc":"Generates an AST node representing the variable given\nby the atoms `var` and `context`.\n\nNote this variable is not unique. If you later on want\nto access this same variable, you can invoke `var/2`\nagain with the same arguments. Use `unique_var/2` to\ngenerate a unique variable that can't be overridden.","ref":"Macro.html#var/2"},{"type":"function","title":"Examples - Macro.var/2","doc":"In order to build a variable, a context is expected.\nMost of the times, in order to preserve hygiene, the\ncontext must be `__MODULE__/0`:\n\n    iex> Macro.var(:foo, __MODULE__)\n    {:foo, [], __MODULE__}\n\nHowever, if there is a need to access the user variable,\nnil can be given:\n\n    iex> Macro.var(:foo, nil)\n    {:foo, [], nil}","ref":"Macro.html#var/2-examples"},{"type":"module","title":"Macro.Env","doc":"A struct that holds compile time environment information.\n\nThe current environment can be accessed at any time as\n`__ENV__/0`. Inside macros, the caller environment can be\naccessed as `__CALLER__/0`.\n\nThe majority of the functions in this module are provided\nfor low-level tools, which need to integrate with the Elixir\ncompiler, such as language servers and embedded languages.\nFor regular usage in Elixir code and macros, you must use\nthe `Macro` module instead. In particular, avoid modifying\nthe `Macro.Env` struct directly and prefer to use high-level\nconstructs, such as a `import`, `aliases`, and so forth to\nbuild your own environment. For example, to build a custom\nenvironment, you can define a function such as:\n\n    def make_custom_env do\n      import SomeModule, only: [some_function: 2], warn: false\n      alias A.B.C, warn: false\n      __ENV__\n    end","ref":"Macro.Env.html"},{"type":"module","title":"Struct fields - Macro.Env","doc":"The `Macro.Env` struct contains the following fields:\n\n  * `context` - the context of the environment; it can be `nil`\n    (default context), `:guard` (inside a guard) or `:match` (inside a match)\n  * `context_modules` - a list of modules defined in the current context\n  * `file` - the current absolute file name as a binary\n  * `function` - a tuple as `{atom, integer}`, where the first\n    element is the function name and the second its arity; returns\n    `nil` if not inside a function\n  * `line` - the current line as an integer\n  * `module` - the current module name\n\nThe following fields are private to Elixir's macro expansion mechanism and\nmust not be accessed directly:\n\n  * `aliases`\n  * `functions`\n  * `macro_aliases`\n  * `macros`\n  * `lexical_tracker`\n  * `requires`\n  * `tracers`\n  * `versioned_vars`","ref":"Macro.Env.html#module-struct-fields"},{"type":"type","title":"Macro.Env.context/0","doc":"","ref":"Macro.Env.html#t:context/0"},{"type":"type","title":"Macro.Env.context_modules/0","doc":"","ref":"Macro.Env.html#t:context_modules/0"},{"type":"function","title":"Macro.Env.define_alias/4","doc":"Defines the given `as` an alias to `module` in the environment.\n\nThis is used by tools which need to mimic the Elixir compiler.\nThe appropriate `:alias` compiler tracing event will be emitted.","ref":"Macro.Env.html#define_alias/4"},{"type":"function","title":"Additional options - Macro.Env.define_alias/4","doc":"It accepts the same options as `Kernel.SpecialForm.alias/2` plus:\n\n  * `:trace` - when set to `false`, it disables compilation tracers and\nlexical tracker. This option must only be used by language servers and\nother tools that need to introspect code without affecting how it is compiled.\nDisabling tracer inside macros or regular code expansion is extremely\ndiscouraged as it blocks the compiler from accurately tracking dependencies","ref":"Macro.Env.html#define_alias/4-additional-options"},{"type":"function","title":"Examples - Macro.Env.define_alias/4","doc":"iex> env = __ENV__\n    iex> Macro.Env.expand_alias(env, [], [:Baz])\n    :error\n    iex> {:ok, env} = Macro.Env.define_alias(env, [line: 10], Foo.Bar, as: Baz)\n    iex> Macro.Env.expand_alias(env, [], [:Baz])\n    {:alias, Foo.Bar}\n    iex> Macro.Env.expand_alias(env, [], [:Baz, :Bat])\n    {:alias, Foo.Bar.Bat}\n\nIf no `:as` option is given, the alias will be inferred from the module:\n\n    iex> env = __ENV__\n    iex> {:ok, env} = Macro.Env.define_alias(env, [line: 10], Foo.Bar)\n    iex> Macro.Env.expand_alias(env, [], [:Bar])\n    {:alias, Foo.Bar}\n\nIf it is not possible to infer one, an error is returned:\n\n    iex> Macro.Env.define_alias(__ENV__, [line: 10], :an_atom)\n    {:error,\n     \"alias cannot be inferred automatically for module: :an_atom, \" <>\n       \"please use the :as option. Implicit aliasing is only supported with Elixir modules\"}","ref":"Macro.Env.html#define_alias/4-examples"},{"type":"function","title":"Macro.Env.define_import/4","doc":"Defines the given `module` as imported in the environment.\n\nIt assumes `module` is available. This is used by tools which\nneed to mimic the Elixir compiler. The appropriate `:import`\ncompiler tracing event will be emitted.","ref":"Macro.Env.html#define_import/4"},{"type":"function","title":"Additional options - Macro.Env.define_import/4","doc":"It accepts the same options as `Kernel.SpecialForm.import/2` plus:\n\n  * `:emit_warnings` - emit warnings found when defining imports\n\n  * `:trace` - when set to `false`, it disables compilation tracers and\nlexical tracker. This option must only be used by language servers and\nother tools that need to introspect code without affecting how it is compiled.\nDisabling tracer inside macros or regular code expansion is extremely\ndiscouraged as it blocks the compiler from accurately tracking dependencies\n\n  * `:info_callback` - a function to use instead of `c:Module.__info__/1`.\n    The function will be invoked with `:functions` or `:macros` argument.\n    It has to return a list of `{function, arity}` key value pairs.\n    If it fails, it defaults to using module metadata based on `module_info/1`.","ref":"Macro.Env.html#define_import/4-additional-options"},{"type":"function","title":"Examples - Macro.Env.define_import/4","doc":"iex> env = __ENV__\n    iex> Macro.Env.lookup_import(env, {:flatten, 1})\n    []\n    iex> {:ok, env} = Macro.Env.define_import(env, [line: 10], List)\n    iex> Macro.Env.lookup_import(env, {:flatten, 1})\n    [{:function, List}]\n\nIt accepts the same options as `Kernel.SpecialForm.import/2`:\n\n    iex> env = __ENV__\n    iex> Macro.Env.lookup_import(env, {:is_odd, 1})\n    []\n    iex> {:ok, env} = Macro.Env.define_import(env, [line: 10], Integer, only: :macros)\n    iex> Macro.Env.lookup_import(env, {:is_odd, 1})\n    [{:macro, Integer}]","ref":"Macro.Env.html#define_import/4-examples"},{"type":"function","title":"Info callback override - Macro.Env.define_import/4","doc":"iex> env = __ENV__\n    iex> Macro.Env.lookup_import(env, {:flatten, 1})\n    []\n    iex> {:ok, env} = Macro.Env.define_import(env, [line: 10], SomeModule, [info_callback: fn :functions -> [{:flatten, 1}]; :macros -> [{:some, 2}]; end])\n    iex> Macro.Env.lookup_import(env, {:flatten, 1})\n    [{:function, SomeModule}]\n    iex> Macro.Env.lookup_import(env, {:some, 2})\n    [{:macro, SomeModule}]","ref":"Macro.Env.html#define_import/4-info-callback-override"},{"type":"function","title":"Macro.Env.define_require/4","doc":"Defines the given `module` as required in the environment.\n\nIt does not check or assert the module is available.\nThis is used by tools which need to mimic the Elixir compiler.\nThe appropriate `:require` compiler tracing event will be emitted.","ref":"Macro.Env.html#define_require/4"},{"type":"function","title":"Additional options - Macro.Env.define_require/4","doc":"It accepts the same options as `Kernel.SpecialForm.require/2` plus:\n\n  * `:trace` - when set to `false`, it disables compilation tracers and\nlexical tracker. This option must only be used by language servers and\nother tools that need to introspect code without affecting how it is compiled.\nDisabling tracer inside macros or regular code expansion is extremely\ndiscouraged as it blocks the compiler from accurately tracking dependencies","ref":"Macro.Env.html#define_require/4-additional-options"},{"type":"function","title":"Examples - Macro.Env.define_require/4","doc":"iex> env = __ENV__\n    iex> Macro.Env.required?(env, Integer)\n    false\n    iex> {:ok, env} = Macro.Env.define_require(env, [line: 10], Integer)\n    iex> Macro.Env.required?(env, Integer)\n    true\n\nIf the `:as` option is given, it will also define an alias:\n\n    iex> env = __ENV__\n    iex> {:ok, env} = Macro.Env.define_require(env, [line: 10], Foo.Bar, as: Baz)\n    iex> Macro.Env.expand_alias(env, [], [:Baz])\n    {:alias, Foo.Bar}","ref":"Macro.Env.html#define_require/4-examples"},{"type":"function","title":"Macro.Env.expand_alias/4","doc":"Expands an alias given by the alias segments.\n\nIt returns `{:alias, alias}` if the segments is a list\nof atoms and an alias was found. Returns `:error` otherwise.\n\nThis expansion may emit the `:alias_expansion` trace event\nbut it does not emit the `:alias_reference` one.","ref":"Macro.Env.html#expand_alias/4"},{"type":"function","title":"Options - Macro.Env.expand_alias/4","doc":"* `:trace` - when set to `false`, it disables compilation tracers and\nlexical tracker. This option must only be used by language servers and\nother tools that need to introspect code without affecting how it is compiled.\nDisabling tracer inside macros or regular code expansion is extremely\ndiscouraged as it blocks the compiler from accurately tracking dependencies","ref":"Macro.Env.html#expand_alias/4-options"},{"type":"function","title":"Examples - Macro.Env.expand_alias/4","doc":"iex> alias List, as: MyList\n    iex> Macro.Env.expand_alias(__ENV__, [], [:MyList])\n    {:alias, List}\n    iex> Macro.Env.expand_alias(__ENV__, [], [:MyList, :Nested])\n    {:alias, List.Nested}\n\nIf there is no alias or the alias starts with `Elixir.`\n(which disables aliasing), then `:error` is returned:\n\n    iex> alias List, as: MyList\n    iex> Macro.Env.expand_alias(__ENV__, [], [:Elixir, MyList])\n    :error\n    iex> Macro.Env.expand_alias(__ENV__, [], [:AnotherList])\n    :error","ref":"Macro.Env.html#expand_alias/4-examples"},{"type":"function","title":"Macro.Env.expand_import/5","doc":"Expands an import given by `name` and `arity`.\n\nIf the import points to a macro, it returns a tuple\nwith the module and a function that expands the macro.\nThe function expects the metadata to be attached to the\nexpansion and the arguments of the macro.\n\nIf the import points to a function, it returns a tuple\nwith the module and the function name.\n\nIf any import is found, the appropriate compiler tracing\nevent will be emitted.\n\nOtherwise returns `{:error, reason}`.","ref":"Macro.Env.html#expand_import/5"},{"type":"function","title":"Options - Macro.Env.expand_import/5","doc":"* `:allow_locals` - when set to `false`, it does not attempt to capture\n    local macros defined in the current module in `env`\n\n  * `:check_deprecations` - when set to `false`, does not check for deprecations\n    when expanding macros\n\n  * `:trace` - when set to `false`, it disables compilation tracers and\nlexical tracker. This option must only be used by language servers and\nother tools that need to introspect code without affecting how it is compiled.\nDisabling tracer inside macros or regular code expansion is extremely\ndiscouraged as it blocks the compiler from accurately tracking dependencies","ref":"Macro.Env.html#expand_import/5-options"},{"type":"function","title":"Macro.Env.expand_require/6","doc":"Expands a require given by `module`, `name`, and `arity`.\n\nIf the require points to a macro and the module has been\nrequired, it returns a tuple with the module and a function\nthat expands the macro. The function expects the metadata\nto be attached to the expansion and the arguments of the macro.\nThe appropriate `:remote_macro` compiler tracing event will\nbe emitted if a macro is found (note a `:remote_function`\nevent is not emitted in `:error` cases).\n\nOtherwise returns `:error`.","ref":"Macro.Env.html#expand_require/6"},{"type":"function","title":"Options - Macro.Env.expand_require/6","doc":"* `:check_deprecations` - when set to `false`, does not check for deprecations\n    when expanding macros\n\n  * `:trace` - when set to `false`, it disables compilation tracers and\nlexical tracker. This option must only be used by language servers and\nother tools that need to introspect code without affecting how it is compiled.\nDisabling tracer inside macros or regular code expansion is extremely\ndiscouraged as it blocks the compiler from accurately tracking dependencies","ref":"Macro.Env.html#expand_require/6-options"},{"type":"type","title":"Macro.Env.file/0","doc":"","ref":"Macro.Env.html#t:file/0"},{"type":"function","title":"Macro.Env.has_var?/2","doc":"Checks if a variable belongs to the environment.","ref":"Macro.Env.html#has_var?/2"},{"type":"function","title":"Examples - Macro.Env.has_var?/2","doc":"iex> x = 13\n    iex> x\n    13\n    iex> Macro.Env.has_var?(__ENV__, {:x, nil})\n    true\n    iex> Macro.Env.has_var?(__ENV__, {:unknown, nil})\n    false","ref":"Macro.Env.html#has_var?/2-examples"},{"type":"function","title":"Macro.Env.in_guard?/1","doc":"Returns whether the compilation environment is currently\ninside a guard.","ref":"Macro.Env.html#in_guard?/1"},{"type":"function","title":"Macro.Env.in_match?/1","doc":"Returns whether the compilation environment is currently\ninside a match clause.","ref":"Macro.Env.html#in_match?/1"},{"type":"type","title":"Macro.Env.line/0","doc":"","ref":"Macro.Env.html#t:line/0"},{"type":"function","title":"Macro.Env.location/1","doc":"Returns a keyword list containing the file and line\ninformation as keys.","ref":"Macro.Env.html#location/1"},{"type":"function","title":"Macro.Env.lookup_alias_as/2","doc":"Returns the names of any aliases for the given module or atom.","ref":"Macro.Env.html#lookup_alias_as/2"},{"type":"function","title":"Examples - Macro.Env.lookup_alias_as/2","doc":"iex> alias Foo.Bar\n    iex> Bar\n    Foo.Bar\n    iex> Macro.Env.lookup_alias_as(__ENV__, Foo.Bar)\n    [Elixir.Bar]\n    iex> alias Foo.Bar, as: Baz\n    iex> Baz\n    Foo.Bar\n    iex> Macro.Env.lookup_alias_as(__ENV__, Foo.Bar)\n    [Elixir.Bar, Elixir.Baz]\n    iex> Macro.Env.lookup_alias_as(__ENV__, Unknown)\n    []","ref":"Macro.Env.html#lookup_alias_as/2-examples"},{"type":"function","title":"Macro.Env.lookup_import/2","doc":"Returns the modules from which the given `{name, arity}` was\nimported.\n\nIt returns a list of two element tuples in the shape of\n`{:function | :macro, module}`. The elements in the list\nare in no particular order and the order is not guaranteed.\n\n> #### Use only for introspection {: .warning}\n>\n> This function does not emit compiler tracing events,\n> which may block the compiler from correctly tracking\n> dependencies. Use this function for reflection purposes\n> but to do not use it to expand imports into qualified\n> calls. Instead, use `expand_import/5`.","ref":"Macro.Env.html#lookup_import/2"},{"type":"function","title":"Examples - Macro.Env.lookup_import/2","doc":"iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    []\n    iex> import Tuple, only: [duplicate: 2], warn: false\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    [{:function, Tuple}]\n    iex> import List, only: [duplicate: 2], warn: false\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    [{:function, List}, {:function, Tuple}]\n\n    iex> Macro.Env.lookup_import(__ENV__, {:def, 1})\n    [{:macro, Kernel}]","ref":"Macro.Env.html#lookup_import/2-examples"},{"type":"type","title":"Macro.Env.name_arity/0","doc":"","ref":"Macro.Env.html#t:name_arity/0"},{"type":"function","title":"Macro.Env.prepend_tracer/2","doc":"Prepend a tracer to the list of tracers in the environment.","ref":"Macro.Env.html#prepend_tracer/2"},{"type":"function","title":"Examples - Macro.Env.prepend_tracer/2","doc":"Macro.Env.prepend_tracer(__ENV__, MyCustomTracer)","ref":"Macro.Env.html#prepend_tracer/2-examples"},{"type":"function","title":"Macro.Env.prune_compile_info/1","doc":"Prunes compile information from the environment.\n\nThis happens when the environment is captured at compilation\ntime, for example, in the module body, and then used to\nevaluate code after the module has been defined.","ref":"Macro.Env.html#prune_compile_info/1"},{"type":"function","title":"Macro.Env.required?/2","doc":"Returns `true` if the given module has been required.","ref":"Macro.Env.html#required?/2"},{"type":"function","title":"Examples - Macro.Env.required?/2","doc":"iex> Macro.Env.required?(__ENV__, Integer)\n    false\n    iex> require Integer\n    iex> Macro.Env.required?(__ENV__, Integer)\n    true\n\n    iex> Macro.Env.required?(__ENV__, Kernel)\n    true","ref":"Macro.Env.html#required?/2-examples"},{"type":"function","title":"Macro.Env.stacktrace/1","doc":"Returns the environment stacktrace.","ref":"Macro.Env.html#stacktrace/1"},{"type":"type","title":"Macro.Env.t/0","doc":"","ref":"Macro.Env.html#t:t/0"},{"type":"function","title":"Macro.Env.to_guard/1","doc":"Returns an environment in the guard context.","ref":"Macro.Env.html#to_guard/1"},{"type":"function","title":"Macro.Env.to_match/1","doc":"Returns an environment in the match context.","ref":"Macro.Env.html#to_match/1"},{"type":"type","title":"Macro.Env.variable/0","doc":"","ref":"Macro.Env.html#t:variable/0"},{"type":"function","title":"Macro.Env.vars/1","doc":"Returns a list of variables in the current environment.\n\nEach variable is identified by a tuple of two elements,\nwhere the first element is the variable name as an atom\nand the second element is its context, which may be an\natom or an integer.","ref":"Macro.Env.html#vars/1"},{"type":"module","title":"Behaviour","doc":"Mechanism for handling behaviours.\n\nThis module is deprecated. Instead of `defcallback/1` and\n`defmacrocallback/1`, the `@callback` and `@macrocallback`\nmodule attributes can be used respectively. See the\ndocumentation for `Module` for more information on these\nattributes.\n\nInstead of `MyModule.__behaviour__(:callbacks)`,\n`MyModule.behaviour_info(:callbacks)` can be used.","ref":"Behaviour.html"},{"type":"macro","title":"Behaviour.defcallback/1","doc":"Defines a function callback according to the given type specification.","ref":"Behaviour.html#defcallback/1"},{"type":"macro","title":"Behaviour.defmacrocallback/1","doc":"Defines a macro callback according to the given type specification.","ref":"Behaviour.html#defmacrocallback/1"},{"type":"module","title":"Dict","doc":"Generic API for dictionaries.\n\nIf you need a general dictionary, use the `Map` module.\nIf you need to manipulate keyword lists, use `Keyword`.\n\nTo convert maps into keywords and vice-versa, use the\n`new` function in the respective modules.","ref":"Dict.html"},{"type":"function","title":"Dict.delete/2","doc":"","ref":"Dict.html#delete/2"},{"type":"function","title":"Dict.drop/2","doc":"","ref":"Dict.html#drop/2"},{"type":"function","title":"Dict.empty/1","doc":"","ref":"Dict.html#empty/1"},{"type":"function","title":"Dict.equal?/2","doc":"","ref":"Dict.html#equal?/2"},{"type":"function","title":"Dict.fetch/2","doc":"","ref":"Dict.html#fetch/2"},{"type":"function","title":"Dict.fetch!/2","doc":"","ref":"Dict.html#fetch!/2"},{"type":"function","title":"Dict.get/3","doc":"","ref":"Dict.html#get/3"},{"type":"function","title":"Dict.get_and_update/3","doc":"","ref":"Dict.html#get_and_update/3"},{"type":"function","title":"Dict.get_lazy/3","doc":"","ref":"Dict.html#get_lazy/3"},{"type":"function","title":"Dict.has_key?/2","doc":"","ref":"Dict.html#has_key?/2"},{"type":"type","title":"Dict.key/0","doc":"","ref":"Dict.html#t:key/0"},{"type":"function","title":"Dict.keys/1","doc":"","ref":"Dict.html#keys/1"},{"type":"function","title":"Dict.merge/2","doc":"","ref":"Dict.html#merge/2"},{"type":"function","title":"Dict.merge/3","doc":"","ref":"Dict.html#merge/3"},{"type":"function","title":"Dict.pop/3","doc":"","ref":"Dict.html#pop/3"},{"type":"function","title":"Dict.pop_lazy/3","doc":"","ref":"Dict.html#pop_lazy/3"},{"type":"function","title":"Dict.put/3","doc":"","ref":"Dict.html#put/3"},{"type":"function","title":"Dict.put_new/3","doc":"","ref":"Dict.html#put_new/3"},{"type":"function","title":"Dict.put_new_lazy/3","doc":"","ref":"Dict.html#put_new_lazy/3"},{"type":"function","title":"Dict.size/1","doc":"","ref":"Dict.html#size/1"},{"type":"function","title":"Dict.split/2","doc":"","ref":"Dict.html#split/2"},{"type":"type","title":"Dict.t/0","doc":"","ref":"Dict.html#t:t/0"},{"type":"function","title":"Dict.take/2","doc":"","ref":"Dict.html#take/2"},{"type":"function","title":"Dict.to_list/1","doc":"","ref":"Dict.html#to_list/1"},{"type":"function","title":"Dict.update/4","doc":"","ref":"Dict.html#update/4"},{"type":"function","title":"Dict.update!/3","doc":"","ref":"Dict.html#update!/3"},{"type":"type","title":"Dict.value/0","doc":"","ref":"Dict.html#t:value/0"},{"type":"function","title":"Dict.values/1","doc":"","ref":"Dict.html#values/1"},{"type":"behaviour","title":"GenEvent","doc":"An event manager with event handlers behaviour.\n\nIf you are interested in implementing an event manager, please read the\n\"Alternatives\" section below. If you have to implement an event handler to\nintegrate with an existing system, such as Elixir's Logger, please use\n[`:gen_event`](`:gen_event`) instead.","ref":"GenEvent.html"},{"type":"behaviour","title":"Alternatives - GenEvent","doc":"There are a few suitable alternatives to replace GenEvent. Each of them can be\nthe most beneficial based on the use case.","ref":"GenEvent.html#module-alternatives"},{"type":"behaviour","title":"Supervisor and GenServers - GenEvent","doc":"One alternative to GenEvent is a very minimal solution consisting of using a\nsupervisor and multiple GenServers started under it. The supervisor acts as\nthe \"event manager\" and the children GenServers act as the \"event handlers\".\nThis approach has some shortcomings (it provides no back-pressure for example)\nbut can still replace GenEvent for low-profile usages of it. [This blog post\nby José\nValim](https://dashbit.co/blog/replacing-genevent-by-a-supervisor-plus-genserver)\nhas more detailed information on this approach.","ref":"GenEvent.html#module-supervisor-and-genservers"},{"type":"behaviour","title":"GenStage - GenEvent","doc":"If the use case where you were using GenEvent requires more complex logic,\n[GenStage](https://github.com/elixir-lang/gen_stage) provides a great\nalternative. GenStage is an external Elixir library maintained by the Elixir\nteam; it provides a tool to implement systems that exchange events in a\ndemand-driven way with built-in support for back-pressure. See the [GenStage\ndocumentation](https://hexdocs.pm/gen_stage) for more information.\n\n### `:gen_event`\n\nIf your use case requires exactly what GenEvent provided, or you have to\nintegrate with an existing `:gen_event`-based system, you can still use the\n[`:gen_event`](`:gen_event`) Erlang module.","ref":"GenEvent.html#module-genstage"},{"type":"callback","title":"GenEvent.code_change/3","doc":"","ref":"GenEvent.html#c:code_change/3"},{"type":"callback","title":"GenEvent.handle_call/2","doc":"","ref":"GenEvent.html#c:handle_call/2"},{"type":"callback","title":"GenEvent.handle_event/2","doc":"","ref":"GenEvent.html#c:handle_event/2"},{"type":"callback","title":"GenEvent.handle_info/2","doc":"","ref":"GenEvent.html#c:handle_info/2"},{"type":"type","title":"GenEvent.handler/0","doc":"","ref":"GenEvent.html#t:handler/0"},{"type":"callback","title":"GenEvent.init/1","doc":"","ref":"GenEvent.html#c:init/1"},{"type":"type","title":"GenEvent.manager/0","doc":"","ref":"GenEvent.html#t:manager/0"},{"type":"type","title":"GenEvent.name/0","doc":"","ref":"GenEvent.html#t:name/0"},{"type":"type","title":"GenEvent.on_start/0","doc":"","ref":"GenEvent.html#t:on_start/0"},{"type":"type","title":"GenEvent.options/0","doc":"","ref":"GenEvent.html#t:options/0"},{"type":"callback","title":"GenEvent.terminate/2","doc":"","ref":"GenEvent.html#c:terminate/2"},{"type":"module","title":"HashDict","doc":"Tuple-based HashDict implementation.\n\nThis module is deprecated. Use the `Map` module instead.","ref":"HashDict.html"},{"type":"function","title":"HashDict.delete/2","doc":"","ref":"HashDict.html#delete/2"},{"type":"function","title":"HashDict.drop/2","doc":"","ref":"HashDict.html#drop/2"},{"type":"function","title":"HashDict.equal?/2","doc":"","ref":"HashDict.html#equal?/2"},{"type":"function","title":"HashDict.fetch/2","doc":"","ref":"HashDict.html#fetch/2"},{"type":"function","title":"HashDict.fetch!/2","doc":"","ref":"HashDict.html#fetch!/2"},{"type":"function","title":"HashDict.get/3","doc":"","ref":"HashDict.html#get/3"},{"type":"function","title":"HashDict.get_and_update/3","doc":"","ref":"HashDict.html#get_and_update/3"},{"type":"function","title":"HashDict.get_lazy/3","doc":"","ref":"HashDict.html#get_lazy/3"},{"type":"function","title":"HashDict.has_key?/2","doc":"","ref":"HashDict.html#has_key?/2"},{"type":"function","title":"HashDict.keys/1","doc":"","ref":"HashDict.html#keys/1"},{"type":"function","title":"HashDict.merge/3","doc":"","ref":"HashDict.html#merge/3"},{"type":"function","title":"HashDict.new/0","doc":"Creates a new empty dict.","ref":"HashDict.html#new/0"},{"type":"function","title":"HashDict.pop/3","doc":"","ref":"HashDict.html#pop/3"},{"type":"function","title":"HashDict.pop_lazy/3","doc":"","ref":"HashDict.html#pop_lazy/3"},{"type":"function","title":"HashDict.put/3","doc":"","ref":"HashDict.html#put/3"},{"type":"function","title":"HashDict.put_new/3","doc":"","ref":"HashDict.html#put_new/3"},{"type":"function","title":"HashDict.put_new_lazy/3","doc":"","ref":"HashDict.html#put_new_lazy/3"},{"type":"function","title":"HashDict.size/1","doc":"","ref":"HashDict.html#size/1"},{"type":"function","title":"HashDict.split/2","doc":"","ref":"HashDict.html#split/2"},{"type":"opaque","title":"HashDict.t/0","doc":"","ref":"HashDict.html#t:t/0"},{"type":"function","title":"HashDict.take/2","doc":"","ref":"HashDict.html#take/2"},{"type":"function","title":"HashDict.to_list/1","doc":"","ref":"HashDict.html#to_list/1"},{"type":"function","title":"HashDict.update/4","doc":"","ref":"HashDict.html#update/4"},{"type":"function","title":"HashDict.update!/3","doc":"","ref":"HashDict.html#update!/3"},{"type":"function","title":"HashDict.values/1","doc":"","ref":"HashDict.html#values/1"},{"type":"module","title":"HashSet","doc":"Tuple-based HashSet implementation.\n\nThis module is deprecated. Use the `MapSet` module instead.","ref":"HashSet.html"},{"type":"function","title":"HashSet.delete/2","doc":"","ref":"HashSet.html#delete/2"},{"type":"function","title":"HashSet.difference/2","doc":"","ref":"HashSet.html#difference/2"},{"type":"function","title":"HashSet.disjoint?/2","doc":"","ref":"HashSet.html#disjoint?/2"},{"type":"function","title":"HashSet.equal?/2","doc":"","ref":"HashSet.html#equal?/2"},{"type":"function","title":"HashSet.intersection/2","doc":"","ref":"HashSet.html#intersection/2"},{"type":"function","title":"HashSet.member?/2","doc":"","ref":"HashSet.html#member?/2"},{"type":"function","title":"HashSet.new/0","doc":"","ref":"HashSet.html#new/0"},{"type":"function","title":"HashSet.put/2","doc":"","ref":"HashSet.html#put/2"},{"type":"function","title":"HashSet.size/1","doc":"","ref":"HashSet.html#size/1"},{"type":"function","title":"HashSet.subset?/2","doc":"","ref":"HashSet.html#subset?/2"},{"type":"opaque","title":"HashSet.t/0","doc":"","ref":"HashSet.html#t:t/0"},{"type":"function","title":"HashSet.to_list/1","doc":"","ref":"HashSet.html#to_list/1"},{"type":"function","title":"HashSet.union/2","doc":"","ref":"HashSet.html#union/2"},{"type":"module","title":"Set","doc":"Generic API for sets.\n\nThis module is deprecated, use the `MapSet` module instead.","ref":"Set.html"},{"type":"function","title":"Set.delete/2","doc":"","ref":"Set.html#delete/2"},{"type":"function","title":"Set.difference/2","doc":"","ref":"Set.html#difference/2"},{"type":"function","title":"Set.disjoint?/2","doc":"","ref":"Set.html#disjoint?/2"},{"type":"function","title":"Set.empty/1","doc":"","ref":"Set.html#empty/1"},{"type":"function","title":"Set.equal?/2","doc":"","ref":"Set.html#equal?/2"},{"type":"function","title":"Set.intersection/2","doc":"","ref":"Set.html#intersection/2"},{"type":"function","title":"Set.member?/2","doc":"","ref":"Set.html#member?/2"},{"type":"function","title":"Set.put/2","doc":"","ref":"Set.html#put/2"},{"type":"function","title":"Set.size/1","doc":"","ref":"Set.html#size/1"},{"type":"function","title":"Set.subset?/2","doc":"","ref":"Set.html#subset?/2"},{"type":"type","title":"Set.t/0","doc":"","ref":"Set.html#t:t/0"},{"type":"function","title":"Set.to_list/1","doc":"","ref":"Set.html#to_list/1"},{"type":"function","title":"Set.union/2","doc":"","ref":"Set.html#union/2"},{"type":"type","title":"Set.value/0","doc":"","ref":"Set.html#t:value/0"},{"type":"type","title":"Set.values/0","doc":"","ref":"Set.html#t:values/0"},{"type":"module","title":"Supervisor.Spec","doc":"Outdated functions for building child specifications.\n\nThe functions in this module are deprecated and they do not work\nwith the module-based child specs introduced in Elixir v1.5.\nPlease see the `Supervisor` documentation instead.\n\nConvenience functions for defining supervisor specifications.","ref":"Supervisor.Spec.html"},{"type":"module","title":"Example - Supervisor.Spec","doc":"By using the functions in this module one can specify the children\nto be used under a supervisor, started with `Supervisor.start_link/2`:\n\n    import Supervisor.Spec\n\n    children = [\n      worker(MyWorker, [arg1, arg2, arg3]),\n      supervisor(MySupervisor, [arg1])\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nSometimes, it may be handy to define supervisors backed\nby a module:\n\n    defmodule MySupervisor do\n      use Supervisor\n\n      def start_link(arg) do\n        Supervisor.start_link(__MODULE__, arg)\n      end\n\n      def init(arg) do\n        children = [\n          worker(MyWorker, [arg], restart: :temporary)\n        ]\n\n        supervise(children, strategy: :simple_one_for_one)\n      end\n    end\n\nNote that in this case we don't have to explicitly import\n`Supervisor.Spec` since `use Supervisor` automatically does so.\nDefining a module-based supervisor can be useful, for example,\nto perform initialization tasks in the `c:Supervisor.init/1` callback.","ref":"Supervisor.Spec.html#module-example"},{"type":"module","title":"Supervisor and worker options - Supervisor.Spec","doc":"In the example above, we defined specs for workers and supervisors.\nThese specs (both for workers as well as supervisors) accept the\nfollowing options:\n\n  * `:id` - a name used to identify the child specification\n    internally by the supervisor; defaults to the given module\n    name for the child worker/supervisor\n\n  * `:function` - the function to invoke on the child to start it\n\n  * `:restart` - an atom that defines when a terminated child process should\n    be restarted (see the \"Restart values\" section below)\n\n  * `:shutdown` - an atom that defines how a child process should be\n    terminated (see the \"Shutdown values\" section below)\n\n  * `:modules` - it should be a list with one element `[module]`,\n    where module is the name of the callback module only if the\n    child process is a `Supervisor` or `GenServer`; if the child\n    process is a `GenEvent`, `:modules` should be `:dynamic`","ref":"Supervisor.Spec.html#module-supervisor-and-worker-options"},{"type":"module","title":"Restart values (:restart) - Supervisor.Spec","doc":"The following restart values are supported in the `:restart` option:\n\n  * `:permanent` - the child process is always restarted\n\n  * `:temporary` - the child process is never restarted (not even\n    when the supervisor's strategy is `:rest_for_one` or `:one_for_all`)\n\n  * `:transient` - the child process is restarted only if it\n    terminates abnormally, i.e., with an exit reason other than\n    `:normal`, `:shutdown` or `{:shutdown, term}`\n\nNote that supervisor that reached maximum restart intensity will exit with `:shutdown` reason.\nIn this case the supervisor will only restart if its child specification was defined with\nthe `:restart` option set to `:permanent` (the default).","ref":"Supervisor.Spec.html#module-restart-values-restart"},{"type":"module","title":"Shutdown values (`:shutdown`) - Supervisor.Spec","doc":"The following shutdown values are supported in the `:shutdown` option:\n\n  * `:brutal_kill` - the child process is unconditionally terminated\n    using `Process.exit(child, :kill)`\n\n  * `:infinity` - if the child process is a supervisor, this is a mechanism\n    to give the subtree enough time to shut down; it can also be used with\n    workers with care\n\n  * a non-negative integer - the amount of time in milliseconds\n    that the supervisor tells the child process to terminate by calling\n    `Process.exit(child, :shutdown)` and then waits for an exit signal back.\n    If no exit signal is received within the specified time,\n    the child process is unconditionally terminated\n    using `Process.exit(child, :kill)`","ref":"Supervisor.Spec.html#module-shutdown-values-shutdown"},{"type":"type","title":"Supervisor.Spec.child_id/0","doc":"Supported ID values","ref":"Supervisor.Spec.html#t:child_id/0"},{"type":"type","title":"Supervisor.Spec.modules/0","doc":"Supported module values","ref":"Supervisor.Spec.html#t:modules/0"},{"type":"type","title":"Supervisor.Spec.restart/0","doc":"Supported restart values","ref":"Supervisor.Spec.html#t:restart/0"},{"type":"type","title":"Supervisor.Spec.shutdown/0","doc":"Supported shutdown values","ref":"Supervisor.Spec.html#t:shutdown/0"},{"type":"type","title":"Supervisor.Spec.spec/0","doc":"The supervisor specification","ref":"Supervisor.Spec.html#t:spec/0"},{"type":"type","title":"Supervisor.Spec.strategy/0","doc":"Supported strategies","ref":"Supervisor.Spec.html#t:strategy/0"},{"type":"function","title":"Supervisor.Spec.supervise/2","doc":"Receives a list of `children` (workers or supervisors) to\nsupervise and a set of `options`.\n\nReturns a tuple containing the supervisor specification. This tuple can be\nused as the return value of the `c:Supervisor.init/1` callback when implementing a\nmodule-based supervisor.","ref":"Supervisor.Spec.html#supervise/2"},{"type":"function","title":"Examples - Supervisor.Spec.supervise/2","doc":"supervise(children, strategy: :one_for_one)","ref":"Supervisor.Spec.html#supervise/2-examples"},{"type":"function","title":"Options - Supervisor.Spec.supervise/2","doc":"* `:strategy` - the restart strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, `:one_for_all`, or\n    `:simple_one_for_one`. You can learn more about strategies\n    in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\nThe `:strategy` option is required and by default a maximum of 3 restarts is\nallowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies.","ref":"Supervisor.Spec.html#supervise/2-options"},{"type":"function","title":"Supervisor.Spec.supervisor/3","doc":"Defines the given `module` as a supervisor which will be started\nwith the given arguments.\n\n    supervisor(module, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: :infinity,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options.","ref":"Supervisor.Spec.html#supervisor/3"},{"type":"type","title":"Supervisor.Spec.worker/0","doc":"Supported worker values","ref":"Supervisor.Spec.html#t:worker/0"},{"type":"function","title":"Supervisor.Spec.worker/3","doc":"Defines the given `module` as a worker which will be started\nwith the given arguments.\n\n    worker(ExUnit.Runner, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: 5000,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options.","ref":"Supervisor.Spec.html#worker/3"},{"type":"exception","title":"ArgumentError","doc":"An exception raised when an argument to a function is invalid.\n\nYou can raise this exception when you want to signal that an argument to\na function is invalid.\n\n`ArgumentError` exceptions have a single field, `:message` (a `t:String.t/0`),\nwhich is public and can be accessed freely when reading or creating `ArgumentError`\nexceptions.","ref":"ArgumentError.html"},{"type":"exception","title":"ArithmeticError","doc":"An exception raised on invalid arithmetic operations.\n\nFor example, this exception is raised if you divide by `0`:\n\n    iex> 1 / 0\n    ** (ArithmeticError) bad argument in arithmetic expression: 1 / 0","ref":"ArithmeticError.html"},{"type":"exception","title":"BadArityError","doc":"An exception raised when a function is called with the wrong number of arguments.","ref":"BadArityError.html"},{"type":"exception","title":"BadBooleanError","doc":"An exception raised when an operator expected a boolean, but received something else.","ref":"BadBooleanError.html"},{"type":"exception","title":"BadFunctionError","doc":"","ref":"BadFunctionError.html"},{"type":"exception","title":"BadMapError","doc":"An exception raised when something expected a map, but received something else.","ref":"BadMapError.html"},{"type":"exception","title":"BadStructError","doc":"","ref":"BadStructError.html"},{"type":"exception","title":"CaseClauseError","doc":"An exception raised when a term in a `case/2` expression\ndoes not match any of the defined `->` clauses.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:term` (`t:term/0`) - the term that did not match any of the clauses\n\nFor example, this exception gets raised for a `case/2` like the following:\n\n    case System.unique_integer() do\n      bin when is_binary(bin) -> :oops\n      :ok -> :neither_this_one\n    end","ref":"CaseClauseError.html"},{"type":"exception","title":"Code.LoadError","doc":"An exception raised when a file cannot be loaded.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:file` (`t:String.t/0`) - the file name\n  * `:reason` (`t:term/0`) - the reason why the file could not be loaded","ref":"Code.LoadError.html"},{"type":"exception","title":"CompileError","doc":"An exception raised when there's an error when compiling code.\n\nThe following fields of this exceptions are public and can be accessed freely:\n\n  * `:file` (`t:Path.t/0` or `nil`) - the file where the error occurred, or `nil` if\n    the error occurred in code that did not come from a file\n  * `:line` (`t:non_neg_integer/0`) - the line where the error occurred","ref":"CompileError.html"},{"type":"exception","title":"CondClauseError","doc":"An exception raised when no clauses in a `cond/1` expression evaluate to a truthy value.\n\nFor example, this exception gets raised for a `cond/1` like the following:\n\n    cond do\n      1 + 1 == 3 -> :woah\n      nil -> \"yeah this won't happen\n    end","ref":"CondClauseError.html"},{"type":"exception","title":"Enum.EmptyError","doc":"An exception that is raised when something expects a non-empty enumerable\nbut finds an empty one.\n\nFor example, this is raised by `Enum.min/3`.","ref":"Enum.EmptyError.html"},{"type":"exception","title":"Enum.OutOfBoundsError","doc":"An exception that is raised when a function expects an enumerable to have\na certain size but finds that it is too small.\n\nFor example, this is raised by `Access.at!/1`.","ref":"Enum.OutOfBoundsError.html"},{"type":"exception","title":"ErlangError","doc":"","ref":"ErlangError.html"},{"type":"exception","title":"File.CopyError","doc":"An exception that is raised when copying a file fails.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:source` (`t:Path.t/0`) - the source path\n  * `:destination` (`t:Path.t/0`) - the destination path\n  * `:reason` (`t:File.posix/0`) - the reason why the file could not be copied","ref":"File.CopyError.html"},{"type":"exception","title":"File.Error","doc":"An exception that is raised when a file operation fails.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:path` (`t:Path.t/0`) - the path of the file that caused the error\n  * `:reason` (`t:File.posix/0`) - the reason for the error","ref":"File.Error.html"},{"type":"exception","title":"File.LinkError","doc":"An exception that is raised when linking a file fails.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:existing` (`t:Path.t/0`) - the existing file to link\n  * `:new` (`t:Path.t/0`) - the link destination\n  * `:reason` (`t:File.posix/0`) - the reason why the file could not be linked","ref":"File.LinkError.html"},{"type":"exception","title":"File.RenameError","doc":"An exception that is raised when renaming a file fails.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:source` (`t:Path.t/0`) - the source path\n  * `:destination` (`t:Path.t/0`) - the destination path\n  * `:reason` (`t:File.posix/0`) - the reason why the file could not be renamed","ref":"File.RenameError.html"},{"type":"exception","title":"FunctionClauseError","doc":"An exception raised when a function call doesn't match any defined clause.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:module` (`t:module/0`) - the module name\n  * `:function` (`t:atom/0`) - the function name\n  * `:arity` (`t:non_neg_integer/0`) - the arity of the function\n\nFor example, if you try to call a function such as `URI.parse/1` with something\nother than a string, the error would look like:\n\n    %FunctionClauseError{\n      module: URI,\n      function: :parse,\n      arity: 1,\n      # Other private fields...\n    }","ref":"FunctionClauseError.html"},{"type":"exception","title":"IO.StreamError","doc":"","ref":"IO.StreamError.html"},{"type":"exception","title":"Inspect.Error","doc":"Raised when a struct cannot be inspected.","ref":"Inspect.Error.html"},{"type":"exception","title":"Kernel.TypespecError","doc":"An exception raised when there's an error in a typespec.\n\nThe following fields of this exceptions are public and can be accessed freely:\n\n  * `:file` (`t:Path.t/0` or `nil`) - the file where the error occurred, or `nil` if\n    the error occurred in code that did not come from a file\n  * `:line` (`t:non_neg_integer/0`) - the line where the error occurred","ref":"Kernel.TypespecError.html"},{"type":"exception","title":"KeyError","doc":"An exception raised when a key is not found in a data structure.\n\nFor example, this is raised by `Map.fetch!/2` when the given key\ncannot be found in the given map.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:term` (`t:term/0`) - the data structure that was searched\n  * `:key` (`t:term/0`) - the key that was not found","ref":"KeyError.html"},{"type":"exception","title":"MatchError","doc":"An exception raised when a pattern match (`=/2`) fails.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:term` (`t:term/0`) - the term that did not match the pattern\n\nFor example, this exception gets raised for code like this:\n\n    [_ | _] = []","ref":"MatchError.html"},{"type":"exception","title":"MismatchedDelimiterError","doc":"An exception raised when a mismatched delimiter is found when parsing code.\n\nFor example:\n\n  * `[1, 2, 3}`\n  * `fn a -> )`\n\nThe following fields of this exceptions are public and can be accessed freely:\n\n  * `:file` (`t:Path.t/0` or `nil`) - the file where the error occurred, or `nil` if\n    the error occurred in code that did not come from a file\n  * `:line` - the line for the opening delimiter\n  * `:column` - the column for the opening delimiter\n  * `:end_line` - the line for the mismatched closing delimiter\n  * `:end_column` - the column for the mismatched closing delimiter\n  * `:opening_delimiter` - an atom representing the opening delimiter\n  * `:closing_delimiter` - an atom representing the mismatched closing delimiter\n  * `:expected_delimiter` - an atom representing the closing delimiter\n  * `:description` - a description of the mismatched delimiter error","ref":"MismatchedDelimiterError.html"},{"type":"exception","title":"OptionParser.ParseError","doc":"An exception raised when parsing option fails.\n\nFor example, see `OptionParser.parse!/2`.","ref":"OptionParser.ParseError.html"},{"type":"exception","title":"Protocol.UndefinedError","doc":"An exception raised when a protocol is not implemented for a given value.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:protocol` (`t:module/0`) - the protocol that is not implemented\n  * `:value` (`t:term/0`) - the value that does not implement the protocol\n\nFor example, this code:\n\n    Enum.at(\"A string!\", 0)\n\nwould raise the following exception:\n\n    %Protocol.UndefinedError{\n      protocol: Enumerable,\n      value: \"A string!\",\n      # ...\n    }","ref":"Protocol.UndefinedError.html"},{"type":"exception","title":"Regex.CompileError","doc":"An exception raised when a regular expression could not be compiled.","ref":"Regex.CompileError.html"},{"type":"exception","title":"RuntimeError","doc":"An exception for a generic runtime error.\n\nThis is the exception that `raise/1` raises when you pass it only a string as\na message:\n\n    iex> raise \"oops!\"\n    ** (RuntimeError) oops!\n\nYou should use this exceptions sparingly, since most of the time it might be\nbetter to define your own exceptions specific to your application or library.\nSometimes, however, there are situations in which you don't expect a condition to\nhappen, but you want to give a meaningful error message if it does. In those cases,\n`RuntimeError` can be a good choice.","ref":"RuntimeError.html"},{"type":"exception","title":"Fields - RuntimeError","doc":"`RuntimeError` exceptions have a single field, `:message` (a `t:String.t/0`),\nwhich is public and can be accessed freely when reading or creating `RuntimeError`\nexceptions.","ref":"RuntimeError.html#module-fields"},{"type":"exception","title":"SyntaxError","doc":"An exception raised when there's a syntax error when parsing code.\n\nThe following fields of this exceptions are public and can be accessed freely:\n\n  * `:file` (`t:Path.t/0` or `nil`) - the file where the error occurred, or `nil` if\n    the error occurred in code that did not come from a file\n  * `:line` - the line where the error occurred\n  * `:column` - the column where the error occurred\n  * `:description` - a description of the syntax error","ref":"SyntaxError.html"},{"type":"exception","title":"System.EnvError","doc":"An exception raised when a system environment variable is not set.\n\nFor example, see `System.fetch_env!/1`.","ref":"System.EnvError.html"},{"type":"exception","title":"SystemLimitError","doc":"An exception raised when a system limit has been reached.\n\nFor example, this can happen if you try to create an atom that is too large.","ref":"SystemLimitError.html"},{"type":"exception","title":"TokenMissingError","doc":"An exception raised when a token is missing when parsing code.\n\nThe following fields of this exceptions are public and can be accessed freely:\n\n  * `:file` (`t:Path.t/0` or `nil`) - the file where the error occurred, or `nil` if\n    the error occurred in code that did not come from a file\n  * `:line` - the line for the opening delimiter\n  * `:column` - the column for the opening delimiter\n  * `:end_line` - the line for the end of the string\n  * `:end_column` - the column for the end of the string\n  * `:opening_delimiter` - an atom representing the opening delimiter\n  * `:expected_delimiter` - an atom representing the expected delimiter\n  * `:description` - a description of the missing token error","ref":"TokenMissingError.html"},{"type":"exception","title":"TryClauseError","doc":"An exception raised when a term in a `try/1` expression\ndoes not match any of the defined `->` clauses in its `else`.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:term` (`t:term/0`) - the term that did not match any of the clauses","ref":"TryClauseError.html"},{"type":"exception","title":"URI.Error","doc":"An exception raised when an error occurs when a `URI` is invalid.\n\nFor example, see `URI.new!/1`.","ref":"URI.Error.html"},{"type":"exception","title":"UndefinedFunctionError","doc":"An exception raised when a function is invoked that is not defined.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:module` (`t:module/0`) - the module name\n  * `:function` (`t:atom/0`) - the function name\n  * `:arity` (`t:non_neg_integer/0`) - the arity of the function\n\nFor example, if you try to call `MyMod.non_existing_fun(\"hello\", 1)`,\nthe error would look like:\n\n    %UndefinedFunctionError{\n      module: MyMod,\n      function: :non_existing_fun,\n      arity: 2,\n      # Other private fields...\n    }","ref":"UndefinedFunctionError.html"},{"type":"exception","title":"UnicodeConversionError","doc":"","ref":"UnicodeConversionError.html"},{"type":"exception","title":"Version.InvalidRequirementError","doc":"An exception raised when a version requirement is invalid.\n\nFor example, see `Version.parse_requirement!/1`.","ref":"Version.InvalidRequirementError.html"},{"type":"exception","title":"Version.InvalidVersionError","doc":"An exception raised when a version is invalid.\n\nFor example, see `Version.parse!/1`.","ref":"Version.InvalidVersionError.html"},{"type":"exception","title":"WithClauseError","doc":"An exception raised when a term in a `with/1` expression\ndoes not match any of the defined `->` clauses in its `else`.\n\nThe following fields of this exception are public and can be accessed freely:\n\n  * `:term` (`t:term/0`) - the term that did not match any of the clauses\n\nFor example, this exception gets raised for a `with/1` like the following, because\nthe `{:ok, 2}` term does not match the `:error` or `{:error, _}` clauses in the\n`else`:\n\n    with {:ok, 1} <- {:ok, 2} do\n      :woah\n    else\n      :error -> :error\n      {:error, _} -> :error\n    end","ref":"WithClauseError.html"},{"type":"extras","title":"Changelog for Elixir v1.17","doc":"# Changelog for Elixir v1.17\n\nThis release includes type inference of patterns to provide warnings for an initial set of constructs (binaries, maps, and atoms) within the same function. It also includes a new Duration data type to interact with Calendar types, support for Erlang/OTP 27, and many other improvements.","ref":"changelog.html"},{"type":"extras","title":"Warnings from gradual set-theoretic types - Changelog for Elixir v1.17","doc":"This release introduces gradual set-theoretic types to infer types from patterns and use them to type check programs, enabling the Elixir compiler to find faults and bugs in codebases without requiring changes to existing software. The underlying principles, theory, and roadmap of our work have been outlined in [\"The Design Principles of the Elixir Type System\" by Giuseppe Castagna, Guillaume Duboc, José Valim](https://arxiv.org/abs/2306.06391).\n\nAt the moment, Elixir developers will interact with set-theoretic types only through warnings found by the type system. The current implementation models all data types in the language:\n\n  * `binary()`, `integer()`, `float()`, `pid()`, `port()`, `reference()` - these types are indivisible. This means both `1` and `13` get the same `integer()` type.\n\n  * `atom()` - it represents all atoms and it is divisible. For instance, the atom `:foo` and `:hello_world` are also valid (distinct) types.\n\n  * `map()` and structs - maps can be \"closed\" or \"open\". Closed maps only allow the specified keys, such as `%{key: atom(), value: integer()}`. Open maps support any other keys in addition to the ones listed and their definition starts with `...`, such as `%{..., key: atom(), value: integer()}`. Structs are closed maps with the `__struct__` key.\n\n  * `tuple()`, `list()`, and `function()` - currently they are modelled as indivisible types. The next Elixir versions will also introduce fine-grained support to them.\n\nWe focused on atoms and maps on this initial release as they are respectively the simplest and the most complex types representations, so we can stress the performance of the type system and quality of error messages. Modelling these types will also provide the most immediate benefits to Elixir developers. Assuming there is a variable named `user`, holding a `%User{}` struct with an `address` field, Elixir v1.17 will emit the following warnings at compile-time:\n\n  * Pattern matching against a map or a struct that does not have the given key, such as `%{adress: ...} = user` (notice `address` vs `adress`)\n\n  * Accessing a key on a map or a struct that does not have the given key, such as `user.adress`\n\n  * Invoking a function on non-modules, such as `user.address()`\n\n  * Capturing a function on non-modules, such as `&user.address/0`\n\n  * Attempting to invoke to call an anonymous function without an actual function, such as `user.()`\n\n  * Performing structural comparisons with structs, such as `my_date < ~D[2010-04-17]`\n\n  * Performing structural comparisons between non-overlapping types, such as `integer >= string`\n\n  * Building and pattern matching on binaries without the relevant specifiers, such as `< >` (this warns because by default it expects an integer, it should have been `< >` instead)\n\n  * Attempting to rescue an undefined exception or a struct that is not an exception\n\n  * Accessing a field that is not defined in a rescued exception\n\nThese new warnings help Elixir developers find bugs earlier and give more confidence when refactoring code, especially around maps and structs. While some of these warnings were emitted in the past, they were discovered using syntax analysis. The new warnings are more reliable, precise, and with better error messages. Keep in mind, however, that the Elixir typechecker only infers types from patterns within the same function at the moment. Analysis from guards and across function boundaries will be added in future relases. For more details, see our new [reference document on gradual set-theoretic types](https://hexdocs.pm/elixir/gradual-set-theoretic-types.html).\n\nThe type system was made possible thanks to a partnership between [CNRS](https://www.cnrs.fr/) and [Remote](https://remote.com/). The development work is currently sponsored by [Fresha](https://www.fresha.com/), [Starfish*](https://starfish.team/), and [Dashbit](https://dashbit.co/).","ref":"changelog.html#warnings-from-gradual-set-theoretic-types"},{"type":"extras","title":"Erlang/OTP support - Changelog for Elixir v1.17","doc":"This release adds support for Erlang/OTP 27 and drops support for Erlang/OTP 24. We recommend Elixir developers to migrate to Erlang/OTP 26 or later, especially on Windows. Support for WERL (a graphical user interface for the Erlang terminal on Windows) will be removed in Elixir v1.18.","ref":"changelog.html#erlang-otp-support"},{"type":"extras","title":"Adding `Duration` and `shift/2` functions - Changelog for Elixir v1.17","doc":"Elixir introduces the `Duration` data type and APIs to shift dates, times, and date times by a given duration, considering different calendars and time zones.\n\n```elixir\niex> Date.shift(~D[2016-01-31], month: 2)\n~D[2016-03-31]\n```\n\nNote the operation is called `shift` (instead of `add`) since working with durations does not obey properties such as associativity. For instance, adding one month and then one month does not give the same result as adding two months:\n\n```elixir\niex> ~D[2016-01-31] |> Date.shift(month: 1) |> Date.shift(month: 1)\n~D[2016-03-29]\n```\n\nStill, durations are essential for building intervals, recurring events, and modelling scheduling complexities found in the world around us. For `DateTime`s, Elixir will correctly deal with time zone changes (such as Daylight Saving Time), but provisions are also available in case you want to surface conflicts (for example, you shifted to a wall clock that does not exist, because the clock has been moved forward by one hour). See `DateTime.shift/2` for examples.\n\nFinally, a new `Kernel.to_timeout/1` function has been added, which helps developers normalize durations and integers to a timeout used by Process APIs. For example, to send a message after one hour, one can now write:\n\n```elixir\nProcess.send_after(pid, :wake_up, to_timeout(hour: 1))\n```","ref":"changelog.html#adding-duration-and-shift-2-functions"},{"type":"extras","title":"v1.17.3 (2024-09-18) - Changelog for Elixir v1.17","doc":"","ref":"changelog.html#v1-17-3-2024-09-18"},{"type":"extras","title":"1. Bug fixes - Changelog for Elixir v1.17","doc":"#### Elixir\n\n  * [Duration] Fix parsing of fractional durations with non-positive seconds\n  * [Kernel] Do not attempt to group module warnings when they have a large context\n\n#### IEx\n\n  * [IEx.Helpers] Properly reconsolidate protocols on `recompile`\n\n#### Mix\n\n  * [mix compile.elixir] Do not verify modules twice\n  * [mix xref] Respect the `--label` option on stats and cycles","ref":"changelog.html#1-bug-fixes"},{"type":"extras","title":"v1.17.2 (2024-07-06) - Changelog for Elixir v1.17","doc":"","ref":"changelog.html#v1-17-2-2024-07-06"},{"type":"extras","title":"1. Bug fixes - Changelog for Elixir v1.17","doc":"#### Logger\n\n  * [Logger.Translator] Fix logger crash when `:gen_statem`'s `format_status/2` returns non-tuple\n\n#### Mix\n\n  * [mix deps.get] Fix regression when fetching a git repository with a `:ref`\n  * [mix release] Validate `RELEASE_MODE` and set ERRORLEVEL on `.bat` scripts\n  * [mix release] Fix invalid example in code comment inside the generated vm.args.eex","ref":"changelog.html#1-bug-fixes"},{"type":"extras","title":"v1.17.1 (2024-06-18) - Changelog for Elixir v1.17","doc":"","ref":"changelog.html#v1-17-1-2024-06-18"},{"type":"extras","title":"1. Enhancements - Changelog for Elixir v1.17","doc":"#### Mix\n\n  * [mix compile.elixir] Do not run fixpoint computation on runtime dependencies. This should considerably improve compilation times for large projects when changing only one or two files","ref":"changelog.html#1-enhancements"},{"type":"extras","title":"2. Bug fixes - Changelog for Elixir v1.17","doc":"#### EEx\n\n  * [EEx] Do not warn for assignment with blocks in EEx\n\n#### Elixir\n\n  * [Kernel] Fix bug when using pinned variables inside `with`'s `else` patterns\n  * [Kernel] Fix Dialyzer error when with else clause is calling a `no_return` function\n\n#### ExUnit\n\n  * [ExUnit] Do not alternative sync/async suites on `--repeat-until-failure`","ref":"changelog.html#2-bug-fixes"},{"type":"extras","title":"v1.17.0 (2024-06-12) - Changelog for Elixir v1.17","doc":"","ref":"changelog.html#v1-17-0-2024-06-12"},{"type":"extras","title":"1. Enhancements - Changelog for Elixir v1.17","doc":"#### Elixir\n\n  * [Access] Add `Access.find/1` that mirrors `Enum.find/2`\n  * [Code] Support cursor inside fn/rescue/catch/else/after inside `Code.Fragment.container_cursor_to_quoted/2`\n  * [Date] Add `Date.shift/2` to shift dates with duration and calendar-specific semantics\n  * [Date] Allow `Date` to accept years outside of `-9999..9999` range\n  * [DateTime] Add `DateTime.shift/2` to shift datetimes with duration and calendar-specific semantics\n  * [Duration] Add a new `Duration` data type\n  * [GenServer] Add `c:GenServer.format_status/1` callback\n  * [Kernel] Add `Kernel.get_in/1` with safe nil-handling for access and structs\n  * [Kernel] Add `Kernel.is_non_struct_map/1` guard\n  * [Kernel] Add `Kernel.to_timeout/1`\n  * [Kernel] Emit warnings for undefined functions from modules defined within the same context as the caller code\n  * [Kernel] Support integers in uppercase sigils\n  * [Keyword] Add `Keyword.intersect/2-3` to mirror the `Map` API\n  * [Macro] Add `Macro.Env.define_alias/4`, `Macro.Env.define_import/4`, `Macro.Env.define_require/4`, `Macro.Env.expand_alias/4`, `Macro.Env.expand_import/5`, and `Macro.Env.expand_require/6` to aid the implementation of language servers and embedded languages\n  * [NaiveDateTime] Add `NaiveDateTime.shift/2` to shift naive datetimes with duration and calendar-specific semantics\n  * [Process] Add `Process.set_label/1`\n  * [String] Add `String.byte_slice/3` to slice a string to a maximum number of bytes while keeping it UTF-8 encoded\n  * [System] Support `use_stdio: false` in `System.cmd/3` and `System.shell/2`\n  * [Time] Add `Time.shift/2` to shift times with duration and calendar-specific semantics\n\n#### ExUnit\n\n  * [ExUnit] Propagate the test process itself as a caller in `start_supervised`\n  * [ExUnit] Include max cases in ExUnit reports\n\n#### IEx\n\n  * [IEx.Helpers] Warns if `recompile` was called and the current working directory changed\n  * [IEx.Helpers] Add `c/0` as an alias to `continue/0`\n  * [IEx.Pry] Add `IEx.Pry.annotate_quoted/3` to annotate a quoted expression with pry breakpoints\n\n#### Logger\n\n  * [Logger] Format `:gen_statem` reports using Elixir data structures\n  * [Logger] Include process label in logger events\n\n#### Mix\n\n  * [mix deps] Add `:depth` option to `Mix.SCM.Git`, thus supporting shallow clones of Git dependencies\n  * [mix deps] Warn if `:optional` is used in combination with `:in_umbrella`\n  * [mix deps.get] Do not add optional dependency requirements if its parent dep was skipped\n  * [mix deps.tree] Add `--umbrella-only` to `mix deps.tree`\n  * [mix profile.tprof] Add a new profiler, available on Erlang/OTP 27+, which can measure count, time, and heap usage\n  * [mix test] Add `mix test --breakpoints` that sets up a breakpoint before each test that will run\n  * [mix test] Add `mix test --repeat-until-failure` to rerun tests until a failure occurs\n  * [mix test] Add `mix test --slowest-modules` to print slowest modules based on all of the tests they hold\n  * [mix test] Generate cover HTML files in parallel","ref":"changelog.html#1-enhancements"},{"type":"extras","title":"2. Bug fixes - Changelog for Elixir v1.17","doc":"#### Elixir\n\n  * [bin/elixir.bat] Improve handling of quotes and exclamation marks in flags\n  * [Code] Address a bug where AST nodes for `(a -> b)` were not wrapped as part of the literal encoder\n  * [Kernel] Resolve inconsistencies of how `..` and `...` are handled at the AST level\n  * [Kernel] Fix parsing precedence of ambiguous operators followed by containers\n  * [Kernel] Do not expand code in `quote bind_quoted: ...` twice\n  * [Kernel] Respect `:line` property when `:file` is given as option to `quote`\n  * [Kernel] Do not crash on `Macro.escape/2` when passing a quote triplet without valid meta\n  * [Kernel] Avoid double tracing events when capturing a function\n  * [Kernel] Fix a bug where captured arguments would conflict when a capture included a macro that also used captures\n  * [Module] Return default value in `Module.get_attribute/3` for persisted attributes which have not yet been written to\n  * [String] Properly handle transpositions in `jaro_distance`. This will correct the distance result in certain cases\n\n#### IEx\n\n  * [IEx.Helpers] Update the history size whenever history is pruned\n\n#### Mix\n\n  * [mix deps] Fix error message for diverged SCM definition in sibling","ref":"changelog.html#2-bug-fixes"},{"type":"extras","title":"3. Soft deprecations (no warnings emitted) - Changelog for Elixir v1.17","doc":"#### Elixir\n\n  * [GenServer] Deprecate `c:GenServer.format_status/2` callback to align with Erlang/OTP 25+\n\n#### Mix\n\n  * [mix profile.cprof] Deprecated in favor of the new `mix profile.tprof`\n  * [mix profile.eprof] Deprecated in favor of the new `mix profile.tprof`","ref":"changelog.html#3-soft-deprecations-no-warnings-emitted"},{"type":"extras","title":"4. Hard deprecations - Changelog for Elixir v1.17","doc":"#### Elixir\n\n  * [IO] Passing `:all` to `IO.read/2` and `IO.binread/2` is deprecated, pass `:eof` instead\n  * [Kernel] Single-quote charlists are deprecated, use `~c` instead\n  * [Kernel] Deprecate escaping closing delimiter in uppercase sigils\n  * [Range] `left..right` without explicit steps inside patterns and guards is deprecated, write `left..right//step` instead\n  * [Range] Decreasing ranges, such as `10..1` without an explicit step is deprecated, write `10..1//-1` instead\n\n#### ExUnit\n\n  * [ExUnit.Case] `register_test/4` is deprecated in favor of `register_test/6` for performance reasons","ref":"changelog.html#4-hard-deprecations"},{"type":"extras","title":"v1.16 - Changelog for Elixir v1.17","doc":"The CHANGELOG for v1.16 releases can be found [in the v1.16 branch](https://github.com/elixir-lang/elixir/blob/v1.16/CHANGELOG.md).","ref":"changelog.html#v1-16"},{"type":"extras","title":"Introduction","doc":"# Introduction\n\nWelcome!\n\nThis guide will teach you about Elixir fundamentals - the language syntax, how to define modules, the common data structures in the language, and more. This chapter will focus on ensuring that Elixir is installed and that you can successfully run Elixir's Interactive Shell, called IEx.\n\nLet's get started.","ref":"introduction.html"},{"type":"extras","title":"Installation - Introduction","doc":"If you haven't yet installed Elixir, visit our [installation page](https://elixir-lang.org/install.html). Once you are done, you can run `elixir --version` to get the current Elixir version. The requirements for this guide are:\n\n  * Elixir 1.15.0 onwards\n  * Erlang/OTP 26 onwards\n\nIf you are looking for other resources for learning Elixir, you can also consult the [learning page](https://elixir-lang.org/learning.html) of the official website.","ref":"introduction.html#installation"},{"type":"extras","title":"Interactive mode - Introduction","doc":"When you install Elixir, you will have three new command line executables: `iex`, `elixir` and `elixirc`.\n\nFor now, let's start by running `iex` (or `iex.bat` if you are on Windows PowerShell, where `iex` is a PowerShell command) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let's warm up with some basic expressions.\n\nOpen up `iex` and type the following expressions:\n\n```elixir\nErlang/OTP 26 [64-bit] [smp:2:2] [...]\n\nInteractive Elixir - press Ctrl+C to exit\niex(1)> 40 + 2\n42\niex(2)> \"hello\" <> \" world\"\n\"hello world\"\n```\n\nPlease note that some details like version numbers may differ a bit in your session, that's not important. By executing the code above, you should evaluate expressions and see their results. To exit `iex` press `Ctrl+C` twice.\n\nIt seems we are ready to go! We will use the interactive shell quite a lot in the next chapters to get a bit more familiar with the language constructs and basic types, starting in the next chapter.\n\n> Note: if you are on Windows and running on an Erlang/OTP version earlier than 26, you can also try `iex --werl` (`iex.bat --werl` on PowerShell) which may provide a better experience depending on which console you are using.","ref":"introduction.html#interactive-mode"},{"type":"extras","title":"Running scripts - Introduction","doc":"After getting familiar with the basics of the language you may want to try writing simple programs. This can be accomplished by putting the following Elixir code into a file:\n\n```elixir\nIO.puts(\"Hello world from Elixir\")\n```\n\nSave it as `simple.exs` and execute it with `elixir`:\n\n```console\n$ elixir simple.exs\nHello world from Elixir\n```\n\nLater on we will learn [how to compile Elixir code](modules-and-functions.md) and how to create and work within Elixir projects using the Mix build tool. For now, let's move on to learn the basic data types in the language.","ref":"introduction.html#running-scripts"},{"type":"extras","title":"Basic types","doc":"# Basic types\n\nIn this chapter we will learn more about Elixir basic types: integers, floats, booleans, atoms, and strings. Other data types, such as lists and tuples, will be explored in the next chapter.\n\n```live-elixir\niex> 1          # integer\niex> 0x1F       # integer\niex> 1.0        # float\niex> true       # boolean\niex> :atom      # atom / symbol\niex> \"elixir\"   # string\niex> [1, 2, 3]  # list\niex> {1, 2, 3}  # tuple\n```","ref":"basic-types.html"},{"type":"extras","title":"Basic arithmetic - Basic types","doc":"Open up `iex` and type the following expressions:\n\n```live-elixir\niex> 1 + 2\n3\niex> 5 * 5\n25\niex> 10 / 2\n5.0\n```\n\nNotice that `10 / 2` returned a float `5.0` instead of an integer `5`. This is expected. In Elixir, the operator `/` always returns a float. If you want to do integer division or get the division remainder, you can invoke the `div` and `rem` functions:\n\n```live-elixir\niex> div(10, 2)\n5\niex> div 10, 2\n5\niex> rem 10, 3\n1\n```\n\nNotice that Elixir allows you to drop the parentheses when invoking functions that expect one or more arguments. This feature gives a cleaner syntax when writing declarations and control-flow constructs. However, Elixir developers generally prefer to use parentheses.\n\nElixir also supports shortcut notations for entering binary, octal, and hexadecimal numbers:\n\n```live-elixir\niex> 0b1010\n10\niex> 0o777\n511\niex> 0x1F\n31\n```\n\nFloat numbers require a dot followed by at least one digit and also support `e` for scientific notation:\n\n```live-elixir\niex> 1.0\n1.0\niex> 1.0e-10\n1.0e-10\n```\n\nFloats in Elixir are 64-bit precision.\n\nYou can invoke the `round` function to get the closest integer to a given float, or the `trunc` function to get the integer part of a float.\n\n```live-elixir\niex> round(3.58)\n4\niex> trunc(3.58)\n3\n```\n\nFinally, we work with different data types, we will learn Elixir provides several predicate functions to check for the type of a value. For example, the `is_integer` can be used to check if a value is an integer or not:\n\n```live-elixir\niex> is_integer(1)\ntrue\niex> is_integer(2.0)\nfalse\n```\n\nYou can also use `is_float` or `is_number` to check, respectively, if an argument is a float, or either an integer or float.","ref":"basic-types.html#basic-arithmetic"},{"type":"extras","title":"Identifying functions and documentation - Basic types","doc":"Before we move on to the next data type, let's talk about how Elixir identifies functions.\n\nFunctions in Elixir are identified by both their name and their arity. The arity of a function describes the number of arguments that the function takes. From this point on we will use both the function name and its arity to describe functions throughout the documentation. `trunc/1` identifies the function which is named `trunc` and takes `1` argument, whereas `trunc/2` identifies a different (nonexistent) function with the same name but with an arity of `2`.\n\nWe can also use this syntax to access documentation. The Elixir shell defines the `h` function, which you can use to access documentation for any function. For example, typing `h trunc/1` is going to print the documentation for the `trunc/1` function:\n\n```elixir\niex> h trunc/1\n                             def trunc()\n\nReturns the integer part of number.\n```\n\n`h trunc/1` works because it is defined in the `Kernel` module. All functions in the `Kernel` module are automatically imported into our namespace. Most often you will also include the module name when looking up the documentation for a given function:\n\n```elixir\niex> h Kernel.trunc/1\n                             def trunc()\n\nReturns the integer part of number.\n```\n\nYou can use the module+function to lookup for anything, including operators (try `h Kernel.+/2`). Invoking `h` without arguments displays the documentation for `IEx.Helpers`, which is where `h` and other functionality is defined.","ref":"basic-types.html#identifying-functions-and-documentation"},{"type":"extras","title":"Booleans and `nil` - Basic types","doc":"Elixir supports `true` and `false` as booleans:\n\n```live-elixir\niex> true\ntrue\niex> true == false\nfalse\n```\n\nElixir also provides three boolean operators: `or/2`, `and/2`, and `not/1`. These operators are strict in the sense that they expect something that evaluates to a boolean (`true` or `false`) as their first argument:\n\n```live-elixir\niex> true and true\ntrue\niex> false or is_boolean(true)\ntrue\n```\n\nProviding a non-boolean will raise an exception:\n\n```live-elixir\niex> 1 and true\n** (BadBooleanError) expected a boolean on left-side of \"and\", got: 1\n```\n\n`or` and `and` are short-circuit operators. They only execute the right side if the left side is not enough to determine the result:\n\n```live-elixir\niex> false and raise(\"This error will never be raised\")\nfalse\niex> true or raise(\"This error will never be raised\")\ntrue\n```\n\nElixir also provides the concept of `nil`, to indicate the absence of a value, and a set of logical operators that also manipulate `nil`: `||/2`, `&&/2`, and `!/1`. For these operators, `false` and `nil` are considered \"falsy\", all other values are considered \"truthy\":\n\n```live-elixir\n# or\niex> 1 || true\n1\niex> false || 11\n11\n\n# and\niex> nil && 13\nnil\niex> true && 17\n17\n\n# not\niex> !true\nfalse\niex> !1\nfalse\niex> !nil\ntrue\n```\n\nSimilarly, values like `0` and `\"\"`, which some other programming languages consider to be \"falsy\", are also \"truthy\" in Elixir.","ref":"basic-types.html#booleans-and-nil"},{"type":"extras","title":"Atoms - Basic types","doc":"An atom is a constant whose value is its own name. Some other languages call these symbols. They are often useful to enumerate over distinct values, such as:\n\n```live-elixir\niex> :apple\n:apple\niex> :orange\n:orange\niex> :watermelon\n:watermelon\n```\n\nAtoms are equal if their names are equal.\n\n```live-elixir\niex> :apple == :apple\ntrue\niex> :apple == :orange\nfalse\n```\n\nOften they are used to express the state of an operation, by using values such as `:ok` and `:error`.\n\nThe booleans `true` and `false` are also atoms:\n\n```live-elixir\niex> true == :true\ntrue\niex> is_atom(false)\ntrue\niex> is_boolean(:false)\ntrue\n```\n\nElixir allows you to skip the leading `:` for the atoms `false`, `true` and `nil`.","ref":"basic-types.html#atoms"},{"type":"extras","title":"Strings - Basic types","doc":"Strings in Elixir are delimited by double quotes, and they are encoded in UTF-8:\n\n```live-elixir\niex> \"hellö\"\n\"hellö\"\n```\n\n> Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running `chcp 65001` before entering IEx.\n\nYou can concatenate two strings with the `<>/2` operator:\n\n```live-elixir\niex> \"hello \" <> \"world!\"\n\"hello world!\"\n```\n\nElixir also supports string interpolation:\n\n```live-elixir\niex> string = \"world\"\niex> \"hello #{string}!\"\n\"hello world!\"\n```\n\nString concatenation requires both sides to be strings but interpolation supports any data type that may be converted to a string:\n\n```live-elixir\niex> number = 42\niex> \"i am #{number} years old!\"\n\"i am 42 years old!\"\n```\n\nStrings can have line breaks in them. You can introduce them using escape sequences:\n\n```live-elixir\niex> \"hello\n...> world\"\n\"hello\\nworld\"\niex> \"hello\\nworld\"\n\"hello\\nworld\"\n```\n\nYou can print a string using the `IO.puts/1` function from the `IO` module:\n\n```live-elixir\niex> IO.puts(\"hello\\nworld\")\nhello\nworld\n:ok\n```\n\nNotice that the `IO.puts/1` function returns the atom `:ok` after printing.\n\nStrings in Elixir are represented internally by contiguous sequences of bytes known as binaries:\n\n```live-elixir\niex> is_binary(\"hellö\")\ntrue\n```\n\nWe can also get the number of bytes in a string:\n\n```live-elixir\niex> byte_size(\"hellö\")\n6\n```\n\nNotice that the number of bytes in that string is 6, even though it has 5 graphemes. That's because the grapheme \"ö\" takes 2 bytes to be represented in UTF-8. We can get the actual length of the string, based on the number of graphemes, by using the `String.length/1` function:\n\n```live-elixir\niex> String.length(\"hellö\")\n5\n```\n\nThe `String` module contains a bunch of functions that operate on strings as defined in the Unicode standard:\n\n```live-elixir\niex> String.upcase(\"hellö\")\n\"HELLÖ\"\n```","ref":"basic-types.html#strings"},{"type":"extras","title":"Structural comparison - Basic types","doc":"Elixir also provides `==`, `!=`, `<=`, `>=`, `<` and `>` as comparison operators. We can compare numbers:\n\n```live-elixir\niex> 1 == 1\ntrue\niex> 1 != 2\ntrue\niex> 1 < 2\ntrue\n```\n\nBut also atoms, strings, booleans, etc:\n\n```live-elixir\niex> \"foo\" == \"foo\"\ntrue\niex> \"foo\" == \"bar\"\nfalse\n```\n\nIntegers and floats compare the same if they have the same value:\n\n```live-elixir\niex> 1 == 1.0\ntrue\niex> 1 == 2.0\nfalse\n```\n\nHowever, you can use the strict comparison operator `===` and `!==` if you want to distinguish between integers and floats (that's the only difference between these operators):\n\n```live-elixir\niex> 1 === 1.0\nfalse\n```\n\nThe comparison operators in Elixir can compare across any data type. We say these operators perform _structural comparison_. For more information, you can read our documentation on [Structural vs Semantic comparisons](`Kernel#module-structural-comparison`).\n\nElixir also provides data-types for expressing collections, such as lists and tuples, which we learn next. When we talk about concurrency and fault-tolerance via processes, we will also discuss ports, pids, and references, but that will come on later chapters. Let's move forward.","ref":"basic-types.html#structural-comparison"},{"type":"extras","title":"Lists and tuples","doc":"# Lists and tuples\n\nIn this chapter we will learn two of the most used collection data-types in Elixir: lists and tuples.\n\n## (Linked) Lists\n\nElixir uses square brackets to specify a list of values. Values can be of any type:\n\n```live-elixir\niex> [1, 2, true, 3]\n[1, 2, true, 3]\niex> length([1, 2, 3])\n3\n```\n\nTwo lists can be concatenated or subtracted using the `++/2` and `--/2` operators respectively:\n\n```live-elixir\niex> [1, 2, 3] ++ [4, 5, 6]\n[1, 2, 3, 4, 5, 6]\niex> [1, true, 2, false, 3, true] -- [true, false]\n[1, 2, 3, true]\n```\n\nList operators never modify the existing list. Concatenating to or removing elements from a list returns a new list. We say that Elixir data structures are _immutable_. One advantage of immutability is that it leads to clearer code. You can freely pass the data around with the guarantee no one will mutate it in memory - only transform it.\n\nThroughout the tutorial, we will talk a lot about the head and tail of a list. The head is the first element of a list and the tail is the remainder of the list. They can be retrieved with the functions `hd/1` and `tl/1`. Let's assign a list to a variable and retrieve its head and tail:\n\n```live-elixir\niex> list = [1, 2, 3]\niex> hd(list)\n1\niex> tl(list)\n[2, 3]\n```\n\nGetting the head or the tail of an empty list throws an error:\n\n```live-elixir\niex> hd([])\n** (ArgumentError) argument error\n```\n\nSometimes you will create a list and it will return a quoted value preceded by `~c`. For example:\n\n```live-elixir\niex> [11, 12, 13]\n~c\"\\v\\f\\r\"\niex> [104, 101, 108, 108, 111]\n~c\"hello\"\n```\n\nWhen Elixir sees a list of printable ASCII numbers, Elixir will print that as a charlist (literally a list of characters). Charlists are quite common when interfacing with existing Erlang code. Whenever you see a value in IEx and you are not quite sure what it is, you can use the `i/1` to retrieve information about it:\n\n```elixir\niex> i ~c\"hello\"\nTerm\n  i ~c\"hello\"\nData type\n  List\nDescription\n  ...\nRaw representation\n  [104, 101, 108, 108, 111]\nReference modules\n  List\nImplemented protocols\n  ...\n```\n\nWe will talk more about charlists in the [\"Binaries, strings, and charlists\"](binaries-strings-and-charlists.md) chapter.\n\n> #### Single-quoted strings {: .info}\n>\n> In Elixir, you can also use `'hello'` to build charlists, but this notation has been soft-deprecated in Elixir v1.15 and will emit warnings in future versions. Prefer to write `~c\"hello\"` instead.","ref":"lists-and-tuples.html"},{"type":"extras","title":"Tuples - Lists and tuples","doc":"Elixir uses curly brackets to define tuples. Like lists, tuples can hold any value:\n\n```live-elixir\niex> {:ok, \"hello\"}\n{:ok, \"hello\"}\niex> tuple_size({:ok, \"hello\"})\n2\n```\n\nTuples store elements contiguously in memory. This means accessing a tuple element by index or getting the tuple size is a fast operation. Indexes start from zero:\n\n```live-elixir\niex> tuple = {:ok, \"hello\"}\n{:ok, \"hello\"}\niex> elem(tuple, 1)\n\"hello\"\niex> tuple_size(tuple)\n2\n```\n\nIt is also possible to put an element at a particular index in a tuple with `put_elem/3`:\n\n```live-elixir\niex> tuple = {:ok, \"hello\"}\n{:ok, \"hello\"}\niex> put_elem(tuple, 1, \"world\")\n{:ok, \"world\"}\niex> tuple\n{:ok, \"hello\"}\n```\n\nNotice that `put_elem/3` returned a new tuple. The original tuple stored in the `tuple` variable was not modified. Like lists, tuples are also immutable. Every operation on a tuple returns a new tuple, it never changes the given one.","ref":"lists-and-tuples.html#tuples"},{"type":"extras","title":"Lists or tuples? - Lists and tuples","doc":"What is the difference between lists and tuples?\n\nLists are stored in memory as linked lists, meaning that each element in a list holds its value and points to the following element until the end of the list is reached. This means accessing the length of a list is a linear operation: we need to traverse the whole list in order to figure out its size.\n\nSimilarly, the performance of list concatenation depends on the length of the left-hand list:\n\n```live-elixir\niex> list = [1, 2, 3]\n[1, 2, 3]\n\n# This is fast as we only need to traverse `[0]` to prepend to `list`\niex> [0] ++ list\n[0, 1, 2, 3]\n\n# This is slow as we need to traverse `list` to append 4\niex> list ++ [4]\n[1, 2, 3, 4]\n```\n\nTuples, on the other hand, are stored contiguously in memory. This means getting the tuple size or accessing an element by index is fast. On the other hand, updating or adding elements to tuples is expensive because it requires creating a new tuple in memory:\n\n```live-elixir\niex> tuple = {:a, :b, :c, :d}\n{:a, :b, :c, :d}\niex> put_elem(tuple, 2, :e)\n{:a, :b, :e, :d}\n```\n\nNote, however, the elements themselves are not copied. When you update a tuple, all entries are shared between the old and the new tuple, except for the entry that has been replaced. This rule applies to most data structures in Elixir. This reduces the amount of memory allocation the language needs to perform and is only possible thanks to the immutable semantics of the language.\n\nThose performance characteristics dictate the usage of those data structures. In a nutshell, lists are used when the number of elements returned may vary. Tuples have a fixed size. Let's see two examples from the `String` module:\n\n```live-elixir\niex> String.split(\"hello world\")\n[\"hello\", \"world\"]\niex> String.split(\"hello beautiful world\")\n[\"hello\", \"beautiful\", \"world\"]\n```\n\nThe `String.split/1` function breaks a string into a list of strings on every whitespace character. Since the amount of elements returned depends on the input, we use a list.\n\nOn the other hand, `String.split_at/2` splits a string in two parts at a given position. Since it always returns two entries, regardless of the input size, it returns tuples:\n\n```live-elixir\niex> String.split_at(\"hello world\", 3)\n{\"hel\", \"lo world\"}\niex> String.split_at(\"hello world\", -4)\n{\"hello w\", \"orld\"}\n```\n\nIt is also very common to use tuples and atoms to create \"tagged tuples\", which is a handy return value when an operation may succeed or fail. For example, `File.read/1` reads the contents of a file at a given path, which may or may not exist. It returns tagged tuples:\n\n```elixir\niex> File.read(\"path/to/existing/file\")\n{:ok, \"... contents ...\"}\niex> File.read(\"path/to/unknown/file\")\n{:error, :enoent}\n```\n\nIf the path given to `File.read/1` exists, it returns a tuple with the atom `:ok` as the first element and the file contents as the second. Otherwise, it returns a tuple with `:error` and the error description. As we will soon learn, Elixir allows us to _pattern match_ on tagged tuples and effortlessly handle both success and failure cases.\n\nGiven Elixir consistently follows those rules, the choice between lists and tuples get clearer as you learn and use the language. Elixir often guides you to do the right thing. For example, there is an `elem/2` function to access a tuple item:\n\n```live-elixir\niex> tuple = {:ok, \"hello\"}\n{:ok, \"hello\"}\niex> elem(tuple, 1)\n\"hello\"\n```\n\nHowever, given you often don't know the number of elements in a list, there is no built-in equivalent for accessing arbitrary entries in a lists, apart from its head.","ref":"lists-and-tuples.html#lists-or-tuples"},{"type":"extras","title":"Size or length? - Lists and tuples","doc":"When counting the elements in a data structure, Elixir also abides by a simple rule: the function is named `size` if the operation is in constant time (the value is pre-calculated) or `length` if the operation is linear (calculating the length gets slower as the input grows). As a mnemonic, both \"length\" and \"linear\" start with \"l\".\n\nFor example, we have used 4 counting functions so far: `byte_size/1` (for the number of bytes in a string), `tuple_size/1` (for tuple size), `length/1` (for list length) and `String.length/1` (for the number of graphemes in a string). We use `byte_size` to get the number of bytes in a string, which is a cheap operation. Retrieving the number of Unicode graphemes, on the other hand, uses `String.length/1`, and may be expensive as it relies on a traversal of the entire string.\n\nNow that we are familiar with the basic data-types in the language, let's learn important constructs for writing code, before we discuss more complex data structures.","ref":"lists-and-tuples.html#size-or-length"},{"type":"extras","title":"Pattern matching","doc":"# Pattern matching\n\nIn this chapter, we will learn why the `=` operator in Elixir is called the match operator and how to use it to pattern match inside data structures. We will learn about the pin operator `^` used to access previously bound values.","ref":"pattern-matching.html"},{"type":"extras","title":"The match operator - Pattern matching","doc":"We have used the `=` operator a couple times to assign variables in Elixir:\n\n```live-elixir\niex> x = 1\n1\niex> x\n1\n```\n\nIn Elixir, the `=` operator is actually called _the match operator_. Let's see why:\n\n```live-elixir\niex> x = 1\n1\niex> 1 = x\n1\niex> 2 = x\n** (MatchError) no match of right hand side value: 1\n```\n\nNotice that `1 = x` is a valid expression, and it matched because both the left and right side are equal to 1. When the sides do not match, a `MatchError` is raised.\n\nA variable can only be assigned on the left side of `=`:\n\n```live-elixir\niex> 1 = unknown\n** (CompileError) iex:1: undefined variable \"unknown\"\n```","ref":"pattern-matching.html#the-match-operator"},{"type":"extras","title":"Pattern matching - Pattern matching","doc":"The match operator is not only used to match against simple values, but it is also useful for destructuring more complex data types. For example, we can pattern match on tuples:\n\n```live-elixir\niex> {a, b, c} = {:hello, \"world\", 42}\n{:hello, \"world\", 42}\niex> a\n:hello\niex> b\n\"world\"\n```\n\nA pattern match error will occur if the sides can't be matched, for example if the tuples have different sizes:\n\n```live-elixir\niex> {a, b, c} = {:hello, \"world\"}\n** (MatchError) no match of right hand side value: {:hello, \"world\"}\n```\n\nAnd also when comparing different types, for example if matching a tuple on the left side with a list on the right side:\n\n```live-elixir\niex> {a, b, c} = [:hello, \"world\", 42]\n** (MatchError) no match of right hand side value: [:hello, \"world\", 42]\n```\n\nMore interestingly, we can match on specific values. The example below asserts that the left side will only match the right side when the right side is a tuple that starts with the atom `:ok`:\n\n```live-elixir\niex> {:ok, result} = {:ok, 13}\n{:ok, 13}\niex> result\n13\n\niex> {:ok, result} = {:error, :oops}\n** (MatchError) no match of right hand side value: {:error, :oops}\n```\n\nWe can pattern match on lists:\n\n```live-elixir\niex> [a, b, c] = [1, 2, 3]\n[1, 2, 3]\niex> a\n1\n```\n\nA list also supports matching on its own head and tail:\n\n```live-elixir\niex> [head | tail] = [1, 2, 3]\n[1, 2, 3]\niex> head\n1\niex> tail\n[2, 3]\n```\n\nSimilar to the `hd/1` and `tl/1` functions, we can't match an empty list with a head and tail pattern:\n\n```live-elixir\niex> [head | tail] = []\n** (MatchError) no match of right hand side value: []\n```\n\nThe `[head | tail]` format is not only used on pattern matching but also for prepending items to a list:\n\n```live-elixir\niex> list = [1, 2, 3]\n[1, 2, 3]\niex> [0 | list]\n[0, 1, 2, 3]\n```\n\nPattern matching allows developers to easily destructure data types such as tuples and lists. As we will see in the following chapters, it is one of the foundations of recursion in Elixir and applies to other types as well, like maps and binaries.","ref":"pattern-matching.html#pattern-matching"},{"type":"extras","title":"The pin operator - Pattern matching","doc":"Variables in Elixir can be rebound:\n\n```live-elixir\niex> x = 1\n1\niex> x = 2\n2\n```\n\nHowever, there are times when we don't want variables to be rebound.\n\nUse the pin operator `^` when you want to pattern match against a variable's _existing value_ rather than rebinding the variable.\n\n```live-elixir\niex> x = 1\n1\niex> ^x = 2\n** (MatchError) no match of right hand side value: 2\n```\n\nBecause we have pinned `x` when it was bound to the value of `1`, it is equivalent to the following:\n\n```live-elixir\niex> 1 = 2\n** (MatchError) no match of right hand side value: 2\n```\n\nNotice that we even see the exact same error message.\n\nWe can use the pin operator inside other pattern matches, such as tuples or lists:\n\n```live-elixir\niex> x = 1\n1\niex> [^x, 2, 3] = [1, 2, 3]\n[1, 2, 3]\niex> {y, ^x} = {2, 1}\n{2, 1}\niex> y\n2\niex> {y, ^x} = {2, 2}\n** (MatchError) no match of right hand side value: {2, 2}\n```\n\nBecause `x` was bound to the value of `1` when it was pinned, this last example could have been written as:\n\n```live-elixir\niex> {y, 1} = {2, 2}\n** (MatchError) no match of right hand side value: {2, 2}\n```\n\nIf a variable is mentioned more than once in a pattern, all references must bind to the same value:\n\n```live-elixir\niex> {x, x} = {1, 1}\n{1, 1}\niex> {x, x} = {1, 2}\n** (MatchError) no match of right hand side value: {1, 2}\n```\n\nIn some cases, you don't care about a particular value in a pattern. It is a common practice to bind those values to the underscore, `_`. For example, if only the head of the list matters to us, we can assign the tail to underscore:\n\n```live-elixir\niex> [head | _] = [1, 2, 3]\n[1, 2, 3]\niex> head\n1\n```\n\nThe variable `_` is special in that it can never be read from. Trying to read from it gives a compile error:\n\n```live-elixir\niex> _\n** (CompileError) iex:1: invalid use of _. \"_\" represents a value to be ignored in a pattern and cannot be used in expressions\n```\n\nAlthough pattern matching allows us to build powerful constructs, its usage is limited. For instance, you cannot make function calls on the left side of a match. The following example is invalid:\n\n```live-elixir\niex> length([1, [2], 3]) = 3\n** (CompileError) iex:1: cannot invoke remote function :erlang.length/1 inside match\n```\n\nThis finishes our introduction to pattern matching. As we will see in the next chapter, pattern matching is very common in many language constructs and they can be further augmented with guards.","ref":"pattern-matching.html#the-pin-operator"},{"type":"extras","title":"case, cond, and if","doc":"# case, cond, and if\n\nIn this chapter, we will learn about the `case`, `cond`, and `if` control flow structures.","ref":"case-cond-and-if.html"},{"type":"extras","title":"case - case, cond, and if","doc":"`case` allows us to compare a value against many patterns until we find a matching one:\n\n```live-elixir\niex> case {1, 2, 3} do\n...>   {4, 5, 6} ->\n...>     \"This clause won't match\"\n...>   {1, x, 3} ->\n...>     \"This clause will match and bind x to 2 in this clause\"\n...>   _ ->\n...>     \"This clause would match any value\"\n...> end\n\"This clause will match and bind x to 2 in this clause\"\n```\n\nIf you want to pattern match against an existing variable, you need to use the `^` operator:\n\n```live-elixir\niex> x = 1\n1\niex> case 10 do\n...>   ^x -> \"Won't match\"\n...>   _ -> \"Will match\"\n...> end\n\"Will match\"\n```\n\nClauses also allow extra conditions to be specified via guards:\n\n```live-elixir\niex> case {1, 2, 3} do\n...>   {1, x, 3} when x > 0 ->\n...>     \"Will match\"\n...>   _ ->\n...>     \"Would match, if guard condition were not satisfied\"\n...> end\n\"Will match\"\n```\n\nThe first clause above will only match when `x` is positive.\n\nKeep in mind errors in guards do not leak but simply make the guard fail:\n\n```live-elixir\niex> hd(1)\n** (ArgumentError) argument error\niex> case 1 do\n...>   x when hd(x) -> \"Won't match\"\n...>   x -> \"Got #{x}\"\n...> end\n\"Got 1\"\n```\n\nIf none of the clauses match, an error is raised:\n\n```live-elixir\niex> case :ok do\n...>   :error -> \"Won't match\"\n...> end\n** (CaseClauseError) no case clause matching: :ok\n```\n\nThe documentation for the `Kernel` module lists all available guards in its sidebar. You can also consult the complete [Patterns and Guards](../references/patterns-and-guards.md#guards) reference for in-depth documentation.","ref":"case-cond-and-if.html#case"},{"type":"extras","title":"if/unless - case, cond, and if","doc":"`case` builds on pattern matching and guards to destructure and match on certain conditions. However, patterns and guards are limited only to certain expressions which are optimized by the compiler. In many situations, you need to write conditions that go beyond what can be expressed with `case`. For those, `if/2` (and `unless/2`) are useful alternatives:\n\n```live-elixir\niex> if true do\n...>   \"This works!\"\n...> end\n\"This works!\"\niex> unless true do\n...>   \"This will never be seen\"\n...> end\nnil\n```\n\nIf the condition given to `if/2` returns `false` or `nil`, the body given between `do`-`end` is not executed and instead it returns `nil`. The opposite happens with `unless/2`.\n\nThey also support `else` blocks (although using `else` with `unless` is generally discouraged):\n\n```live-elixir\niex> if nil do\n...>   \"This won't be seen\"\n...> else\n...>   \"This will\"\n...> end\n\"This will\"\n```\n\nThis is also a good opportunity to talk about variable scoping in Elixir. If any variable is declared or changed inside `if`, `case`, and similar constructs, the declaration and change will only be visible inside the construct. For example:\n\n```live-elixir\niex> x = 1\n1\niex> if true do\n...>   x = x + 1\n...> end\n2\niex> x\n1\n```\n\nIn said cases, if you want to change a value, you must return the value from the `if`:\n\n```live-elixir\niex> x = 1\n1\niex> x = if true do\n...>   x + 1\n...> else\n...>   x\n...> end\n2\n```\n\n> #### `if` and `unless` are macros {: .info}\n>\n> An interesting note regarding `if/2` and `unless/2` is that they are implemented as macros in the language: they aren't special language constructs as they would be in many languages. You can check the documentation and their source for more information.\n\nIf you find yourself nesting several `if/2` blocks, you may want to consider using `cond/1` instead. Let's check it out.","ref":"case-cond-and-if.html#if-unless"},{"type":"extras","title":"cond - case, cond, and if","doc":"If you need to check across several conditions and find the first one that does not evaluate to `nil` or `false`, `cond/1` is a useful construct:\n\n```live-elixir\niex> cond do\n...>   2 + 2 == 5 ->\n...>     \"This will not be true\"\n...>   2 * 2 == 3 ->\n...>     \"Nor this\"\n...>   1 + 1 == 2 ->\n...>     \"But this will\"\n...> end\n\"But this will\"\n```\n\nThis is equivalent to `else if` clauses in many imperative languages - although used less frequently in Elixir.\n\nIf all of the conditions return `nil` or `false`, an error (`CondClauseError`) is raised. For this reason, it may be necessary to add a final condition, equal to `true`, which will always match:\n\n```live-elixir\niex> cond do\n...>   2 + 2 == 5 ->\n...>     \"This is never true\"\n...>   2 * 2 == 3 ->\n...>     \"Nor this\"\n...>   true ->\n...>     \"This is always true (equivalent to else)\"\n...> end\n\"This is always true (equivalent to else)\"\n```\n\nSimilar to `if/2` and `unless/2`, `cond` considers any value besides `nil` and `false` to be true:\n\n```live-elixir\niex> cond do\n...>   hd([1, 2, 3]) ->\n...>     \"1 is considered as true\"\n...> end\n\"1 is considered as true\"\n```","ref":"case-cond-and-if.html#cond"},{"type":"extras","title":"Summing up - case, cond, and if","doc":"We have concluded the introduction to the most fundamental control-flow constructs in Elixir. Generally speaking, Elixir developers prefer pattern matching and guards, using `case` and function definitions (which we will explore in future chapters), as they are succinct and precise. When your logic cannot be outlined within patterns and guards, you may consider `if/2`, falling back to `cond/1` when there are several conditions to check.","ref":"case-cond-and-if.html#summing-up"},{"type":"extras","title":"Anonymous functions","doc":"# Anonymous functions\n\nAnonymous functions allow us to store and pass executable code around as if it was an integer or a string. Let's learn more.","ref":"anonymous-functions.html"},{"type":"extras","title":"Defining anonymous functions - Anonymous functions","doc":"Anonymous functions in Elixir are delimited by the keywords `fn` and `end`:\n\n```live-elixir\niex> add = fn a, b -> a + b end\n#Function<12.71889879/2 in :erl_eval.expr/5>\niex> add.(1, 2)\n3\niex> is_function(add)\ntrue\n```\n\nIn the example above, we defined an anonymous function that receives two arguments, `a` and `b`, and returns the result of `a + b`. The arguments are always on the left-hand side of `->` and the code to be executed on the right-hand side. The anonymous function is stored in the variable `add`.\n\nWe can invoke anonymous functions by passing arguments to it. Note that a dot (`.`) between the variable and parentheses is required to invoke an anonymous function. The dot makes it clear when you are calling an anonymous function, stored in the variable `add`, opposed to a function named `add/2`. For example, if you have an anonymous function stored in the variable `is_atom`, there is no ambiguity between `is_atom.(:foo)` and `is_atom(:foo)`. If both used the same `is_atom(:foo)` syntax, the only way to know the actual behavior of `is_atom(:foo)` would be by scanning all code thus far for a possible definition of the `is_atom` variable. This scanning hurts maintainability as it requires developers to track additional context in their head when reading and writing code.\n\nAnonymous functions in Elixir are also identified by the number of arguments they receive. We can check if a function is of any given arity by using `is_function/2`:\n\n```live-elixir\n# check if add is a function that expects exactly 2 arguments\niex> is_function(add, 2)\ntrue\n# check if add is a function that expects exactly 1 argument\niex> is_function(add, 1)\nfalse\n```","ref":"anonymous-functions.html#defining-anonymous-functions"},{"type":"extras","title":"Closures - Anonymous functions","doc":"Anonymous functions can also access variables that are in scope when the function is defined. This is typically referred to as closures, as they close over their scope. Let's define a new anonymous function that uses the `add` anonymous function we have previously defined:\n\n```live-elixir\niex> double = fn a -> add.(a, a) end\n#Function<6.71889879/1 in :erl_eval.expr/5>\niex> double.(2)\n4\n```\n\nA variable assigned inside a function does not affect its surrounding environment:\n\n```live-elixir\niex> x = 42\n42\niex> (fn -> x = 0 end).()\n0\niex> x\n42\n```","ref":"anonymous-functions.html#closures"},{"type":"extras","title":"Clauses and guards - Anonymous functions","doc":"Similar to `case/2`, we can pattern match on the arguments of anonymous functions as well as define multiple clauses and guards:\n\n```live-elixir\niex> f = fn\n...>   x, y when x > 0 -> x + y\n...>   x, y -> x * y\n...> end\n#Function<12.71889879/2 in :erl_eval.expr/5>\niex> f.(1, 3)\n4\niex> f.(-1, 3)\n-3\n```\n\nThe number of arguments in each anonymous function clause needs to be the same, otherwise an error is raised.\n\n```live-elixir\niex> f2 = fn\n...>   x, y when x > 0 -> x + y\n...>   x, y, z -> x * y + z\n...> end\n** (CompileError) iex:1: cannot mix clauses with different arities in anonymous functions\n```","ref":"anonymous-functions.html#clauses-and-guards"},{"type":"extras","title":"The capture operator - Anonymous functions","doc":"Throughout this guide, we have been using the notation `name/arity` to refer to functions. It happens that this notation can actually be used to capture an existing function into a data-type we can pass around, similar to how anonymous functions behave.\n\n```live-elixir\niex> fun = &is_atom/1\n&:erlang.is_atom/1\niex> is_function(fun)\ntrue\niex> fun.(:hello)\ntrue\niex> fun.(123)\nfalse\n```\n\nAs you can see, once a function is captured, we can pass it as argument or invoke it using the anonymous function notation. The returned value above also hints we can capture functions defined in modules:\n\n```live-elixir\niex> fun = &String.length/1\n&String.length/1\niex> fun.(\"hello\")\n5\n```\n\nYou can also capture operators:\n\n```live-elixir\niex> add = &+/2\n&:erlang.+/2\niex> add.(1, 2)\n3\n```\n\nThe capture syntax can also be used as a shortcut for creating functions. This is handy when you want to create functions that are mostly wrapping existing functions or operators:\n\n```live-elixir\niex> fun = &(&1 + 1)\n#Function<6.71889879/1 in :erl_eval.expr/5>\niex> fun.(1)\n2\n\niex> fun2 = &\"Good #{&1}\"\n#Function<6.127694169/1 in :erl_eval.expr/5>\niex> fun2.(\"morning\")\n\"Good morning\"\n```\n\nThe `&1` represents the first argument passed into the function. `&(&1 + 1)` above is exactly the same as `fn x -> x + 1 end`. You can read more about the capture operator `&` in [its documentation](`&/1`).\n\nNext let's revisit some of the data-types we learned in the past and dig deeper into how they work.","ref":"anonymous-functions.html#the-capture-operator"},{"type":"extras","title":"Binaries, strings, and charlists","doc":"# Binaries, strings, and charlists\n\nIn [\"Basic types\"](basic-types.md), we learned a bit about strings and we used the `is_binary/1` function for checks:\n\n```live-elixir\niex> string = \"hello\"\n\"hello\"\niex> is_binary(string)\ntrue\n```\n\nIn this chapter, we will gain clarity on what exactly binaries are and how they relate to strings. We will also learn about charlists, `~c\"like this\"`, which are often used for interoperability with Erlang.\n\nAlthough strings are one of the most common data types in computer languages, they are subtly complex and are often misunderstood. To understand strings in Elixir, let's first discuss [Unicode](https://en.wikipedia.org/wiki/Unicode) and character encodings, specifically the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) encoding.","ref":"binaries-strings-and-charlists.html"},{"type":"extras","title":"Unicode and Code Points - Binaries, strings, and charlists","doc":"In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The [Unicode Standard](https://unicode.org/standard/standard.html) acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.\n\nUnicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a [Code Point](https://en.wikipedia.org/wiki/Code_point).\n\nIn Elixir you can use a `?` in front of a character literal to reveal its code point:\n\n```live-elixir\niex> ?a\n97\niex> ?ł\n322\n```\n\nNote that most Unicode code charts will refer to a code point by its hexadecimal (hex) representation, e.g. `97` translates to `0061` in hex, and we can represent any Unicode character in an Elixir string by using the `\\uXXXX` notation and the hex representation of its code point number:\n\n```live-elixir\niex> \"\\u0061\" == \"a\"\ntrue\niex> 0x0061 = 97 = ?a\n97\n```\n\nThe hex representation will also help you look up information about a code point, e.g. [https://codepoints.net/U+0061](https://codepoints.net/U+0061) has a data sheet all about the lower case `a`, a.k.a. code point 97.","ref":"binaries-strings-and-charlists.html#unicode-and-code-points"},{"type":"extras","title":"UTF-8 and Encodings - Binaries, strings, and charlists","doc":"Now that we understand what the Unicode standard is and what code points are, we can finally talk about encodings. Whereas the code point is **what** we store, an encoding deals with **how** we store it: encoding is an implementation. In other words, we need a mechanism to convert the code point numbers into bytes so they can be stored in memory, written to disk, etc.\n\nElixir uses UTF-8 to encode its strings, which means that code points are encoded as a series of 8-bit bytes. UTF-8 is a **variable width** character encoding that uses one to four bytes to store each code point. It is capable of encoding all valid Unicode code points. Let's see an example:\n\n```live-elixir\niex> string = \"héllo\"\n\"héllo\"\niex> String.length(string)\n5\niex> byte_size(string)\n6\n```\n\nAlthough the string above has 5 characters, it uses 6 bytes, as two bytes are used to represent the character `é`.\n\n> Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running `chcp 65001` before entering `iex` (`iex.bat`).\n\nBesides defining characters, UTF-8 also provides a notion of graphemes. Graphemes may consist of multiple characters that are often perceived as one. For example, the [woman firefighter emoji](https://emojipedia.org/woman-firefighter/) is represented as the combination of three characters: the woman emoji (👩), a hidden zero-width joiner, and the fire engine emoji (🚒):\n\n```live-elixir\niex> String.codepoints(\"👩‍🚒\")\n[\"👩\", \"‍\", \"🚒\"]\niex> String.graphemes(\"👩‍🚒\")\n[\"👩‍🚒\"]\n```\n\nHowever, Elixir is smart enough to know they are seen as a single character, and therefore the length is still one:\n\n```live-elixir\niex> String.length(\"👩‍🚒\")\n1\n```\n\n> Note: if you can't see the emoji above in your terminal, you need to make sure your terminal supports emoji and that you are using a font that can render them.\n\nAlthough these rules may sound complicated, UTF-8 encoded documents are everywhere. This page itself is encoded in UTF-8. The encoding information is given to your browser which then knows how to render all of the bytes, characters, and graphemes accordingly.\n\nIf you want to see the exact bytes that a string would be stored in a file, a common trick is to concatenate the null byte `<<0>>` to it:\n\n```live-elixir\niex> \"hełło\" <> <<0>>\n<<104, 101, 197, 130, 197, 130, 111, 0>>\n```\n\nAlternatively, you can view a string's binary representation by using `IO.inspect/2`:\n\n```live-elixir\niex> IO.inspect(\"hełło\", binaries: :as_binaries)\n<<104, 101, 197, 130, 197, 130, 111>>\n```\n\nWe are getting a little bit ahead of ourselves. Let's talk about bitstrings to learn about what exactly the `<<>>` constructor means.","ref":"binaries-strings-and-charlists.html#utf-8-and-encodings"},{"type":"extras","title":"Bitstrings - Binaries, strings, and charlists","doc":"Although we have covered code points and UTF-8 encoding, we still need to go a bit deeper into how exactly we store the encoded bytes, and this is where we introduce the **bitstring**. A bitstring is a fundamental data type in Elixir, denoted with the [`<<>>`](`<<>>/1`) syntax. **A bitstring is a contiguous sequence of bits in memory.**\n\nBy default, 8 bits (i.e. 1 byte) is used to store each number in a bitstring, but you can manually specify the number of bits via a `::n` modifier to denote the size in `n` bits, or you can use the more verbose declaration `::size(n)`:\n\n```live-elixir\niex> <<42>> == <<42::8>>\ntrue\niex> <<3::4>>\n<<3::size(4)>>\n```\n\nFor example, the decimal number `3` when represented with 4 bits in base 2 would be `0011`, which is equivalent to the values `0`, `0`, `1`, `1`, each stored using 1 bit:\n\n```live-elixir\niex> <<0::1, 0::1, 1::1, 1::1>> == <<3::4>>\ntrue\n```\n\nAny value that exceeds what can be stored by the number of bits provisioned is truncated:\n\n```live-elixir\niex> <<1>> == <<257>>\ntrue\n```\n\nHere, 257 in base 2 would be represented as `100000001`, but since we have reserved only 8 bits for its representation (by default), the left-most bit is ignored and the value becomes truncated to `00000001`, or simply `1` in decimal.\n\nA complete reference for the bitstring constructor can be found in [`<<>>`](`<<>>/1`)'s documentation.","ref":"binaries-strings-and-charlists.html#bitstrings"},{"type":"extras","title":"Binaries - Binaries, strings, and charlists","doc":"**A binary is a bitstring where the number of bits is divisible by 8.** That means that every binary is a bitstring, but not every bitstring is a binary. We can use the `is_bitstring/1` and `is_binary/1` functions to demonstrate this.\n\n```live-elixir\niex> is_bitstring(<<3::4>>)\ntrue\niex> is_binary(<<3::4>>)\nfalse\niex> is_bitstring(<<0, 255, 42>>)\ntrue\niex> is_binary(<<0, 255, 42>>)\ntrue\niex> is_binary(<<42::16>>)\ntrue\n```\n\nWe can pattern match on binaries / bitstrings:\n\n```live-elixir\niex> <<0, 1, x>> = <<0, 1, 2>>\n<<0, 1, 2>>\niex> x\n2\niex> <<0, 1, x>> = <<0, 1, 2, 3>>\n** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>\n```\n\nNote that unless you explicitly use `::` modifiers, each entry in the binary pattern is expected to match a single byte (exactly 8 bits). If we want to match on a binary of unknown size, we can use the `binary` modifier at the end of the pattern:\n\n```live-elixir\niex> <<0, 1, x::binary>> = <<0, 1, 2, 3>>\n<<0, 1, 2, 3>>\niex> x\n<<2, 3>>\n```\n\nThere are a couple other modifiers that can be useful when doing pattern matches on binaries. The `binary-size(n)` modifier will match `n` bytes in a binary:\n\n```live-elixir\niex> < > = <<0, 1, 2, 3>>\n<<0, 1, 2, 3>>\niex> head\n<<0, 1>>\niex> rest\n<<2, 3>>\n```\n\n**A string is a UTF-8 encoded binary**, where the code point for each character is encoded using 1 to 4 bytes. Thus every string is a binary, but due to the UTF-8 standard encoding rules, not every binary is a valid string.\n\n```live-elixir\niex> is_binary(\"hello\")\ntrue\niex> is_binary(<<239, 191, 19>>)\ntrue\niex> String.valid?(<<239, 191, 19>>)\nfalse\n```\n\nThe string concatenation operator `<>` is actually a binary concatenation operator:\n\n```live-elixir\niex> \"a\" <> \"ha\"\n\"aha\"\niex> <<0, 1>> <> <<2, 3>>\n<<0, 1, 2, 3>>\n```\n\nGiven that strings are binaries, we can also pattern match on strings:\n\n```live-elixir\niex> < > = \"banana\"\n\"banana\"\niex> head == ?b\ntrue\niex> rest\n\"anana\"\n```\n\nHowever, remember that binary pattern matching works on _bytes_, so matching on the string like \"über\" with multibyte characters won't match on the _character_, it will match on the _first byte of that character_:\n\n```live-elixir\niex> \"ü\" <> <<0>>\n<<195, 188, 0>>\niex> < > = \"über\"\n\"über\"\niex> x == ?ü\nfalse\niex> rest\n<<188, 98, 101, 114>>\n```\n\nAbove, `x` matched on only the first byte of the multibyte `ü` character.\n\nTherefore, when pattern matching on strings, it is important to use the `utf8` modifier:\n\n```live-elixir\niex> < > = \"über\"\n\"über\"\niex> x == ?ü\ntrue\niex> rest\n\"ber\"\n```","ref":"binaries-strings-and-charlists.html#binaries"},{"type":"extras","title":"Charlists - Binaries, strings, and charlists","doc":"Our tour of our bitstrings, binaries, and strings is nearly complete, but we have one more data type to explain: the charlist.\n\n**A charlist is a list of integers where all the integers are valid code points.** In practice, you will not come across them often, only in specific scenarios such as interfacing with older Erlang libraries that do not accept binaries as arguments.\n\n```live-elixir\niex> ~c\"hello\"\n~c\"hello\"\niex> [?h, ?e, ?l, ?l, ?o]\n~c\"hello\"\n```\n\nThe `~c` sigil (we'll cover sigils later in the [\"Sigils\"](sigils.md) chapter) indicates the fact that we are dealing with a charlist and not a regular string.\n\nInstead of containing bytes, a charlist contains integer code points. However, the list is only printed as a sigil if all code points are within the ASCII range:\n\n```live-elixir\niex> ~c\"hełło\"\n[104, 101, 322, 322, 111]\niex> is_list(~c\"hełło\")\ntrue\n```\n\nThis is done to ease interoperability with Erlang, even though it may lead to some surprising behavior. For example, if you are storing a list of integers that happen to range between 0 and 127, by default IEx will interpret this as a charlist and it will display the corresponding ASCII characters.\n\n```live-elixir\niex> heartbeats_per_minute = [99, 97, 116]\n~c\"cat\"\n```\n\nYou can always force charlists to be printed in their list representation by calling the `inspect/2` function:\n\n```live-elixir\niex> inspect(heartbeats_per_minute, charlists: :as_list)\n\"[99, 97, 116]\"\n```\n\nFurthermore, you can convert a charlist to a string and back by using the `to_string/1` and `to_charlist/1`:\n\n```live-elixir\niex> to_charlist(\"hełło\")\n[104, 101, 322, 322, 111]\niex> to_string(~c\"hełło\")\n\"hełło\"\niex> to_string(:hello)\n\"hello\"\niex> to_string(1)\n\"1\"\n```\n\nThe functions above are polymorphic, in other words, they accept many shapes: not only do they convert charlists to strings (and vice-versa), they can also convert integers, atoms, and so on.\n\nString (binary) concatenation uses the `<>` operator but charlists, being lists, use the list concatenation operator `++`:\n\n```live-elixir\niex> ~c\"this \" <> ~c\"fails\"\n** (ArgumentError) expected binary argument in <> operator but got: ~c\"this \"\n    (elixir) lib/kernel.ex:1821: Kernel.wrap_concatenation/3\n    (elixir) lib/kernel.ex:1808: Kernel.extract_concatenations/2\n    (elixir) expanding macro: Kernel.<>/2\n    iex:1: (file)\niex> ~c\"this \" ++ ~c\"works\"\n~c\"this works\"\niex> \"he\" ++ \"llo\"\n** (ArgumentError) argument error\n    :erlang.++(\"he\", \"llo\")\niex> \"he\" <> \"llo\"\n\"hello\"\n```\n\nWith binaries, strings, and charlists out of the way, it is time to talk about key-value data structures.","ref":"binaries-strings-and-charlists.html#charlists"},{"type":"extras","title":"Keyword lists and maps","doc":"# Keyword lists and maps\n\nNow let's talk about associative data structures. Associative data structures are able to associate a key to a certain value. Different languages call these different names like dictionaries, hashes, associative arrays, etc.\n\nIn Elixir, we have two main associative data structures: keyword lists and maps.","ref":"keywords-and-maps.html"},{"type":"extras","title":"Keyword lists - Keyword lists and maps","doc":"Keyword lists are a data-structure used to pass options to functions. Imagine you want to split a string of numbers. We can use `String.split/2`:\n\n```live-elixir\niex> String.split(\"1 2 3\", \" \")\n[\"1\", \"2\", \"3\"]\n```\n\nHowever, what happens if there is an additional space between the numbers:\n\n```live-elixir\niex> String.split(\"1  2  3\", \" \")\n[\"1\", \"\", \"2\", \"\", \"3\"]\n```\n\nAs you can see, there are now empty strings in our results. Luckily, the `String.split/3` function allows the `trim` option to be set to true:\n\n```live-elixir\niex> String.split(\"1  2  3\", \" \", [trim: true])\n[\"1\", \"2\", \"3\"]\n```\n\n`[trim: true]` is a keyword list. Furthermore, when a keyword list is the last argument of a function, we can skip the brackets and write:\n\n```live-elixir\niex> String.split(\"1  2  3\", \" \", trim: true)\n[\"1\", \"2\", \"3\"]\n```\n\nAs shown in the example above, keyword lists are mostly used as optional arguments to functions.\n\nAs the name implies, keyword lists are simply lists. In particular, they are lists consisting of 2-item tuples where the first element (the key) is an atom and the second element can be any value. Both representations are the same:\n\n```live-elixir\niex> [{:trim, true}] == [trim: true]\ntrue\n```\n\nSince keyword lists are lists, we can use all operations available to lists. For example, we can use `++` to add new values to a keyword list:\n\n```live-elixir\niex> list = [a: 1, b: 2]\n[a: 1, b: 2]\niex> list ++ [c: 3]\n[a: 1, b: 2, c: 3]\niex> [a: 0] ++ list\n[a: 0, a: 1, b: 2]\n```\n\nYou can read the value of a keyword list using the brackets syntax. This is also known as the access syntax, as it is defined by the `Access` module:\n\n```live-elixir\niex> list[:a]\n1\niex> list[:b]\n2\n```\n\nIn case of duplicate keys, values added to the front are the ones fetched:\n\n```live-elixir\niex> new_list = [a: 0] ++ list\n[a: 0, a: 1, b: 2]\niex> new_list[:a]\n0\n```\n\nKeyword lists are important because they have three special characteristics:\n\n- Keys must be atoms.\n- Keys are ordered, as specified by the developer.\n- Keys can be given more than once.\n\nFor example, [the Ecto library](https://github.com/elixir-lang/ecto) makes use of these features to provide an elegant DSL for writing database queries:\n\n```live-elixir\nquery =\n  from w in Weather,\n    where: w.prcp > 0,\n    where: w.temp < 20,\n    select: w\n```\n\nAlthough we can pattern match on keyword lists, it is not done in practice since pattern matching on lists requires the number of items and their order to match:\n\n```live-elixir\niex> [a: a] = [a: 1]\n[a: 1]\niex> a\n1\niex> [a: a] = [a: 1, b: 2]\n** (MatchError) no match of right hand side value: [a: 1, b: 2]\niex> [b: b, a: a] = [a: 1, b: 2]\n** (MatchError) no match of right hand side value: [a: 1, b: 2]\n```\n\nFurthermore, given keyword lists are often used as optional arguments, they are used in situations where not all keys may be present, which would make it impossible to match on them. In a nutshell, do not pattern match on keyword lists.\n\nIn order to manipulate keyword lists, Elixir provides the `Keyword` module. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics as them: the longer the list, the longer it will take to find a key, to count the number of items, and so on. If you need to store a large amount of keys in a key-value data structure, Elixir offers maps, which we will soon learn.\n\n### `do`-blocks and keywords\n\nAs we have seen, keywords are mostly used in the language to pass optional values. In fact, we have used keywords in earlier chapters. For example, we have seen:\n\n```live-elixir\niex> if true do\n...>   \"This will be seen\"\n...> else\n...>   \"This won't\"\n...> end\n\"This will be seen\"\n```\n\nIt happens that `do` blocks are nothing more than a syntax convenience on top of keywords. We can rewrite the above to:\n\n```live-elixir\niex> if true, do: \"This will be seen\", else: \"This won't\"\n\"This will be seen\"\n```\n\nPay close attention to both syntaxes. In the keyword list format, we separate each key-value pair with commas, and each key is followed by `:`. In the `do`-blocks, we get rid of the colons, the commas, and separate each keyword by a newline. They are useful exactly because they remove the verbosity when writing blocks of code. Most of the time, you will use the block syntax, but it is good to know they are equivalent.\n\nThis plays an important role in the language as it allows Elixir syntax to stay small but still expressive. We only need few data structures to represent the language, a topic we will come back to when talking about [optional syntax](optional-syntax.md) and go in-depth when discussing [meta-programming](../meta-programming/quote-and-unquote.md).\n\nWith this out of the way, let's talk about maps.","ref":"keywords-and-maps.html#keyword-lists"},{"type":"extras","title":"Maps as key-value pairs - Keyword lists and maps","doc":"Whenever you need to store key-value pairs, maps are the \"go to\" data structure in Elixir. A map is created using the `%{}` syntax:\n\n```live-elixir\niex> map = %{:a => 1, 2 => :b}\n%{2 => :b, :a => 1}\niex> map[:a]\n1\niex> map[2]\n:b\niex> map[:c]\nnil\n```\n\nCompared to keyword lists, we can already see two differences:\n\n- Maps allow any value as a key.\n- Maps' keys do not follow any ordering.\n\nIn contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:\n\n```live-elixir\niex> %{} = %{:a => 1, 2 => :b}\n%{2 => :b, :a => 1}\niex> %{:a => a} = %{:a => 1, 2 => :b}\n%{2 => :b, :a => 1}\niex> a\n1\niex> %{:c => c} = %{:a => 1, 2 => :b}\n** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}\n```\n\nAs shown above, a map matches as long as the keys in the pattern exist in the given map. Therefore, an empty map matches all maps.\n\nThe `Map` module provides a very similar API to the `Keyword` module with convenience functions to add, remove, and update maps keys:\n\n```live-elixir\niex> Map.get(%{:a => 1, 2 => :b}, :a)\n1\niex> Map.put(%{:a => 1, 2 => :b}, :c, 3)\n%{2 => :b, :a => 1, :c => 3}\niex> Map.to_list(%{:a => 1, 2 => :b})\n[{2, :b}, {:a, 1}]\n```","ref":"keywords-and-maps.html#maps-as-key-value-pairs"},{"type":"extras","title":"Maps of predefined keys - Keyword lists and maps","doc":"In the previous section, we have used maps as a key-value data structure where keys can be added or removed at any time. However, it is also common to create maps with a pre-defined set of keys. Their values may be updated, but new keys are never added nor removed. This is useful when we know the shape of the data we are working with and, if we get a different key, it likely means a mistake was done elsewhere.\n\nWe define such maps using the same syntax as in the previous section, except that all keys must be atoms:\n\n```live-elixir\niex> map = %{:name => \"John\", :age => 23}\n%{name: \"John\", age: 23}\n```\n\nAs you can see from the printed result above, Elixir also allows you to write maps of atom keys using the same `key: value` syntax as keyword lists.\n\nWhen the keys are atoms, in particular when working with maps of predefined keys, we can also access them using the `map.key` syntax:\n\n```live-elixir\niex> map = %{name: \"John\", age: 23}\n%{name: \"John\", age: 23}\n\niex> map.name\n\"John\"\niex> map.agee\n** (KeyError) key :agee not found in: %{name: \"John\", age: 23}\n```\n\nThere is also syntax for updating keys, which also raises if the key has not yet been defined:\n\n```live-elixir\niex> %{map | name: \"Mary\"}\n%{name: \"Mary\", age: 23}\niex> %{map | agee: 27}\n** (KeyError) key :agee not found in: %{name: \"John\", age: 23}\n```\n\nThese operations have one large benefit in that they raise if the key does not exist in the map and the compiler may even detect and warn when possible. This makes them useful to get quick feedback and spot bugs and typos early on. This is also the syntax used to power another Elixir feature called \"Structs\", which we will learn later on.\n\nElixir developers typically prefer to use the `map.key` syntax and pattern matching instead of the functions in the `Map` module when working with maps because they lead to an assertive style of programming. [This blog post by José Valim](https://dashbit.co/blog/writing-assertive-code-with-elixir) provides insight and examples on how you get more concise and faster software by writing assertive code in Elixir.","ref":"keywords-and-maps.html#maps-of-predefined-keys"},{"type":"extras","title":"Nested data structures - Keyword lists and maps","doc":"Often we will have maps inside maps, or even keywords lists inside maps, and so forth. Elixir provides conveniences for manipulating nested data structures via the `get_in/1`, `put_in/2`, `update_in/2`, and other macros giving the same conveniences you would find in imperative languages while keeping the immutable properties of the language.\n\nImagine you have the following structure:\n\n```live-elixir\niex> users = [\n  john: %{name: \"John\", age: 27, languages: [\"Erlang\", \"Ruby\", \"Elixir\"]},\n  mary: %{name: \"Mary\", age: 29, languages: [\"Elixir\", \"F#\", \"Clojure\"]}\n]\n[\n  john: %{age: 27, languages: [\"Erlang\", \"Ruby\", \"Elixir\"], name: \"John\"},\n  mary: %{age: 29, languages: [\"Elixir\", \"F#\", \"Clojure\"], name: \"Mary\"}\n]\n```\n\nWe have a keyword list of users where each value is a map containing the name, age and a list of programming languages each user likes. If we wanted to access the age for john, we could write:\n\n```live-elixir\niex> users[:john].age\n27\n```\n\nIt happens we can also use this same syntax for updating the value:\n\n```live-elixir\niex> users = put_in users[:john].age, 31\n[\n  john: %{age: 31, languages: [\"Erlang\", \"Ruby\", \"Elixir\"], name: \"John\"},\n  mary: %{age: 29, languages: [\"Elixir\", \"F#\", \"Clojure\"], name: \"Mary\"}\n]\n```\n\nThe `update_in/2` macro is similar but allows us to pass a function that controls how the value changes. For example, let's remove \"Clojure\" from Mary's list of languages:\n\n```live-elixir\niex> users = update_in users[:mary].languages, fn languages -> List.delete(languages, \"Clojure\") end\n[\n  john: %{age: 31, languages: [\"Erlang\", \"Ruby\", \"Elixir\"], name: \"John\"},\n  mary: %{age: 29, languages: [\"Elixir\", \"F#\"], name: \"Mary\"}\n]\n```\n\nThere is more to learn about `get_in/1`, `pop_in/1` and others, including the `get_and_update_in/2` that allows us to extract a value and update the data structure at once. There are also `get_in/3`, `put_in/3`, `update_in/3`, `get_and_update_in/3`, `pop_in/2` which allow dynamic access into the data structure.","ref":"keywords-and-maps.html#nested-data-structures"},{"type":"extras","title":"Summary - Keyword lists and maps","doc":"There are two different data structures for working with key-value stores in Elixir. Alongside the `Access` module and pattern matching, they provide a rich set of tools for manipulating complex, potentially nested, data structures.\n\nAs we conclude this chapter, remember that you should:\n\n- Use keyword lists for passing optional values to functions\n\n- Use maps for general key-value data structures\n\n- Use maps when working with data that has a predefined set of keys\n\nNow let's talk about modules and functions.","ref":"keywords-and-maps.html#summary"},{"type":"extras","title":"Modules and functions","doc":"# Modules and functions\n\nIn Elixir we group several functions into modules. We've already used many different modules in the previous chapters, such as the `String` module:\n\n```live-elixir\niex> String.length(\"hello\")\n5\n```\n\nIn order to create our own modules in Elixir, we use the `defmodule` macro. The first letter of the module must be in uppercase. We use the `def` macro to define functions in that module. The first letter of every function must be in lowercase (or underscore):\n\n```live-elixir\niex> defmodule Math do\n...>   def sum(a, b) do\n...>     a + b\n...>   end\n...> end\n\niex> Math.sum(1, 2)\n3\n```\n\nIn this chapter we will define our own modules, with different levels of complexity. As our examples get longer in size, it can be tricky to type them all in the shell. It's about time for us to learn how to compile Elixir code and also how to run Elixir scripts.","ref":"modules-and-functions.html"},{"type":"extras","title":"Compilation - Modules and functions","doc":"Most of the time it is convenient to write modules into files so they can be compiled and reused. Let's assume we have a file named `math.ex` with the following contents:\n\n```live-elixir\ndefmodule Math do\n  def sum(a, b) do\n    a + b\n  end\nend\n```\n\nThis file can be compiled using `elixirc`:\n\n```console\n$ elixirc math.ex\n```\n\nThis will generate a file named `Elixir.Math.beam` containing the bytecode for the defined module. If we start `iex` again, our module definition will be available (provided that `iex` is started in the same directory the bytecode file is in):\n\n```live-elixir\niex> Math.sum(1, 2)\n3\n```\n\nElixir projects are usually organized into three directories:\n\n- `_build` - contains compilation artifacts\n- `lib` - contains Elixir code (usually `.ex` files)\n- `test` - contains tests (usually `.exs` files)\n\nWhen working on actual projects, the build tool called `mix` will be responsible for compiling and setting up the proper paths for you. For learning and convenience purposes, Elixir also supports a scripting mode which is more flexible and does not generate any compiled artifacts.","ref":"modules-and-functions.html#compilation"},{"type":"extras","title":"Scripting mode - Modules and functions","doc":"In addition to the Elixir file extension `.ex`, Elixir also supports `.exs` files for scripting. Elixir treats both files exactly the same way, the only difference is in intention. `.ex` files are meant to be compiled while `.exs` files are used for scripting. This convention is followed by projects like `mix`.\n\nFor instance, we can create a file called `math.exs`:\n\n```live-elixir\ndefmodule Math do\n  def sum(a, b) do\n    a + b\n  end\nend\n\nIO.puts Math.sum(1, 2)\n```\n\nAnd execute it as:\n\n```console\n$ elixir math.exs\n```\n\nBecause we used `elixir` instead of `elixirc`, the module was compiled and loaded into memory, but no `.beam` file was written to disk. In the following examples, we recommend you write your code into script files and execute them as shown above.","ref":"modules-and-functions.html#scripting-mode"},{"type":"extras","title":"Function definition - Modules and functions","doc":"Inside a module, we can define functions with `def/2` and private functions with `defp/2`. A function defined with `def/2` can be invoked from other modules while a private function can only be invoked locally.\n\n```live-elixir\ndefmodule Math do\n  def sum(a, b) do\n    do_sum(a, b)\n  end\n\n  defp do_sum(a, b) do\n    a + b\n  end\nend\n\nIO.puts Math.sum(1, 2)    #=> 3\nIO.puts Math.do_sum(1, 2) #=> ** (UndefinedFunctionError)\n```\n\nFunction declarations also support guards and multiple clauses. If a function has several clauses, Elixir will try each clause until it finds one that matches. Here is an implementation of a function that checks if the given number is zero or not:\n\n```live-elixir\ndefmodule Math do\n  def zero?(0) do\n    true\n  end\n\n  def zero?(x) when is_integer(x) do\n    false\n  end\nend\n\nIO.puts Math.zero?(0)         #=> true\nIO.puts Math.zero?(1)         #=> false\nIO.puts Math.zero?([1, 2, 3]) #=> ** (FunctionClauseError)\nIO.puts Math.zero?(0.0)       #=> ** (FunctionClauseError)\n```\n\nThe trailing question mark in `zero?` means that this function returns a boolean. To learn more about the naming conventions for modules, function names, variables and more in Elixir, see [Naming Conventions](../references/naming-conventions.md).\n\nGiving an argument that does not match any of the clauses raises an error.\n\nSimilar to constructs like `if`, function definitions support both `do:` and `do`-block syntax, as [we learned in the previous chapter](keywords-and-maps.md#do-blocks-and-keywords). For example, we can edit `math.exs` to look like this:\n\n```live-elixir\ndefmodule Math do\n  def zero?(0), do: true\n  def zero?(x) when is_integer(x), do: false\nend\n```\n\nAnd it will provide the same behavior. You may use `do:` for one-liners but always use `do`-blocks for functions spanning multiple lines. If you prefer to be consistent, you can use `do`-blocks throughout your codebase.","ref":"modules-and-functions.html#function-definition"},{"type":"extras","title":"Default arguments - Modules and functions","doc":"Function definitions in Elixir also support default arguments:\n\n```live-elixir\ndefmodule Concat do\n  def join(a, b, sep \\\\ \" \") do\n    a <> sep <> b\n  end\nend\n\nIO.puts Concat.join(\"Hello\", \"world\")      #=> Hello world\nIO.puts Concat.join(\"Hello\", \"world\", \"_\") #=> Hello_world\n```\n\nAny expression is allowed to serve as a default value, but it won't be evaluated during the function definition. Every time the function is invoked and any of its default values have to be used, the expression for that default value will be evaluated:\n\n```live-elixir\ndefmodule DefaultTest do\n  def dowork(x \\\\ \"hello\") do\n    x\n  end\nend\n```\n\n```live-elixir\niex> DefaultTest.dowork()\n\"hello\"\niex> DefaultTest.dowork(123)\n123\niex> DefaultTest.dowork()\n\"hello\"\n```\n\nIf a function with default values has multiple clauses, it is required to create a function head (a function definition without a body) for declaring defaults:\n\n```live-elixir\ndefmodule Concat do\n  # A function head declaring defaults\n  def join(a, b \\\\ nil, sep \\\\ \" \")\n\n  def join(a, b, _sep) when is_nil(b) do\n    a\n  end\n\n  def join(a, b, sep) do\n    a <> sep <> b\n  end\nend\n\nIO.puts Concat.join(\"Hello\", \"world\")      #=> Hello world\nIO.puts Concat.join(\"Hello\", \"world\", \"_\") #=> Hello_world\nIO.puts Concat.join(\"Hello\")               #=> Hello\n```\n\nWhen a variable is not used by a function or a clause, we add a leading underscore (`_`) to its name to signal this intent. This rule is also covered in our [Naming Conventions](../references/naming-conventions.md#underscore-_foo) document.\n\nWhen using default values, one must be careful to avoid overlapping function definitions. Consider the following example:\n\n```live-elixir\ndefmodule Concat do\n  def join(a, b) do\n    IO.puts \"***First join\"\n    a <> b\n  end\n\n  def join(a, b, sep \\\\ \" \") do\n    IO.puts \"***Second join\"\n    a <> sep <> b\n  end\nend\n```\n\nElixir will emit the following warning:\n\n```text\nwarning: this clause cannot match because a previous clause at line 2 always matches\n    concat.ex:7: Concat\n```\n\nThe compiler is telling us that invoking the `join` function with two arguments will always choose the first definition of `join` whereas the second one will only be invoked when three arguments are passed:\n\n```console\n$ iex concat.ex\n```\n\n```live-elixir\niex> Concat.join \"Hello\", \"world\"\n***First join\n\"Helloworld\"\n```\n\n```live-elixir\niex> Concat.join \"Hello\", \"world\", \"_\"\n***Second join\n\"Hello_world\"\n```\n\nRemoving the default argument in this case will fix the warning.\n\nThis finishes our short introduction to modules. In the next chapters, we will learn how to use function definitions for recursion and later on explore more functionality related to modules.","ref":"modules-and-functions.html#default-arguments"},{"type":"extras","title":"Recursion","doc":"# Recursion\n\nElixir does not provide loop constructs. Instead we leverage recursion and high-level functions for working with collections. This chapter will explore the former.","ref":"recursion.html"},{"type":"extras","title":"Loops through recursion - Recursion","doc":"Due to immutability, loops in Elixir (as in any functional programming language) are written differently from imperative languages. For example, in an imperative language like C, one would write:\n\n```c\nfor(i = 0; i   0 do\n    IO.puts(msg)\n    print_multiple_times(msg, n - 1)\n  end\n\n  def print_multiple_times(_msg, 0) do\n    :ok\n  end\nend\n\nRecursion.print_multiple_times(\"Hello!\", 3)\n# Hello!\n# Hello!\n# Hello!\n:ok\n```\n\nSimilar to `case`, a function may have many clauses. A particular clause is executed when the arguments passed to the function match the clause's argument patterns and its guards evaluate to `true`.\n\nWhen `print_multiple_times/2` is initially called in the example above, the argument `n` is equal to `3`.\n\nThe first clause has a guard which says \"use this definition if and only if `n` is more than `0`\". Since this is the case, it prints the `msg` and then calls itself passing `n - 1` (`2`) as the second argument.\n\nNow we execute the same function again, starting from the first clause. Given the second argument, `n`, is still more than 0, we print the message and call ourselves once more, now with the second argument set to `1`. Then we print the message one last time and call `print_multiple_times(\"Hello!\", 0)`, starting from the top once again.\n\nWhen the second argument is zero, the guard `n > 0` evaluates to false, and the first function clause won't execute. Elixir then proceeds to try the next function clause, which explicitly matches on the case where `n` is `0`. This clause, also known as the termination clause, ignores the message argument by assigning it to the `_msg` variable and returns the atom `:ok`.\n\nFinally, if you pass an argument that does not match any clause, Elixir raises a `FunctionClauseError`:\n\n```live-elixir\niex> Recursion.print_multiple_times \"Hello!\", -1\n** (FunctionClauseError) no function clause matching in Recursion.print_multiple_times/2\n\n    The following arguments were given to Recursion.print_multiple_times/2:\n\n        # 1\n        \"Hello!\"\n\n        # 2\n        -1\n\n    iex:1: Recursion.print_multiple_times/2\n```","ref":"recursion.html#loops-through-recursion"},{"type":"extras","title":"Reduce and map algorithms - Recursion","doc":"Let's now see how we can use the power of recursion to sum a list of numbers:\n\n```live-elixir\ndefmodule Math do\n  def sum_list([head | tail], accumulator) do\n    sum_list(tail, head + accumulator)\n  end\n\n  def sum_list([], accumulator) do\n    accumulator\n  end\nend\n\nIO.puts Math.sum_list([1, 2, 3], 0) #=> 6\n```\n\nWe invoke `sum_list` with the list `[1, 2, 3]` and the initial value `0` as arguments. We will try each clause until we find one that matches according to the pattern matching rules. In this case, the list `[1, 2, 3]` matches against `[head | tail]` which binds `head` to `1` and `tail` to `[2, 3]`; `accumulator` is set to `0`.\n\nThen, we add the head of the list to the accumulator `head + accumulator` and call `sum_list` again, recursively, passing the tail of the list as its first argument. The tail will once again match `[head | tail]` until the list is empty, as seen below:\n\n```live-elixir\nsum_list [1, 2, 3], 0\nsum_list [2, 3], 1\nsum_list [3], 3\nsum_list [], 6\n```\n\nWhen the list is empty, it will match the final clause which returns the final result of `6`.\n\nThe process of taking a list and _reducing_ it down to one value is known as a _reduce algorithm_ and is central to functional programming.\n\nWhat if we instead want to double all of the values in our list?\n\n```live-elixir\ndefmodule Math do\n  def double_each([head | tail]) do\n    [head * 2 | double_each(tail)]\n  end\n\n  def double_each([]) do\n    []\n  end\nend\n```\n\n```console\n$ iex math.exs\n```\n\n```live-elixir\niex> Math.double_each([1, 2, 3]) #=> [2, 4, 6]\n```\n\nHere we have used recursion to traverse a list, doubling each element and returning a new list. The process of taking a list and _mapping_ over it is known as a _map algorithm_.\n\nRecursion and [tail call](https://en.wikipedia.org/wiki/Tail_call) optimization are an important part of Elixir and are commonly used to create loops. However, when programming in Elixir you will rarely use recursion as above to manipulate lists.\n\nThe `Enum` module, which we're going to see in the next chapter already provides many conveniences for working with lists. For instance, the examples above could be written as:\n\n```live-elixir\niex> Enum.reduce([1, 2, 3], 0, fn x, acc -> x + acc end)\n6\niex> Enum.map([1, 2, 3], fn x -> x * 2 end)\n[2, 4, 6]\n```\n\nOr, using the capture syntax:\n\n```live-elixir\niex> Enum.reduce([1, 2, 3], 0, &+/2)\n6\niex> Enum.map([1, 2, 3], &(&1 * 2))\n[2, 4, 6]\n```\n\nLet's take a deeper look at `Enumerable` and, while we're at it, its lazy counterpart, `Stream`.","ref":"recursion.html#reduce-and-map-algorithms"},{"type":"extras","title":"Enumerables and Streams","doc":"# Enumerables and Streams\n\nWhile Elixir allows us to write recursive code, most operations we perform on collections is done with the help of the `Enum` and `Stream` modules. Let's learn how.","ref":"enumerable-and-streams.html"},{"type":"extras","title":"Enumerables - Enumerables and Streams","doc":"Elixir provides the concept of enumerables and the `Enum` module to work with them. We have already learned two enumerables: lists and maps.\n\n```live-elixir\niex> Enum.map([1, 2, 3], fn x -> x * 2 end)\n[2, 4, 6]\niex> Enum.map(%{1 => 2, 3 => 4}, fn {k, v} -> k * v end)\n[2, 12]\n```\n\nThe `Enum` module provides a huge range of functions to transform, sort, group, filter and retrieve items from enumerables. It is one of the modules developers use frequently in their Elixir code. For a general overview of all functions in the `Enum` module, see [the `Enum` cheatsheet](enum-cheat.cheatmd).\n\nElixir also provides ranges (see `Range`), which are also enumerable:\n\n```live-elixir\niex> Enum.map(1..3, fn x -> x * 2 end)\n[2, 4, 6]\niex> Enum.reduce(1..3, 0, &+/2)\n6\n```\n\nThe functions in the `Enum` module are limited to, as the name says, enumerating values in data structures. For specific operations, like inserting and updating particular elements, you may need to reach for modules specific to the data type. For example, if you want to insert an element at a given position in a list, you should use the `List.insert_at/3` function, as it would make little sense to insert a value into, for example, a range.\n\nWe say the functions in the `Enum` module are polymorphic because they can work with diverse data types. In particular, the functions in the `Enum` module can work with any data type that implements the `Enumerable` protocol. We are going to discuss Protocols in a later chapter, for now we are going to move on to a specific kind of enumerable called a stream.","ref":"enumerable-and-streams.html#enumerables"},{"type":"extras","title":"Eager vs Lazy - Enumerables and Streams","doc":"All the functions in the `Enum` module are eager. Many functions expect an enumerable and return a list back:\n\n```live-elixir\niex> odd? = fn x -> rem(x, 2) != 0 end\n#Function<6.80484245/1 in :erl_eval.expr/5>\niex> Enum.filter(1..3, odd?)\n[1, 3]\n```\n\nThis means that when performing multiple operations with `Enum`, each operation is going to generate an intermediate list until we reach the result:\n\n```live-elixir\niex> 1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(odd?) |> Enum.sum()\n7500000000\n```\n\nThe example above has a pipeline of operations. We start with a range and then multiply each element in the range by 3. This first operation will now create and return a list with `100_000` items. Then we keep all odd elements from the list, generating a new list, now with `50_000` items, and then we sum all entries.","ref":"enumerable-and-streams.html#eager-vs-lazy"},{"type":"extras","title":"The pipe operator - Enumerables and Streams","doc":"The `|>` symbol used in the snippet above is the **pipe operator**: it takes the output from the expression on its left side and passes it as the first argument to the function call on its right side. Its purpose is to highlight the data being transformed by a series of functions. To see how it can make the code cleaner, have a look at the example above rewritten without using the `|>` operator:\n\n```live-elixir\niex> Enum.sum(Enum.filter(Enum.map(1..100_000, &(&1 * 3)), odd?))\n7500000000\n```\n\nFind more about the pipe operator [by reading its documentation](`|>/2`).","ref":"enumerable-and-streams.html#the-pipe-operator"},{"type":"extras","title":"Streams - Enumerables and Streams","doc":"As an alternative to `Enum`, Elixir provides the `Stream` module which supports lazy operations:\n\n```live-elixir\niex> 1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?) |> Enum.sum()\n7500000000\n```\n\nStreams are lazy, composable enumerables.\n\nIn the example above, `1..100_000 |> Stream.map(&(&1 * 3))` returns a data type, an actual stream, that represents the `map` computation over the range `1..100_000`:\n\n```live-elixir\niex> 1..100_000 |> Stream.map(&(&1 * 3))\n#Stream<[enum: 1..100000, funs: [#Function<34.16982430/1 in Stream.map/2>]]>\n```\n\nFurthermore, they are composable because we can pipe many stream operations:\n\n```live-elixir\niex> 1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?)\n#Stream<[enum: 1..100000, funs: [...]]>\n```\n\nInstead of generating intermediate lists, streams build a series of computations that are invoked only when we pass the underlying stream to the `Enum` module. Streams are useful when working with large, _possibly infinite_, collections.\n\nMany functions in the `Stream` module accept any enumerable as an argument and return a stream as a result. It also provides functions for creating streams. For example, `Stream.cycle/1` can be used to create a stream that cycles a given enumerable infinitely. Be careful to not call a function like `Enum.map/2` on such streams, as they would cycle forever:\n\n```live-elixir\niex> stream = Stream.cycle([1, 2, 3])\n#Function<15.16982430/2 in Stream.unfold/2>\niex> Enum.take(stream, 10)\n[1, 2, 3, 1, 2, 3, 1, 2, 3, 1]\n```\n\nOn the other hand, `Stream.unfold/2` can be used to generate values from a given initial value:\n\n```live-elixir\niex> stream = Stream.unfold(\"hełło\", &String.next_codepoint/1)\n#Function<39.75994740/2 in Stream.unfold/2>\niex> Enum.take(stream, 3)\n[\"h\", \"e\", \"ł\"]\n```\n\nAnother interesting function is `Stream.resource/3` which can be used to wrap around resources, guaranteeing they are opened right before enumeration and closed afterwards, even in the case of failures. For example, `File.stream!/1` builds on top of `Stream.resource/3` to stream files:\n\n```elixir\niex> stream = File.stream!(\"path/to/file\")\n%File.Stream{\n  line_or_bytes: :line,\n  modes: [:raw, :read_ahead, :binary],\n  path: \"path/to/file\",\n  raw: true\n}\niex> Enum.take(stream, 10)\n```\n\nThe example above will fetch the first 10 lines of the file you have selected. This means streams can be very useful for handling large files or even slow resources like network resources.\n\nThe `Enum` and `Stream` modules provide a wide range of functions, but you don't have to know all of them by heart. Familiarize yourself with `Enum.map/2`, `Enum.reduce/3` and other functions with either `map` or `reduce` in their names, and you will naturally build an intuition around the most important use cases. You may also focus on the `Enum` module first and only move to `Stream` for the particular scenarios where laziness is required, to either deal with slow resources or large, possibly infinite, collections.\n\nNext, we'll look at a feature central to Elixir, Processes, which allows us to write concurrent, parallel and distributed programs in an easy and understandable way.","ref":"enumerable-and-streams.html#streams"},{"type":"extras","title":"Processes","doc":"# Processes\n\nIn Elixir, all code runs inside processes. Processes are isolated from each other, run concurrent to one another and communicate via message passing. Processes are not only the basis for concurrency in Elixir, but they also provide the means for building distributed and fault-tolerant programs.\n\nElixir's processes should not be confused with operating system processes. Processes in Elixir are extremely lightweight in terms of memory and CPU (even compared to threads as used in many other programming languages). Because of this, it is not uncommon to have tens or even hundreds of thousands of processes running simultaneously.\n\nIn this chapter, we will learn about the basic constructs for spawning new processes, as well as sending and receiving messages between processes.","ref":"processes.html"},{"type":"extras","title":"Spawning processes - Processes","doc":"The basic mechanism for spawning new processes is the auto-imported `spawn/1` function:\n\n```live-elixir\niex> spawn(fn -> 1 + 2 end)\n#PID<0.43.0>\n```\n\n`spawn/1` takes a function which it will execute in another process.\n\nNotice `spawn/1` returns a PID (process identifier). At this point, the process you spawned is very likely dead. The spawned process will execute the given function and exit after the function is done:\n\n```live-elixir\niex> pid = spawn(fn -> 1 + 2 end)\n#PID<0.44.0>\niex> Process.alive?(pid)\nfalse\n```\n\n> Note: you will likely get different process identifiers than the ones we are showing in our snippets.\n\nWe can retrieve the PID of the current process by calling `self/0`:\n\n```live-elixir\niex> self()\n#PID<0.41.0>\niex> Process.alive?(self())\ntrue\n```\n\nProcesses get much more interesting when we are able to send and receive messages.","ref":"processes.html#spawning-processes"},{"type":"extras","title":"Sending and receiving messages - Processes","doc":"We can send messages to a process with `send/2` and receive them with `receive/1`:\n\n```live-elixir\niex> send(self(), {:hello, \"world\"})\n{:hello, \"world\"}\niex> receive do\n...>   {:hello, msg} -> msg\n...>   {:world, _msg} -> \"won't match\"\n...> end\n\"world\"\n```\n\nWhen a message is sent to a process, the message is stored in the process mailbox. The `receive/1` block goes through the current process mailbox searching for a message that matches any of the given patterns. `receive/1` supports guards and many clauses, such as `case/2`.\n\nThe process that sends the message does not block on `send/2`, it puts the message in the recipient's mailbox and continues. In particular, a process can send messages to itself.\n\nIf there is no message in the mailbox matching any of the patterns, the current process will wait until a matching message arrives. A timeout can also be specified:\n\n```live-elixir\niex> receive do\n...>   {:hello, msg}  -> msg\n...> after\n...>   1_000 -> \"nothing after 1s\"\n...> end\n\"nothing after 1s\"\n```\n\nA timeout of 0 can be given when you already expect the message to be in the mailbox.\n\nLet's put it all together and send messages between processes:\n\n```live-elixir\niex> parent = self()\n#PID<0.41.0>\niex> spawn(fn -> send(parent, {:hello, self()}) end)\n#PID<0.48.0>\niex> receive do\n...>   {:hello, pid} -> \"Got hello from #{inspect pid}\"\n...> end\n\"Got hello from #PID<0.48.0>\"\n```\n\nThe `inspect/1` function is used to convert a data structure's internal representation into a string, typically for printing. Notice that when the `receive` block gets executed the sender process we have spawned may already be dead, as its only instruction was to send a message.\n\nWhile in the shell, you may find the helper `flush/0` quite useful. It flushes and prints all the messages in the mailbox.\n\n```elixir\niex> send(self(), :hello)\n:hello\niex> flush()\n:hello\n:ok\n```","ref":"processes.html#sending-and-receiving-messages"},{"type":"extras","title":"Links - Processes","doc":"The majority of times we spawn processes in Elixir, we spawn them as linked processes. Before we show an example with `spawn_link/1`, let's see what happens when a process started with `spawn/1` fails:\n\n```live-elixir\niex> spawn(fn -> raise \"oops\" end)\n#PID<0.58.0>\n\n[error] Process #PID<0.58.00> raised an exception\n** (RuntimeError) oops\n    (stdlib) erl_eval.erl:668: :erl_eval.do_apply/6\n```\n\nIt merely logged an error but the parent process is still running. That's because processes are isolated. If we want the failure in one process to propagate to another one, we should link them. This can be done with `spawn_link/1`:\n\n```live-elixir\niex> self()\n#PID<0.41.0>\niex> spawn_link(fn -> raise \"oops\" end)\n\n** (EXIT from #PID<0.41.0>) evaluator process exited with reason: an exception was raised:\n    ** (RuntimeError) oops\n        (stdlib) erl_eval.erl:668: :erl_eval.do_apply/6\n\n[error] Process #PID<0.289.0> raised an exception\n** (RuntimeError) oops\n    (stdlib) erl_eval.erl:668: :erl_eval.do_apply/6\n```\n\nBecause processes are linked, we now see a message saying the parent process, which is the shell process, has received an EXIT signal from another process causing the shell to terminate. IEx detects this situation and starts a new shell session.\n\nLinking can also be done manually by calling `Process.link/1`. We recommend that you take a look at the `Process` module for other functionality provided by processes.\n\nProcesses and links play an important role when building fault-tolerant systems. Elixir processes are isolated and don't share anything by default. Therefore, a failure in a process will never crash or corrupt the state of another process. Links, however, allow processes to establish a relationship in case of failure. We often link our processes to supervisors which will detect when a process dies and start a new process in its place.\n\nWhile other languages would require us to catch/handle exceptions, in Elixir we are actually fine with letting processes fail because we expect supervisors to properly restart our systems. \"Failing fast\" (sometimes referred as \"let it crash\") is a common philosophy when writing Elixir software!\n\n`spawn/1` and `spawn_link/1` are the basic primitives for creating processes in Elixir. Although we have used them exclusively so far, most of the time we are going to use abstractions that build on top of them. Let's see the most common one, called tasks.","ref":"processes.html#links"},{"type":"extras","title":"Tasks - Processes","doc":"Tasks build on top of the spawn functions to provide better error reports and introspection:\n\n```live-elixir\niex> Task.start(fn -> raise \"oops\" end)\n{:ok, #PID<0.55.0>}\n\n15:22:33.046 [error] Task #PID<0.55.0> started from #PID<0.53.0> terminating\n** (RuntimeError) oops\n    (stdlib) erl_eval.erl:668: :erl_eval.do_apply/6\n    (elixir) lib/task/supervised.ex:85: Task.Supervised.do_apply/2\n    (stdlib) proc_lib.erl:247: :proc_lib.init_p_do_apply/3\nFunction: #Function<20.99386804/0 in :erl_eval.expr/5>\n    Args: []\n```\n\nInstead of `spawn/1` and `spawn_link/1`, we use `Task.start/1` and `Task.start_link/1` which return `{:ok, pid}` rather than just the PID. This is what enables tasks to be used in supervision trees. Furthermore, `Task` provides convenience functions, like `Task.async/1` and `Task.await/1`, and functionality to ease distribution.\n\nWe will explore tasks and other abstractions around processes in the [\"Mix and OTP guide\"](../mix-and-otp/introduction-to-mix.md).","ref":"processes.html#tasks"},{"type":"extras","title":"State - Processes","doc":"We haven't talked about state so far. If you are building an application that requires state, for example, to keep your application configuration, or you need to parse a file and keep it in memory, where would you store it?\n\nProcesses are the most common answer to this question. We can write processes that loop infinitely, maintain state, and send and receive messages. As an example, let's write a module that starts new processes that work as a key-value store in a file named `kv.exs`:\n\n```live-elixir\ndefmodule KV do\n  def start_link do\n    Task.start_link(fn -> loop(%{}) end)\n  end\n\n  defp loop(map) do\n    receive do\n      {:get, key, caller} ->\n        send(caller, Map.get(map, key))\n        loop(map)\n      {:put, key, value} ->\n        loop(Map.put(map, key, value))\n    end\n  end\nend\n```\n\nNote that the `start_link` function starts a new process that runs the `loop/1` function, starting with an empty map. The `loop/1` (private) function then waits for messages and performs the appropriate action for each message. We made `loop/1` private by using `defp` instead of `def`. In the case of a `:get` message, it sends a message back to the caller and calls `loop/1` again, to wait for a new message. While the `:put` message actually invokes `loop/1` with a new version of the map, with the given `key` and `value` stored.\n\nLet's give it a try by running `iex kv.exs`:\n\n<!-- TODO-SWM: flush() -->\n\n```elixir\niex> {:ok, pid} = KV.start_link()\n{:ok, #PID<0.62.0>}\niex> send(pid, {:get, :hello, self()})\n{:get, :hello, #PID<0.41.0>}\niex> flush()\nnil\n:ok\n```\n\nAt first, the process map has no keys, so sending a `:get` message and then flushing the current process inbox returns `nil`. Let's send a `:put` message and try it again:\n\n```elixir\niex> send(pid, {:put, :hello, :world})\n{:put, :hello, :world}\niex> send(pid, {:get, :hello, self()})\n{:get, :hello, #PID<0.41.0>}\niex> flush()\n:world\n:ok\n```\n\nNotice how the process is keeping a state and we can get and update this state by sending the process messages. In fact, any process that knows the `pid` above will be able to send it messages and manipulate the state.\n\nIt is also possible to register the `pid`, giving it a name, and allowing everyone that knows the name to send it messages:\n\n```elixir\niex> Process.register(pid, :kv)\ntrue\niex> send(:kv, {:get, :hello, self()})\n{:get, :hello, #PID<0.41.0>}\niex> flush()\n:world\n:ok\n```\n\nUsing processes to maintain state and name registration are very common patterns in Elixir applications. However, most of the time, we won't implement those patterns manually as above, but by using one of the many abstractions that ship with Elixir. For example, Elixir provides `Agent`s, which are simple abstractions around state. Our code above could be directly written as:\n\n```live-elixir\niex> {:ok, pid} = Agent.start_link(fn -> %{} end)\n{:ok, #PID<0.72.0>}\niex> Agent.update(pid, fn map -> Map.put(map, :hello, :world) end)\n:ok\niex> Agent.get(pid, fn map -> Map.get(map, :hello) end)\n:world\n```\n\nA `:name` option could also be given to `Agent.start_link/2` and it would be automatically registered. Besides agents, Elixir provides an API for building generic servers (called `GenServer`), registries, and more, all powered by processes underneath. Those, along with supervision trees, will be explored with more detail in the [\"Mix and OTP guide\"](../mix-and-otp/introduction-to-mix.md), which will build a complete Elixir application from start to finish.\n\nFor now, let's move on and explore the world of I/O in Elixir.","ref":"processes.html#state"},{"type":"extras","title":"IO and the file system","doc":"# IO and the file system\n\nThis chapter introduces the input/output mechanisms, file-system-related tasks, and related modules such as `IO`, `File`, and `Path`. The IO system provides a great opportunity to shed some light on some philosophies and curiosities of Elixir and the Erlang VM.","ref":"io-and-the-file-system.html"},{"type":"extras","title":"The `IO` module - IO and the file system","doc":"The `IO` module is the main mechanism in Elixir for reading and writing to standard input/output (`:stdio`), standard error (`:stderr`), files, and other IO devices. Usage of the module is pretty straightforward:\n\n```elixir\niex> IO.puts(\"hello world\")\nhello world\n:ok\niex> IO.gets(\"yes or no? \")\nyes or no? yes\n\"yes\\n\"\n```\n\nBy default, functions in the `IO` module read from the standard input and write to the standard output. We can change that by passing, for example, `:stderr` as an argument (in order to write to the standard error device):\n\n```live-elixir\niex> IO.puts(:stderr, \"hello world\")\nhello world\n:ok\n```","ref":"io-and-the-file-system.html#the-io-module"},{"type":"extras","title":"The `File` module - IO and the file system","doc":"The `File` module contains functions that allow us to open files as IO devices. By default, files are opened in binary mode, which requires developers to use the specific `IO.binread/2` and `IO.binwrite/2` functions from the `IO` module:\n\n> #### Potential data loss warning {: .warning}\n>\n> The following code opens a file for writing. If an existing file is available at the given path, its contents will be deleted.\n\n```elixir\niex> {:ok, file} = File.open(\"path/to/file/hello\", [:write])\n{:ok, #PID<0.47.0>}\niex> IO.binwrite(file, \"world\")\n:ok\niex> File.close(file)\n:ok\niex> File.read(\"path/to/file/hello\")\n{:ok, \"world\"}\n```\n\nThe file could be opened with the `:append` option, instead of `:write`, to preserve its contents. You may also pass the `:utf8` option, which tells the `File` module to interpret the bytes read from the file as UTF-8-encoded bytes.\n\nBesides functions for opening, reading and writing files, the `File` module has many functions to work with the file system. Those functions are named after their UNIX equivalents. For example, `File.rm/1` can be used to remove files, `File.mkdir/1` to create directories, `File.mkdir_p/1` to create directories and all their parent chain. There are even `File.cp_r/2` and `File.rm_rf/1` to respectively copy and remove files and directories recursively (i.e., copying and removing the contents of the directories too).\n\nYou will also notice that functions in the `File` module have two variants: one \"regular\" variant and another variant with a trailing bang (`!`). For example, when we read the `\"hello\"` file in the example above, we use `File.read/1`. Alternatively, we can use `File.read!/1`:\n\n```elixir\niex> File.read(\"path/to/file/hello\")\n{:ok, \"world\"}\niex> File.read!(\"path/to/file/hello\")\n\"world\"\niex> File.read(\"path/to/file/unknown\")\n{:error, :enoent}\niex> File.read!(\"path/to/file/unknown\")\n** (File.Error) could not read file \"path/to/file/unknown\": no such file or directory\n```\n\nNotice that the version with `!` returns the contents of the file instead of a tuple, and if anything goes wrong the function raises an error.\n\nThe version without `!` is preferred when you want to handle different outcomes using pattern matching:\n\n```elixir\ncase File.read(\"path/to/file/hello\") do\n  {:ok, body} -> # do something with the `body`\n  {:error, reason} -> # handle the error caused by `reason`\nend\n```\n\nHowever, if you expect the file to be there, the bang variation is more useful as it raises a meaningful error message. Avoid writing:\n\n```elixir\n{:ok, body} = File.read(\"path/to/file/unknown\")\n```\n\nas, in case of an error, `File.read/1` will return `{:error, reason}` and the pattern matching will fail. You will still get the desired result (a raised error), but the message will be about the pattern which doesn't match (thus being cryptic in respect to what the error actually is about).\n\nTherefore, if you don't want to handle the error outcomes, prefer to use the functions ending with an exclamation mark, such as `File.read!/1`.","ref":"io-and-the-file-system.html#the-file-module"},{"type":"extras","title":"The `Path` module - IO and the file system","doc":"The majority of the functions in the `File` module expect paths as arguments. Most commonly, those paths will be regular binaries. The `Path` module provides facilities for working with such paths:\n\n```live-elixir\niex> Path.join(\"foo\", \"bar\")\n\"foo/bar\"\niex> Path.expand(\"~/hello\")\n\"/Users/jose/hello\"\n```\n\nUsing functions from the `Path` module as opposed to directly manipulating strings is preferred since the `Path` module takes care of different operating systems transparently. Finally, keep in mind that Elixir will automatically convert slashes (`/`) into backslashes (`\\`) on Windows when performing file operations.\n\nWith this, we have covered the main modules that Elixir provides for dealing with IO and interacting with the file system. In the next section, we will peek a bit under the covers and learn how the IO system is implemented in the VM.","ref":"io-and-the-file-system.html#the-path-module"},{"type":"extras","title":"Processes - IO and the file system","doc":"You may have noticed that `File.open/2` returns a tuple like `{:ok, pid}`:\n\n```elixir\niex> {:ok, file} = File.open(\"hello\")\n{:ok, #PID<0.47.0>}\n```\n\nThis happens because the `IO` module actually works with processes (see [the previous chapter](processes.md)). Given a file is a process, when you write to a file that has been closed, you are actually sending a message to a process which has been terminated:\n\n```elixir\niex> File.close(file)\n:ok\niex> IO.write(file, \"is anybody out there\")\n** (ErlangError) Erlang error: :terminated:\n\n  * 1st argument: the device has terminated\n\n    (stdlib 5.0) io.erl:94: :io.put_chars(#PID<0.114.0>, \"is anybody out there\")\n    iex:4: (file)\n```\n\nLet's see in more detail what happens when you request `IO.write(pid, binary)`. The `IO` module sends a message to the process identified by `pid` with the desired operation. A small ad-hoc process can help us see it:\n\n```elixir\niex> pid = spawn(fn ->\n...>  receive do: (msg -> IO.inspect(msg))\n...> end)\n#PID<0.57.0>\niex> IO.write(pid, \"hello\")\n{:io_request, #PID<0.41.0>, #Reference<0.0.8.91>,\n {:put_chars, :unicode, \"hello\"}}\n** (ErlangError) erlang error: :terminated\n```\n\nAfter `IO.write/2`, we can see the request sent by the `IO` module printed out (a four-elements tuple). Soon after that, we see that it fails since the `IO` module expected some kind of result, which we did not supply.\n\nBy modeling IO devices with processes, the Erlang VM allows us to even read and write to files across nodes. Neat!\n\n## `iodata` and `chardata`\n\nIn all of the examples above, we used binaries when writing to files. However, most of the IO functions in Elixir also accept either \"iodata\" or \"chardata\".\n\nOne of the main reasons for using \"iodata\" and \"chardata\" is for performance. For example,\nimagine you need to greet someone in your application:\n\n```live-elixir\nname = \"Mary\"\nIO.puts(\"Hello \" <> name <> \"!\")\n```\n\nGiven strings in Elixir are immutable, as most data structures, the example above will copy the string \"Mary\" into the new \"Hello Mary!\" string. While this is unlikely to matter for the short string as above, copying can be quite expensive for large strings! For this reason, the IO functions in Elixir allow you to pass instead a list of strings:\n\n```live-elixir\nname = \"Mary\"\nIO.puts([\"Hello \", name, \"!\"])\n```\n\nIn the example above, there is no copying. Instead we create a list that contains the original name. We call such lists either \"iodata\" or \"chardata\" and we will learn the precise difference between them soon.\n\nThose lists are very useful because it can actually simplify the processing strings in several scenarios. For example, imagine you have a list of values, such as `[\"apple\", \"banana\", \"lemon\"]` that you want to write to disk separated by commas. How can you achieve this?\n\nOne option is to use `Enum.join/2` and convert the values to a string:\n\n```live-elixir\niex> Enum.join([\"apple\", \"banana\", \"lemon\"], \",\")\n\"apple,banana,lemon\"\n```\n\nThe above returns a new string by copying each value into the new string. However, with the knowledge in this section, we know that we can pass a list of strings to the IO/File functions. So instead we can do:\n\n```live-elixir\niex> Enum.intersperse([\"apple\", \"banana\", \"lemon\"], \",\")\n[\"apple\", \",\", \"banana\", \",\", \"lemon\"]\n```\n\n\"iodata\" and \"chardata\" do not only contain strings, but they may contain arbitrary nested lists of strings too:\n\n```live-elixir\niex> IO.puts([\"apple\", [\",\", \"banana\", [\",\", \"lemon\"]]])\n```\n\n\"iodata\" and \"chardata\" may also contain integers. For example, we could print our comma separated list of values by using `?,` as separator, which is the integer representing a comma (`44`):\n\n```live-elixir\niex> IO.puts([\"apple\", ?,, \"banana\", ?,, \"lemon\"])\n```\n\nThe difference between \"iodata\" and \"chardata\" is precisely what said integer represents. For iodata, the integers represent bytes. For chardata, the integers represent Unicode codepoints. For ASCII characters, the byte representation is the same as the codepoint representation, so it fits both classifications. However, the default IO device works with chardata, which means we can do:\n\n```live-elixir\niex> IO.puts([?O, ?l, ?á, ?\\s, \"Mary\", ?!])\n```\n\nOverall, integers in a list may represent either a bunch of bytes or a bunch of characters and which one to use depends on the encoding of the IO device. If the file is opened without encoding, the file is expected to be in raw mode, and the functions in the `IO` module starting with `bin*` must be used. Those functions expect an `iodata` as an argument, where integers in the list would represent bytes.\n\nOn the other hand, the default IO device (`:stdio`) and files opened with `:utf8` encoding work with the remaining functions in the `IO` module. Those functions expect a `chardata` as an argument, where integers represent codepoints.\n\nAlthough this is a subtle difference, you only need to worry about these details if you intend to pass lists containing integers to those functions. If you pass binaries, or list of binaries, then there is no ambiguity.\n\nFinally, there is one last construct called charlist, which [we discussed in earlier chapters](binaries-strings-and-charlists.md). Charlists are a special case of chardata where all values are integers representing Unicode codepoints. They can be created with the `~c` sigil:\n\n```live-elixir\niex> ~c\"hello\"\n~c\"hello\"\n```\n\nCharlists mostly show up when interfacing with Erlang, as some Erlang APIs use charlist as their representation for strings. For this reason, any list containing printable ASCII codepoints will be printed as a charlist:\n\n```live-elixir\niex> [?a, ?b, ?c]\n~c\"abc\"\n```\n\nWe packed a lot into this small section, so let's break it down:\n\n- iodata and chardata are lists of binaries and integers. Those binaries and integers can be arbitrarily nested inside lists. Their goal is to give flexibility and performance when working with IO devices and files;\n\n- the choice between iodata and chardata depends on the encoding of the IO device. If the file is opened without encoding, the file expects iodata, and the functions in the `IO` module starting with `bin*` must be used. The default IO device (`:stdio`) and files opened with `:utf8` encoding expect chardata and work with the remaining functions in the `IO` module;\n\n- charlists are a special case of chardata, where it exclusively uses a list of integers Unicode codepoints. They can be created with the `~c` sigil. Lists of integers are automatically printed using the `~c` sigil if all integers in a list represent printable ASCII codepoints.\n\nThis finishes our tour of IO devices and IO related functionality. We have learned about three Elixir modules - `IO`, `File`, and `Path` - as well as how the VM uses processes for the underlying IO mechanisms and how to use `chardata` and `iodata` for IO operations.","ref":"io-and-the-file-system.html#processes"},{"type":"extras","title":"alias, require, import, and use","doc":"# alias, require, import, and use\n\nIn order to facilitate software reuse, Elixir provides three directives (`alias`, `require`, and `import`) plus a macro called `use` summarized below:\n\n```elixir\n# Alias the module so it can be called as Bar instead of Foo.Bar\nalias Foo.Bar, as: Bar\n\n# Require the module in order to use its macros\nrequire Foo\n\n# Import functions from Foo so they can be called without the `Foo.` prefix\nimport Foo\n\n# Invokes the custom code defined in Foo as an extension point\nuse Foo\n```\n\nWe are going to explore them in detail now. Keep in mind the first three are called directives because they have _lexical scope_, while `use` is a common extension point that allows the used module to inject code.","ref":"alias-require-and-import.html"},{"type":"extras","title":"alias - alias, require, import, and use","doc":"`alias` allows you to set up aliases for any given module name.\n\nImagine a module uses a specialized list implemented in `Math.List`. The `alias` directive allows referring to `Math.List` just as `List` within the module definition:\n\n```elixir\ndefmodule Stats do\n  alias Math.List, as: List\n  # In the remaining module definition List expands to Math.List.\nend\n```\n\nThe original `List` can still be accessed within `Stats` by the fully-qualified name `Elixir.List`.\n\n> All modules defined in Elixir are defined inside the main `Elixir` namespace, such as `Elixir.String`. However, for convenience, you can omit \"Elixir.\" when referencing them.\n\nAliases are frequently used to define shortcuts. In fact, calling `alias` without an `:as` option sets the alias automatically to the last part of the module name, for example:\n\n```elixir\nalias Math.List\n```\n\nIs the same as:\n\n```elixir\nalias Math.List, as: List\n```\n\nNote that `alias` is _lexically scoped_, which allows you to set aliases inside specific functions:\n\n```elixir\ndefmodule Math do\n  def plus(a, b) do\n    alias Math.List\n    # ...\n  end\n\n  def minus(a, b) do\n    # ...\n  end\nend\n```\n\nIn the example above, since we are invoking `alias` inside the function `plus/2`, the alias will be valid only inside the function `plus/2`. `minus/2` won't be affected at all.","ref":"alias-require-and-import.html#alias"},{"type":"extras","title":"require - alias, require, import, and use","doc":"Elixir provides macros as a mechanism for meta-programming (writing code that generates code). Macros are expanded at compile time.\n\nPublic functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in.\n\n```live-elixir\niex> Integer.is_odd(3)\n** (UndefinedFunctionError) function Integer.is_odd/1 is undefined or private. However, there is a macro with the same name and arity. Be sure to require Integer if you intend to invoke this macro\n    (elixir) Integer.is_odd(3)\niex> require Integer\nInteger\niex> Integer.is_odd(3)\ntrue\n```\n\nIn Elixir, `Integer.is_odd/1` is defined as a macro so that it can be used as a guard. This means that, in order to invoke `Integer.is_odd/1`, we need to first require the `Integer` module.\n\nNote that like the `alias` directive, `require` is also lexically scoped. We will talk more about macros in a later chapter.","ref":"alias-require-and-import.html#require"},{"type":"extras","title":"import - alias, require, import, and use","doc":"We use `import` whenever we want to access functions or macros from other modules without using the fully-qualified name. Note we can only import public functions, as private functions are never accessible externally.\n\nFor example, if we want to use the `duplicate/2` function from the `List` module several times, we can import it:\n\n```live-elixir\niex> import List, only: [duplicate: 2]\nList\niex> duplicate(:ok, 3)\n[:ok, :ok, :ok]\n```\n\nWe imported only the function `duplicate` (with arity 2) from `List`. Although `:only` is optional, its usage is recommended in order to avoid importing all the functions of a given module inside the current scope. `:except` could also be given as an option in order to import everything in a module except a list of functions.\n\nNote that `import` is _lexically scoped_ too. This means that we can import specific macros or functions inside function definitions:\n\n```live-elixir\ndefmodule Math do\n  def some_function do\n    import List, only: [duplicate: 2]\n    duplicate(:ok, 10)\n  end\nend\n```\n\nIn the example above, the imported `List.duplicate/2` is only visible within that specific function. `duplicate/2` won't be available in any other function in that module (or any other module for that matter).\n\nWhile `import`s can be a useful for frameworks and libraries to build abstractions, developers should generally prefer `alias` to `import` on their own codebases, as aliases make the origin of the function being invoked clearer.","ref":"alias-require-and-import.html#import"},{"type":"extras","title":"use - alias, require, import, and use","doc":"The `use` macro is frequently used as an extension point. This means that, when you `use` a module `FooBar`, you allow that module to inject _any_ code in the current module, such as importing itself or other modules, defining new functions, setting a module state, etc.\n\nFor example, in order to write tests using the ExUnit framework, a developer should use the `ExUnit.Case` module:\n\n```elixir\ndefmodule AssertionTest do\n  use ExUnit.Case, async: true\n\n  test \"always pass\" do\n    assert true\n  end\nend\n```\n\nBehind the scenes, `use` requires the given module and then calls the `__using__/1` callback on it allowing the module to inject some code into the current context. Some modules (for example, the above `ExUnit.Case`, but also `Supervisor` and `GenServer`) use this mechanism to populate your module with some basic behaviour, which your module is intended to override or complete.\n\nGenerally speaking, the following module:\n\n```elixir\ndefmodule Example do\n  use Feature, option: :value\nend\n```\n\nis compiled into\n\n```elixir\ndefmodule Example do\n  require Feature\n  Feature.__using__(option: :value)\nend\n```\n\nSince `use` allows any code to run, we can't really know the side-effects of using a module without reading its documentation. Therefore use this function with care and only if strictly required. Don't use `use` where an `import` or `alias` would do.","ref":"alias-require-and-import.html#use"},{"type":"extras","title":"Understanding Aliases - alias, require, import, and use","doc":"At this point, you may be wondering: what exactly is an Elixir alias and how is it represented?\n\nAn alias in Elixir is a capitalized identifier (like `String`, `Keyword`, etc) which is converted to an atom during compilation. For instance, the `String` alias translates by default to the atom `:\"Elixir.String\"`:\n\n```live-elixir\niex> is_atom(String)\ntrue\niex> to_string(String)\n\"Elixir.String\"\niex> :\"Elixir.String\" == String\ntrue\n```\n\nBy using the `alias/2` directive, we are changing the atom the alias expands to.\n\nAliases expand to atoms because in the Erlang Virtual Machine (and consequently Elixir) modules are always represented by atoms:\n\n```live-elixir\niex> List.flatten([1, [2], 3])\n[1, 2, 3]\niex> :\"Elixir.List\".flatten([1, [2], 3])\n[1, 2, 3]\n```\n\nThat's the mechanism we use to call Erlang modules:\n\n```live-elixir\niex> :lists.flatten([1, [2], 3])\n[1, 2, 3]\n```","ref":"alias-require-and-import.html#understanding-aliases"},{"type":"extras","title":"Module nesting - alias, require, import, and use","doc":"Now that we have talked about aliases, we can talk about nesting and how it works in Elixir. Consider the following example:\n\n```live-elixir\ndefmodule Foo do\n  defmodule Bar do\n  end\nend\n```\n\nThe example above will define two modules: `Foo` and `Foo.Bar`. The second can be accessed as `Bar` inside `Foo` as long as they are in the same lexical scope.\n\nIf, later, the `Bar` module is moved outside the `Foo` module definition, it must be referenced by its full name (`Foo.Bar`) or an alias must be set using the `alias` directive discussed above.\n\n**Note**: in Elixir, you don't have to define the `Foo` module before being able to define the `Foo.Bar` module, as they are effectively independent. The above could also be written as:\n\n```live-elixir\ndefmodule Foo.Bar do\nend\n\ndefmodule Foo do\n  alias Foo.Bar\n  # Can still access it as `Bar`\nend\n```\n\nAliasing a nested module does not bring parent modules into scope. Consider the following example:\n\n```live-elixir\ndefmodule Foo do\n  defmodule Bar do\n    defmodule Baz do\n    end\n  end\nend\n\nalias Foo.Bar.Baz\n# The module `Foo.Bar.Baz` is now available as `Baz`\n# However, the module `Foo.Bar` is *not* available as `Bar`\n```\n\nAs we will see in later chapters, aliases also play a crucial role in macros, to guarantee they are hygienic.","ref":"alias-require-and-import.html#module-nesting"},{"type":"extras","title":"Multi alias/import/require/use - alias, require, import, and use","doc":"It is possible to `alias`, `import`, `require`, or `use` multiple modules at once. This is particularly useful once we start nesting modules, which is very common when building Elixir applications. For example, imagine you have an application where all modules are nested under `MyApp`, you can alias the modules `MyApp.Foo`, `MyApp.Bar` and `MyApp.Baz` at once as follows:\n\n```elixir\nalias MyApp.{Foo, Bar, Baz}\n```\n\nWith this, we have finished our tour of Elixir modules. The next topic to cover is module attributes.","ref":"alias-require-and-import.html#multi-alias-import-require-use"},{"type":"extras","title":"Module attributes","doc":"# Module attributes\n\nModule attributes in Elixir serve three purposes:\n\n1. as module and function annotations\n2. as temporary module storage to be used during compilation\n3. as compile-time constants\n\nLet's check these examples.","ref":"module-attributes.html"},{"type":"extras","title":"As annotations - Module attributes","doc":"Elixir brings the concept of module attributes from Erlang. For example:\n\n```live-elixir\ndefmodule MyServer do\n  @moduledoc \"My server code.\"\nend\n```\n\nIn the example above, we are defining the module documentation by using the module attribute syntax. Elixir has a handful of reserved attributes. Here are a few of them, the most commonly used ones:\n\n- `@moduledoc` — provides documentation for the current module.\n- `@doc` — provides documentation for the function or macro that follows the attribute.\n- `@spec` — provides a typespec for the function that follows the attribute.\n- `@behaviour` — (notice the British spelling) used for specifying an OTP or user-defined behaviour.\n\n`@moduledoc` and `@doc` are by far the most used attributes, and we expect you to use them a lot. Elixir treats documentation as first-class and provides many functions to access documentation. We will cover them [in their own chapter](writing-documentation.md).\n\nLet's go back to the `Math` module defined in the previous chapters, add some documentation and save it to the `math.ex` file:\n\n```live-elixir\ndefmodule Math do\n  @moduledoc \"\"\"\n  Provides math-related functions.","ref":"module-attributes.html#as-annotations"},{"type":"extras","title":"Examples - Module attributes","doc":"iex> Math.sum(1, 2)\n      3\n\n  \"\"\"\n\n  @doc \"\"\"\n  Calculates the sum of two numbers.\n  \"\"\"\n  def sum(a, b), do: a + b\nend\n```\n\nElixir promotes the use of Markdown with heredocs to write readable documentation. Heredocs are multi-line strings, they start and end with triple double-quotes, keeping the formatting of the inner text. We can access the documentation of any compiled module directly from IEx:\n\n```console\n$ elixirc math.ex\n$ iex\n```\n\n```elixir\niex> h Math # Access the docs for the module Math\n...\niex> h Math.sum # Access the docs for the sum function\n...\n```\n\nWe also provide a tool called [ExDoc](https://github.com/elixir-lang/ex_doc) which is used to generate HTML pages from the documentation.\n\nYou can take a look at the docs for `Module` for a complete list of supported attributes. Elixir also uses attributes to annotate our code with [typespecs](../references/typespecs.md).","ref":"module-attributes.html#examples"},{"type":"extras","title":"As temporary storage - Module attributes","doc":"So far, we have seen how to define attributes, but how can read them? Let's see an example:\n\n```live-elixir\ndefmodule MyServer do\n  @service URI.parse(\"https://example.com\")\n  IO.inspect @service\nend\n```\n\n> #### Newlines {: .warning}\n>\n> Do not add a newline between the attribute and its value, otherwise Elixir will assume you are reading the value, rather than setting it.\n\nTrying to access an attribute that was not defined will print a warning:\n\n```live-elixir\ndefmodule MyServer do\n  @unknown\nend\nwarning: undefined module attribute @unknown, please remove access to @unknown or explicitly set it before access\n```\n\nAttributes can also be read inside functions:\n\n```live-elixir\ndefmodule MyApp.Status do\n  @service URI.parse(\"https://example.com\")\n  def status(email) do\n    SomeHttpClient.get(@service)\n  end\nend\n```\n\nThe module attribute is defined at compilation time and its _return value_, not the function call itself, is what will be substituted in for the attribute. So the above will effectively compile to this:\n\n```elixir\ndefmodule MyApp.Status do\n  def status(email) do\n    SomeHttpClient.get(%URI{\n      authority: \"example.com\",\n      host: \"example.com\",\n      port: 443,\n      scheme: \"https\"\n    })\n  end\nend\n```\n\nThis can be useful for pre-computing values and then injecting its results into the module. This is what we mean by temporary storage: after the module is compiled, the module attribute is discarded, except for the functions that have read the attribute. Note you cannot invoke functions defined in the same module as part of the attribute itself, as those functions have not yet been defined.\n\nEvery time we read an attribute inside a function, Elixir takes a snapshot of its current value. Therefore if you read the same attribute multiple times inside multiple functions, you end-up increasing compilation times as Elixir now has to compile every snapshot. Generally speaking, you want to avoid reading the same attribute multiple times and instead move it to function. For example, instead of this:\n\n```elixir\ndef some_function, do: do_something_with(@example)\ndef another_function, do: do_something_else_with(@example)\n```\n\nPrefer this:\n\n```elixir\ndef some_function, do: do_something_with(example())\ndef another_function, do: do_something_else_with(example())\ndefp example, do: @example\n```","ref":"module-attributes.html#as-temporary-storage"},{"type":"extras","title":"As compile-time constants - Module attributes","doc":"Module attributes may also be useful as compile-time constants. Generally speaking, functions themselves are sufficient for the role of constants in a codebase. For example, instead of defining:\n\n```elixir\n@hours_in_a_day 24\n```\n\nYou should prefer:\n\n```elixir\ndefp hours_in_a_day(), do: 24\n```\n\nYou may even define a public function if it needs to be shared across modules. It is common in many projects to have a module called `MyApp.Constants` that defines all constants used throughout the codebase.\n\nYou can even have composite data structures as constants, as long as they are made exclusively of other data types (no function calls, no operators, and no other expressions). For example, you may specify a system configuration constant as follows:\n\n```elixir\ndefp system_config(), do: %{timezone: \"Etc/UTC\", locale: \"pt-BR\"}\n```\n\nGiven data structures in Elixir are immutable, only a single instance of the data structure above is allocated and shared across all functions calls, as long as it doesn't have any executable expression.\n\nThe use case for module attributes arise when you need to do some work at compile-time and then inject its results inside a function. A common scenario is module attributes inside patterns and guards (as an alternative to `defguard/1`), since they only support a limited set of expressions:\n\n```elixir\n# Inside pattern\n@default_timezone \"Etc/UTC\"\ndef shift(@default_timezone), do: ...\n\n# Inside guards\n@time_periods [:am, :pm]\ndef shift(time, period) when period in @time_periods, do: ...\n```\n\nModule attributes as constants and as temporary storage are most often used together: the module attribute is used to compute and store an expensive value, and then exposed as constant from that module.","ref":"module-attributes.html#as-compile-time-constants"},{"type":"extras","title":"Going further - Module attributes","doc":"Libraries and frameworks can leverage module attributes to provide custom annotations. To see an example, look no further than Elixir's unit test framework called `ExUnit`. ExUnit uses module attributes for multiple different purposes:\n\n```elixir\ndefmodule MyTest do\n  use ExUnit.Case, async: true\n\n  @tag :external\n  @tag os: :unix\n  test \"contacts external service\" do\n    # ...\n  end\nend\n```\n\nIn the example above, `ExUnit` stores the value of `async: true` in a module attribute to change how the module is compiled. Tags also work as annotations and they can be supplied multiple times, thanks to Elixir's ability to [accumulate attribute](`Module.register_attribute/3`). Then you can use tags to setup and filter tests, such as avoiding executing Unix specific tests while running your test suite on Windows.\n\nTo fully understand how ExUnit works, we'd need macros, so we will revisit this pattern in the Meta-programming guide and learn how to use module attributes as storage for custom annotations.\n\nIn the next chapters, we'll explore structs and protocols before moving to exception handling and other constructs like sigils and comprehensions.","ref":"module-attributes.html#going-further"},{"type":"extras","title":"Structs","doc":"# Structs\n\nWe learned about maps [in earlier chapters](keywords-and-maps.md):\n\n```live-elixir\niex> map = %{a: 1, b: 2}\n%{a: 1, b: 2}\niex> map[:a]\n1\niex> %{map | a: 3}\n%{a: 3, b: 2}\n```\n\nStructs are extensions built on top of maps that provide compile-time checks and default values.","ref":"structs.html"},{"type":"extras","title":"Defining structs - Structs","doc":"To define a struct, the `defstruct/1` construct is used:\n\n```live-elixir\niex> defmodule User do\n...>   defstruct name: \"John\", age: 27\n...> end\n```\n\nThe keyword list used with `defstruct` defines what fields the struct will have along with their default values. Structs take the name of the module they're defined in. In the example above, we defined a struct named `User`.\n\nWe can now create `User` structs by using a syntax similar to the one used to create maps:\n\n```live-elixir\niex> %User{}\n%User{age: 27, name: \"John\"}\niex> %User{name: \"Jane\"}\n%User{age: 27, name: \"Jane\"}\n```\n\nStructs provide _compile-time_ guarantees that only the fields defined through `defstruct` will be allowed to exist in a struct:\n\n```live-elixir\niex> %User{oops: :field}\n** (KeyError) key :oops not found expanding struct: User.__struct__/1\n```","ref":"structs.html#defining-structs"},{"type":"extras","title":"Accessing and updating structs - Structs","doc":"Structs share the same syntax for accessing and updating fields as maps of fixed keys:\n\n```live-elixir\niex> john = %User{}\n%User{age: 27, name: \"John\"}\niex> john.name\n\"John\"\niex> jane = %{john | name: \"Jane\"}\n%User{age: 27, name: \"Jane\"}\niex> %{jane | oops: :field}\n** (KeyError) key :oops not found in: %User{age: 27, name: \"Jane\"}\n```\n\nWhen using the update syntax (`|`), Elixir is aware that no new keys will be added to the struct, allowing the maps underneath to share their structure in memory. In the example above, both `john` and `jane` share the same key structure in memory.\n\nStructs can also be used in pattern matching, both for matching on the value of specific keys as well as for ensuring that the matching value is a struct of the same type as the matched value.\n\n```live-elixir\niex> %User{name: name} = john\n%User{age: 27, name: \"John\"}\niex> name\n\"John\"\niex> %User{} = %{}\n** (MatchError) no match of right hand side value: %{}\n```","ref":"structs.html#accessing-and-updating-structs"},{"type":"extras","title":"Structs are bare maps underneath - Structs","doc":"Structs are simply maps with a \"special\" field named `__struct__` that holds the name of the struct:\n\n```live-elixir\niex> is_map(john)\ntrue\niex> john.__struct__\nUser\n```\n\nHowever, structs do not inherit any of the protocols that maps do. For example, you can neither enumerate nor access a struct:\n\n```live-elixir\niex> john = %User{}\n%User{age: 27, name: \"John\"}\niex> john[:name]\n** (UndefinedFunctionError) function User.fetch/2 is undefined (User does not implement the Access behaviour)\n             User.fetch(%User{age: 27, name: \"John\"}, :name)\niex> Enum.each(john, fn {field, value} -> IO.puts(value) end)\n** (Protocol.UndefinedError) protocol Enumerable not implemented for %User{age: 27, name: \"John\"} of type User (a struct)\n```\n\nStructs alongside protocols provide one of the most important features for Elixir developers: data polymorphism. That's what we will explore in the next chapter.","ref":"structs.html#structs-are-bare-maps-underneath"},{"type":"extras","title":"Default values and required keys - Structs","doc":"If you don't specify a default key value when defining a struct, `nil` will be assumed:\n\n```live-elixir\niex> defmodule Product do\n...>   defstruct [:name]\n...> end\niex> %Product{}\n%Product{name: nil}\n```\n\nYou can define a structure combining both fields with explicit default values, and implicit `nil` values. In this case you must first specify the fields which implicitly default to nil:\n\n```live-elixir\niex> defmodule User do\n...>   defstruct [:email, name: \"John\", age: 27]\n...> end\niex> %User{}\n%User{age: 27, email: nil, name: \"John\"}\n```\n\nDoing it in reverse order will raise a syntax error:\n\n```live-elixir\niex> defmodule User do\n...>   defstruct [name: \"John\", age: 27, :email]\n...> end\n** (SyntaxError) iex:107: unexpected expression after keyword list. Keyword lists must always come last in lists and maps.\n```\n\nYou can also enforce that certain keys have to be specified when creating the struct via the `@enforce_keys` module attribute:\n\n```live-elixir\niex> defmodule Car do\n...>   @enforce_keys [:make]\n...>   defstruct [:model, :make]\n...> end\niex> %Car{}\n** (ArgumentError) the following keys must also be given when building struct Car: [:make]\n    expanding struct: Car.__struct__/1\n```\n\nEnforcing keys provides a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation.","ref":"structs.html#default-values-and-required-keys"},{"type":"extras","title":"Protocols","doc":"# Protocols\n\nProtocols are a mechanism to achieve polymorphism in Elixir where you want the behavior to vary depending on the data type. We are already familiar with one way of solving this type of problem: via pattern matching and guard clauses. Consider a simple utility module that would tell us the type of input variable:\n\n```elixir\ndefmodule Utility do\n  def type(value) when is_binary(value), do: \"string\"\n  def type(value) when is_integer(value), do: \"integer\"\n  # ... other implementations ...\nend\n```\n\nIf the use of this module were confined to your own project, you would be able to keep defining new `type/1` functions for each new data type. However, this code could be problematic if it was shared as a dependency by multiple apps because there would be no easy way to extend its functionality.\n\nThis is where protocols can help us: protocols allow us to extend the original behavior for as many data types as we need. That's because **dispatching on a protocol is available to any data type that has implemented the protocol** and a protocol can be implemented by anyone, at any time.\n\nHere's how we could write the same `Utility.type/1` functionality as a protocol:\n\n```live-elixir\ndefprotocol Utility do\n  @spec type(t) :: String.t()\n  def type(value)\nend\n\ndefimpl Utility, for: BitString do\n  def type(_value), do: \"string\"\nend\n\ndefimpl Utility, for: Integer do\n  def type(_value), do: \"integer\"\nend\n```\n\nWe define the protocol using `defprotocol/2` - its functions and specs may look similar to interfaces or abstract base classes in other languages. We can add as many implementations as we like using `defimpl/2`. The output is exactly the same as if we had a single module with multiple functions:\n\n```live-elixir\niex> Utility.type(\"foo\")\n\"string\"\niex> Utility.type(123)\n\"integer\"\n```\n\nWith protocols, however, we are no longer stuck having to continuously modify the same module to support more and more data types. For example, we could spread the `defimpl` calls above over multiple files and Elixir will dispatch the execution to the appropriate implementation based on the data type. Functions defined in a protocol may have more than one input, but the **dispatching will always be based on the data type of the first input**.\n\nOne of the most common protocols you may encounter is the `String.Chars` protocol: implementing its `to_string/1` function for your custom structs will tell the Elixir kernel how to represent them as strings. We will explore all built-in protocols later. For now, let's implement our own.","ref":"protocols.html"},{"type":"extras","title":"Example - Protocols","doc":"Now that you have seen an example of the type of problem protocols help solve and how they solve them, let's look at a more in-depth example.\n\nIn Elixir, we have two idioms for checking how many items there are in a data structure: `length` and `size`. `length` means the information must be computed. For example, `length(list)` needs to traverse the whole list to calculate its length. On the other hand, `tuple_size(tuple)` and `byte_size(binary)` do not depend on the tuple and binary size as the size information is pre-computed in the data structure.\n\nEven if we have type-specific functions for getting the size built into Elixir (such as `tuple_size/1`), we could implement a generic `Size` protocol that all data structures for which size is pre-computed would implement.\n\nThe protocol definition would look like this:\n\n```live-elixir\ndefprotocol Size do\n  @doc \"Calculates the size (and not the length!) of a data structure\"\n  def size(data)\nend\n```\n\nThe `Size` protocol expects a function called `size` that receives one argument (the data structure we want to know the size of) to be implemented. We can now implement this protocol for the data structures that would have a compliant implementation:\n\n```live-elixir\ndefimpl Size, for: BitString do\n  def size(string), do: byte_size(string)\nend\n\ndefimpl Size, for: Map do\n  def size(map), do: map_size(map)\nend\n\ndefimpl Size, for: Tuple do\n  def size(tuple), do: tuple_size(tuple)\nend\n```\n\nWe didn't implement the `Size` protocol for lists as there is no \"size\" information pre-computed for lists, and the length of a list has to be computed (with `length/1`).\n\nNow with the protocol defined and implementations in hand, we can start using it:\n\n```live-elixir\niex> Size.size(\"foo\")\n3\niex> Size.size({:ok, \"hello\"})\n2\niex> Size.size(%{label: \"some label\"})\n1\n```\n\nPassing a data type that doesn't implement the protocol raises an error:\n\n```live-elixir\niex> Size.size([1, 2, 3])\n** (Protocol.UndefinedError) protocol Size not implemented for [1, 2, 3] of type List\n```\n\nIt's possible to implement protocols for all Elixir data types:\n\n- `Atom`\n- `BitString`\n- `Float`\n- `Function`\n- `Integer`\n- `List`\n- `Map`\n- `PID`\n- `Port`\n- `Reference`\n- `Tuple`","ref":"protocols.html#example"},{"type":"extras","title":"Protocols and structs - Protocols","doc":"The power of Elixir's extensibility comes when protocols and structs are used together.\n\nIn the [previous chapter](structs.md), we have learned that although structs are maps, they do not share protocol implementations with maps. For example, `MapSet`s (sets based on maps) are implemented as structs. Let's try to use the `Size` protocol with a `MapSet`:\n\n```live-elixir\niex> Size.size(%{})\n0\niex> set = %MapSet{} = MapSet.new\nMapSet.new([])\niex> Size.size(set)\n** (Protocol.UndefinedError) protocol Size not implemented for MapSet.new([]) of type MapSet (a struct)\n```\n\nInstead of sharing protocol implementation with maps, structs require their own protocol implementation. Since a `MapSet` has its size precomputed and accessible through `MapSet.size/1`, we can define a `Size` implementation for it:\n\n```live-elixir\ndefimpl Size, for: MapSet do\n  def size(set), do: MapSet.size(set)\nend\n```\n\nIf desired, you could come up with your own semantics for the size of your struct. Not only that, you could use structs to build more robust data types, like queues, and implement all relevant protocols, such as `Enumerable` and possibly `Size`, for this data type.\n\n```live-elixir\ndefmodule User do\n  defstruct [:name, :age]\nend\n\ndefimpl Size, for: User do\n  def size(_user), do: 2\nend\n```","ref":"protocols.html#protocols-and-structs"},{"type":"extras","title":"Implementing `Any` - Protocols","doc":"Manually implementing protocols for all types can quickly become repetitive and tedious. In such cases, Elixir provides two options: we can explicitly derive the protocol implementation for our types or automatically implement the protocol for all types. In both cases, we need to implement the protocol for `Any`.","ref":"protocols.html#implementing-any"},{"type":"extras","title":"Deriving - Protocols","doc":"Elixir allows us to derive a protocol implementation based on the `Any` implementation. Let's first implement `Any` as follows:\n\n```live-elixir\ndefimpl Size, for: Any do\n  def size(_), do: 0\nend\n```\n\nThe implementation above is arguably not a reasonable one. For example, it makes no sense to say that the size of a `PID` or an `Integer` is `0`.\n\nHowever, should we be fine with the implementation for `Any`, in order to use such implementation we would need to tell our struct to explicitly derive the `Size` protocol:\n\n```live-elixir\ndefmodule OtherUser do\n  @derive [Size]\n  defstruct [:name, :age]\nend\n```\n\nWhen deriving, Elixir will implement the `Size` protocol for `OtherUser` based on the implementation provided for `Any`.","ref":"protocols.html#deriving"},{"type":"extras","title":"Fallback to `Any` - Protocols","doc":"Another alternative to `@derive` is to explicitly tell the protocol to fallback to `Any` when an implementation cannot be found. This can be achieved by setting `@fallback_to_any` to `true` in the protocol definition:\n\n```live-elixir\ndefprotocol Size do\n  @fallback_to_any true\n  def size(data)\nend\n```\n\nAs we said in the previous section, the implementation of `Size` for `Any` is not one that can apply to any data type. That's one of the reasons why `@fallback_to_any` is an opt-in behavior. For the majority of protocols, raising an error when a protocol is not implemented is the proper behavior. That said, assuming we have implemented `Any` as in the previous section:\n\n```live-elixir\ndefimpl Size, for: Any do\n  def size(_), do: 0\nend\n```\n\nNow all data types (including structs) that have not implemented the `Size` protocol will be considered to have a size of `0`.\n\nWhich technique is best between deriving and falling back to `Any` depends on the use case but, given Elixir developers prefer explicit over implicit, you may see many libraries pushing towards the `@derive` approach.","ref":"protocols.html#fallback-to-any"},{"type":"extras","title":"Built-in protocols - Protocols","doc":"Elixir ships with some built-in protocols. In previous chapters, we have discussed the `Enum` module which provides many functions that work with any data structure that implements the `Enumerable` protocol:\n\n```live-elixir\niex> Enum.map([1, 2, 3], fn x -> x * 2 end)\n[2, 4, 6]\niex> Enum.reduce(1..3, 0, fn x, acc -> x + acc end)\n6\n```\n\nAnother useful example is the `String.Chars` protocol, which specifies how to convert a data structure to its human representation as a string. It's exposed via the `to_string` function:\n\n```live-elixir\niex> to_string(:hello)\n\"hello\"\n```\n\nNotice that string interpolation in Elixir calls the `to_string` function:\n\n```live-elixir\niex> \"age: #{25}\"\n\"age: 25\"\n```\n\nThe snippet above only works because numbers implement the `String.Chars` protocol. Passing a tuple, for example, will lead to an error:\n\n```live-elixir\niex> tuple = {1, 2, 3}\n{1, 2, 3}\niex> \"tuple: #{tuple}\"\n** (Protocol.UndefinedError) protocol String.Chars not implemented for {1, 2, 3} of type Tuple\n```\n\nWhen there is a need to \"print\" a more complex data structure, one can use the `inspect` function, based on the `Inspect` protocol:\n\n```live-elixir\niex> \"tuple: #{inspect(tuple)}\"\n\"tuple: {1, 2, 3}\"\n```\n\nThe `Inspect` protocol is the protocol used to transform any data structure into a readable textual representation. This is what tools like IEx use to print results:\n\n```live-elixir\niex> {1, 2, 3}\n{1, 2, 3}\niex> %User{}\n%User{name: \"john\", age: 27}\n```\n\nKeep in mind that, by convention, whenever the inspected value starts with `#`, it is representing a data structure in non-valid Elixir syntax. This means the inspect protocol is not reversible as information may be lost along the way:\n\n```live-elixir\niex> inspect &(&1+2)\n\"#Function<6.71889879/1 in :erl_eval.expr/5>\"\n```\n\nThere are other protocols in Elixir but this covers the most common ones. You can learn more about protocols and implementations in the `Protocol` module.","ref":"protocols.html#built-in-protocols"},{"type":"extras","title":"Comprehensions","doc":"# Comprehensions\n\nIn Elixir, it is common to loop over an Enumerable, often filtering out some results and mapping values into another list. Comprehensions are syntactic sugar for such constructs: they group those common tasks into the `for` special form.\n\nFor example, we can map a list of integers into their squared values:\n\n```live-elixir\niex> for n <- [1, 2, 3, 4], do: n * n\n[1, 4, 9, 16]\n```\n\nA comprehension is made of three parts: generators, filters, and collectables.","ref":"comprehensions.html"},{"type":"extras","title":"Generators and filters - Comprehensions","doc":"In the expression above, `n <- [1, 2, 3, 4]` is the **generator**. It is literally generating values to be used in the comprehension. Any enumerable can be passed on the right-hand side of the generator expression:\n\n```live-elixir\niex> for n <- 1..4, do: n * n\n[1, 4, 9, 16]\n```\n\nGenerator expressions also support pattern matching on their left-hand side; all non-matching patterns are _ignored_. Imagine that, instead of a range, we have a keyword list where the key is the atom `:good` or `:bad` and we only want to compute the square of the `:good` values:\n\n```live-elixir\niex> values = [good: 1, good: 2, bad: 3, good: 4]\niex> for {:good, n} <- values, do: n * n\n[1, 4, 16]\n```\n\nAlternatively to pattern matching, filters can be used to select some particular elements. For example, we can select the multiples of 3 and discard all others:\n\n```live-elixir\niex> for n <- 0..5, rem(n, 3) == 0, do: n * n\n[0, 9]\n```\n\nComprehensions discard all elements for which the filter expression returns `false` or `nil`; all other values are selected.\n\nComprehensions generally provide a much more concise representation than using the equivalent functions from the `Enum` and `Stream` modules. Furthermore, comprehensions also allow multiple generators and filters to be given. Here is an example that receives a list of directories and gets the size of each file in those directories:\n\n```elixir\ndirs = [\"/home/mikey\", \"/home/james\"]\n\nfor dir <- dirs,\n    file <- File.ls!(dir),\n    path = Path.join(dir, file),\n    File.regular?(path) do\n  File.stat!(path).size\nend\n```\n\nMultiple generators can also be used to calculate the Cartesian product of two lists:\n\n```live-elixir\niex> for i <- [:a, :b, :c], j <- [1, 2], do:  {i, j}\n[a: 1, a: 2, b: 1, b: 2, c: 1, c: 2]\n```\n\nFinally, keep in mind that variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension.","ref":"comprehensions.html#generators-and-filters"},{"type":"extras","title":"Bitstring generators - Comprehensions","doc":"Bitstring generators are also supported and are very useful when you need to comprehend over bitstring streams. The example below receives a list of pixels from a binary with their respective red, green and blue values and converts them into tuples of three elements each:\n\n```live-elixir\niex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\niex> for < >, do: {r, g, b}\n[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]\n```\n\nA bitstring generator can be mixed with \"regular\" enumerable generators, and supports filters as well.","ref":"comprehensions.html#bitstring-generators"},{"type":"extras","title":"The `:into` option - Comprehensions","doc":"In the examples above, all the comprehensions returned lists as their result. However, the result of a comprehension can be inserted into different data structures by passing the `:into` option to the comprehension.\n\nFor example, a bitstring generator can be used with the `:into` option in order to easily remove all spaces in a string:\n\n```live-elixir\niex> for < >, c != ?\\s, into: \"\", do: < >\n\"helloworld\"\n```\n\nSets, maps, and other dictionaries can also be given to the `:into` option. In general, `:into` accepts any structure that implements the `Collectable` protocol.\n\nA common use case of `:into` can be transforming values in a map:\n\n```live-elixir\niex> for {key, val} <- %{\"a\" => 1, \"b\" => 2}, into: %{}, do: {key, val * val}\n%{\"a\" => 1, \"b\" => 4}\n```\n\nLet's make another example using streams. Since the `IO` module provides streams (that are both `Enumerable`s and `Collectable`s), an echo terminal that echoes back the upcased version of whatever is typed can be implemented using comprehensions:\n\n```elixir\niex> stream = IO.stream(:stdio, :line)\niex> for line <- stream, into: stream do\n...>   String.upcase(line) <> \"\\n\"\n...> end\n```\n\nNow type any string into the terminal and you will see that the same value will be printed in upper-case. Unfortunately, this example also got your IEx shell stuck in the comprehension, so you will need to hit `Ctrl+C` twice to get out of it. :)","ref":"comprehensions.html#the-into-option"},{"type":"extras","title":"Other options - Comprehensions","doc":"Comprehensions support other options, such as `:reduce` and `:uniq`. Here are additional resources to learn more about comprehensions:\n\n- [`for` official reference in Elixir documentation](`for/1`)\n- [Mitchell Hanberg's comprehensive guide to Elixir's comprehensions](https://www.mitchellhanberg.com/the-comprehensive-guide-to-elixirs-for-comprehension/)","ref":"comprehensions.html#other-options"},{"type":"extras","title":"Sigils","doc":"# Sigils\n\nElixir provides double-quoted strings as well as a concept called charlists, which are defined using the `~c\"hello world\"` sigil syntax. In this chapter, we will learn more about sigils and how to define our own.\n\nOne of Elixir's goals is extensibility: developers should be able to extend the language to fit any particular domain. Sigils provide the foundation for extending the language with custom textual representations. Sigils start with the tilde (`~`) character which is followed by either a single lower-case letter or one or more upper-case letters, and then a delimiter. Optional modifiers are added after the final delimiter.","ref":"sigils.html"},{"type":"extras","title":"Regular expressions - Sigils","doc":"The most common sigil in Elixir is `~r`, which is used to create [regular expressions](https://en.wikipedia.org/wiki/Regular_Expressions):\n\n```live-elixir\n# A regular expression that matches strings which contain \"foo\" or \"bar\":\niex> regex = ~r/foo|bar/\n~r/foo|bar/\niex> \"foo\" =~ regex\ntrue\niex> \"bat\" =~ regex\nfalse\n```\n\nElixir provides Perl-compatible regular expressions (regexes), as implemented by the [PCRE](http://www.pcre.org/) library. Regexes also support modifiers. For example, the `i` modifier makes a regular expression case insensitive:\n\n```live-elixir\niex> \"HELLO\" =~ ~r/hello/\nfalse\niex> \"HELLO\" =~ ~r/hello/i\ntrue\n```\n\nCheck out the `Regex` module for more information on other modifiers and the supported operations with regular expressions.\n\nSo far, all examples have used `/` to delimit a regular expression. However, sigils support 8 different delimiters:\n\n```elixir\n~r/hello/\n~r|hello|\n~r\"hello\"\n~r'hello'\n~r(hello)\n~r[hello]\n~r{hello}\n~r \n```\n\nThe reason behind supporting different delimiters is to provide a way to write literals without escaped delimiters. For example, a regular expression with forward slashes like `~r(^https?://)` reads arguably better than `~r/^https?:\\/\\//`. Similarly, if the regular expression has forward slashes and capturing groups (that use `()`), you may then choose double quotes instead of parentheses.","ref":"sigils.html#regular-expressions"},{"type":"extras","title":"Strings, charlists, and word lists sigils - Sigils","doc":"Besides regular expressions, Elixir ships with three other sigils.","ref":"sigils.html#strings-charlists-and-word-lists-sigils"},{"type":"extras","title":"Strings - Sigils","doc":"The `~s` sigil is used to generate strings, like double quotes are. The `~s` sigil is useful when a string contains double quotes:\n\n```live-elixir\niex> ~s(this is a string with \"double\" quotes, not 'single' ones)\n\"this is a string with \\\"double\\\" quotes, not 'single' ones\"\n```","ref":"sigils.html#strings"},{"type":"extras","title":"Charlists - Sigils","doc":"The `~c` sigil is the regular way to represent charlists.\n\n```live-elixir\niex> [?c, ?a, ?t]\n~c\"cat\"\niex> ~c(this is a char list containing \"double quotes\")\n~c\"this is a char list containing \\\"double quotes\\\"\"\n```","ref":"sigils.html#charlists"},{"type":"extras","title":"Word lists - Sigils","doc":"The `~w` sigil is used to generate lists of words (_words_ are just regular strings). Inside the `~w` sigil, words are separated by whitespace.\n\n```live-elixir\niex> ~w(foo bar bat)\n[\"foo\", \"bar\", \"bat\"]\n```\n\nThe `~w` sigil also accepts the `c`, `s` and `a` modifiers (for charlists, strings, and atoms, respectively), which specify the data type of the elements of the resulting list:\n\n```live-elixir\niex> ~w(foo bar bat)a\n[:foo, :bar, :bat]\n```","ref":"sigils.html#word-lists"},{"type":"extras","title":"Interpolation and escaping in string sigils - Sigils","doc":"Elixir supports some sigil variants to deal with escaping characters and interpolation. In particular, uppercase letters sigils do not perform interpolation nor escaping. For example, although both `~s` and `~S` will return strings, the former allows escape codes and interpolation while the latter does not:\n\n```live-elixir\niex> ~s(String with escape codes \\x26 #{\"inter\" <> \"polation\"})\n\"String with escape codes & interpolation\"\niex> ~S(String without escape codes \\x26 without #{interpolation})\n\"String without escape codes \\\\x26 without \\#{interpolation}\"\n```\n\nThe following escape codes can be used in strings and charlists:\n\n- `\\\\` – single backslash\n- `\\a` – bell/alert\n- `\\b` – backspace\n- `\\d` - delete\n- `\\e` - escape\n- `\\f` - form feed\n- `\\n` – newline\n- `\\r` – carriage return\n- `\\s` – space\n- `\\t` – tab\n- `\\v` – vertical tab\n- `\\0` - null byte\n- `\\xDD` - represents a single byte in hexadecimal (such as `\\x13`)\n- `\\uDDDD` and `\\u{D...}` - represents a Unicode codepoint in hexadecimal (such as `\\u{1F600}`)\n\nIn addition to those, a double quote inside a double-quoted string needs to be escaped as `\\\"`, and, analogously, a single quote inside a single-quoted char list needs to be escaped as `\\'`. Nevertheless, it is better style to change delimiters as seen above than to escape them.\n\nSigils also support heredocs, that is, three double-quotes or single-quotes as separators:\n\n```live-elixir\niex> ~s\"\"\"\n...> this is\n...> a heredoc string\n...> \"\"\"\n```\n\nThe most common use case for heredoc sigils is when writing documentation. For example, writing escape characters in the documentation would soon become error prone because of the need to double-escape some characters:\n\n```elixir\n@doc \"\"\"\nConverts double-quotes to single-quotes.","ref":"sigils.html#interpolation-and-escaping-in-string-sigils"},{"type":"extras","title":"Examples - Sigils","doc":"iex> convert(\"\\\\\\\"foo\\\\\\\"\")\n    \"'foo'\"\n\n\"\"\"\ndef convert(...)\n```\n\nBy using `~S`, this problem can be avoided altogether:\n\n```elixir\n@doc ~S\"\"\"\nConverts double-quotes to single-quotes.","ref":"sigils.html#examples"},{"type":"extras","title":"Examples - Sigils","doc":"iex> convert(\"\\\"foo\\\"\")\n    \"'foo'\"\n\n\"\"\"\ndef convert(...)\n```","ref":"sigils.html#examples"},{"type":"extras","title":"Calendar sigils - Sigils","doc":"Elixir offers several sigils to deal with various flavors of times and dates.","ref":"sigils.html#calendar-sigils"},{"type":"extras","title":"Date - Sigils","doc":"A [%Date{}](`Date`) struct contains the fields `year`, `month`, `day`, and `calendar`. You can create one using the `~D` sigil:\n\n```live-elixir\niex> d = ~D[2019-10-31]\n~D[2019-10-31]\niex> d.day\n31\n```","ref":"sigils.html#date"},{"type":"extras","title":"Time - Sigils","doc":"The [%Time{}](`Time`) struct contains the fields `hour`, `minute`, `second`, `microsecond`, and `calendar`. You can create one using the `~T` sigil:\n\n```live-elixir\niex> t = ~T[23:00:07.0]\n~T[23:00:07.0]\niex> t.second\n7\n```","ref":"sigils.html#time"},{"type":"extras","title":"NaiveDateTime - Sigils","doc":"The [%NaiveDateTime{}](`NaiveDateTime`) struct contains fields from both `Date` and `Time`. You can create one using the `~N` sigil:\n\n```live-elixir\niex> ndt = ~N[2019-10-31 23:00:07]\n~N[2019-10-31 23:00:07]\n```\n\nWhy is it called naive? Because it does not contain timezone information. Therefore, the given datetime may not exist at all or it may exist twice in certain timezones - for example, when we move the clock back and forward for daylight saving time.","ref":"sigils.html#naivedatetime"},{"type":"extras","title":"UTC DateTime - Sigils","doc":"A [%DateTime{}](`DateTime`) struct contains the same fields as a `NaiveDateTime` with the addition of fields to track timezones. The `~U` sigil allows developers to create a DateTime in the UTC timezone:\n\n```live-elixir\niex> dt = ~U[2019-10-31 19:59:03Z]\n~U[2019-10-31 19:59:03Z]\niex> %DateTime{minute: minute, time_zone: time_zone} = dt\n~U[2019-10-31 19:59:03Z]\niex> minute\n59\niex> time_zone\n\"Etc/UTC\"\n```","ref":"sigils.html#utc-datetime"},{"type":"extras","title":"Custom sigils - Sigils","doc":"As hinted at the beginning of this chapter, sigils in Elixir are extensible. In fact, using the sigil `~r/foo/i` is equivalent to calling `sigil_r` with a binary and a char list as the argument:\n\n```elixir\niex> sigil_r(<<\"foo\">>, [?i])\n~r\"foo\"i\n```\n\nWe can access the documentation for the `~r` sigil via `sigil_r`:\n\n```elixir\niex> h sigil_r\n...\n```\n\nWe can also provide our own sigils by implementing functions that follow the `sigil_{character}` pattern. For example, let's implement the `~i` sigil that returns an integer (with the optional `n` modifier to make it negative):\n\n```live-elixir\niex> defmodule MySigils do\n...>   def sigil_i(string, []), do: String.to_integer(string)\n...>   def sigil_i(string, [?n]), do: -String.to_integer(string)\n...> end\niex> import MySigils\niex> ~i(13)\n13\niex> ~i(42)n\n-42\n```\n\nCustom sigils may be either a single lowercase character, or an uppercase character followed by more uppercase characters and digits.\n\nSigils can also be used to do compile-time work with the help of macros. For example, regular expressions in Elixir are compiled into an efficient representation during compilation of the source code, therefore skipping this step at runtime. If you're interested in the subject, you can learn more about macros and check out how sigils are implemented in the `Kernel` module (where the `sigil_*` functions are defined).","ref":"sigils.html#custom-sigils"},{"type":"extras","title":"try, catch, and rescue","doc":"# try, catch, and rescue\n\nElixir has three error mechanisms: errors, throws, and exits. In this chapter, we will explore each of them and include remarks about when each should be used.","ref":"try-catch-and-rescue.html"},{"type":"extras","title":"Errors - try, catch, and rescue","doc":"Errors (or _exceptions_) are used when exceptional things happen in the code. A sample error can be retrieved by trying to add a number to an atom:\n\n```live-elixir\niex> :foo + 1\n** (ArithmeticError) bad argument in arithmetic expression\n     :erlang.+(:foo, 1)\n```\n\nA runtime error can be raised any time by using `raise/1`:\n\n```live-elixir\niex> raise \"oops\"\n** (RuntimeError) oops\n```\n\nOther errors can be raised with `raise/2` passing the error name and a list of keyword arguments:\n\n```live-elixir\niex> raise ArgumentError, message: \"invalid argument foo\"\n** (ArgumentError) invalid argument foo\n```\n\nYou can also define your own errors by creating a module and using the `defexception/1` construct inside it. This way, you'll create an error with the same name as the module it's defined in. The most common case is to define a custom exception with a message field:\n\n```live-elixir\niex> defmodule MyError do\n...>   defexception message: \"default message\"\n...> end\niex> raise MyError\n** (MyError) default message\niex> raise MyError, message: \"custom message\"\n** (MyError) custom message\n```\n\nErrors can be **rescued** using the `try/rescue` construct:\n\n```live-elixir\niex> try do\n...>   raise \"oops\"\n...> rescue\n...>   e in RuntimeError -> e\n...> end\n%RuntimeError{message: \"oops\"}\n```\n\nThe example above rescues the runtime error and returns the exception itself, which is then printed in the `iex` session.\n\nIf you don't have any use for the exception, you don't have to pass a variable to `rescue`:\n\n```live-elixir\niex> try do\n...>   raise \"oops\"\n...> rescue\n...>   RuntimeError -> \"Error!\"\n...> end\n\"Error!\"\n```\n\nIn practice, Elixir developers rarely use the `try/rescue` construct. For example, many languages would force you to rescue an error when a file cannot be opened successfully. Elixir instead provides a `File.read/1` function which returns a tuple containing information about whether the file was opened successfully:\n\n```elixir\niex> File.read(\"hello\")\n{:error, :enoent}\niex> File.write(\"hello\", \"world\")\n:ok\niex> File.read(\"hello\")\n{:ok, \"world\"}\n```\n\nThere is no `try/rescue` here. In case you want to handle multiple outcomes of opening a file, you can use pattern matching using the `case` construct:\n\n```elixir\niex> case File.read(\"hello\") do\n...>   {:ok, body} -> IO.puts(\"Success: #{body}\")\n...>   {:error, reason} -> IO.puts(\"Error: #{reason}\")\n...> end\n```\n\nFor the cases where you do expect a file to exist (and the lack of that file is truly an _error_) you may use `File.read!/1`:\n\n```elixir\niex> File.read!(\"unknown\")\n** (File.Error) could not read file \"unknown\": no such file or directory\n    (elixir) lib/file.ex:272: File.read!/1\n```\n\nAt the end of the day, it's up to your application to decide if an error while opening a file is exceptional or not. That's why Elixir doesn't impose exceptions on `File.read/1` and many other functions. Instead, it leaves it up to the developer to choose the best way to proceed.\n\nMany functions in the standard library follow the pattern of having a counterpart that raises an exception instead of returning tuples to match against. The convention is to create a function (`foo`) which returns `{:ok, result}` or `{:error, reason}` tuples and another function (`foo!`, same name but with a trailing `!`) that takes the same arguments as `foo` but which raises an exception if there's an error. `foo!` should return the result (not wrapped in a tuple) if everything goes fine. The `File` module is a good example of this convention.","ref":"try-catch-and-rescue.html#errors"},{"type":"extras","title":"Fail fast / Let it crash - try, catch, and rescue","doc":"One saying that is common in the Erlang community, as well as Elixir's, is \"fail fast\" / \"let it crash\". The idea behind let it crash is that, in case something _unexpected_ happens, it is best to let the exception happen, without rescuing it.\n\nIt is important to emphasize the word _unexpected_. For example, imagine you are building a script to process files. Your script receives filenames as inputs. It is expected that users may make mistakes and provide unknown filenames. In this scenario, while you could use `File.read!/1` to read files and let it crash in case of invalid filenames, it probably makes more sense to use `File.read/1` and provide users of your script with a clear and precise feedback of what went wrong.\n\nOther times, you may fully expect a certain file to exist, and in case it does not, it means something terribly wrong has happened elsewhere. In such cases, `File.read!/1` is all you need.\n\nThe second approach also works because, as discussed in the [Processes](processes.md) chapter, all Elixir code runs inside processes that are isolated and don't share anything by default. Therefore, an unhandled exception in a process will never crash or corrupt the state of another process. This allows us to define supervisor processes, which are meant to observe when a process terminates unexpectedly, and start a new one in its place.\n\nAt the end of the day, \"fail fast\" / \"let it crash\" is a way of saying that, when _something unexpected_ happens, it is best to start from scratch within a new process, freshly started by a supervisor, rather than blindly trying to rescue all possible error cases without the full context of when and how they can happen.","ref":"try-catch-and-rescue.html#fail-fast-let-it-crash"},{"type":"extras","title":"Reraise - try, catch, and rescue","doc":"While we generally avoid using `try/rescue` in Elixir, one situation where we may want to use such constructs is for observability/monitoring. Imagine you want to log that something went wrong, you could do:\n\n```elixir\ntry do\n  ... some code ...\nrescue\n  e ->\n    Logger.error(Exception.format(:error, e, __STACKTRACE__))\n    reraise e, __STACKTRACE__\nend\n```\n\nIn the example above, we rescued the exception, logged it, and then re-raised it. We use the `__STACKTRACE__` construct both when formatting the exception and when re-raising. This ensures we reraise the exception as is, without changing value or its origin.\n\nGenerally speaking, we take errors in Elixir literally: they are reserved for unexpected and/or exceptional situations, never for controlling the flow of our code. In case you actually need flow control constructs, _throws_ should be used. That's what we are going to see next.","ref":"try-catch-and-rescue.html#reraise"},{"type":"extras","title":"Throws - try, catch, and rescue","doc":"In Elixir, a value can be thrown and later be caught. `throw` and `catch` are reserved for situations where it is not possible to retrieve a value unless by using `throw` and `catch`.\n\nThose situations are quite uncommon in practice except when interfacing with libraries that do not provide a proper API. For example, let's imagine the `Enum` module did not provide any API for finding a value and that we needed to find the first multiple of 13 in a list of numbers:\n\n```live-elixir\niex> try do\n...>   Enum.each(-50..50, fn x ->\n...>     if rem(x, 13) == 0, do: throw(x)\n...>   end)\n...>   \"Got nothing\"\n...> catch\n...>   x -> \"Got #{x}\"\n...> end\n\"Got -39\"\n```\n\nSince `Enum` _does_ provide a proper API, in practice `Enum.find/2` is the way to go:\n\n```live-elixir\niex> Enum.find(-50..50, &(rem(&1, 13) == 0))\n-39\n```","ref":"try-catch-and-rescue.html#throws"},{"type":"extras","title":"Exits - try, catch, and rescue","doc":"All Elixir code runs inside processes that communicate with each other. When a process dies of \"natural causes\" (e.g., unhandled exceptions), it sends an `exit` signal. A process can also die by explicitly sending an `exit` signal:\n\n```live-elixir\niex> spawn_link(fn -> exit(1) end)\n** (EXIT from #PID<0.56.0>) shell process exited with reason: 1\n```\n\nIn the example above, the linked process died by sending an `exit` signal with a value of 1. The Elixir shell automatically handles those messages and prints them to the terminal.\n\n`exit` can also be \"caught\" using `try/catch`:\n\n```live-elixir\niex> try do\n...>   exit(\"I am exiting\")\n...> catch\n...>   :exit, _ -> \"not really\"\n...> end\n\"not really\"\n```\n\n`catch` can also be used within a function body without a matching `try`.\n\n```live-elixir\ndefmodule Example do\n  def matched_catch do\n    exit(:timeout)\n  catch\n    :exit, :timeout ->\n      {:error, :timeout}\n  end\n\n  def mismatched_catch do\n    exit(:timeout)\n  catch\n    # Since no clause matches, this catch will have no effect\n    :exit, :explosion ->\n      {:error, :explosion}\n  end\nend\n```\n\nHowever, using `try/catch` is already uncommon and using it to catch exits is even rarer.\n\n`exit` signals are an important part of the fault tolerant system provided by the Erlang VM. Processes usually run under supervision trees which are themselves processes that listen to `exit` signals from the supervised processes. Once an `exit` signal is received, the supervision strategy kicks in and the supervised process is restarted.\n\nIt is exactly this supervision system that makes constructs like `try/catch` and `try/rescue` so uncommon in Elixir. Instead of rescuing an error, we'd rather \"fail fast\" since the supervision tree will guarantee our application will go back to a known initial state after the error.","ref":"try-catch-and-rescue.html#exits"},{"type":"extras","title":"After - try, catch, and rescue","doc":"Sometimes it's necessary to ensure that a resource is cleaned up after some action that could potentially raise an error. The `try/after` construct allows you to do that. For example, we can open a file and use an `after` clause to close it -- even if something goes wrong:\n\n```elixir\niex> {:ok, file} = File.open(\"sample\", [:utf8, :write])\niex> try do\n...>   IO.write(file, \"olá\")\n...>   raise \"oops, something went wrong\"\n...> after\n...>   File.close(file)\n...> end\n** (RuntimeError) oops, something went wrong\n```\n\nThe `after` clause will be executed regardless of whether or not the tried block succeeds. Note, however, that if a linked process exits,\nthis process will exit and the `after` clause will not get run. Thus `after` provides only a soft guarantee. Luckily, files in Elixir are also linked to the current processes and therefore they will always get closed if the current process crashes, independent of the\n`after` clause. You will find the same to be true for other resources like ETS tables, sockets, ports and more.\n\nSometimes you may want to wrap the entire body of a function in a `try` construct, often to guarantee some code will be executed afterwards. In such cases, Elixir allows you to omit the `try` line:\n\n```live-elixir\niex> defmodule RunAfter do\n...>   def without_even_trying do\n...>     raise \"oops\"\n...>   after\n...>     IO.puts \"cleaning up!\"\n...>   end\n...> end\niex> RunAfter.without_even_trying\ncleaning up!\n** (RuntimeError) oops\n```\n\nElixir will automatically wrap the function body in a `try` whenever one of `after`, `rescue` or `catch` is specified.","ref":"try-catch-and-rescue.html#after"},{"type":"extras","title":"Else - try, catch, and rescue","doc":"If an `else` block is present, it will match on the results of the `try` block whenever the `try` block finishes without a throw or an error.\n\n```live-elixir\niex> x = 2\n2\niex> try do\n...>   1 / x\n...> rescue\n...>   ArithmeticError ->\n...>     :infinity\n...> else\n...>   y when y < 1 and y > -1 ->\n...>     :small\n...>   _ ->\n...>     :large\n...> end\n:small\n```\n\nExceptions in the `else` block are not caught. If no pattern inside the `else` block matches, an exception will be raised; this exception is not caught by the current `try/catch/rescue/after` block.","ref":"try-catch-and-rescue.html#else"},{"type":"extras","title":"Variables scope - try, catch, and rescue","doc":"Similar to `case`, `cond`, `if` and other constructs in Elixir, variables defined inside `try/catch/rescue/after` blocks do not leak to the outer context. In other words, this code is invalid:\n\n```live-elixir\niex> try do\n...>   raise \"fail\"\n...>   what_happened = :did_not_raise\n...> rescue\n...>   _ -> what_happened = :rescued\n...> end\niex> what_happened\n** (CompileError) undefined variable \"what_happened\"\n```\n\nInstead, you should return the value of the `try` expression:\n\n```live-elixir\niex> what_happened =\n...>   try do\n...>     raise \"fail\"\n...>     :did_not_raise\n...>   rescue\n...>     _ -> :rescued\n...>   end\niex> what_happened\n:rescued\n```\n\nFurthermore, variables defined in the do-block of `try` are not available inside `rescue/after/else` either. This is because the `try` block may fail at any moment and therefore the variables may have never been bound in the first place. So this also isn't valid:\n\n```live-elixir\niex> try do\n...>   raise \"fail\"\n...>   another_what_happened = :did_not_raise\n...> rescue\n...>   _ -> another_what_happened\n...> end\n** (CompileError) undefined variable \"another_what_happened\"\n```\n\nThis finishes our introduction on `try`, `catch`, and `rescue`. You will find they are used less frequently in Elixir than in other languages. Next we will talk about a very important subject to Elixir developers: writing documentation.","ref":"try-catch-and-rescue.html#variables-scope"},{"type":"extras","title":"Writing documentation","doc":"# Writing documentation\n\nElixir treats documentation as a first-class citizen. Documentation must be easy to write and easy to read. In this guide you will learn how to write documentation in Elixir, covering constructs like module attributes, style practices, and doctests.","ref":"writing-documentation.html"},{"type":"extras","title":"Markdown - Writing documentation","doc":"Elixir documentation is written using Markdown. There are plenty of guides on Markdown online, we recommend the one from GitHub as a getting started point:\n\n  * [Basic writing and formatting syntax](https://help.github.com/articles/basic-writing-and-formatting-syntax/)","ref":"writing-documentation.html#markdown"},{"type":"extras","title":"Module Attributes - Writing documentation","doc":"Documentation in Elixir is usually attached to module attributes. Let's see an example:\n\n```elixir\ndefmodule MyApp.Hello do\n  @moduledoc \"\"\"\n  This is the Hello module.\n  \"\"\"\n  @moduledoc since: \"1.0.0\"\n\n  @doc \"\"\"\n  Says hello to the given `name`.\n\n  Returns `:ok`.","ref":"writing-documentation.html#module-attributes"},{"type":"extras","title":"Examples - Writing documentation","doc":"iex> MyApp.Hello.world(:john)\n      :ok\n\n  \"\"\"\n  @doc since: \"1.3.0\"\n  def world(name) do\n    IO.puts(\"hello #{name}\")\n  end\nend\n```\n\nThe `@moduledoc` attribute is used to add documentation to the module. `@doc` is used before a function to provide documentation for it. Besides the attributes above, `@typedoc` can also be used to attach documentation to types defined as part of typespecs, which we will explore later on. Elixir also allows metadata to be attached to documentation, by passing a keyword list to `@doc` and friends.","ref":"writing-documentation.html#examples"},{"type":"extras","title":"Function Arguments - Writing documentation","doc":"When documenting a function, argument names are inferred by the compiler. For example:\n\n```elixir\ndef size(%{size: size}) do\n  size\nend\n```\n\nThe compiler will infer this argument as `map`. Sometimes the inference will be suboptimal, especially if the function contains multiple clauses with the argument matching on different values each time. You can specify the proper names for documentation by declaring only the function head at any moment before the implementation:\n\n```elixir\ndef size(map_with_size)\ndef size(%{size: size}) do\n  size\nend\n```","ref":"writing-documentation.html#function-arguments"},{"type":"extras","title":"Documentation metadata - Writing documentation","doc":"Elixir allows developers to attach arbitrary metadata to the documentation. This is done by passing a keyword list to the relevant attribute (such as `@moduledoc`, `@typedoc`, and `@doc`). A commonly used metadata is `:since`, which annotates in which version that particular module, function, type, or callback was added, as shown in the example above.\n\nAnother common metadata is `:deprecated`, which emits a warning in the documentation, explaining that its usage is discouraged:\n\n```elixir\n@doc deprecated: \"Use Foo.bar/2 instead\"\n```\n\nNote that the `:deprecated` key does not warn when a developer invokes the functions. If you want the code to also emit a warning, you can use the `@deprecated` attribute:\n\n```elixir\n@deprecated \"Use Foo.bar/2 instead\"\n```\n\nMetadata can have any key. Documentation tools often use metadata to provide more data to readers and to enrich the user experience.","ref":"writing-documentation.html#documentation-metadata"},{"type":"extras","title":"Recommendations - Writing documentation","doc":"When writing documentation:\n\n  * Keep the first paragraph of the documentation concise and simple, typically one-line. Tools like [ExDoc](https://github.com/elixir-lang/ex_doc/) use the first line to generate a summary.\n\n  * Reference modules by their full name.\n\n    Markdown uses backticks (`` ` ``) to quote code. Elixir builds on top of that to automatically generate links when module or function names are referenced. For this reason, always use full module names. If you have a module called `MyApp.Hello`, always reference it as `` `MyApp.Hello` `` and never as `` `Hello` ``.\n\n  * Reference functions by name and arity if they are local, as in `` `world/1` ``, or by module, name and arity if pointing to an external module: `` `MyApp.Hello.world/1` ``.\n\n  * Reference a `@callback` by prepending `c:`, as in `` `c:world/1` ``.\n\n  * Reference a `@type` by prepending `t:`, as in `` `t:values/0` ``.\n\n  * Start new sections with second level Markdown headers `##`. First level headers are reserved for module and function names.\n\n  * Place documentation before the first clause of multi-clause functions. Documentation is always per function and arity and not per clause.\n\n  * Use the `:since` key in the documentation metadata to annotate whenever new functions or modules are added to your API.","ref":"writing-documentation.html#recommendations"},{"type":"extras","title":"Doctests - Writing documentation","doc":"We recommend that developers include examples in their documentation, often under their own `","ref":"writing-documentation.html#doctests"},{"type":"extras","title":"Examples` heading. To ensure examples do not get out of date, Elixir's test framework (ExUnit) provides a feature called doctests that allows developers to test the examples in their documentation. Doctests work by parsing out code samples starting with `iex>` from the documentation. You can read more about them at `ExUnit.DocTest`. - Writing documentation","doc":"","ref":"writing-documentation.html#examples-heading-to-ensure-examples-do-not-get-out-of-date-elixir-s-test-framework-exunit-provides-a-feature-called-doctests-that-allows-developers-to-test-the-examples-in-their-documentation-doctests-work-by-parsing-out-code-samples-starting-with-iex-from-the-documentation-you-can-read-more-about-them-at-exunit-doctest"},{"type":"extras","title":"Documentation != Code comments - Writing documentation","doc":"Elixir treats documentation and code comments as different concepts. Documentation is an explicit contract between you and users of your Application Programming Interface (API), be them third-party developers, co-workers, or your future self. Modules and functions must always be documented if they are part of your API.\n\nCode comments are aimed at developers reading the code. They are useful for marking improvements, leaving notes (for example, why you had to resort to a workaround due to a bug in a library), and so forth. They are tied to the source code: you can completely rewrite a function and remove all existing code comments, and it will continue to behave the same, with no change to either its behavior or its documentation.\n\nBecause private functions cannot be accessed externally, Elixir will warn if a private function has a `@doc` attribute and will discard its content. However, you can add code comments to private functions, as with any other piece of code, and we recommend developers to do so whenever they believe it will add relevant information to the readers and maintainers of such code.\n\nIn summary, documentation is a contract with users of your API, who may not necessarily have access to the source code, whereas code comments are for those who interact directly with the source. You can learn and express different guarantees about your software by separating those two concepts.","ref":"writing-documentation.html#documentation-code-comments"},{"type":"extras","title":"Hiding internal Modules and Functions - Writing documentation","doc":"Besides the modules and functions libraries provide as part of their public interface, libraries may also implement important functionality that is not part of their API. While these modules and functions can be accessed, they are meant to be internal to the library and thus should not have documentation for end users.\n\nConveniently, Elixir allows developers to hide modules and functions from the documentation, by setting `@doc false` to hide a particular function, or `@moduledoc false` to hide the whole module. If a module is hidden, you may even document the functions in the module, but the module itself won't be listed in the documentation:\n\n```elixir\ndefmodule MyApp.Hidden do\n  @moduledoc false\n\n  @doc \"\"\"\n  This function won't be listed in docs.\n  \"\"\"\n  def function_that_wont_be_listed_in_docs do\n    # ...\n  end\nend\n```\n\nIn case you don't want to hide a whole module, you can hide functions individually:\n\n```elixir\ndefmodule MyApp.Sample do\n  @doc false\n  def add(a, b), do: a + b\nend\n```\n\nHowever, keep in mind `@moduledoc false` or `@doc false` do not make a function private. The function above can still be invoked as `MyApp.Sample.add(1, 2)`. Not only that, if `MyApp.Sample` is imported, the `add/2` function will also be imported into the caller. For those reasons, be cautious when adding `@doc false` to functions, instead use one of these two options:\n\n  * Move the undocumented function to a module with `@moduledoc false`, like `MyApp.Hidden`, ensuring the function won't be accidentally exposed or imported. Remember that you can use `@moduledoc false` to hide a whole module and still document each function with `@doc`. Tools will still ignore the module.\n\n  * Start the function name with one or two underscores, for example, `__add__/2`. Functions starting with underscore are automatically treated as hidden, although you can also be explicit and add `@doc false`. The compiler does not import functions with leading underscores and they hint to anyone reading the code of their intended private usage.\n\n## `Code.fetch_docs/1`\n\nElixir stores documentation inside pre-defined chunks in the bytecode. Documentation is not loaded into memory when modules are loaded, instead, it can be read from the bytecode in disk using the `Code.fetch_docs/1` function. The downside is that modules defined in-memory, like the ones defined in IEx, cannot have their documentation accessed as they do not write their bytecode to disk.","ref":"writing-documentation.html#hiding-internal-modules-and-functions"},{"type":"extras","title":"Optional syntax sheet","doc":"# Optional syntax sheet\n\nIn the previous chapters, we learned that the Elixir syntax allows developers to omit delimiters in a few occasions to make code more readable. For example, we learned that parentheses are optional:\n\n```live-elixir\niex> length([1, 2, 3]) == length [1, 2, 3]\ntrue\n```\n\nand that `do`-`end` blocks are equivalent to keyword lists:\n\n```live-elixir\n# do-end blocks\niex> if true do\n...>   :this\n...> else\n...>   :that\n...> end\n:this\n\n# keyword lists\niex> if true, do: :this, else: :that\n:this\n```\n\nKeyword lists use Elixir's regular notation for separating arguments, where we separate each key-value pair with commas, and each key is followed by `:`. In the `do`-blocks, we get rid of the colons, the commas, and separate each keyword by a newline. They are useful exactly because they remove the verbosity when writing blocks of code. Most of the time, we use the block syntax, but it is good to know they are equivalent.\n\nThose conveniences, which we call here \"optional syntax\", allow the language syntax core to be small, without sacrificing the readability and expressiveness of your code. In this brief chapter, we will review the four rules provided by the language, using a short snippet as playground.","ref":"optional-syntax.html"},{"type":"extras","title":"Walk-through - Optional syntax sheet","doc":"Take the following code:\n\n```elixir\nif variable? do\n  Call.this()\nelse\n  Call.that()\nend\n```\n\nNow let's remove the conveniences one by one:\n\n1. `do`-`end` blocks are equivalent to keywords:\n\n   ```elixir\n   if variable?, do: Call.this(), else: Call.that()\n   ```\n\n2. Keyword lists as last argument do not require square brackets, but let's add them:\n\n   ```elixir\n   if variable?, [do: Call.this(), else: Call.that()]\n   ```\n\n3. Keyword lists are the same as lists of two-element tuples:\n\n   ```elixir\n   if variable?, [{:do, Call.this()}, {:else, Call.that()}]\n   ```\n\n4. Finally, parentheses are optional on function calls, but let's add them:\n\n   ```elixir\n   if(variable?, [{:do, Call.this()}, {:else, Call.that()}])\n   ```\n\nThat's it! Those four rules outline the optional syntax available in Elixir.\n\nTo understand why these rules matter, we can briefly compare Elixir with many other programming languages. Most programming languages have several keywords for defining methods, functions, conditionals, loops, and so forth. Each of those keywords have their own syntax rules attached to them.\n\nHowever, in Elixir, none of these language features require special \"keywords\", instead they all build from this small set of rules. The other benefit is that developers can also extend the language in a way that is consistent with the language itself, since the constructs for designing and extending the language are the same. We further explore this topic in [the \"Meta-programming\" guide](../meta-programming/quote-and-unquote.md).\n\nAt the end of the day, those rules are what enables us to write:\n\n```elixir\ndefmodule Math do\n  def add(a, b) do\n    a + b\n  end\nend\n```\n\ninstead of:\n\n```elixir\ndefmodule(Math, [\n  {:do, def(add(a, b), [{:do, a + b}])}\n])\n```\n\nWhenever you have any questions, this quick walk-through has you covered.\n\nFinally, if you are concerned about when to apply these rules, it's worth noting that the Elixir formatter handles those concerns for you. Most Elixir developers use the `mix format` task to format their codebases according to a well-defined set of rules defined by the Elixir team and the community. For instance, `mix format` will always add parentheses to function calls unless explicitly configured not to do so. This helps to maintain consistency across all codebases within organizations and the wider community.","ref":"optional-syntax.html#walk-through"},{"type":"extras","title":"Erlang libraries","doc":"# Erlang libraries\n\nElixir provides excellent interoperability with Erlang libraries. In fact, Elixir discourages simply wrapping Erlang libraries in favor of directly interfacing with Erlang code. In this section, we will present some of the most common and useful Erlang functionality that is not found in Elixir.\n\nErlang modules have a different naming convention than in Elixir and start in lowercase. In both cases, module names are atoms and we invoke functions by dispatching to the module name:\n\n```live-elixir\niex> is_atom(String)\ntrue\niex> String.first(\"hello\")\n\"h\"\niex> is_atom(:binary)\ntrue\niex> :binary.first(\"hello\")\n104\n```\n\nAs you grow more proficient in Elixir, you may want to explore the Erlang [STDLIB Reference Manual](http://www.erlang.org/doc/apps/stdlib/index.html) in more detail.","ref":"erlang-libraries.html"},{"type":"extras","title":"The binary module - Erlang libraries","doc":"The built-in Elixir String module handles binaries that are UTF-8 encoded. [The `:binary` module](`:binary`) is useful when you are dealing with binary data that is not necessarily UTF-8 encoded.\n\n```live-elixir\niex> String.to_charlist(\"Ø\")\n[216]\niex> :binary.bin_to_list(\"Ø\")\n[195, 152]\n```\n\nThe above example shows the difference; the `String` module returns Unicode codepoints, while `:binary` deals with raw data bytes.","ref":"erlang-libraries.html#the-binary-module"},{"type":"extras","title":"Formatted text output - Erlang libraries","doc":"Elixir does not contain a function similar to `printf` found in C and other languages. Luckily, the Erlang standard library functions `:io.format/2` and `:io_lib.format/2` may be used. The first formats to terminal output, while the second formats to an iolist. The format specifiers differ from `printf`, [refer to the Erlang documentation for details](`:io.format/2`).\n\n```live-elixir\niex> :io.format(\"Pi is approximately given by:~10.3f~n\", [:math.pi])\nPi is approximately given by:     3.142\n:ok\niex> to_string(:io_lib.format(\"Pi is approximately given by:~10.3f~n\", [:math.pi]))\n\"Pi is approximately given by:     3.142\\n\"\n```","ref":"erlang-libraries.html#formatted-text-output"},{"type":"extras","title":"The crypto module - Erlang libraries","doc":"[The `:crypto` module](`:crypto`) contains hashing functions, digital signatures, encryption and more:\n\n```live-elixir\niex> Base.encode16(:crypto.hash(:sha256, \"Elixir\"))\n\"3315715A7A3AD57428298676C5AE465DADA38D951BDFAC9348A8A31E9C7401CB\"\n```\n\nThe `:crypto` module is part of the `:crypto` application that ships with Erlang. This means you must list the `:crypto` application as an additional application in your project configuration. To do this, edit your `mix.exs` file to include:\n\n```elixir\ndef application do\n  [extra_applications: [:crypto]]\nend\n```\n\nAny module that is not part of the `:kernel` or `:stdlib` Erlang applications must have their application explicitly listed in your `mix.exs`. You can find the application name of any Erlang module in the Erlang documentation, immediately below the Erlang logo in the sidebar.","ref":"erlang-libraries.html#the-crypto-module"},{"type":"extras","title":"The digraph module - Erlang libraries","doc":"The [`:digraph`](`:digraph`) and [`:digraph_utils`](`:digraph_utils`) modules contain functions for dealing with directed graphs built of vertices and edges. After constructing the graph, the algorithms in there will help find, for instance, the shortest path between two vertices, or loops in the graph.\n\nGiven three vertices, find the shortest path from the first to the last.\n\n```live-elixir\niex> digraph = :digraph.new()\niex> coords = [{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]\niex> [v0, v1, v2] = (for c <- coords, do: :digraph.add_vertex(digraph, c))\niex> :digraph.add_edge(digraph, v0, v1)\niex> :digraph.add_edge(digraph, v1, v2)\niex> :digraph.get_short_path(digraph, v0, v2)\n[{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]\n```\n\nNote that the functions in `:digraph` alter the graph structure in-place, this\nis possible because they are implemented as ETS tables, explained next.","ref":"erlang-libraries.html#the-digraph-module"},{"type":"extras","title":"Erlang Term Storage - Erlang libraries","doc":"The modules [`:ets`](`:ets`) and [`:dets`](`:dets`) handle storage of large data structures in memory or on disk respectively.\n\nETS lets you create a table containing tuples. By default, ETS tables are protected, which means only the owner process may write to the table but any other process can read. ETS has some functionality to allow a table to be used as a simple database, a key-value store or as a cache mechanism.\n\nThe functions in the `ets` module will modify the state of the table as a side-effect.\n\n```elixir\niex> table = :ets.new(:ets_test, [])\n# Store as tuples with {name, population}\niex> :ets.insert(table, {\"China\", 1_374_000_000})\niex> :ets.insert(table, {\"India\", 1_284_000_000})\niex> :ets.insert(table, {\"USA\", 322_000_000})\niex> :ets.i(table)\n<1   > {<<\"India\">>,1284000000}\n<2   > {<<\"USA\">>,322000000}\n<3   > {<<\"China\">>,1374000000}\n```","ref":"erlang-libraries.html#erlang-term-storage"},{"type":"extras","title":"The math module - Erlang libraries","doc":"The [`:math`](`:math`) module contains common mathematical operations covering trigonometry, exponential, and logarithmic functions.\n\n```live-elixir\niex> angle_45_deg = :math.pi() * 45.0 / 180.0\niex> :math.sin(angle_45_deg)\n0.7071067811865475\niex> :math.exp(55.0)\n7.694785265142018e23\niex> :math.log(7.694785265142018e23)\n55.0\n```","ref":"erlang-libraries.html#the-math-module"},{"type":"extras","title":"The queue module - Erlang libraries","doc":"The [`:queue`](`:queue`) module provides a data structure that implements (double-ended) FIFO (first-in first-out) queues efficiently:\n\n```elixir\niex> q = :queue.new\niex> q = :queue.in(\"A\", q)\niex> q = :queue.in(\"B\", q)\niex> {value, q} = :queue.out(q)\niex> value\n{:value, \"A\"}\niex> {value, q} = :queue.out(q)\niex> value\n{:value, \"B\"}\niex> {value, q} = :queue.out(q)\niex> value\n:empty\n```","ref":"erlang-libraries.html#the-queue-module"},{"type":"extras","title":"The rand module - Erlang libraries","doc":"The [`:rand`](`:rand`) has functions for returning random values and setting the random seed.\n\n```elixir\niex> :rand.uniform()\n0.8175669086010815\niex> _ = :rand.seed(:exs1024, {123, 123534, 345345})\niex> :rand.uniform()\n0.5820506340260994\niex> :rand.uniform(6)\n6\n```","ref":"erlang-libraries.html#the-rand-module"},{"type":"extras","title":"The zip and zlib modules - Erlang libraries","doc":"The [`:zip`](`:zip`) module lets you read and write ZIP files to and from disk or memory, as well as extracting file information.\n\nThis code counts the number of files in a ZIP file:\n\n```elixir\niex> :zip.foldl(fn _, _, _, acc -> acc + 1 end, 0, :binary.bin_to_list(\"file.zip\"))\n{:ok, 633}\n```\n\nThe [`:zlib`](`:zlib`) module deals with data compression in zlib format, as found in the `gzip` command line utility found in Unix systems.\n\n```elixir\niex> song = \"\n...> Mary had a little lamb,\n...> His fleece was white as snow,\n...> And everywhere that Mary went,\n...> The lamb was sure to go.\"\niex> compressed = :zlib.compress(song)\niex> byte_size(song)\n110\niex> byte_size(compressed)\n99\niex> :zlib.uncompress(compressed)\n\"\\nMary had a little lamb,\\nHis fleece was white as snow,\\nAnd everywhere that Mary went,\\nThe lamb was sure to go.\"\n```","ref":"erlang-libraries.html#the-zip-and-zlib-modules"},{"type":"extras","title":"Learning Erlang - Erlang libraries","doc":"If you want to get deeper into Erlang, here's a list of online resources that cover Erlang's fundamentals and its more advanced features:\n\n- This [Erlang Syntax: A Crash Course](https://elixir-lang.org/crash-course.html) provides a concise intro to Erlang's syntax. Each code snippet is accompanied by equivalent code in Elixir. This is an opportunity for you to not only get some exposure to Erlang's syntax but also review what you learned about Elixir.\n\n- Erlang's official website has a short [tutorial](https://www.erlang.org/course). There is a chapter with pictures briefly describing Erlang's primitives for [concurrent programming](https://www.erlang.org/course/concurrent_programming.html).\n\n- [Learn You Some Erlang for Great Good!](http://learnyousomeerlang.com/) is an excellent introduction to Erlang, its design principles, standard library, best practices, and much more. Once you have read through the crash course mentioned above, you'll be able to safely skip the first couple of chapters in the book that mostly deal with the syntax. When you reach [The Hitchhiker's Guide to Concurrency](http://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency) chapter, that's where the real fun starts.\n\nOur last step is to take a look at existing Elixir (and Erlang) libraries you might use while debugging.","ref":"erlang-libraries.html#learning-erlang"},{"type":"extras","title":"Debugging","doc":"# Debugging\n\nThere are a number of ways to debug code in Elixir. In this chapter we will cover some of the more common ways of doing so.","ref":"debugging.html"},{"type":"extras","title":"IO.inspect/2 - Debugging","doc":"What makes `IO.inspect(item, opts \\\\ [])` really useful in debugging is that it returns the `item` argument passed to it without affecting the behavior of the original code. Let's see an example.\n\n```live-elixir\n(1..10)\n|> IO.inspect()\n|> Enum.map(fn x -> x * 2 end)\n|> IO.inspect()\n|> Enum.sum()\n|> IO.inspect()\n```\n\nPrints:\n\n```elixir\n1..10\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n110\n```\n\nAs you can see `IO.inspect/2` makes it possible to \"spy\" on values almost anywhere in your code without altering the result, making it very helpful inside of a pipeline like in the above case.\n\n`IO.inspect/2` also provides the ability to decorate the output with a `label` option. The label will be printed before the inspected `item`:\n\n```live-elixir\n[1, 2, 3]\n|> IO.inspect(label: \"before\")\n|> Enum.map(&(&1 * 2))\n|> IO.inspect(label: \"after\")\n|> Enum.sum\n```\n\nPrints:\n\n```elixir\nbefore: [1, 2, 3]\nafter: [2, 4, 6]\n```\n\nIt is also very common to use `IO.inspect/2` with `binding/0`, which returns all variable names and their values:\n\n```elixir\ndef some_fun(a, b, c) do\n  IO.inspect binding()\n  ...\nend\n```\n\nWhen `some_fun/3` is invoked with `:foo`, `\"bar\"`, `:baz` it prints:\n\n```elixir\n[a: :foo, b: \"bar\", c: :baz]\n```\n\nSee `IO.inspect/2` and `Inspect.Opts` respectively to learn more about the function and read about all supported options.","ref":"debugging.html#io-inspect-2"},{"type":"extras","title":"dbg/2 - Debugging","doc":"Elixir v1.14 introduced `dbg/2`. `dbg` is similar to `IO.inspect/2` but specifically tailored for debugging. It prints the value passed to it and returns it (just like `IO.inspect/2`), but it also prints the code and location.\n\n```live-elixir\n# In my_file.exs\nfeature = %{name: :dbg, inspiration: \"Rust\"}\ndbg(feature)\ndbg(Map.put(feature, :in_version, \"1.14.0\"))\n```\n\nThe code above prints this:\n\n```shell\n[my_file.exs:2: (file)]\nfeature #=> %{inspiration: \"Rust\", name: :dbg}\n[my_file.exs:3: (file)]\nMap.put(feature, :in_version, \"1.14.0\") #=> %{in_version: \"1.14.0\", inspiration: \"Rust\", name: :dbg}\n```\n\nWhen talking about `IO.inspect/2`, we mentioned its usefulness when placed between steps of `|>` pipelines. `dbg` does it better: it understands Elixir code, so it will print values at _every step of the pipeline_.\n\n```live-elixir\n# In dbg_pipes.exs\n__ENV__.file\n|> String.split(\"/\", trim: true)\n|> List.last()\n|> File.exists?()\n|> dbg()\n```\n\nThis code prints:\n\n```shell\n[dbg_pipes.exs:5: (file)]\n__ENV__.file #=> \"/home/myuser/dbg_pipes.exs\"\n|> String.split(\"/\", trim: true) #=> [\"home\", \"myuser\", \"dbg_pipes.exs\"]\n|> List.last() #=> \"dbg_pipes.exs\"\n|> File.exists?() #=> true\n```\n\nWhile `dbg` provides conveniences around Elixir constructs, you will need `IEx` if you want to execute code and set breakpoints while debugging.","ref":"debugging.html#dbg-2"},{"type":"extras","title":"Pry - Debugging","doc":"When using `IEx`, you may pass `--dbg pry` as an option to \"stop\" the code execution where the `dbg` call is:\n\n```console\n$ iex --dbg pry\n```\n\nOr to debug inside a of a project:\n\n```console\n$ iex --dbg pry -S mix\n```\n\nNow any call to `dbg` will ask if you want to pry the existing code. If you accept, you'll be able to access all variables, as well as imports and aliases from the code, directly from IEx. This is called \"prying\". While the pry session is running, the code execution stops, until `continue` (or `c`) or `next` (or `n`) are called. Remember you can always run `iex` in the context of a project with `iex -S mix TASK`.\n\n     See the example in asciinema","ref":"debugging.html#pry"},{"type":"extras","title":"Breakpoints - Debugging","doc":"`dbg` calls require us to change the code we intend to debug and has limited stepping functionality. Luckily IEx also provides a `IEx.break!/2` function which allows you to set and manage breakpoints on any Elixir code without modifying its source:\n\n     See the example in asciinema   \n\nSimilar to `dbg`, once a breakpoint is reached, code execution stops until `continue` (or `c`) or `next` (or `n`) are invoked. Breakpoints can navigate line-by-line by default, however, they do not have access to aliases and imports when breakpoints are set on compiled modules.\n\nThe `mix test` task direct integration with breakpoints via the `-b`/`--breakpoints` flag. When the flag is used, a breakpoint is set at the beginning of every test that will run:\n\n     See the example in asciinema   \n\nHere are some commands you can use in practice:\n\n```console\n# Debug all failed tests\n$ iex -S mix test --breakpoints --failed\n# Debug the test at the given file:line\n$ iex -S mix test -b path/to/file:line\n```","ref":"debugging.html#breakpoints"},{"type":"extras","title":"Observer - Debugging","doc":"For debugging complex systems, jumping at the code is not enough. It is necessary to have an understanding of the whole virtual machine, processes, applications, as well as set up tracing mechanisms. Luckily this can be achieved in Erlang with `:observer`. In your application:\n\n```elixir\n$ iex\niex> :observer.start()\n```\n\n> #### Missing dependencies {: .warning}\n>\n> When running `iex` inside a project with `iex -S mix`, `observer` won't be available as a dependency. To do so, you will need to call the following functions before:\n>\n> ```elixir\n> iex> Mix.ensure_application!(:wx)             # Not necessary on Erlang/OTP 27+\n> iex> Mix.ensure_application!(:runtime_tools)  # Not necessary on Erlang/OTP 27+\n> iex> Mix.ensure_application!(:observer)\n> iex> :observer.start()\n> ```\n>\n> If any of the calls above fail, here is what may have happened: some package managers default to installing a minimized Erlang without WX bindings for GUI support. In some package managers, you may be able to replace the headless Erlang with a more complete package (look for packages named `erlang` vs `erlang-nox` on Debian/Ubuntu/Arch). In others managers, you may need to install a separate `erlang-wx` (or similarly named) package.\n\nThe above will open another Graphical User Interface that provides many panes to fully understand and navigate the runtime and your project.\n\nWe explore the Observer in the context of an actual project [in the Dynamic Supervisor chapter of the Mix & OTP guide](../mix-and-otp/dynamic-supervisor.md). This is one of the debugging techniques [the Phoenix framework used to achieve 2 million connections on a single machine](https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections).\n\nIf you are using the Phoenix web framework, it ships with the [Phoenix LiveDashboard](https://github.com/phoenixframework/phoenix_live_dashboard), a web dashboard for production nodes which provides similar features to Observer.\n\nFinally, remember you can also get a mini-overview of the runtime info by calling `runtime_info/0` directly in IEx.","ref":"debugging.html#observer"},{"type":"extras","title":"Other tools and community - Debugging","doc":"We have just scratched the surface of what the Erlang VM has to offer, for example:\n\n- Alongside the observer application, Erlang also includes a [`:crashdump_viewer`](https://www.erlang.org/doc/man/crashdump_viewer.html) to view crash dumps\n\n- Integration with OS level tracers, such as [Linux Trace Toolkit,](https://www.erlang.org/doc/apps/runtime_tools/lttng) [DTRACE,](https://www.erlang.org/doc/apps/runtime_tools/dtrace) and [SystemTap](https://www.erlang.org/doc/apps/runtime_tools/systemtap)\n\n- [Microstate accounting](http://www.erlang.org/doc/man/msacc.html) measures how much time the runtime spends in several low-level tasks in a short time interval\n\n- Mix ships with many tasks under the `profile` namespace, such as `mix profile.cprof` and `mix profile.fprof`\n\n- For more advanced use cases, we recommend the excellent [Erlang in Anger](https://www.erlang-in-anger.com/), which is available as a free ebook\n\nHappy debugging!","ref":"debugging.html#other-tools-and-community"},{"type":"extras","title":"Enum cheatsheet","doc":"# Enum cheatsheet\n\nA quick reference into the `Enum` module, a module for working with collections (known as enumerables). Most of the examples below use the following data structure:\n\n```elixir\ncart = [\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"banana\", count: 1},\n  %{fruit: \"orange\", count: 6}\n]\n```\n\nSome examples use the [`string =~ part`](`=~/2`) operator, which checks the string on the left contains the part on the right.","ref":"enum-cheat.html"},{"type":"extras","title":"Predicates - Enum cheatsheet","doc":"{: .col-2}\n\n### [`any?(enum, fun)`](`Enum.any?/2`)\n\n```elixir\niex> Enum.any?(cart, & &1.fruit == \"orange\")\ntrue\niex> Enum.any?(cart, & &1.fruit == \"pear\")\nfalse\n```\n\n`any?` with an empty collection is always false:\n\n```elixir\niex> Enum.any?([], & &1.fruit == \"orange\")\nfalse\n```\n\n### [`all?(enum, fun)`](`Enum.all?/2`)\n\n```elixir\niex> Enum.all?(cart, & &1.count > 0)\ntrue\niex> Enum.all?(cart, & &1.count > 1)\nfalse\n```\n\n`all?` with an empty collection is always true:\n\n```elixir\niex> Enum.all?([], & &1.count > 0)\ntrue\n```\n\n### [`member?(enum, value)`](`Enum.member?/2`)\n\n```elixir\niex> Enum.member?(cart, %{fruit: \"apple\", count: 3})\ntrue\niex> Enum.member?(cart, :something_else)\nfalse\n```\n\n`item in enum` is equivalent to `Enum.member?(enum, item)`:\n\n```elixir\niex> %{fruit: \"apple\", count: 3} in cart\ntrue\niex> :something_else in cart\nfalse\n```\n\n### [`empty?(enum)`](`Enum.empty?/1`)\n\n```elixir\niex> Enum.empty?(cart)\nfalse\niex> Enum.empty?([])\ntrue\n```","ref":"enum-cheat.html#predicates"},{"type":"extras","title":"Filtering - Enum cheatsheet","doc":"{: .col-2}\n\n### [`filter(enum, fun)`](`Enum.filter/2`)\n\n```elixir\niex> Enum.filter(cart, &(&1.fruit =~ \"o\"))\n[%{fruit: \"orange\", count: 6}]\niex> Enum.filter(cart, &(&1.fruit =~ \"e\"))\n[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"orange\", count: 6}\n]\n```\n\n### [`reject(enum, fun)`](`Enum.reject/2`)\n\n```elixir\niex> Enum.reject(cart, &(&1.fruit =~ \"o\"))\n[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"banana\", count: 1}\n]\n```\n\n### [`Comprehension`](`for/1`)\n\nFiltering can also be done with comprehensions:\n\n```elixir\niex> for item <- cart, item.fruit =~ \"e\" do\n...>   item\n...> end\n[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"orange\", count: 6}\n]\n```\n\nPattern-matching in comprehensions acts as a filter as well:\n\n```elixir\niex> for %{count: 1, fruit: fruit} <- cart do\n...>   fruit\n...> end\n[\"banana\"]\n```","ref":"enum-cheat.html#filtering"},{"type":"extras","title":"Mapping - Enum cheatsheet","doc":"{: .col-2}\n\n### [`map(enum, fun)`](`Enum.map/2`)\n\n```elixir\niex> Enum.map(cart, & &1.fruit)\n[\"apple\", \"banana\", \"orange\"]\niex> Enum.map(cart, fn item ->\n...>   %{item | count: item.count + 10}\n...> end)\n[\n  %{fruit: \"apple\", count: 13},\n  %{fruit: \"banana\", count: 11},\n  %{fruit: \"orange\", count: 16}\n]\n```\n\n### [`map_every(enum, nth, fun)`](`Enum.map_every/3`)\n\n```elixir\niex> Enum.map_every(cart, 2, fn item ->\n...>   %{item | count: item.count + 10}\n...> end)\n[\n  %{fruit: \"apple\", count: 13},\n  %{fruit: \"banana\", count: 1},\n  %{fruit: \"orange\", count: 16}\n]\n```\n\n### [`Comprehension`](`for/1`)\n\nMapping can also be done with comprehensions:\n\n```elixir\niex> for item <- cart do\n...>   item.fruit\n...> end\n[\"apple\", \"banana\", \"orange\"]\n```\n\nYou can also filter and map at once:\n\n```elixir\niex> for item <- cart, item.fruit =~ \"e\" do\n...>   item.fruit\n...> end\n[\"apple\", \"orange\"]\n```","ref":"enum-cheat.html#mapping"},{"type":"extras","title":"Side-effects - Enum cheatsheet","doc":"{: .col-2}\n\n### [`each(enum, fun)`](`Enum.each/2`)\n\n```elixir\niex> Enum.each(cart, &IO.puts(&1.fruit))\napple\nbanana\norange\n:ok\n```\n\n`Enum.each/2` is used exclusively for side-effects.","ref":"enum-cheat.html#side-effects"},{"type":"extras","title":"Accumulating - Enum cheatsheet","doc":"{: .col-2}\n\n### [`reduce(enum, acc, fun)`](`Enum.reduce/3`)\n\n```elixir\niex> Enum.reduce(cart, 0, fn item, acc ->\n...>   item.count + acc\n...> end)\n10\n```\n\n### [`map_reduce(enum, acc, fun)`](`Enum.map_reduce/3`)\n\n```elixir\niex> Enum.map_reduce(cart, 0, fn item, acc ->\n...>   {item.fruit, item.count + acc}\n...> end)\n{[\"apple\", \"banana\", \"orange\"], 10}\n```\n\n### [`scan(enum, acc, fun)`](`Enum.scan/3`)\n\n```elixir\niex> Enum.scan(cart, 0, fn item, acc ->\n...>   item.count + acc\n...> end)\n[3, 4, 10]\n```\n\n### [`reduce_while(enum, acc, fun)`](`Enum.reduce_while/3`)\n\n```elixir\niex> Enum.reduce_while(cart, 0, fn item, acc ->\n...>   if item.fruit == \"orange\" do\n...>     {:halt, acc}\n...>   else\n...>     {:cont, item.count + acc}\n...>   end\n...> end)\n4\n```\n\n### [`Comprehension`](`for/1`)\n\nReducing can also be done with comprehensions:\n\n```elixir\niex> for item <- cart, reduce: 0 do\n...>   acc -> item.count + acc\n...> end\n10\n```\n\nYou can also filter and reduce at once:\n\n```elixir\niex> for item <- cart, item.fruit =~ \"e\", reduce: 0 do\n...>   acc -> item.count + acc\n...> end\n9\n```","ref":"enum-cheat.html#accumulating"},{"type":"extras","title":"Aggregations - Enum cheatsheet","doc":"{: .col-2}\n\n### [`count(enum)`](`Enum.count/1`)\n\n```elixir\niex> Enum.count(cart)\n3\n```\n\nSee `Enum.count_until/2` to count until a limit.\n\n### [`frequencies(enum)`](`Enum.frequencies/1`)\n\n```elixir\niex> Enum.frequencies([\"apple\", \"banana\", \"orange\", \"apple\"])\n%{\"apple\" => 2, \"banana\" => 1, \"orange\" => 1}\n```\n\n### [`frequencies_by(enum, key_fun)`](`Enum.frequencies_by/2`)\n\nFrequencies of the last letter of the fruit:\n\n```elixir\niex> Enum.frequencies_by(cart, &String.last(&1.fruit))\n%{\"a\" => 1, \"e\" => 2}\n```\n\n### [`count(enum, fun)`](`Enum.count/2`)\n\n```elixir\niex> Enum.count(cart, &(&1.fruit =~ \"e\"))\n2\niex> Enum.count(cart, &(&1.fruit =~ \"y\"))\n0\n```\n\nSee `Enum.count_until/3` to count until a limit with a function.\n\n### [`sum(enum)`](`Enum.sum/1`)\n\n```elixir\niex> cart |> Enum.map(& &1.count) |> Enum.sum()\n10\n```\n\n### [`product(enum)`](`Enum.product/1`)\n\n```elixir\niex> cart |> Enum.map(& &1.count) |> Enum.product()\n18\n```","ref":"enum-cheat.html#aggregations"},{"type":"extras","title":"Sorting - Enum cheatsheet","doc":"{: .col-2}\n\n### [`sort(enum, sorter \\\\ :asc)`](`Enum.sort/2`)\n\n```elixir\niex> cart |> Enum.map(& &1.fruit) |> Enum.sort()\n[\"apple\", \"banana\", \"orange\"]\niex> cart |> Enum.map(& &1.fruit) |> Enum.sort(:desc)\n[\"orange\", \"banana\", \"apple\"]\n```\n\nWhen sorting structs, use `Enum.sort/2` with a module as sorter.\n\n### [`sort_by(enum, mapper, sorter \\\\ :asc)`](`Enum.sort_by/2`)\n\n```elixir\niex> Enum.sort_by(cart, & &1.count)\n[\n  %{fruit: \"banana\", count: 1},\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"orange\", count: 6}\n]\niex> Enum.sort_by(cart, & &1.count, :desc)\n[\n  %{fruit: \"orange\", count: 6},\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"banana\", count: 1}\n]\n```\n\nWhen the sorted by value is a struct, use `Enum.sort_by/3` with a module as sorter.\n\n### [`min(enum)`](`Enum.min/1`)\n\n```elixir\niex> cart |> Enum.map(& &1.count) |> Enum.min()\n1\n```\n\nWhen comparing structs, use `Enum.min/2` with a module as sorter.\n\n### [`min_by(enum, mapper)`](`Enum.min_by/2`)\n\n```elixir\niex> Enum.min_by(cart, & &1.count)\n%{fruit: \"banana\", count: 1}\n```\n\nWhen comparing structs, use `Enum.min_by/3` with a module as sorter.\n\n### [`max(enum)`](`Enum.max/1`)\n\n```elixir\niex> cart |> Enum.map(& &1.count) |> Enum.max()\n6\n```\n\nWhen comparing structs, use `Enum.max/2` with a module as sorter.\n\n### [`max_by(enum, mapper)`](`Enum.max_by/2`)\n\n```elixir\niex> Enum.max_by(cart, & &1.count)\n%{fruit: \"orange\", count: 6}\n```\n\nWhen comparing structs, use `Enum.max_by/3` with a module as sorter.","ref":"enum-cheat.html#sorting"},{"type":"extras","title":"Concatenating & flattening - Enum cheatsheet","doc":"{: .col-2}\n\n### [`concat(enums)`](`Enum.concat/1`)\n\n```elixir\niex> Enum.concat([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n### [`concat(left, right)`](`Enum.concat/2`)\n\n```elixir\niex> Enum.concat([1, 2, 3], [4, 5, 6])\n[1, 2, 3, 4, 5, 6]\n```\n\n### [`flat_map(enum, fun)`](`Enum.flat_map/2`)\n\n```elixir\niex> Enum.flat_map(cart, fn item ->\n...>   List.duplicate(item.fruit, item.count)\n...> end)\n[\"apple\", \"apple\", \"apple\", \"banana\", \"orange\",\n \"orange\", \"orange\", \"orange\", \"orange\", \"orange\"]\n```\n\n### [`flat_map_reduce(enum, acc, fun)`](`Enum.flat_map_reduce/3`)\n\n```elixir\niex> Enum.flat_map_reduce(cart, 0, fn item, acc ->\n...>   list = List.duplicate(item.fruit, item.count)\n...>   acc = acc + item.count\n...>   {list, acc}\n...> end)\n{[\"apple\", \"apple\", \"apple\", \"banana\", \"orange\",\n  \"orange\", \"orange\", \"orange\", \"orange\", \"orange\"], 10}\n```\n\n### [`Comprehension`](`for/1`)\n\nFlattening can also be done with comprehensions:\n\n```elixir\niex> for item <- cart,\n...>     fruit <- List.duplicate(item.fruit, item.count) do\n...>   fruit\n...> end\n[\"apple\", \"apple\", \"apple\", \"banana\", \"orange\",\n \"orange\", \"orange\", \"orange\", \"orange\", \"orange\"]\n```","ref":"enum-cheat.html#concatenating-flattening"},{"type":"extras","title":"Conversion - Enum cheatsheet","doc":"{: .col-2}\n\n### [`into(enum, collectable)`](`Enum.into/2`)\n\n```elixir\niex> pairs = [{\"apple\", 3}, {\"banana\", 1}, {\"orange\", 6}]\niex> Enum.into(pairs, %{})\n%{\"apple\" => 3, \"banana\" => 1, \"orange\" => 6}\n```\n\n### [`into(enum, collectable, transform)`](`Enum.into/3`)\n\n```elixir\niex> Enum.into(cart, %{}, fn item ->\n...>   {item.fruit, item.count}\n...> end)\n%{\"apple\" => 3, \"banana\" => 1, \"orange\" => 6}\n```\n\n### [`to_list(enum)`](`Enum.to_list/1`)\n\n```elixir\niex> Enum.to_list(1..5)\n[1, 2, 3, 4, 5]\n```\n\n### [`Comprehension`](`for/1`)\n\nConversion can also be done with comprehensions:\n\n```elixir\niex> for item <- cart, into: %{} do\n...>   {item.fruit, item.count}\n...> end\n%{\"apple\" => 3, \"banana\" => 1, \"orange\" => 6}\n```","ref":"enum-cheat.html#conversion"},{"type":"extras","title":"Duplicates & uniques - Enum cheatsheet","doc":"{: .col-2}\n\n### [`dedup(enum)`](`Enum.dedup/1`)\n\n`dedup` only removes contiguous duplicates:\n\n```elixir\niex> Enum.dedup([1, 2, 2, 3, 3, 3, 1, 2, 3])\n[1, 2, 3, 1, 2, 3]\n```\n\n### [`dedup_by(enum, fun)`](`Enum.dedup_by/2`)\n\nRemove contiguous entries given a property:\n\n```elixir\niex> Enum.dedup_by(cart, & &1.fruit =~ \"a\")\n[%{fruit: \"apple\", count: 3}]\niex> Enum.dedup_by(cart, & &1.count < 5)\n[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"orange\", count: 6}\n]\n```\n\n### [`uniq(enum)`](`Enum.uniq/1`)\n\n`uniq` applies to the whole collection:\n\n```elixir\niex> Enum.uniq([1, 2, 2, 3, 3, 3, 1, 2, 3])\n[1, 2, 3]\n```\n\nComprehensions also support the `uniq: true` option.\n\n### [`uniq_by(enum, fun)`](`Enum.uniq_by/2`)\n\nGet entries which are unique by the last letter of the fruit:\n\n```elixir\niex> Enum.uniq_by(cart, &String.last(&1.fruit))\n[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"banana\", count: 1}\n]\n```","ref":"enum-cheat.html#duplicates-uniques"},{"type":"extras","title":"Indexing - Enum cheatsheet","doc":"{: .col-2}\n\n### [`at(enum, index, default \\\\ nil)`](`Enum.at/2`)\n\n```elixir\niex> Enum.at(cart, 0)\n%{fruit: \"apple\", count: 3}\niex> Enum.at(cart, 10)\nnil\niex> Enum.at(cart, 10, :none)\n:none\n```\n\nAccessing a list by index in a loop is discouraged.\n\n### [`fetch(enum, index)`](`Enum.fetch/2`)\n\n```elixir\niex> Enum.fetch(cart, 0)\n{:ok, %{fruit: \"apple\", count: 3}}\niex> Enum.fetch(cart, 10)\n:error\n```\n\n### [`fetch!(enum, index)`](`Enum.fetch!/2`)\n\n```elixir\niex> Enum.fetch!(cart, 0)\n%{fruit: \"apple\", count: 3}\niex> Enum.fetch!(cart, 10)\n** (Enum.OutOfBoundsError) out of bounds error\n```\n\n### [`with_index(enum)`](`Enum.with_index/1`)\n\n```elixir\niex> Enum.with_index(cart)\n[\n  {%{fruit: \"apple\", count: 3}, 0},\n  {%{fruit: \"banana\", count: 1}, 1},\n  {%{fruit: \"orange\", count: 6}, 2}\n]\n```\n\n### [`with_index(enum, fun)`](`Enum.with_index/2`)\n\n```elixir\niex> Enum.with_index(cart, fn item, index ->\n...>   {item.fruit, index}\n...> end)\n[\n  {\"apple\", 0},\n  {\"banana\", 1},\n  {\"orange\", 2}\n]\n```","ref":"enum-cheat.html#indexing"},{"type":"extras","title":"Finding - Enum cheatsheet","doc":"{: .col-2}\n\n### [`find(enum, default \\\\ nil, fun)`](`Enum.find/2`)\n\n```elixir\niex> Enum.find(cart, &(&1.fruit =~ \"o\"))\n%{fruit: \"orange\", count: 6}\niex> Enum.find(cart, &(&1.fruit =~ \"y\"))\nnil\niex> Enum.find(cart, :none, &(&1.fruit =~ \"y\"))\n:none\n```\n\n### [`find_index(enum, fun)`](`Enum.find_index/2`)\n\n```elixir\niex> Enum.find_index(cart, &(&1.fruit =~ \"o\"))\n2\niex> Enum.find_index(cart, &(&1.fruit =~ \"y\"))\nnil\n```\n\n### [`find_value(enum, default \\\\ nil, fun)`](`Enum.find_value/2`)\n\n```elixir\niex> Enum.find_value(cart, fn item ->\n...>   if item.count == 1, do: item.fruit, else: nil\n...> end)\n\"banana\"\niex> Enum.find_value(cart, :none, fn item ->\n...>   if item.count == 100, do: item.fruit, else: nil\n...> end)\n:none\n```","ref":"enum-cheat.html#finding"},{"type":"extras","title":"Grouping - Enum cheatsheet","doc":"{: .col-2}\n\n### [`group_by(enum, key_fun)`](`Enum.group_by/2`)\n\nGroup by the last letter of the fruit:\n\n```elixir\niex> Enum.group_by(cart, &String.last(&1.fruit))\n%{\n  \"a\" => [%{fruit: \"banana\", count: 1}],\n  \"e\" => [\n    %{fruit: \"apple\", count: 3},\n    %{fruit: \"orange\", count: 6}\n  ]\n}\n```\n\n### [`group_by(enum, key_fun, value_fun)`](`Enum.group_by/3`)\n\nGroup by the last letter of the fruit with custom value:\n\n```elixir\niex> Enum.group_by(cart, &String.last(&1.fruit), & &1.fruit)\n%{\n  \"a\" => [\"banana\"],\n  \"e\" => [\"apple\", \"orange\"]\n}\n```","ref":"enum-cheat.html#grouping"},{"type":"extras","title":"Joining & interspersing - Enum cheatsheet","doc":"{: .col-2}\n\n### [`join(enum, joiner \\\\ \"\")`](`Enum.join/2`)\n\n```elixir\niex> Enum.join([\"apple\", \"banana\", \"orange\"], \", \")\n\"apple, banana, orange\"\n```\n\n### [`map_join(enum, joiner \\\\ \"\", mapper)`](`Enum.map_join/3`)\n\n```elixir\niex> Enum.map_join(cart, \", \", & &1.fruit)\n\"apple, banana, orange\"\n```\n\n### [`intersperse(enum, separator \\\\ \"\")`](`Enum.intersperse/2`)\n\n```elixir\niex> Enum.intersperse([\"apple\", \"banana\", \"orange\"], \", \")\n[\"apple\", \", \", \"banana\", \", \", \"orange\"]\n```\n\n### [`map_intersperse(enum, separator \\\\ \"\", mapper)`](`Enum.map_intersperse/3`)\n\n```elixir\niex> Enum.map_intersperse(cart, \", \", & &1.fruit)\n[\"apple\", \", \", \"banana\", \", \", \"orange\"]\n```","ref":"enum-cheat.html#joining-interspersing"},{"type":"extras","title":"Slicing - Enum cheatsheet","doc":"{: .col-2}\n\n### [`slice(enum, index_range)`](`Enum.slice/2`)\n\n```elixir\niex> Enum.slice(cart, 0..1)\n[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"banana\", count: 1}\n]\n```\n\nNegative ranges count from the back:\n\n```elixir\niex> Enum.slice(cart, -2..-1)\n[\n  %{fruit: \"banana\", count: 1},\n  %{fruit: \"orange\", count: 6}\n]\n```\n\n### [`slice(enum, start_index, amount)`](`Enum.slice/3`)\n\n```elixir\niex> Enum.slice(cart, 1, 2)\n[\n  %{fruit: \"banana\", count: 1},\n  %{fruit: \"orange\", count: 6}\n]\n```\n\n### [`slide(enum, range_or_single_index, insertion_index)`](`Enum.slide/3`)\n\n```elixir\nfruits = [\"apple\", \"banana\", \"grape\", \"orange\", \"pear\"]\niex> Enum.slide(fruits, 2, 0)\n[\"grape\", \"apple\", \"banana\", \"orange\", \"pear\"]\niex> Enum.slide(fruits, 2, 4)\n[\"apple\", \"banana\", \"orange\", \"pear\", \"grape\"]\niex> Enum.slide(fruits, 1..3, 0)\n[\"banana\", \"grape\", \"orange\", \"apple\", \"pear\"]\niex> Enum.slide(fruits, 1..3, 4)\n[\"apple\", \"pear\", \"banana\", \"grape\", \"orange\"]\n```","ref":"enum-cheat.html#slicing"},{"type":"extras","title":"Reversing - Enum cheatsheet","doc":"{: .col-2}\n\n### [`reverse(enum)`](`Enum.reverse/1`)\n\n```elixir\niex> Enum.reverse(cart)\n[\n  %{fruit: \"orange\", count: 6},\n  %{fruit: \"banana\", count: 1},\n  %{fruit: \"apple\", count: 3}\n]\n```\n\n### [`reverse(enum, tail)`](`Enum.reverse/2`)\n\n```elixir\niex> Enum.reverse(cart, [:this_will_be, :the_tail])\n[\n  %{fruit: \"orange\", count: 6},\n  %{fruit: \"banana\", count: 1},\n  %{fruit: \"apple\", count: 3},\n  :this_will_be,\n  :the_tail\n]\n```\n\n### [`reverse_slice(enum, start_index, count)`](`Enum.reverse_slice/3`)\n\n```elixir\niex> Enum.reverse_slice(cart, 1, 2)\n[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"orange\", count: 6},\n  %{fruit: \"banana\", count: 1}\n]\n```","ref":"enum-cheat.html#reversing"},{"type":"extras","title":"Splitting - Enum cheatsheet","doc":"{: .col-2}\n\n### [`split(enum, amount)`](`Enum.split/2`)\n\n```elixir\niex> Enum.split(cart, 1)\n{[%{fruit: \"apple\", count: 3}],\n [\n   %{fruit: \"banana\", count: 1},\n   %{fruit: \"orange\", count: 6}\n ]}\n```\n\nNegative indexes count from the back:\n\n```elixir\niex> Enum.split(cart, -1)\n{[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"banana\", count: 1}\n ],\n [%{fruit: \"orange\", count: 6}]}\n```\n\n### [`split_while(enum, fun)`](`Enum.split_while/2`)\n\nStops splitting as soon as it is false:\n\n```elixir\niex> Enum.split_while(cart, &(&1.fruit =~ \"e\"))\n{[%{fruit: \"apple\", count: 3}],\n [\n   %{fruit: \"banana\", count: 1},\n   %{fruit: \"orange\", count: 6}\n ]}\n```\n\n### [`split_with(enum, fun)`](`Enum.split_with/2`)\n\nSplits the whole collection:\n\n```elixir\niex> Enum.split_with(cart, &(&1.fruit =~ \"e\"))\n{[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"orange\", count: 6}\n ],\n [%{fruit: \"banana\", count: 1}]}\n```","ref":"enum-cheat.html#splitting"},{"type":"extras","title":"Splitting (drop and take) - Enum cheatsheet","doc":"{: .col-2}\n\n### [`drop(enum, amount)`](`Enum.drop/2`)\n\n```elixir\niex> Enum.drop(cart, 1)\n[\n  %{fruit: \"banana\", count: 1},\n  %{fruit: \"orange\", count: 6}\n]\n```\n\nNegative indexes count from the back:\n\n```elixir\niex> Enum.drop(cart, -1)\n[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"banana\", count: 1}\n]\n```\n\n### [`drop_every(enum, nth)`](`Enum.drop_every/2`)\n\n```elixir\niex> Enum.drop_every(cart, 2)\n[%{fruit: \"banana\", count: 1}]\n```\n\n### [`drop_while(enum, fun)`](`Enum.drop_while/2`)\n\n```elixir\niex> Enum.drop_while(cart, &(&1.fruit =~ \"e\"))\n[\n  %{fruit: \"banana\", count: 1},\n  %{fruit: \"orange\", count: 6}\n]\n```\n\n### [`take(enum, amount)`](`Enum.take/2`)\n\n```elixir\niex> Enum.take(cart, 1)\n[%{fruit: \"apple\", count: 3}]\n```\n\nNegative indexes count from the back:\n\n```elixir\niex> Enum.take(cart, -1)\n[%{fruit: \"orange\", count: 6}]\n```\n\n### [`take_every(enum, nth)`](`Enum.take_every/2`)\n\n```elixir\niex> Enum.take_every(cart, 2)\n[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"orange\", count: 6}\n]\n```\n\n### [`take_while(enum, fun)`](`Enum.take_while/2`)\n\n```elixir\niex> Enum.take_while(cart, &(&1.fruit =~ \"e\"))\n[%{fruit: \"apple\", count: 3}]\n```","ref":"enum-cheat.html#splitting-drop-and-take"},{"type":"extras","title":"Random - Enum cheatsheet","doc":"{: .col-2}\n\n### [`random(enum)`](`Enum.random/1`)\n\nResults will vary on every call:\n\n```elixir\niex> Enum.random(cart)\n%{fruit: \"orange\", count: 6}\n```\n\n### [`take_random(enum, count)`](`Enum.take_random/2`)\n\nResults will vary on every call:\n\n```elixir\niex> Enum.take_random(cart, 2)\n[\n  %{fruit: \"orange\", count: 6},\n  %{fruit: \"apple\", count: 3}\n]\n```\n\n### [`shuffle(enum)`](`Enum.shuffle/1`)\n\nResults will vary on every call:\n\n```elixir\niex> Enum.shuffle(cart)\n[\n  %{fruit: \"orange\", count: 6},\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"banana\", count: 1}\n]\n```","ref":"enum-cheat.html#random"},{"type":"extras","title":"Chunking - Enum cheatsheet","doc":"{: .col-2}\n\n### [`chunk_by(enum, fun)`](`Enum.chunk_by/2`)\n\n```elixir\niex> Enum.chunk_by(cart, &String.length(&1.fruit))\n[\n  [%{fruit: \"apple\", count: 3}],\n  [\n    %{fruit: \"banana\", count: 1},\n    %{fruit: \"orange\", count: 6}\n  ]\n]\n```\n\n### [`chunk_every(enum, count)`](`Enum.chunk_every/2`)\n\n```elixir\niex> Enum.chunk_every(cart, 2)\n[\n  [\n    %{fruit: \"apple\", count: 3},\n    %{fruit: \"banana\", count: 1}\n  ],\n  [%{fruit: \"orange\", count: 6}]\n]\n```\n\n### [`chunk_every(enum, count, step, leftover \\\\ [])`](`Enum.chunk_every/2`)\n\n```elixir\niex> Enum.chunk_every(cart, 2, 2, [:elements, :to_complete])\n[\n  [\n    %{fruit: \"apple\", count: 3},\n    %{fruit: \"banana\", count: 1}\n  ],\n  [\n    %{fruit: \"orange\", count: 6},\n    :elements\n  ]\n]\niex> Enum.chunk_every(cart, 2, 1, :discard)\n[\n  [\n    %{fruit: \"apple\", count: 3},\n    %{fruit: \"banana\", count: 1}\n  ],\n  [\n    %{fruit: \"banana\", count: 1},\n    %{fruit: \"orange\", count: 6}\n  ]\n]\n```\n\nSee `Enum.chunk_while/4` for custom chunking.","ref":"enum-cheat.html#chunking"},{"type":"extras","title":"Zipping - Enum cheatsheet","doc":"{: .col-2}\n\n### [`zip(enum1, enum2)`](`Enum.zip/2`)\n\n```elixir\niex> fruits = [\"apple\", \"banana\", \"orange\"]\niex> counts = [3, 1, 6]\niex> Enum.zip(fruits, counts)\n[{\"apple\", 3}, {\"banana\", 1}, {\"orange\", 6}]\n```\n\nSee `Enum.zip/1` for zipping many collections at once.\n\n### [`zip_with(enum1, enum2, fun)`](`Enum.zip_with/2`)\n\n```elixir\niex> fruits = [\"apple\", \"banana\", \"orange\"]\niex> counts = [3, 1, 6]\niex> Enum.zip_with(fruits, counts, fn fruit, count ->\n...>   %{fruit: fruit, count: count}\n...> end)\n[\n  %{fruit: \"apple\", count: 3},\n  %{fruit: \"banana\", count: 1},\n  %{fruit: \"orange\", count: 6}\n]\n```\n\nSee `Enum.zip_with/2` for zipping many collections at once.\n\n### [`zip_reduce(left, right, acc, fun)`](`Enum.zip_reduce/4`)\n\n```elixir\niex> fruits = [\"apple\", \"banana\", \"orange\"]\niex> counts = [3, 1, 6]\niex> Enum.zip_reduce(fruits, counts, 0, fn fruit, count, acc ->\n...>   price = if fruit =~ \"e\", do: count * 2, else: count\n...>   acc + price\n...> end)\n19\n```\n\nSee `Enum.zip_reduce/3` for zipping many collections at once.\n\n### [`unzip(list)`](`Enum.unzip/1`)\n\n```elixir\niex> cart |> Enum.map(&{&1.fruit, &1.count}) |> Enum.unzip()\n{[\"apple\", \"banana\", \"orange\"], [3, 1, 6]}\n```","ref":"enum-cheat.html#zipping"},{"type":"extras","title":"What are anti-patterns?","doc":"# What are anti-patterns?\n\nAnti-patterns describe common mistakes or indicators of problems in code.\nThey are also known as \"code smells\".\n\nThe goal of these guides is to document potential anti-patterns found in Elixir software\nand teach developers how to identify them and their pitfalls. If an existing piece\nof code matches an anti-pattern, it does not mean your code must be rewritten.\nSometimes, even if a snippet matches a potential anti-pattern and its limitations,\nit may be the best approach to the problem at hand. No codebase is free of anti-patterns\nand one should not aim to remove all of them.\n\nThe anti-patterns in these guides are broken into 4 main categories:\n\n  * **Code-related anti-patterns:** related to your code and particular\n    language idioms and features;\n\n  * **Design-related anti-patterns:** related to your modules, functions,\n    and the role they play within a codebase;\n\n  * **Process-related anti-patterns:** related to processes and process-based\n    abstractions;\n\n  * **Meta-programming anti-patterns:** related to meta-programming.\n\nEach anti-pattern is documented using the following structure:\n\n  * **Name:** Unique identifier of the anti-pattern. This name is important to facilitate\n    communication between developers;\n\n  * **Problem:** How the anti-pattern can harm code quality and what impacts this can have\n    for developers;\n\n  * **Example:** Code and textual descriptions to illustrate the occurrence of the anti-pattern;\n\n  * **Refactoring:** Ways to change your code to improve its qualities. Examples of refactored\n    code are presented to illustrate these changes.\n\nAn additional section with \"Additional Remarks\" may be provided. Those may include known scenarios where the anti-pattern does not apply.\n\nThe initial catalog of anti-patterns was proposed by Lucas Vegi and Marco Tulio Valente, from [ASERG/DCC/UFMG](http://aserg.labsoft.dcc.ufmg.br/). For more info, see [Understanding Code Smells in Elixir Functional Language](https://github.com/lucasvegi/Elixir-Code-Smells/blob/main/etc/2023-emse-code-smells-elixir.pdf) and [the associated code repository](https://github.com/lucasvegi/Elixir-Code-Smells).\n\nAdditionally, the Security Working Group of the [Erlang Ecosystem Foundation](https://erlef.github.io/security-wg/) publishes [documents with security resources and best-practices of both Erlang and Elixir, including detailed guides for web applications](https://erlef.github.io/security-wg/).","ref":"what-anti-patterns.html"},{"type":"extras","title":"Code-related anti-patterns","doc":"# Code-related anti-patterns\n\nThis document outlines potential anti-patterns related to your code and particular Elixir idioms and features.","ref":"code-anti-patterns.html"},{"type":"extras","title":"Comments overuse - Code-related anti-patterns","doc":"#### Problem\n\nWhen you overuse comments or comment self-explanatory code, it can have the effect of making code *less readable*.\n\n#### Example\n\n```elixir\n# Returns the Unix timestamp of 5 minutes from the current time\ndefp unix_five_min_from_now do\n  # Get the current time\n  now = DateTime.utc_now()\n\n  # Convert it to a Unix timestamp\n  unix_now = DateTime.to_unix(now, :second)\n\n  # Add five minutes in seconds\n  unix_now + (60 * 5)\nend\n```\n\n#### Refactoring\n\nPrefer clear and self-explanatory function names, module names, and variable names when possible. In the example above, the function name explains well what the function does, so you likely won't need the comment before it. The code also explains the operations well through variable names and clear function calls.\n\nYou could refactor the code above like this:\n\n```elixir\n@five_min_in_seconds 60 * 5\n\ndefp unix_five_min_from_now do\n  now = DateTime.utc_now()\n  unix_now = DateTime.to_unix(now, :second)\n  unix_now + @five_min_in_seconds\nend\n```\n\nWe removed the unnecessary comments. We also added a `@five_min_in_seconds` module attribute, which serves the additional purpose of giving a name to the \"magic\" number `60 * 5`, making the code clearer and more expressive.\n\n#### Additional remarks\n\nElixir makes a clear distinction between **documentation** and code comments. The language has built-in first-class support for documentation through `@doc`, `@moduledoc`, and more. See the [\"Writing documentation\"](../getting-started/writing-documentation.md) guide for more information.","ref":"code-anti-patterns.html#comments-overuse"},{"type":"extras","title":"Complex `else` clauses in `with` - Code-related anti-patterns","doc":"#### Problem\n\nThis anti-pattern refers to `with` statements that flatten all its error clauses into a single complex `else` block. This situation is harmful to the code readability and maintainability because it's difficult to know from which clause the error value came.\n\n#### Example\n\nAn example of this anti-pattern, as shown below, is a function `open_decoded_file/1` that reads a Base64-encoded string content from a file and returns a decoded binary string. This function uses a `with` statement that needs to handle two possible errors, all of which are concentrated in a single complex `else` block.\n\n```elixir\ndef open_decoded_file(path) do\n  with {:ok, encoded} <- File.read(path),\n       {:ok, decoded} <- Base.decode64(encoded) do\n    {:ok, String.trim(decoded)}\n  else\n    {:error, _} -> {:error, :badfile}\n    :error -> {:error, :badencoding}\n  end\nend\n```\n\nIn the code above, it is unclear how each pattern on the left side of `<-` relates to their error at the end. The more patterns in a `with`, the less clear the code gets, and the more likely it is that unrelated failures will overlap each other.\n\n#### Refactoring\n\nIn this situation, instead of concentrating all error handling within a single complex `else` block, it is better to normalize the return types in specific private functions. In this way, `with` can focus on the success case and the errors are normalized closer to where they happen, leading to better organized and maintainable code.\n\n```elixir\ndef open_decoded_file(path) do\n  with {:ok, encoded} <- file_read(path),\n       {:ok, decoded} <- base_decode64(encoded) do\n    {:ok, String.trim(decoded)}\n  end\nend\n\ndefp file_read(path) do\n  case File.read(path) do\n    {:ok, contents} -> {:ok, contents}\n    {:error, _} -> {:error, :badfile}\n  end\nend\n\ndefp base_decode64(contents) do\n  case Base.decode64(contents) do\n    {:ok, decoded} -> {:ok, decoded}\n    :error -> {:error, :badencoding}\n  end\nend\n```","ref":"code-anti-patterns.html#complex-else-clauses-in-with"},{"type":"extras","title":"Complex extractions in clauses - Code-related anti-patterns","doc":"#### Problem\n\nWhen we use multi-clause functions, it is possible to extract values in the clauses for further usage and for pattern matching/guard checking. This extraction itself does not represent an anti-pattern, but when you have *extractions made across several clauses and several arguments of the same function*, it becomes hard to know which extracted parts are used for pattern/guards and what is used only inside the function body. This anti-pattern is related to [Unrelated multi-clause function](design-anti-patterns.md#unrelated-multi-clause-function), but with implications of its own. It impairs the code readability in a different way.\n\n#### Example\n\nThe multi-clause function `drive/1` is extracting fields of an `%User{}` struct for usage in the clause expression (`age`) and for usage in the function body (`name`):\n\n```elixir\ndef drive(%User{name: name, age: age}) when age >= 18 do\n  \"#{name} can drive\"\nend\n\ndef drive(%User{name: name, age: age}) when age < 18 do\n  \"#{name} cannot drive\"\nend\n```\n\nWhile the example above is small and does not constitute an anti-pattern, it is an example of mixed extraction and pattern matching. A situation where `drive/1` was more complex, having many more clauses, arguments, and extractions, would make it hard to know at a glance which variables are used for pattern/guards and which ones are not.\n\n#### Refactoring\n\nAs shown below, a possible solution to this anti-pattern is to extract only pattern/guard related variables in the signature once you have many arguments or multiple clauses:\n\n```elixir\ndef drive(%User{age: age} = user) when age >= 18 do\n  %User{name: name} = user\n  \"#{name} can drive\"\nend\n\ndef drive(%User{age: age} = user) when age < 18 do\n  %User{name: name} = user\n  \"#{name} cannot drive\"\nend\n```","ref":"code-anti-patterns.html#complex-extractions-in-clauses"},{"type":"extras","title":"Dynamic atom creation - Code-related anti-patterns","doc":"#### Problem\n\nAn `Atom` is an Elixir basic type whose value is its own name. Atoms are often useful to identify resources or express the state, or result, of an operation. Creating atoms dynamically is not an anti-pattern by itself; however, atoms are not garbage collected by the Erlang Virtual Machine, so values of this type live in memory during a software's entire execution lifetime. The Erlang VM limits the number of atoms that can exist in an application by default to *1_048_576*, which is more than enough to cover all atoms defined in a program, but attempts to serve as an early limit for applications which are \"leaking atoms\" through dynamic creation.\n\nFor these reason, creating atoms dynamically can be considered an anti-pattern when the developer has no control over how many atoms will be created during the software execution. This unpredictable scenario can expose the software to unexpected behavior caused by excessive memory usage, or even by reaching the maximum number of *atoms* possible.\n\n#### Example\n\nPicture yourself implementing code that converts string values into atoms. These strings could have been received from an external system, either as part of a request into our application, or as part of a response to your application. This dynamic and unpredictable scenario poses a security risk, as these uncontrolled conversions can potentially trigger out-of-memory errors.\n\n```elixir\ndefmodule MyRequestHandler do\n  def parse(%{\"status\" => status, \"message\" => message} = _payload) do\n    %{status: String.to_atom(status), message: message}\n  end\nend\n```\n\n```elixir\niex> MyRequestHandler.parse(%{\"status\" => \"ok\", \"message\" => \"all good\"})\n%{status: :ok, message: \"all good\"}\n```\n\nWhen we use the `String.to_atom/1` function to dynamically create an atom, it essentially gains potential access to create arbitrary atoms in our system, causing us to lose control over adhering to the limits established by the BEAM. This issue could be exploited by someone to create enough atoms to shut down a system.\n\n#### Refactoring\n\nTo eliminate this anti-pattern, developers must either perform explicit conversions by mapping strings to atoms or replace the use of `String.to_atom/1` with `String.to_existing_atom/1`. An explicit conversion could be done as follows:\n\n```elixir\ndefmodule MyRequestHandler do\n  def parse(%{\"status\" => status, \"message\" => message} = _payload) do\n    %{status: convert_status(status), message: message}\n  end\n\n  defp convert_status(\"ok\"), do: :ok\n  defp convert_status(\"error\"), do: :error\n  defp convert_status(\"redirect\"), do: :redirect\nend\n```\n\n```elixir\niex> MyRequestHandler.parse(%{\"status\" => \"status_not_seen_anywhere\", \"message\" => \"all good\"})\n** (FunctionClauseError) no function clause matching in MyRequestHandler.convert_status/1\n```\n\nBy explicitly listing all supported statuses, you guarantee only a limited number of conversions may happen. Passing an invalid status will lead to a function clause error.\n\nAn alternative is to use `String.to_existing_atom/1`, which will only convert a string to atom if the atom already exists in the system:\n\n```elixir\ndefmodule MyRequestHandler do\n  def parse(%{\"status\" => status, \"message\" => message} = _payload) do\n    %{status: String.to_existing_atom(status), message: message}\n  end\nend\n```\n\n```elixir\niex> MyRequestHandler.parse(%{\"status\" => \"status_not_seen_anywhere\", \"message\" => \"all good\"})\n** (ArgumentError) errors were found at the given arguments:\n\n  * 1st argument: not an already existing atom\n```\n\nIn such cases, passing an unknown status will raise as long as the status was not defined anywhere as an atom in the system. However, assuming `status` can be either `:ok`, `:error`, or `:redirect`, how can you guarantee those atoms exist? You must ensure those atoms exist somewhere **in the same module** where `String.to_existing_atom/1` is called. For example, if you had this code:\n\n```elixir\ndefmodule MyRequestHandler do\n  def parse(%{\"status\" => status, \"message\" => message} = _payload) do\n    %{status: String.to_existing_atom(status), message: message}\n  end\n\n  def handle(%{status: status}) do\n    case status do\n      :ok -> ...\n      :error -> ...\n      :redirect -> ...\n    end\n  end\nend\n```\n\nAll valid statuses are defined as atoms within the same module, and that's enough. If you want to be explicit, you could also have a function that lists them:\n\n```elixir\ndef valid_statuses do\n  [:ok, :error, :redirect]\nend\n```\n\nHowever, keep in mind using a module attribute or defining the atoms in the module body, outside of a function, are not sufficient, as the module body is only executed during compilation and it is not necessarily part of the compiled module loaded at runtime.","ref":"code-anti-patterns.html#dynamic-atom-creation"},{"type":"extras","title":"Long parameter list - Code-related anti-patterns","doc":"#### Problem\n\nIn a functional language like Elixir, functions tend to explicitly receive all inputs and return all relevant outputs, instead of relying on mutations or side-effects. As functions grow in complexity, the amount of arguments (parameters) they need to work with may grow, to a point where the function's interface becomes confusing and prone to errors during use.\n\n#### Example\n\nIn the following example, the `loan/6` functions takes too many arguments, causing its interface to be confusing and potentially leading developers to introduce errors during calls to this function.\n\n```elixir\ndefmodule Library do\n  # Too many parameters that can be grouped!\n  def loan(user_name, email, password, user_alias, book_title, book_ed) do\n    ...\n  end\nend\n```\n\n#### Refactoring\n\nTo address this anti-pattern, related arguments can be grouped using key-value data structures, such as maps, structs, or even keyword lists in the case of optional arguments. This effectively reduces the number of arguments and the key-value data structures adds clarity to the caller.\n\nFor this particular example, the arguments to `loan/6` can be grouped into two different maps, thereby reducing its arity to `loan/2`:\n\n```elixir\ndefmodule Library do\n  def loan(%{name: name, email: email, password: password, alias: alias} = user, %{title: title, ed: ed} = book) do\n    ...\n  end\nend\n```\n\nIn some cases, the function with too many arguments may be a private function, which gives us more flexibility over how to separate the function arguments. One possible suggestion for such scenarios is to split the arguments in two maps (or tuples): one map keeps the data that may change, and the other keeps the data that won't change (read-only). This gives us a mechanical option to refactor the code.\n\nOther times, a function may legitimately take half a dozen or more completely unrelated arguments. This may suggest the function is trying to do too much and would be better broken into multiple functions, each responsible for a smaller piece of the overall responsibility.","ref":"code-anti-patterns.html#long-parameter-list"},{"type":"extras","title":"Namespace trespassing - Code-related anti-patterns","doc":"#### Problem\n\nThis anti-pattern manifests when a package author or a library defines modules outside of its \"namespace\". A library should use its name as a \"prefix\" for all of its modules. For example, a package named `:my_lib` should define all of its modules within the `MyLib` namespace, such as `MyLib.User`, `MyLib.SubModule`, `MyLib.Application`, and `MyLib` itself.\n\nThis is important because the Erlang VM can only load one instance of a module at a time. So if there are multiple libraries that define the same module, then they are incompatible with each other due to this limitation. By always using the library name as a prefix, it avoids module name clashes due to the unique prefix.\n\n#### Example\n\nThis problem commonly manifests when writing an extension of another library. For example, imagine you are writing a package that adds authentication to [Plug](https://github.com/elixir-plug/plug) called `:plug_auth`. You must avoid defining modules within the `Plug` namespace:\n\n```elixir\ndefmodule Plug.Auth do\n  # ...\nend\n```\n\nEven if `Plug` does not currently define a `Plug.Auth` module, it may add such a module in the future, which would ultimately conflict with `plug_auth`'s definition.\n\n#### Refactoring\n\nGiven the package is named `:plug_auth`, it must define modules inside the `PlugAuth` namespace:\n\n```elixir\ndefmodule PlugAuth do\n  # ...\nend\n```\n\n#### Additional remarks\n\nThere are few known exceptions to this anti-pattern:\n\n  * [Protocol implementations](`Kernel.defimpl/2`) are, by design, defined under the protocol namespace\n\n  * In some scenarios, the namespace owner may allow exceptions to this rule. For example, in Elixir itself, you defined [custom Mix tasks](`Mix.Task`) by placing them under the `Mix.Tasks` namespace, such as `Mix.Tasks.PlugAuth`\n\n  * If you are the maintainer for both `plug` and `plug_auth`, then you may allow `plug_auth` to define modules with the `Plug` namespace, such as `Plug.Auth`. However, you are responsible for avoiding or managing any conflicts that may arise in the future","ref":"code-anti-patterns.html#namespace-trespassing"},{"type":"extras","title":"Non-assertive map access - Code-related anti-patterns","doc":"#### Problem\n\nIn Elixir, it is possible to access values from `Map`s, which are key-value data structures, either statically or dynamically.\n\nWhen a key is expected to exist in a map, it must be accessed using the `map.key` notation, making it clear to developers (and the compiler) that the key must exist. If the key does not exist, an exception is raised (and in some cases also compiler warnings). This is also known as the static notation, as the key is known at the time of writing the code.\n\nWhen a key is optional, the `map[:key]` notation must be used instead. This way, if the informed key does not exist, `nil` is returned. This is the dynamic notation, as it also supports dynamic key access, such as `map[some_var]`.\n\nWhen you use `map[:key]` to access a key that always exists in the map, you are making the code less clear for developers and for the compiler, as they now need to work with the assumption the key may not be there. This mismatch may also make it harder to track certain bugs. If the key is unexpectedly missing, you will have a `nil` value propagate through the system, instead of raising on map access.\n\n#### Example\n\nThe function `plot/1` tries to draw a graphic to represent the position of a point in a Cartesian plane. This function receives a parameter of `Map` type with the point attributes, which can be a point of a 2D or 3D Cartesian coordinate system. This function uses dynamic access to retrieve values for the map keys:\n\n```elixir\ndefmodule Graphics do\n  def plot(point) do\n    # Some other code...\n    {point[:x], point[:y], point[:z]}\n  end\nend\n```\n\n```elixir\niex> point_2d = %{x: 2, y: 3}\n%{x: 2, y: 3}\niex> point_3d = %{x: 5, y: 6, z: 7}\n%{x: 5, y: 6, z: 7}\niex> Graphics.plot(point_2d)\n{2, 3, nil}\niex> Graphics.plot(point_3d)\n{5, 6, 7}\n```\n\nGiven we want to plot both 2D and 3D points, the behavior above is expected. But what happens if we forget to pass a point with either `:x` or `:y`?\n\n```elixir\niex> bad_point = %{y: 3, z: 4}\n%{y: 3, z: 4}\niex> Graphics.plot(bad_point)\n{nil, 3, 4}\n```\n\nThe behavior above is unexpected because our function should not work with points without a `:x` key. This leads to subtle bugs, as we may now pass `nil` to another function, instead of raising early on.\n\n#### Refactoring\n\nTo remove this anti-pattern, we must use the dynamic `map[:key]` syntax and the static `map.key` notation according to our requirements. We expect `:x` and `:y` to always exist, but not `:z`. The next code illustrates the refactoring of `plot/1`, removing this anti-pattern:\n\n```elixir\ndefmodule Graphics do\n  def plot(point) do\n    # Some other code...\n    {point.x, point.y, point[:z]}\n  end\nend\n```\n\n```elixir\niex> Graphics.plot(point_2d)\n{2, 3, nil}\niex> Graphics.plot(bad_point)\n** (KeyError) key :x not found in: %{y: 3, z: 4}\n  graphic.ex:4: Graphics.plot/1\n```\n\nOverall, the usage of `map.key` and `map[:key]` encode important information about your data structure, allowing developers to be clear about their intent. See both `Map` and `Access` module documentation for more information and examples.\n\nAn alternative to refactor this anti-pattern is to use pattern matching, defining explicit clauses for 2d vs 3d points:\n\n```elixir\ndefmodule Graphics do\n  # 3d\n  def plot(%{x: x, y: y, z: z}) do\n    # Some other code...\n    {x, y, z}\n  end\n\n  # 2d\n  def plot(%{x: x, y: y}) do\n    # Some other code...\n    {x, y}\n  end\nend\n```\n\nPattern-matching is specially useful when matching over multiple keys as well as on the values themselves at once.\n\nAnother option is to use structs. By default, structs only support static access to its fields. In such scenarios, you may consider defining structs for both 2D and 3D points:\n\n```elixir\ndefmodule Point2D do\n  @enforce_keys [:x, :y]\n  defstruct [x: nil, y: nil]\nend\n```\n\nGenerally speaking, structs are useful when sharing data structures across modules, at the cost of adding a compile time dependency between these modules. If module `A` uses a struct defined in module `B`, `A` must be recompiled if the fields in the struct `B` change.\n\n#### Additional remarks\n\nThis anti-pattern was formerly known as [Accessing non-existent map/struct fields](https://github.com/lucasvegi/Elixir-Code-Smells#accessing-non-existent-mapstruct-fields).","ref":"code-anti-patterns.html#non-assertive-map-access"},{"type":"extras","title":"Non-assertive pattern matching - Code-related anti-patterns","doc":"#### Problem\n\nOverall, Elixir systems are composed of many supervised processes, so the effects of an error are localized to a single process, and don't propagate to the entire application. A supervisor detects the failing process, reports it, and possibly restarts it. This anti-pattern arises when developers write defensive or imprecise code, capable of returning incorrect values which were not planned for, instead of programming in an assertive style through pattern matching and guards.\n\n#### Example\n\nThe function `get_value/2` tries to extract a value from a specific key of a URL query string. As it is not implemented using pattern matching, `get_value/2` always returns a value, regardless of the format of the URL query string passed as a parameter in the call. Sometimes the returned value will be valid. However, if a URL query string with an unexpected format is used in the call, `get_value/2` will extract incorrect values from it:\n\n```elixir\ndefmodule Extract do\n  def get_value(string, desired_key) do\n    parts = String.split(string, \"&\")\n\n    Enum.find_value(parts, fn pair ->\n      key_value = String.split(pair, \"=\")\n      Enum.at(key_value, 0) == desired_key && Enum.at(key_value, 1)\n    end)\n  end\nend\n```\n\n```elixir\n# URL query string with the planned format - OK!\niex> Extract.get_value(\"name=Lucas&university=UFMG&lab=ASERG\", \"lab\")\n\"ASERG\"\niex> Extract.get_value(\"name=Lucas&university=UFMG&lab=ASERG\", \"university\")\n\"UFMG\"\n# Unplanned URL query string format - Unplanned value extraction!\niex> Extract.get_value(\"name=Lucas&university=institution=UFMG&lab=ASERG\", \"university\")\n\"institution\"   # <= why not \"institution=UFMG\"? or only \"UFMG\"?\n```\n\n#### Refactoring\n\nTo remove this anti-pattern, `get_value/2` can be refactored through the use of pattern matching. So, if an unexpected URL query string format is used, the function will crash instead of returning an invalid value. This behavior, shown below, allows clients to decide how to handle these errors and doesn't give a false impression that the code is working correctly when unexpected values are extracted:\n\n```elixir\ndefmodule Extract do\n  def get_value(string, desired_key) do\n    parts = String.split(string, \"&\")\n\n    Enum.find_value(parts, fn pair ->\n      [key, value] = String.split(pair, \"=\") # <= pattern matching\n      key == desired_key && value\n    end)\n  end\nend\n```\n\n```elixir\n# URL query string with the planned format - OK!\niex> Extract.get_value(\"name=Lucas&university=UFMG&lab=ASERG\", \"name\")\n\"Lucas\"\n# Unplanned URL query string format - Crash explaining the problem to the client!\niex> Extract.get_value(\"name=Lucas&university=institution=UFMG&lab=ASERG\", \"university\")\n** (MatchError) no match of right hand side value: [\"university\", \"institution\", \"UFMG\"]\n  extract.ex:7: anonymous fn/2 in Extract.get_value/2 # <= left hand: [key, value] pair\niex> Extract.get_value(\"name=Lucas&university&lab=ASERG\", \"university\")\n** (MatchError) no match of right hand side value: [\"university\"]\n  extract.ex:7: anonymous fn/2 in Extract.get_value/2 # <= left hand: [key, value] pair\n```\n\nElixir and pattern matching promote an assertive style of programming where you handle the known cases. Once an unexpected scenario arises, you can decide to address it accordingly based on practical examples, or conclude the scenario is indeed invalid and the exception is the desired choice.\n\n`case/2` is another important construct in Elixir that help us write assertive code, by matching on specific patterns. For example, if a function returns `{:ok, ...}` or `{:error, ...}`, prefer to explicitly match on both patterns:\n\n```elixir\ncase some_function(arg) do\n  {:ok, value} -> # ...\n  {:error, _} -> # ...\nend\n```\n\nIn particular, avoid matching solely on `_`, as shown below:\n\n```elixir\ncase some_function(arg) do\n  {:ok, value} -> # ...\n  _ -> # ...\nend\n```\n\n Matching on `_` is less clear in intent and it may hide bugs if `some_function/1` adds new return values in the future.\n\n#### Additional remarks\n\nThis anti-pattern was formerly known as [Speculative assumptions](https://github.com/lucasvegi/Elixir-Code-Smells#speculative-assumptions).","ref":"code-anti-patterns.html#non-assertive-pattern-matching"},{"type":"extras","title":"Non-assertive truthiness - Code-related anti-patterns","doc":"#### Problem\n\nElixir provides the concept of truthiness: `nil` and `false` are considered \"falsy\" and all other values are \"truthy\". Many constructs in the language, such as `&&/2`, `||/2`, and `!/1` handle truthy and falsy values. Using those operators is not an anti-pattern. However, using those operators when all operands are expected to be booleans, may be an anti-pattern.\n\n#### Example\n\nThe simplest scenario where this anti-pattern manifests is in conditionals, such as:\n\n```elixir\nif is_binary(name) && is_integer(age) do\n  # ...\nelse\n  # ...\nend\n```\n\nGiven both operands of `&&/2` are booleans, the code is more generic than necessary, and potentially unclear.\n\n#### Refactoring\n\nTo remove this anti-pattern, we can replace `&&/2`, `||/2`, and `!/1` by `and/2`, `or/2`, and `not/1` respectively. These operators assert at least their first argument is a boolean:\n\n```elixir\nif is_binary(name) and is_integer(age) do\n  # ...\nelse\n  # ...\nend\n```\n\nThis technique may be particularly important when working with Erlang code. Erlang does not have the concept of truthiness. It never returns `nil`, instead its functions may return `:error` or `:undefined` in places an Elixir developer would return `nil`. Therefore, to avoid accidentally interpreting `:undefined` or `:error` as a truthy value, you may prefer to use `and/2`, `or/2`, and `not/1` exclusively when interfacing with Erlang APIs.","ref":"code-anti-patterns.html#non-assertive-truthiness"},{"type":"extras","title":"Design-related anti-patterns","doc":"# Design-related anti-patterns\n\nThis document outlines potential anti-patterns related to your modules, functions, and the role they play within a codebase.","ref":"design-anti-patterns.html"},{"type":"extras","title":"Alternative return types - Design-related anti-patterns","doc":"#### Problem\n\nThis anti-pattern refers to functions that receive options (typically as a *keyword list* parameter) that drastically change their return type. Because options are optional and sometimes set dynamically, if they also change the return type, it may be hard to understand what the function actually returns.\n\n#### Example\n\nAn example of this anti-pattern, as shown below, is when a function has many alternative return types, depending on the options received as a parameter.\n\n```elixir\ndefmodule AlternativeInteger do\n  @spec parse(String.t(), keyword()) :: integer() | {integer(), String.t()} | :error\n  def parse(string, options \\\\ []) when is_list(options) do\n    if Keyword.get(options, :discard_rest, false) do\n      case Integer.parse(string) do\n        {int, _rest} -> int\n        :error -> :error\n      end\n    else\n      Integer.parse(string)\n    end\n  end\nend\n```\n\n```elixir\niex> AlternativeInteger.parse(\"13\")\n{13, \"\"}\niex> AlternativeInteger.parse(\"13\", discard_rest: false)\n{13, \"\"}\niex> AlternativeInteger.parse(\"13\", discard_rest: true)\n13\n```\n\n#### Refactoring\n\nTo refactor this anti-pattern, as shown next, add a specific function for each return type (for example, `parse_discard_rest/1`), no longer delegating this to options passed as arguments.\n\n```elixir\ndefmodule AlternativeInteger do\n  @spec parse(String.t()) :: {integer(), String.t()} | :error\n  def parse(string) do\n    Integer.parse(string)\n  end\n\n  @spec parse_discard_rest(String.t()) :: integer() | :error\n  def parse_discard_rest(string) do\n    case Integer.parse(string) do\n      {int, _rest} -> int\n      :error -> :error\n    end\n  end\nend\n```\n\n```elixir\niex> AlternativeInteger.parse(\"13\")\n{13, \"\"}\niex> AlternativeInteger.parse_discard_rest(\"13\")\n13\n```","ref":"design-anti-patterns.html#alternative-return-types"},{"type":"extras","title":"Boolean obsession - Design-related anti-patterns","doc":"#### Problem\n\nThis anti-pattern happens when booleans are used instead of atoms to encode information. The usage of booleans themselves is not an anti-pattern, but whenever multiple booleans are used with overlapping states, replacing the booleans by atoms (or composite data types such as *tuples*) may lead to clearer code.\n\nThis is a special case of [*Primitive obsession*](#primitive-obsession), specific to boolean values.\n\n#### Example\n\nAn example of this anti-pattern is a function that receives two or more options, such as `editor: true` and `admin: true`, to configure its behavior in overlapping ways. In the code below, the `:editor` option has no effect if `:admin` is set, meaning that the `:admin` option has higher priority than `:editor`, and they are ultimately related.\n\n```elixir\ndefmodule MyApp do\n  def process(invoice, options \\\\ []) do\n    cond do\n      options[:admin] ->  # Is an admin\n      options[:editor] -> # Is an editor\n      true ->          # Is none\n    end\n  end\nend\n```\n\n#### Refactoring\n\nInstead of using multiple options, the code above could be refactored to receive a single option, called `:role`, that can be either `:admin`, `:editor`, or `:default`:\n\n```elixir\ndefmodule MyApp do\n  def process(invoice, options \\\\ []) do\n    case Keyword.get(options, :role, :default) do\n      :admin ->   # Is an admin\n      :editor ->  # Is an editor\n      :default -> # Is none\n    end\n  end\nend\n```\n\nThis anti-pattern may also happen in our own data structures. For example, we may define a `User` struct with two boolean fields, `:editor` and `:admin`, while a single field named `:role` may be preferred.\n\nFinally, it is worth noting that using atoms may be preferred even when we have a single boolean argument/option. For example, consider an invoice which may be set as approved/unapproved. One option is to provide a function that expects a boolean:\n\n```elixir\nMyApp.update(invoice, approved: true)\n```\n\nHowever, using atoms may read better and make it simpler to add further states (such as pending) in the future:\n\n```elixir\nMyApp.update(invoice, status: :approved)\n```\n\nRemember booleans are internally represented as atoms. Therefore there is no performance penalty in one approach over the other.","ref":"design-anti-patterns.html#boolean-obsession"},{"type":"extras","title":"Exceptions for control-flow - Design-related anti-patterns","doc":"#### Problem\n\nThis anti-pattern refers to code that uses `Exception`s for control flow. Exception handling itself does not represent an anti-pattern, but developers must prefer to use `case` and pattern matching to change the flow of their code, instead of `try/rescue`. In turn, library authors should provide developers with APIs to handle errors without relying on exception handling. When developers have no freedom to decide if an error is exceptional or not, this is considered an anti-pattern.\n\n#### Example\n\nAn example of this anti-pattern, as shown below, is using `try/rescue` to deal with file operations:\n\n```elixir\ndefmodule MyModule do\n  def print_file(file) do\n    try do\n      IO.puts(File.read!(file))\n    rescue\n      e -> IO.puts(:stderr, Exception.message(e))\n    end\n  end\nend\n```\n\n```elixir\niex> MyModule.print_file(\"valid_file\")\nThis is a valid file!\n:ok\niex> MyModule.print_file(\"invalid_file\")\ncould not read file \"invalid_file\": no such file or directory\n:ok\n```\n\n#### Refactoring\n\nTo refactor this anti-pattern, as shown next, use `File.read/1`, which returns tuples instead of raising when a file cannot be read:\n\n```elixir\ndefmodule MyModule do\n  def print_file(file) do\n    case File.read(file) do\n      {:ok, binary} -> IO.puts(binary)\n      {:error, reason} -> IO.puts(:stderr, \"could not read file #{file}: #{reason}\")\n    end\n  end\nend\n```\n\nThis is only possible because the `File` module provides APIs for reading files with tuples as results (`File.read/1`), as well as a version that raises an exception (`File.read!/1`). The bang (exclamation point) is effectively part of [Elixir's naming conventions](naming-conventions.md#trailing-bang-foo).\n\nLibrary authors are encouraged to follow the same practices. In practice, the bang variant is implemented on top of the non-raising version of the code. For example, `File.read!/1` is implemented as:\n\n```elixir\ndef read!(path) do\n  case read(path) do\n    {:ok, binary} ->\n      binary\n\n    {:error, reason} ->\n      raise File.Error, reason: reason, action: \"read file\", path: IO.chardata_to_string(path)\n  end\nend\n```\n\nA common practice followed by the community is to make the non-raising version return `{:ok, result}` or `{:error, Exception.t}`. For example, an HTTP client may return `{:ok, %HTTP.Response{}}` on success cases and `{:error, %HTTP.Error{}}` for failures, where `HTTP.Error` is [implemented as an exception](`Kernel.defexception/1`). This makes it convenient for anyone to raise an exception by simply calling `Kernel.raise/1`.\n\n#### Additional remarks\n\nThis anti-pattern is of special importance to library authors and whenever writing functions that will be invoked by other developers and third-party code. Nevertheless, there are still scenarios where developers can afford to raise exceptions directly, for example:\n\n  * invalid arguments: it is expected that functions will raise for invalid arguments, as those are structural error and not semantic errors. For example, `File.read(123)` will always raise, because `123` is never a valid filename\n\n  * during tests, scripts, etc: those are common scenarios where you want your code to fail as soon as possible in case of errors. Using `!` functions, such as `File.read!/1`, allows you to do so quickly and with clear error messages\n\n  * some frameworks, such as [Phoenix](https://phoenixframework.org), allow developers to raise exceptions in their code and uses a protocol to convert these exceptions into semantic HTTP responses\n\nThis anti-pattern was formerly known as [Using exceptions for control-flow](https://github.com/lucasvegi/Elixir-Code-Smells#using-exceptions-for-control-flow).","ref":"design-anti-patterns.html#exceptions-for-control-flow"},{"type":"extras","title":"Primitive obsession - Design-related anti-patterns","doc":"#### Problem\n\nThis anti-pattern happens when Elixir basic types (for example, *integer*, *float*, and *string*) are excessively used to carry structured information, rather than creating specific composite data types (for example, *tuples*, *maps*, and *structs*) that can better represent a domain.\n\n#### Example\n\nAn example of this anti-pattern is the use of a single *string* to represent an `Address`. An `Address` is a more complex structure than a simple basic (aka, primitive) value.\n\n```elixir\ndefmodule MyApp do\n  def extract_postal_code(address) when is_binary(address) do\n    # Extract postal code with address...\n  end\n\n  def fill_in_country(address) when is_binary(address) do\n    # Fill in missing country...\n  end\nend\n```\n\nWhile you may receive the `address` as a string from a database, web request, or a third-party, if you find yourself frequently manipulating or extracting information from the string, it is a good indicator you should convert the address into structured data:\n\nAnother example of this anti-pattern is using floating numbers to model money and currency, when [richer data structures should be preferred](https://hexdocs.pm/ex_money/).\n\n#### Refactoring\n\nPossible solutions to this anti-pattern is to use maps or structs to model our address. The example below creates an `Address` struct, better representing this domain through a composite type. Additionally, we introduce a `parse/1` function, that converts the string into an `Address`, which will simplify the logic of remaining functions. With this modification, we can extract each field of this composite type individually when needed.\n\n```elixir\ndefmodule Address do\n  defstruct [:street, :city, :state, :postal_code, :country]\nend\n```\n\n```elixir\ndefmodule MyApp do\n  def parse(address) when is_binary(address) do\n    # Returns %Address{}\n  end\n\n  def extract_postal_code(%Address{} = address) do\n    # Extract postal code with address...\n  end\n\n  def fill_in_country(%Address{} = address) do\n    # Fill in missing country...\n  end\nend\n```","ref":"design-anti-patterns.html#primitive-obsession"},{"type":"extras","title":"Unrelated multi-clause function - Design-related anti-patterns","doc":"#### Problem\n\nUsing multi-clause functions is a powerful Elixir feature. However, some developers may abuse this feature to group *unrelated* functionality, which is an anti-pattern.\n\n#### Example\n\nA frequent example of this usage of multi-clause functions occurs when developers mix unrelated business logic into the same function definition, in a way that the behavior of each clause becomes completely distinct from the others. Such functions often have too broad specifications, making it difficult for other developers to understand and maintain them.\n\nSome developers may use documentation mechanisms such as `@doc` annotations to compensate for poor code readability, however the documentation itself may end-up full of conditionals to describe how the function behaves for each different argument combination. This is a good indicator that the clauses are ultimately unrelated.\n\n```elixir\n@doc \"\"\"\nUpdates a struct.\n\nIf given a product, it will...\n\nIf given an animal, it will...\n\"\"\"\ndef update(%Product{count: count, material: material})  do\n  # ...\nend\n\ndef update(%Animal{count: count, skin: skin})  do\n  # ...\nend\n```\n\nIf updating an animal is completely different from updating a product and requires a different set of rules, it may be worth splitting those over different functions or even different modules.\n\n#### Refactoring\n\nAs shown below, a possible solution to this anti-pattern is to break the business rules that are mixed up in a single unrelated multi-clause function in simple functions. Each function can have a specific name and `@doc`, describing its behavior and parameters received. While this refactoring sounds simple, it can impact the function's callers, so be careful!\n\n```elixir\n@doc \"\"\"\nUpdates a product.\n\nIt will...\n\"\"\"\ndef update_product(%Product{count: count, material: material}) do\n  # ...\nend\n\n@doc \"\"\"\nUpdates an animal.\n\nIt will...\n\"\"\"\ndef update_animal(%Animal{count: count, skin: skin}) do\n  # ...\nend\n```\n\nThese functions may still be implemented with multiple clauses, as long as the clauses group related functionality. For example, `update_product` could be in practice implemented as follows:\n\n```elixir\ndef update_product(%Product{count: 0}) do\n  # ...\nend\n\ndef update_product(%Product{material: material})\n    when material in [\"metal\", \"glass\"] do\n  # ...\nend\n\ndef update_product(%Product{material: material})\n    when material not in [\"metal\", \"glass\"] do\n  # ...\nend\n```\n\nYou can see this pattern in practice within Elixir itself. The `+/2` operator can add `Integer`s and `Float`s together, but not `String`s, which instead use the `<>/2` operator. In this sense, it is reasonable to handle integers and floats in the same operation, but strings are unrelated enough to deserve their own function.\n\nYou will also find examples in Elixir of functions that work with any struct, which would seemingly be an occurrence of this anti-pattern, such as `struct/2`:\n\n```elixir\niex> struct(URI.parse(\"/foo/bar\"), path: \"/bar/baz\")\n%URI{\n  scheme: nil,\n  userinfo: nil,\n  host: nil,\n  port: nil,\n  path: \"/bar/baz\",\n  query: nil,\n  fragment: nil\n}\n```\n\nThe difference here is that the `struct/2` function behaves precisely the same for any struct given, therefore there is no question of how the function handles different inputs. If the behavior is clear and consistent for all inputs, then the anti-pattern does not take place.","ref":"design-anti-patterns.html#unrelated-multi-clause-function"},{"type":"extras","title":"Using application configuration for libraries - Design-related anti-patterns","doc":"#### Problem\n\nThe [*application environment*](https://hexdocs.pm/elixir/Application.html#module-the-application-environment) can be used to parameterize global values that can be used in an Elixir system. This mechanism can be very useful and therefore is not considered an anti-pattern by itself. However, library authors should avoid using the application environment to configure their library. The reason is exactly that the application environment is a **global** state, so there can only be a single value for each key in the environment for an application. This makes it impossible for multiple applications depending on the same library to configure the same aspect of the library in different ways.\n\n#### Example\n\nThe `DashSplitter` module represents a library that configures the behavior of its functions through the global application environment. These configurations are concentrated in the *config/config.exs* file, shown below:\n\n```elixir\nimport Config\n\nconfig :app_config,\n  parts: 3\n\nimport_config \"#{config_env()}.exs\"\n```\n\nOne of the functions implemented by the `DashSplitter` library is `split/1`. This function aims to separate a string received via a parameter into a certain number of parts. The character used as a separator in `split/1` is always `\"-\"` and the number of parts the string is split into is defined globally by the application environment. This value is retrieved by the `split/1` function by calling `Application.fetch_env!/2`, as shown next:\n\n```elixir\ndefmodule DashSplitter do\n  def split(string) when is_binary(string) do\n    parts = Application.fetch_env!(:app_config, :parts) # <= retrieve parameterized value\n    String.split(string, \"-\", parts: parts)             # <= parts: 3\n  end\nend\n```\n\nDue to this parameterized value used by the `DashSplitter` library, all applications dependent on it can only use the `split/1` function with identical behavior about the number of parts generated by string separation. Currently, this value is equal to 3, as we can see in the use examples shown below:\n\n```elixir\niex> DashSplitter.split(\"Lucas-Francisco-Vegi\")\n[\"Lucas\", \"Francisco\", \"Vegi\"]\niex> DashSplitter.split(\"Lucas-Francisco-da-Matta-Vegi\")\n[\"Lucas\", \"Francisco\", \"da-Matta-Vegi\"]\n```\n\n#### Refactoring\n\nTo remove this anti-pattern, this type of configuration should be performed using a parameter passed to the function. The code shown below performs the refactoring of the `split/1` function by accepting [keyword lists](`Keyword`) as a new optional parameter. With this new parameter, it is possible to modify the default behavior of the function at the time of its call, allowing multiple different ways of using `split/2` within the same application:\n\n```elixir\ndefmodule DashSplitter do\n  def split(string, opts \\\\ []) when is_binary(string) and is_list(opts) do\n    parts = Keyword.get(opts, :parts, 2) # <= default config of parts == 2\n    String.split(string, \"-\", parts: parts)\n  end\nend\n```\n\n```elixir\niex> DashSplitter.split(\"Lucas-Francisco-da-Matta-Vegi\", [parts: 5])\n[\"Lucas\", \"Francisco\", \"da\", \"Matta\", \"Vegi\"]\niex> DashSplitter.split(\"Lucas-Francisco-da-Matta-Vegi\") #<= default config is used!\n[\"Lucas\", \"Francisco-da-Matta-Vegi\"]\n```\n\nOf course, not all uses of the application environment by libraries are incorrect. One example is using configuration to replace a component (or dependency) of a library by another that must behave the exact same. Consider a library that needs to parse CSV files. The library author may pick one package to use as default parser but allow its users to swap to different implementations via the application environment. At the end of the day, choosing a different CSV parser should not change the outcome, and library authors can even enforce this by [defining behaviours](../references/typespecs.md#behaviours) with the exact semantics they expect.\n\n#### Additional remarks: Supervision trees\n\nIn practice, libraries may require additional configuration beyond keyword lists. For example, if a library needs to start a supervision tree, how can the user of said library customize its supervision tree? Given the supervision tree itself is global (as it belongs to the library), library authors may be tempted to use the application configuration once more.\n\nOne solution is for the library to provide its own child specification, instead of starting the supervision tree itself. This allows the user to start all necessary processes under its own supervision tree, potentially passing custom configuration options during initialization.\n\nYou can see this pattern in practice in projects like [Nx](https://github.com/elixir-nx/nx) and [DNS Cluster](https://github.com/phoenixframework/dns_cluster). These libraries require that you list processes under your own supervision tree:\n\n```elixir\nchildren = [\n  {DNSCluster, query: \"my.subdomain\"}\n]\n```\n\nIn such cases, if the users of `DNSCluster` need to configure DNSCluster per environment, they can be the ones reading from the application environment, without the library forcing them to:\n\n```elixir\nchildren = [\n  {DNSCluster, query: Application.get_env(:my_app, :dns_cluster_query) || :ignore}\n]\n```\n\nSome libraries, such as [Ecto](https://github.com/elixir-ecto/ecto), allow you to pass your application name as an option (called `:otp_app` or similar) and then automatically read the environment from *your* application. While this addresses the issue with the application environment being global, as they read from each individual application, it comes at the cost of some indirection, compared to the example above where users explicitly read their application environment from their own code, whenever desired.\n\n#### Additional remarks: Compile-time configuration\n\nA similar discussion entails compile-time configuration. What if a library author requires some configuration to be provided at compilation time?\n\nOnce again, instead of forcing users of your library to provide compile-time configuration, you may want to allow users of your library to generate the code themselves. That's the approach taken by libraries such as [Ecto](https://github.com/elixir-ecto/ecto):\n\n```elixir\ndefmodule MyApp.Repo do\n  use Ecto.Repo, adapter: Ecto.Adapters.Postgres\nend\n```\n\nInstead of forcing developers to share a single repository, Ecto allows its users to define as many repositories as they want. Given the `:adapter` configuration is required at compile-time, it is a required value on `use Ecto.Repo`. If developers want to configure the adapter per environment, then it is their choice:\n\n```elixir\ndefmodule MyApp.Repo do\n  use Ecto.Repo, adapter: Application.compile_env(:my_app, :repo_adapter)\nend\n```\n\nOn the other hand, [code generation comes with its own anti-patterns](macro-anti-patterns.md), and must be considered carefully. That's to say: while using the application environment for libraries is discouraged, especially compile-time configuration, in some cases they may be the best option. For example, consider a library needs to parse CSV or JSON files to generate code based on data files. In such cases, it is best to provide reasonable defaults and make them customizable via the application environment, instead of asking each user of your library to generate the exact same code.\n\n#### Additional remarks: Mix tasks\n\nFor Mix tasks and related tools, it may be necessary to provide per-project configuration. For example, imagine you have a `:linter` project, which supports setting the output file and the verbosity level. You may choose to configure it through application environment:\n\n```elixir\nconfig :linter,\n  output_file: \"/path/to/output.json\",\n  verbosity: 3\n```\n\nHowever, `Mix` allows tasks to read per-project configuration via `Mix.Project.config/0`. In this case, you can configure the `:linter` directly in the `mix.exs` file:\n\n```elixir\ndef project do\n  [\n    app: :my_app,\n    version: \"1.0.0\",\n    linter: [\n      output_file: \"/path/to/output.json\",\n      verbosity: 3\n    ],\n    ...\n  ]\nend\n```\n\nAdditionally, if a Mix task is available, you can also accept these options as command line arguments (see `OptionParser`):\n\n```bash\nmix linter --output-file /path/to/output.json --verbosity 3\n```","ref":"design-anti-patterns.html#using-application-configuration-for-libraries"},{"type":"extras","title":"Process-related anti-patterns","doc":"# Process-related anti-patterns\n\nThis document outlines potential anti-patterns related to processes and process-based abstractions.","ref":"process-anti-patterns.html"},{"type":"extras","title":"Code organization by process - Process-related anti-patterns","doc":"#### Problem\n\nThis anti-pattern refers to code that is unnecessarily organized by processes. A process itself does not represent an anti-pattern, but it should only be used to model runtime properties (such as concurrency, access to shared resources, error isolation, etc). When you use a process for code organization, it can create bottlenecks in the system.\n\n#### Example\n\nAn example of this anti-pattern, as shown below, is a module that implements arithmetic operations (like `add` and `subtract`) by means of a `GenServer` process. If the number of calls to this single process grows, this code organization can compromise the system performance, therefore becoming a bottleneck.\n\n```elixir\ndefmodule Calculator do\n  @moduledoc \"\"\"\n  Calculator that performs basic arithmetic operations.\n\n  This code is unnecessarily organized in a GenServer process.\n  \"\"\"\n\n  use GenServer\n\n  def add(a, b, pid) do\n    GenServer.call(pid, {:add, a, b})\n  end\n\n  def subtract(a, b, pid) do\n    GenServer.call(pid, {:subtract, a, b})\n  end\n\n  @impl GenServer\n  def init(init_arg) do\n    {:ok, init_arg}\n  end\n\n  @impl GenServer\n  def handle_call({:add, a, b}, _from, state) do\n    {:reply, a + b, state}\n  end\n\n  def handle_call({:subtract, a, b}, _from, state) do\n    {:reply, a - b, state}\n  end\nend\n```\n\n```elixir\niex> {:ok, pid} = GenServer.start_link(Calculator, :init)\n{:ok, #PID<0.132.0>}\niex> Calculator.add(1, 5, pid)\n6\niex> Calculator.subtract(2, 3, pid)\n-1\n```\n\n#### Refactoring\n\nIn Elixir, as shown next, code organization must be done only through modules and functions. Whenever possible, a library should not impose specific behavior (such as parallelization) on its users. It is better to delegate this behavioral decision to the developers of clients, thus increasing the potential for code reuse of a library.\n\n```elixir\ndefmodule Calculator do\n  def add(a, b) do\n    a + b\n  end\n\n  def subtract(a, b) do\n    a - b\n  end\nend\n```\n\n```elixir\niex> Calculator.add(1, 5)\n6\niex> Calculator.subtract(2, 3)\n-1\n```","ref":"process-anti-patterns.html#code-organization-by-process"},{"type":"extras","title":"Scattered process interfaces - Process-related anti-patterns","doc":"#### Problem\n\nIn Elixir, the use of an `Agent`, a `GenServer`, or any other process abstraction is not an anti-pattern in itself. However, when the responsibility for direct interaction with a process is spread throughout the entire system, it can become problematic. This bad practice can increase the difficulty of code maintenance and make the code more prone to bugs.\n\n#### Example\n\nThe following code seeks to illustrate this anti-pattern. The responsibility for interacting directly with the `Agent` is spread across four different modules (`A`, `B`, `C`, and `D`).\n\n```elixir\ndefmodule A do\n  def update(process) do\n    # Some other code...\n    Agent.update(process, fn _list -> 123 end)\n  end\nend\n```\n\n```elixir\ndefmodule B do\n  def update(process) do\n    # Some other code...\n    Agent.update(process, fn content -> %{a: content} end)\n  end\nend\n```\n\n```elixir\ndefmodule C do\n  def update(process) do\n    # Some other code...\n    Agent.update(process, fn content -> [:atom_value | content] end)\n  end\nend\n```\n\n```elixir\ndefmodule D do\n  def get(process) do\n    # Some other code...\n    Agent.get(process, fn content -> content end)\n  end\nend\n```\n\nThis spreading of responsibility can generate duplicated code and make code maintenance more difficult. Also, due to the lack of control over the format of the shared data, complex composed data can be shared. This freedom to use any format of data is dangerous and can induce developers to introduce bugs.\n\n```elixir\n# start an agent with initial state of an empty list\niex> {:ok, agent} = Agent.start_link(fn -> [] end)\n{:ok, #PID<0.135.0>}\n\n# many data formats (for example, List, Map, Integer, Atom) are\n# combined through direct access spread across the entire system\niex> A.update(agent)\niex> B.update(agent)\niex> C.update(agent)\n\n# state of shared information\niex> D.get(agent)\n[:atom_value, %{a: 123}]\n```\n\nFor a `GenServer` and other behaviours, this anti-pattern will manifest when scattering calls to `GenServer.call/3` and `GenServer.cast/2` throughout multiple modules, instead of encapsulating all the interaction with the `GenServer` in a single place.\n\n#### Refactoring\n\nInstead of spreading direct access to a process abstraction, such as `Agent`, over many places in the code, it is better to refactor this code by centralizing the responsibility for interacting with a process in a single module. This refactoring improves maintainability by removing duplicated code; it also allows you to limit the accepted format for shared data, reducing bug-proneness. As shown below, the module `Foo.Bucket` is centralizing the responsibility for interacting with the `Agent`. Any other place in the code that needs to access shared data must now delegate this action to `Foo.Bucket`. Also, `Foo.Bucket` now only allows data to be shared in `Map` format.\n\n```elixir\ndefmodule Foo.Bucket do\n  use Agent\n\n  def start_link(_opts) do\n    Agent.start_link(fn -> %{} end)\n  end\n\n  def get(bucket, key) do\n    Agent.get(bucket, &Map.get(&1, key))\n  end\n\n  def put(bucket, key, value) do\n    Agent.update(bucket, &Map.put(&1, key, value))\n  end\nend\n```\n\nThe following are examples of how to delegate access to shared data (provided by an `Agent`) to `Foo.Bucket`.\n\n```elixir\n# start an agent through `Foo.Bucket`\niex> {:ok, bucket} = Foo.Bucket.start_link(%{})\n{:ok, #PID<0.114.0>}\n\n# add shared values to the keys `milk` and `beer`\niex> Foo.Bucket.put(bucket, \"milk\", 3)\niex> Foo.Bucket.put(bucket, \"beer\", 7)\n\n# access shared data of specific keys\niex> Foo.Bucket.get(bucket, \"beer\")\n7\niex> Foo.Bucket.get(bucket, \"milk\")\n3\n```\n\n#### Additional remarks\n\nThis anti-pattern was formerly known as [Agent obsession](https://github.com/lucasvegi/Elixir-Code-Smells/tree/main#agent-obsession).","ref":"process-anti-patterns.html#scattered-process-interfaces"},{"type":"extras","title":"Sending unnecessary data - Process-related anti-patterns","doc":"#### Problem\n\nSending a message to a process can be an expensive operation if the message is big enough. That's because that message will be fully copied to the receiving process, which may be CPU and memory intensive. This is due to Erlang's \"share nothing\" architecture, where each process has its own memory, which simplifies and speeds up garbage collection.\n\nThis is more obvious when using `send/2`, `GenServer.call/3`, or the initial data in `GenServer.start_link/3`. Notably this also happens when using `spawn/1`, `Task.async/1`, `Task.async_stream/3`, and so on. It is more subtle here as the anonymous function passed to these functions captures the variables it references, and all captured variables will be copied over. By doing this, you can accidentally send way more data to a process than you actually need.\n\n#### Example\n\nImagine you were to implement some simple reporting of IP addresses that made requests against your application. You want to do this asynchronously and not block processing, so you decide to use `spawn/1`. It may seem like a good idea to hand over the whole connection because we might need more data later. However passing the connection results in copying a lot of unnecessary data like the request body, params, etc.\n\n```elixir\n# log_request_ip send the ip to some external service\nspawn(fn -> log_request_ip(conn) end)\n```\n\nThis problem also occurs when accessing only the relevant parts:\n\n```elixir\nspawn(fn -> log_request_ip(conn.remote_ip) end)\n```\n\nThis will still copy over all of `conn`, because the `conn` variable is being captured inside the spawned function. The function then extracts the `remote_ip` field, but only after the whole `conn` has been copied over.\n\n`send/2` and the `GenServer` APIs also rely on message passing. In the example below, the `conn` is once again copied to the underlying `GenServer`:\n\n```elixir\nGenServer.cast(pid, {:report_ip_address, conn})\n```\n\n#### Refactoring\n\nThis anti-pattern has many potential remedies:\n\n  * Limit the data you send to the absolute necessary minimum instead of sending an entire struct. For example, don't send an entire `conn` struct if all you need is a couple of fields.\n\n  * If the only process that needs data is the one you are sending to, consider making the process fetch that data instead of passing it.\n\n  * Some abstractions, such as [`:persistent_term`](https://www.erlang.org/doc/man/persistent_term.html), allows you to share data between processes, as long as such data changes infrequently.\n\nIn our case, limiting the input data is a reasonable strategy. If all we need *right now* is the IP address, then let's only work with that and make sure we're only passing the IP address into the closure, like so:\n\n```elixir\nip_address = conn.remote_ip\nspawn(fn -> log_request_ip(ip_address) end)\n```\n\nOr in the `GenServer` case:\n\n```elixir\nGenServer.cast(pid, {:report_ip_address, conn.remote_ip})\n```","ref":"process-anti-patterns.html#sending-unnecessary-data"},{"type":"extras","title":"Unsupervised processes - Process-related anti-patterns","doc":"#### Problem\n\nIn Elixir, creating a process outside a supervision tree is not an anti-pattern in itself. However, when you spawn many long-running processes outside of supervision trees, this can make visibility and monitoring of these processes difficult, preventing developers from fully controlling their applications.\n\n#### Example\n\nThe following code example seeks to illustrate a library responsible for maintaining a numerical `Counter` through a `GenServer` process *outside a supervision tree*. Multiple counters can be created simultaneously by a client (one process for each counter), making these *unsupervised* processes difficult to manage. This can cause problems with the initialization, restart, and shutdown of a system.\n\n```elixir\ndefmodule Counter do\n  @moduledoc \"\"\"\n  Global counter implemented through a GenServer process.\n  \"\"\"\n\n  use GenServer\n\n  @doc \"Starts a counter process.\"\n  def start_link(opts \\\\ []) do\n    initial_value = Keyword.get(opts, :initial_value, 0)\n    name = Keyword.get(opts, :name, __MODULE__)\n    GenServer.start(__MODULE__, initial_value, name: name)\n  end\n\n  @doc \"Gets the current value of the given counter.\"\n  def get(pid_name \\\\ __MODULE__) do\n    GenServer.call(pid_name, :get)\n  end\n\n  @doc \"Bumps the value of the given counter.\"\n  def bump(pid_name \\\\ __MODULE__, value) do\n    GenServer.call(pid_name, {:bump, value})\n  end\n\n  @impl true\n  def init(counter) do\n    {:ok, counter}\n  end\n\n  @impl true\n  def handle_call(:get, _from, counter) do\n    {:reply, counter, counter}\n  end\n\n  def handle_call({:bump, value}, _from, counter) do\n    {:reply, counter, counter + value}\n  end\nend\n```\n\n```elixir\niex> Counter.start_link()\n{:ok, #PID<0.115.0>}\niex> Counter.get()\n0\niex> Counter.start_link(initial_value: 15, name: :other_counter)\n{:ok, #PID<0.120.0>}\niex> Counter.get(:other_counter)\n15\niex> Counter.bump(:other_counter, -3)\n12\niex> Counter.bump(Counter, 7)\n7\n```\n\n#### Refactoring\n\nTo ensure that clients of a library have full control over their systems, regardless of the number of processes used and the lifetime of each one, all processes must be started inside a supervision tree. As shown below, this code uses a `Supervisor` as a supervision tree. When this Elixir application is started, two different counters (`Counter` and `:other_counter`) are also started as child processes of the `Supervisor` named `App.Supervisor`. One is initialized with `0`, the other with `15`. By means of this supervision tree, it is possible to manage the life cycle of all child processes (stopping or restarting each one), improving the visibility of the entire app.\n\n```elixir\ndefmodule SupervisedProcess.Application do\n  use Application\n\n  @impl true\n  def start(_type, _args) do\n    children = [\n      # With the default values for counter and name\n      Counter,\n      # With custom values for counter, name, and a custom ID\n      Supervisor.child_spec(\n        {Counter, name: :other_counter, initial_value: 15},\n        id: :other_counter\n      )\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one, name: App.Supervisor)\n  end\nend\n```\n\n```elixir\niex> Supervisor.count_children(App.Supervisor)\n%{active: 2, specs: 2, supervisors: 0, workers: 2}\niex> Counter.get(Counter)\n0\niex> Counter.get(:other_counter)\n15\niex> Counter.bump(Counter, 7)\n7\niex> Supervisor.terminate_child(App.Supervisor, Counter)\niex> Supervisor.count_children(App.Supervisor) # Only one active child\n%{active: 1, specs: 2, supervisors: 0, workers: 2}\niex> Counter.get(Counter) # The process was terminated\n** (EXIT) no process: the process is not alive...\niex> Supervisor.restart_child(App.Supervisor, Counter)\niex> Counter.get(Counter) # After the restart, this process can be used again\n0\n```","ref":"process-anti-patterns.html#unsupervised-processes"},{"type":"extras","title":"Meta-programming anti-patterns","doc":"# Meta-programming anti-patterns\n\nThis document outlines potential anti-patterns related to meta-programming.","ref":"macro-anti-patterns.html"},{"type":"extras","title":"Large code generation - Meta-programming anti-patterns","doc":"#### Problem\n\nThis anti-pattern is related to macros that generate too much code. When a macro generates a large amount of code, it impacts how the compiler and/or the runtime work. The reason for this is that Elixir may have to expand, compile, and execute the code multiple times, which will make compilation slower and the resulting compiled artifacts larger.\n\n#### Example\n\nImagine you are defining a router for a web application, where you could have macros like `get/2`. On every invocation of the macro (which could be hundreds), the code inside `get/2` will be expanded and compiled, which can generate a large volume of code overall.\n\n```elixir\ndefmodule Routes do\n  defmacro get(route, handler) do\n    quote do\n      route = unquote(route)\n      handler = unquote(handler)\n\n      if not is_binary(route) do\n        raise ArgumentError, \"route must be a binary\"\n      end\n\n      if not is_atom(handler) do\n        raise ArgumentError, \"handler must be a module\"\n      end\n\n      @store_route_for_compilation {route, handler}\n    end\n  end\nend\n```\n\n#### Refactoring\n\nTo remove this anti-pattern, the developer should simplify the macro, delegating part of its work to other functions. As shown below, by encapsulating the code inside `quote/1` inside the function `__define__/3` instead, we reduce the code that is expanded and compiled on every invocation of the macro, and instead we dispatch to a function to do the bulk of the work.\n\n```elixir\ndefmodule Routes do\n  defmacro get(route, handler) do\n    quote do\n      Routes.__define__(__MODULE__, unquote(route), unquote(handler))\n    end\n  end\n\n  def __define__(module, route, handler) do\n    if not is_binary(route) do\n      raise ArgumentError, \"route must be a binary\"\n    end\n\n    if not is_atom(handler) do\n      raise ArgumentError, \"handler must be a module\"\n    end\n\n    Module.put_attribute(module, :store_route_for_compilation, {route, handler})\n  end\nend\n```","ref":"macro-anti-patterns.html#large-code-generation"},{"type":"extras","title":"Unnecessary macros - Meta-programming anti-patterns","doc":"#### Problem\n\n*Macros* are powerful meta-programming mechanisms that can be used in Elixir to extend the language. While using macros is not an anti-pattern in itself, this meta-programming mechanism should only be used when absolutely necessary. Whenever a macro is used, but it would have been possible to solve the same problem using functions or other existing Elixir structures, the code becomes unnecessarily more complex and less readable. Because macros are more difficult to implement and reason about, their indiscriminate use can compromise the evolution of a system, reducing its maintainability.\n\n#### Example\n\nThe `MyMath` module implements the `sum/2` macro to perform the sum of two numbers received as parameters. While this code has no syntax errors and can be executed correctly to get the desired result, it is unnecessarily more complex. By implementing this functionality as a macro rather than a conventional function, the code became less clear:\n\n```elixir\ndefmodule MyMath do\n  defmacro sum(v1, v2) do\n    quote do\n      unquote(v1) + unquote(v2)\n    end\n  end\nend\n```\n\n```elixir\niex> require MyMath\nMyMath\niex> MyMath.sum(3, 5)\n8\niex> MyMath.sum(3 + 1, 5 + 6)\n15\n```\n\n#### Refactoring\n\nTo remove this anti-pattern, the developer must replace the unnecessary macro with structures that are simpler to write and understand, such as named functions. The code shown below is the result of the refactoring of the previous example. Basically, the `sum/2` macro has been transformed into a conventional named function. Note that the `require/2` call is no longer needed:\n\n```elixir\ndefmodule MyMath do\n  def sum(v1, v2) do # <= The macro became a named function\n    v1 + v2\n  end\nend\n```\n\n```elixir\niex> MyMath.sum(3, 5)\n8\niex> MyMath.sum(3+1, 5+6)\n15\n```\n\n## `use` instead of `import`\n\n#### Problem\n\nElixir has mechanisms such as `import/1`, `alias/1`, and `use/1` to establish dependencies between modules. Code implemented with these mechanisms does not characterize a smell by itself. However, while the `import/1` and `alias/1` directives have lexical scope and only facilitate a module calling functions of another, the `use/1` directive has a *broader scope*, which can be problematic.\n\nThe `use/1` directive allows a module to inject any type of code into another, including propagating dependencies. In this way, using the `use/1` directive makes code harder to read, because to understand exactly what will happen when it references a module, it is necessary to have knowledge of the internal details of the referenced module.\n\n#### Example\n\nThe code shown below is an example of this anti-pattern. It defines three modules -- `ModuleA`, `Library`, and `ClientApp`. `ClientApp` is reusing code from the `Library` via the `use/1` directive, but is unaware of its internal details. This makes it harder for the author of `ClientApp` to visualize which modules and functionality are now available within its module. To make matters worse, `Library` also imports `ModuleA`, which defines a `foo/0` function that conflicts with a local function defined in `ClientApp`:\n\n```elixir\ndefmodule ModuleA do\n  def foo do\n    \"From Module A\"\n  end\nend\n```\n\n```elixir\ndefmodule Library do\n  defmacro __using__(_opts) do\n    quote do\n      import Library\n      import ModuleA  # <= propagating dependencies!\n    end\n  end\n\n  def from_lib do\n    \"From Library\"\n  end\nend\n```\n\n```elixir\ndefmodule ClientApp do\n  use Library\n\n  def foo do\n    \"Local function from client app\"\n  end\n\n  def from_client_app do\n    from_lib() <> \" - \" <> foo()\n  end\nend\n```\n\nWhen we try to compile `ClientApp`, Elixir detects the conflict and throws the following error:\n\n```text\nerror: imported ModuleA.foo/0 conflicts with local function\n  └ client_app.ex:4:\n```\n\n#### Refactoring\n\nTo remove this anti-pattern, we recommend library authors avoid providing `__using__/1` callbacks whenever it can be replaced by `alias/1` or `import/1` directives. In the following code, we assume `use Library` is no longer available and `ClientApp` was refactored in this way, and with that, the code is clearer and the conflict as previously shown no longer exists:\n\n```elixir\ndefmodule ClientApp do\n  import Library\n\n  def foo do\n    \"Local function from client app\"\n  end\n\n  def from_client_app do\n    from_lib() <> \" - \" <> foo()\n  end\nend\n```\n\n```elixir\niex> ClientApp.from_client_app()\n\"From Library - Local function from client app\"\n```\n\n#### Additional remarks\n\nIn situations where you need to do more than importing and aliasing modules, providing `use MyModule` may be necessary, as it provides a common extension point within the Elixir ecosystem.\n\nTherefore, to provide guidance and clarity, we recommend library authors to include an admonition block in their `@moduledoc` that explains how `use MyModule` impacts the developer's code. As an example, the `GenServer` documentation outlines:\n\n> #### `use GenServer` {: .info}\n>\n> When you `use GenServer`, the `GenServer` module will\n> set `@behaviour GenServer` and define a `child_spec/1`\n> function, so your module can be used as a child\n> in a supervision tree.\n\nThink of this summary as a [\"Nutrition facts label\"](https://en.wikipedia.org/wiki/Nutrition_facts_label) for code generation. Make sure to only list changes made to the public API of the module. For example, if `use Library` sets an internal attribute called `@_some_module_info` and this attribute is never meant to be public, avoid documenting it in the nutrition facts.\n\nFor convenience, the markup notation to generate the admonition block above is this:\n\n```markdown\n> #### `use GenServer` {: .info}\n>\n> When you `use GenServer`, the `GenServer` module will\n> set `@behaviour GenServer` and define a `child_spec/1`\n> function, so your module can be used as a child\n> in a supervision tree.\n```","ref":"macro-anti-patterns.html#unnecessary-macros"},{"type":"extras","title":"Quote and unquote","doc":"# Quote and unquote\n\nThis guide aims to introduce the meta-programming techniques available in Elixir. The ability to represent an Elixir program by its own data structures is at the heart of meta-programming. This chapter starts by exploring those structures and the associated `quote/2` and `unquote/1` constructs, so we can take a look at macros in the next guide, and finally build our own domain specific language.","ref":"quote-and-unquote.html"},{"type":"extras","title":"Quoting - Quote and unquote","doc":"The building block of an Elixir program is a tuple with three elements. For example, the function call `sum(1, 2, 3)` is represented internally as:\n\n```elixir\n{:sum, [], [1, 2, 3]}\n```\n\nYou can get the representation of any expression by using the `quote/2` macro:\n\n```elixir\niex> quote do: sum(1, 2, 3)\n{:sum, [], [1, 2, 3]}\n```\n\nThe first element is the function name, the second is a keyword list containing metadata, and the third is the arguments list.\n\nOperators are also represented as such tuples:\n\n```elixir\niex> quote do: 1 + 2\n{:+, [context: Elixir, import: Kernel], [1, 2]}\n```\n\nEven a map is represented as a call to `%{}`:\n\n```elixir\niex> quote do: %{1 => 2}\n{:%{}, [], [{1, 2}]}\n```\n\nVariables are represented using such triplets, with the difference that the last element is an atom, instead of a list:\n\n```elixir\niex> quote do: x\n{:x, [], Elixir}\n```\n\nWhen quoting more complex expressions, we can see that the code is represented in such tuples, which are often nested inside each other in a structure resembling a tree. Many languages would call such representations an [*Abstract Syntax Tree*](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST). Elixir calls them *quoted expressions*:\n\n```elixir\niex> quote do: sum(1, 2 + 3, 4)\n{:sum, [], [1, {:+, [context: Elixir, import: Kernel], [2, 3]}, 4]}\n```\n\nSometimes, when working with quoted expressions, it may be useful to get the textual code representation back. This can be done with `Macro.to_string/1`:\n\n```elixir\niex> Macro.to_string(quote do: sum(1, 2 + 3, 4))\n\"sum(1, 2 + 3, 4)\"\n```\n\nIn general, the tuples above are structured according to the following format:\n\n```elixir\n{atom | tuple, list, list | atom}\n```\n\n  * The first element is an atom or another tuple in the same representation;\n  * The second element is a keyword list containing metadata, like numbers and contexts;\n  * The third element is either a list of arguments for the function call or an atom. When this element is an atom, it means the tuple represents a variable.\n\nBesides the tuple defined above, there are five Elixir literals that, when quoted, return themselves (and not a tuple). They are:\n\n```elixir\n:sum         #=> Atoms\n1.0          #=> Numbers\n[1, 2]       #=> Lists\n\"strings\"    #=> Strings\n{key, value} #=> Tuples with two elements\n```\n\nMost Elixir code has a straight-forward translation to its underlying quoted expression. We recommend you try out different code samples and see what the results are. For example, what does `String.upcase(\"foo\")` expand to? We have also learned that `if(true, do: :this, else: :that)` is the same as `if true do :this else :that end`. How does this affirmation hold with quoted expressions?","ref":"quote-and-unquote.html#quoting"},{"type":"extras","title":"Unquoting - Quote and unquote","doc":"Quoting is about retrieving the inner representation of some particular chunk of code. However, sometimes it may be necessary to inject some other particular chunk of code inside the representation we want to retrieve.\n\nFor example, imagine you have a variable called `number` which contains the number you want to inject inside a quoted expression.\n\n```elixir\niex> number = 13\niex> Macro.to_string(quote do: 11 + number)\n\"11 + number\"\n```\n\nThat's not what we wanted, since the value of the `number` variable has not been injected and `number` has been quoted in the expression. In order to inject the *value* of the `number` variable, `unquote/1` has to be used inside the quoted representation:\n\n```elixir\niex> number = 13\niex> Macro.to_string(quote do: 11 + unquote(number))\n\"11 + 13\"\n```\n\n`unquote/1` can even be used to inject function names:\n\n```elixir\niex> fun = :hello\niex> Macro.to_string(quote do: unquote(fun)(:world))\n\"hello(:world)\"\n```\n\nIn some cases, it may be necessary to inject many values inside a list. For example, imagine you have a list containing `[1, 2, 6]`, and we want to inject `[3, 4, 5]` into it. Using `unquote/1` won't yield the desired result:\n\n```elixir\niex> inner = [3, 4, 5]\niex> Macro.to_string(quote do: [1, 2, unquote(inner), 6])\n\"[1, 2, [3, 4, 5], 6]\"\n```\n\nThat's when `unquote_splicing/1` comes in handy:\n\n```elixir\niex> inner = [3, 4, 5]\niex> Macro.to_string(quote do: [1, 2, unquote_splicing(inner), 6])\n\"[1, 2, 3, 4, 5, 6]\"\n```\n\nUnquoting is very useful when working with macros. When writing macros, developers are able to receive code chunks and inject them inside other code chunks, which can be used to transform code or write code that generates code during compilation.","ref":"quote-and-unquote.html#unquoting"},{"type":"extras","title":"Escaping - Quote and unquote","doc":"As we saw at the beginning of this chapter, only some values are valid quoted expressions in Elixir. For example, a map is not a valid quoted expression. Neither is a tuple with four elements. However, such values *can* be expressed as a quoted expression:\n\n```elixir\niex> quote do: %{1 => 2}\n{:%{}, [], [{1, 2}]}\n```\n\nIn some cases, you may need to inject such *values* into *quoted expressions*. To do that, we need to first escape those values into quoted expressions with the help of `Macro.escape/1`:\n\n```elixir\niex> map = %{hello: :world}\niex> Macro.escape(map)\n{:%{}, [], [hello: :world]}\n```\n\nMacros receive quoted expressions and must return quoted expressions. However, sometimes during the execution of a macro, you may need to work with values and making a distinction between values and quoted expressions will be required.\n\nIn other words, it is important to make a distinction between a regular Elixir value (like a list, a map, a process, a reference, and so on) and a quoted expression. Some values, such as integers, atoms, and strings, have a quoted expression equal to the value itself. Other values, like maps, need to be explicitly converted. Finally, values like functions and references cannot be converted to a quoted expression at all.\n\nWhen working with macros and code that generates code, check out the documentation for the `Macro` module, which contains many functions to work with Elixir's AST.\n\nIn this introduction, we have laid the groundwork to finally write our first macro. You can check that out in the [next guide](macros.md).","ref":"quote-and-unquote.html#escaping"},{"type":"extras","title":"Macros","doc":"# Macros\n\nEven though Elixir attempts its best to provide a safe environment for macros, most of the responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions, and it's considered to be bad style to use them when they're not necessary. Write macros responsibly.\n\nElixir already provides mechanisms to write your everyday code in a simple and readable fashion by using its data structures and functions. Macros should only be used as a last resort. Remember that **explicit is better than implicit**. **Clear code is better than concise code.**","ref":"macros.html"},{"type":"extras","title":"Our first macro - Macros","doc":"Macros in Elixir are defined via `defmacro/2`.\n\n> For this guide, we will be using files instead of running code samples in IEx. That's because the code samples will span multiple lines of code and typing them all in IEx can be counter-productive. You should be able to run the code samples by saving them into a `macros.exs` file and running it with `elixir macros.exs` or `iex macros.exs`.\n\nIn order to better understand how macros work, let's create a new module where we are going to implement `unless` (which does the opposite of `if/2`), as a macro and as a function:\n\n```elixir\ndefmodule Unless do\n  def fun_unless(clause, do: expression) do\n    if(!clause, do: expression)\n  end\n\n  defmacro macro_unless(clause, do: expression) do\n    quote do\n      if(!unquote(clause), do: unquote(expression))\n    end\n  end\nend\n```\n\nThe function receives the arguments and passes them to `if/2`. However, as we learned in the [previous guide](quote-and-unquote.md), the macro will receive quoted expressions, inject them into the quote, and finally return another quoted expression.\n\nLet's start `iex` with the module above:\n\n```console\n$ iex macros.exs\n```\n\nand play with those definitions:\n\n```elixir\niex> require Unless\niex> Unless.macro_unless(true, do: IO.puts \"this should never be printed\")\nnil\niex> Unless.fun_unless(true, do: IO.puts \"this should never be printed\")\n\"this should never be printed\"\nnil\n```\n\nIn our *macro* implementation, the sentence was not printed, although it was printed in our *function* implementation. That's because the arguments to a function call are evaluated before calling the function. However, macros do not evaluate their arguments. Instead, they receive the arguments as quoted expressions which are then transformed into other quoted expressions. In this case, we have rewritten our `unless` macro to become an `if/2` behind the scenes.\n\nIn other words, when invoked as:\n\n```elixir\nUnless.macro_unless(true, do: IO.puts \"this should never be printed\")\n```\n\nOur `macro_unless` macro received the following:\n\n```elixir\nmacro_unless(true, [do: {{:., [], [{:__aliases__, [alias: false], [:IO]}, :puts]}, [], [\"this should never be printed\"]}])\n```\n\nand it then returned a quoted expression as follows:\n\n```elixir\n{:if, [],\n [{:!, [], [true]},\n  [do: {{:., [],\n     [{:__aliases__,\n       [], [:IO]},\n      :puts]}, [], [\"this should never be printed\"]}]]}\n```\n\nWe can actually verify that this is the case by using `Macro.expand_once/2`:\n\n```elixir\niex> expr = quote do: Unless.macro_unless(true, do: IO.puts(\"this should never be printed\"))\niex> res  = Macro.expand_once(expr, __ENV__)\niex> IO.puts(Macro.to_string(res))\nif(!true) do\n  IO.puts(\"this should never be printed\")\nend\n:ok\n```\n\n`Macro.expand_once/2` receives a quoted expression and expands it according to the current environment. In this case, it expanded/invoked the `Unless.macro_unless/2` macro and returned its result. We then proceeded to convert the returned quoted expression to a string and print it (we will talk about `__ENV__` later in this chapter).\n\nThat's what macros are all about. They are about receiving quoted expressions and transforming them into something else. In fact, `unless/2` in Elixir is implemented as a macro:\n\n```elixir\ndefmacro unless(clause, do: expression) do\n  quote do\n    if(!unquote(clause), do: unquote(expression))\n  end\nend\n```\n\nConstructs such as `unless/2`, `defmacro/2`, `def/2`, `defprotocol/2`, and many others used throughout the Elixir standard library are written in pure Elixir, often as a macro. This means that the constructs being used to build the language can be used by developers to extend the language to the domains they are working on.\n\nWe can define any function and macro we want, including ones that override the built-in definitions provided by Elixir. The only exceptions are Elixir special forms which are not implemented in Elixir and therefore cannot be overridden. The full list of special forms is available in `Kernel.SpecialForms`.","ref":"macros.html#our-first-macro"},{"type":"extras","title":"Macro hygiene - Macros","doc":"Elixir macros have \"late resolution\". This guarantees that a variable defined inside a quote won't conflict with a variable defined in the context where that macro is expanded. For example:\n\n```elixir\ndefmodule Hygiene do\n  defmacro no_interference do\n    quote do: a = 1\n  end\nend\n\ndefmodule HygieneTest do\n  def go do\n    require Hygiene\n    a = 13\n    Hygiene.no_interference()\n    a\n  end\nend\n\nHygieneTest.go()\n# => 13\n```\n\nIn the example above, even though the macro injects `a = 1`, it does not affect the variable `a` defined by the `go/0` function. If a macro wants to explicitly affect the context, it can use `var!/1`:\n\n```elixir\ndefmodule Hygiene do\n  defmacro interference do\n    quote do: var!(a) = 1\n  end\nend\n\ndefmodule HygieneTest do\n  def go do\n    require Hygiene\n    a = 13\n    Hygiene.interference()\n    a\n  end\nend\n\nHygieneTest.go()\n# => 1\n```\n\nThe code above will work but issue a warning: `variable \"a\" is unused`. The macro is overriding the original value and the original value is never used.\n\nVariable hygiene only works because Elixir annotates variables with their **context**. For example, a variable `x` defined on line 3 of a module would be represented as:\n\n```elixir\n{:x, [line: 3], nil}\n```\n\nHowever, a quoted variable would be represented as:\n\n```elixir\ndefmodule Sample do\n  def quoted do\n    quote do: x\n  end\nend\n\nSample.quoted() #=> {:x, [line: 3], Sample}\n```\n\nNotice that the *third element* in the quoted variable is the atom `Sample`, instead of `nil`, which marks the variable as coming from the `Sample` module. Therefore, Elixir considers these two variables as coming from different contexts and handles them accordingly.\n\nElixir provides similar mechanisms for imports and aliases too. This guarantees that a macro will behave as specified by its source module rather than conflicting with the target module where the macro is expanded. Hygiene can be bypassed under specific situations by using macros like `var!/2` and `alias!/1`, although one must be careful when using those as they directly change the user environment.\n\nSometimes variable names might be dynamically created. In such cases, `Macro.var/2` can be used to define new variables:\n\n```elixir\ndefmodule Sample do\n  defmacro initialize_to_char_count(variables) do\n    Enum.map(variables, fn name ->\n      var = Macro.var(name, nil)\n      length = name |> Atom.to_string() |> String.length()\n\n      quote do\n        unquote(var) = unquote(length)\n      end\n    end)\n  end\n\n  def run do\n    initialize_to_char_count([:red, :green, :yellow])\n    [red, green, yellow]\n  end\nend\n\n> Sample.run() #=> [3, 5, 6]\n```\n\nTake note of the second argument to `Macro.var/2`. This is the **context** being used and will determine hygiene as described in the next section. Check out also `Macro.unique_var/2`, for cases when you need to generate variables with unique names.","ref":"macros.html#macro-hygiene"},{"type":"extras","title":"The environment - Macros","doc":"When calling `Macro.expand_once/2` earlier in this chapter, we used the special form `__ENV__/0`.\n\n`__ENV__/0` returns a `Macro.Env` struct which contains useful information about the compilation environment, including the current module, file, and line, all variables defined in the current scope, as well as imports, requires, and more:\n\n```elixir\niex> __ENV__.module\nnil\niex> __ENV__.file\n\"iex\"\niex> __ENV__.requires\n[IEx.Helpers, Kernel, Kernel.Typespec]\niex> require Integer\nnil\niex> __ENV__.requires\n[IEx.Helpers, Integer, Kernel, Kernel.Typespec]\n```\n\nMany of the functions in the `Macro` module expect a `Macro.Env` environment. You can read more about these functions in `Macro` and learn more about the compilation environment in the `Macro.Env`.","ref":"macros.html#the-environment"},{"type":"extras","title":"Private macros - Macros","doc":"Elixir also supports **private macros** via `defmacrop`. Like private functions, these macros are only available inside the module that defines them, and only at compilation time.\n\nIt is important that a macro is defined before its usage. Failing to define a macro before its invocation will raise an error at runtime, since the macro won't be expanded and will be translated to a function call:\n\n```elixir\niex> defmodule Sample do\n...>  def four, do: two() + two()\n...>  defmacrop two, do: 2\n...> end\n** (CompileError) iex:2: function two/0 undefined\n```","ref":"macros.html#private-macros"},{"type":"extras","title":"Write macros responsibly - Macros","doc":"Macros are a powerful construct and Elixir provides many mechanisms to ensure they are used responsibly.\n\n  * Macros are **hygienic**: by default, variables defined inside a macro are not going to affect the user code. Furthermore, function calls and aliases available in the macro context are not going to leak into the user context.\n\n  * Macros are **lexical**: it is impossible to inject code or macros globally. In order to use a macro, you need to explicitly `require` or `import` the module that defines the macro.\n\n  * Macros are **explicit**: it is impossible to run a macro without explicitly invoking it. For example, some languages allow developers to completely rewrite functions behind the scenes, often via parse transforms or via some reflection mechanisms. In Elixir, a macro must be explicitly invoked in the caller during compilation time.\n\n  * Macros' language is clear: many languages provide syntax shortcuts for `quote` and `unquote`. In Elixir, we preferred to have them explicitly spelled out, in order to clearly delimit the boundaries of a macro definition and its quoted expressions.\n\nEven with such guarantees, the developer plays a big role when writing macros responsibly. If you are confident you need to resort to macros, remember that macros are not your API. Keep your macro definitions short, including their quoted contents. For example, instead of writing a macro like this:\n\n```elixir\ndefmodule MyModule do\n  defmacro my_macro(a, b, c) do\n    quote do\n      do_this(unquote(a))\n      # ...\n      do_that(unquote(b))\n      # ...\n      and_that(unquote(c))\n    end\n  end\nend\n```\n\nwrite:\n\n```elixir\ndefmodule MyModule do\n  defmacro my_macro(a, b, c) do\n    quote do\n      # Keep what you need to do here to a minimum\n      # and move everything else to a function\n      MyModule.do_this_that_and_that(unquote(a), unquote(b), unquote(c))\n    end\n  end\n\n  def do_this_that_and_that(a, b, c) do\n    do_this(a)\n    ...\n    do_that(b)\n    ...\n    and_that(c)\n  end\nend\n```\n\nThis makes your code clearer and easier to test and maintain, as you can invoke and test `do_this_that_and_that/3` directly. It also helps you design an actual API for developers that do not want to rely on macros.\n\nWith this guide, we finish our introduction to macros. The next guide is a brief discussion on **DSLs** that shows how we can mix macros and module attributes to annotate and extend modules and functions.","ref":"macros.html#write-macros-responsibly"},{"type":"extras","title":"Domain-Specific Languages (DSLs)","doc":"# Domain-Specific Languages (DSLs)\n\n[Domain-specific Languages (DSLs)](https://en.wikipedia.org/wiki/Domain-specific_language) are languages tailored to a specific application domain. You don't need macros in order to have a DSL: every data structure and every function you define in your module is part of your domain-specific language.\n\nFor example, imagine we want to implement a `Validator` module which provides a data validation domain-specific language. We could implement it using data structures, functions, or macros. Let's see what those different DSLs would look like:\n\n```elixir\n# 1. Data structures\nimport Validator\nvalidate user, name: [length: 1..100], email: [matches: ~r/@/]\n\n# 2. Functions\nimport Validator\nuser\n|> validate_length(:name, 1..100)\n|> validate_matches(:email, ~r/@/)\n\n# 3. Macros + modules\ndefmodule MyValidator do\n  use Validator\n  validate_length :name, 1..100\n  validate_matches :email, ~r/@/\nend\n\nMyValidator.validate(user)\n```\n\nOf all the approaches above, the first is definitely the most flexible. If our domain rules can be encoded with data structures, they are by far the easiest to compose and implement, as Elixir's standard library is filled with functions for manipulating different data types.\n\nThe second approach uses function calls which better suits more complex APIs (for example, if you need to pass many options) and reads nicely in Elixir thanks to the pipe operator.\n\nThe third approach uses macros, and is by far the most complex. It will take more lines of code to implement, it is hard and expensive to test (compared to testing simple functions), and it limits how the user may use the library since all validations need to be defined inside a module.\n\nTo drive the point home, imagine you want to validate a certain attribute only if a given condition is met. We could easily achieve it with the first solution, by manipulating the data structure accordingly, or with the second solution by using conditionals (if/else) before invoking the function. However, it is impossible to do so with the macros approach unless its DSL is augmented.\n\nIn other words:\n\n```text\ndata > functions > macros\n```\n\nThat said, there are still cases where using macros and modules to build domain-specific languages is useful. Since we have explored data structures and function definitions in the Getting Started guide, this chapter will explore how to use macros and module attributes to tackle more complex DSLs.","ref":"domain-specific-languages.html"},{"type":"extras","title":"Building our own test case - Domain-Specific Languages (DSLs)","doc":"The goal in this chapter is to build a module named `TestCase` that allows us to write the following:\n\n```elixir\ndefmodule MyTest do\n  use TestCase\n\n  test \"arithmetic operations\" do\n    4 = 2 + 2\n  end\n\n  test \"list operations\" do\n    [1, 2, 3] = [1, 2] ++ [3]\n  end\nend\n\nMyTest.run()\n```\n\nIn the example above, by using `TestCase`, we can write tests using the `test` macro, which defines a function named `run` to automatically run all tests for us. Our prototype will rely on the match operator (`=`) as a mechanism to do assertions.","ref":"domain-specific-languages.html#building-our-own-test-case"},{"type":"extras","title":"The `test` macro - Domain-Specific Languages (DSLs)","doc":"Let's start by creating a module that defines and imports the `test` macro when used:\n\n```elixir\ndefmodule TestCase do\n  # Callback invoked by `use`.\n  #\n  # For now it returns a quoted expression that\n  # imports the module itself into the user code.\n  @doc false\n  defmacro __using__(_opts) do\n    quote do\n      import TestCase\n    end\n  end\n\n  @doc \"\"\"\n  Defines a test case with the given description.","ref":"domain-specific-languages.html#the-test-macro"},{"type":"extras","title":"Examples - Domain-Specific Languages (DSLs)","doc":"test \"arithmetic operations\" do\n        4 = 2 + 2\n      end\n\n  \"\"\"\n  defmacro test(description, do: block) do\n    function_name = String.to_atom(\"test \" <> description)\n    quote do\n      def unquote(function_name)(), do: unquote(block)\n    end\n  end\nend\n```\n\nAssuming we defined `TestCase` in a file named `tests.exs`, we can open it up by running `iex tests.exs` and define our first tests:\n\n```elixir\niex> defmodule MyTest do\n...>   use TestCase\n...>\n...>   test \"hello\" do\n...>     \"hello\" = \"world\"\n...>   end\n...> end\n```\n\nFor now, we don't have a mechanism to run tests, but we know that a function named `test hello` was defined behind the scenes. When we invoke it, it should fail:\n\n```elixir\niex> MyTest.\"test hello\"()\n** (MatchError) no match of right hand side value: \"world\"\n```","ref":"domain-specific-languages.html#examples"},{"type":"extras","title":"Storing information with attributes - Domain-Specific Languages (DSLs)","doc":"In order to finish our `TestCase` implementation, we need to be able to access all defined test cases. One way of doing this is by retrieving the tests at runtime via `__MODULE__.__info__(:functions)`, which returns a list of all functions in a given module. However, considering that we may want to store more information about each test besides the test name, a more flexible approach is required.\n\nWhen discussing module attributes in earlier chapters, we mentioned how they can be used as temporary storage. That's exactly the property we will apply in this section.\n\nIn the `__using__/1` implementation, we will initialize a module attribute named `@tests` to an empty list, then store the name of each defined test in this attribute so the tests can be invoked from the `run` function.\n\nHere is the updated code for the `TestCase` module:\n\n```elixir\ndefmodule TestCase do\n  @doc false\n  defmacro __using__(_opts) do\n    quote do\n      import TestCase\n\n      # Initialize @tests to an empty list\n      @tests []\n\n      # Invoke TestCase.__before_compile__/1 before the module is compiled\n      @before_compile TestCase\n    end\n  end\n\n  @doc \"\"\"\n  Defines a test case with the given description.","ref":"domain-specific-languages.html#storing-information-with-attributes"},{"type":"extras","title":"Examples - Domain-Specific Languages (DSLs)","doc":"test \"arithmetic operations\" do\n        4 = 2 + 2\n      end\n\n  \"\"\"\n  defmacro test(description, do: block) do\n    function_name = String.to_atom(\"test \" <> description)\n    quote do\n      # Prepend the newly defined test to the list of tests\n      @tests [unquote(function_name) | @tests]\n      def unquote(function_name)(), do: unquote(block)\n    end\n  end\n\n  # This will be invoked right before the target module is compiled\n  # giving us the perfect opportunity to inject the `run/0` function\n  @doc false\n  defmacro __before_compile__(_env) do\n    quote do\n      def run do\n        Enum.each(@tests, fn name ->\n          IO.puts(\"Running #{name}\")\n          apply(__MODULE__, name, [])\n        end)\n      end\n    end\n  end\nend\n```\n\nBy starting a new IEx session, we can now define our tests and run them:\n\n```elixir\niex> defmodule MyTest do\n...>   use TestCase\n...>\n...>   test \"hello\" do\n...>     \"hello\" = \"world\"\n...>   end\n...> end\niex> MyTest.run()\nRunning test hello\n** (MatchError) no match of right hand side value: \"world\"\n```\n\nAlthough we have overlooked some details, this is the main idea behind creating domain-specific languages in Elixir via modules and macros. Macros enable us to return quoted expressions that are executed in the caller, which we can then use to transform code and store relevant information in the target module via module attributes. Finally, callbacks such as `@before_compile` allow us to inject code into the module when its definition is complete.\n\nBesides `@before_compile`, there are other useful module attributes like `@on_definition` and `@after_compile`, which you can read more about in the docs for `Module`. You can also find useful information about macros and the compilation environment in the documentation for the `Macro` and `Macro.Env`.","ref":"domain-specific-languages.html#examples"},{"type":"extras","title":"Introduction to Mix","doc":"# Introduction to Mix\n\nIn this guide, we will build a complete Elixir application, with its own supervision tree, configuration, tests, and more.\n\nThe requirements for this guide are (see `elixir -v`):\n\n  * Elixir 1.15.0 onwards\n  * Erlang/OTP 24 onwards\n\nThe application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:\n\n```text\nCREATE shopping\nOK\n\nPUT shopping milk 1\nOK\n\nPUT shopping eggs 3\nOK\n\nGET shopping milk\n1\nOK\n\nDELETE shopping eggs\nOK\n```\n\nIn order to build our key-value application, we are going to use three main tools:\n\n  * ***OTP*** *(Open Telecom Platform)* is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;\n\n  * ***[Mix](`Mix`)*** is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;\n\n  * ***[ExUnit](`ExUnit`)*** is a test-unit based framework that ships with Elixir.\n\nIn this chapter, we will create our first project using Mix and explore different features in OTP, Mix, and ExUnit as we go.\n\n> #### Source code {: .info}\n>\n> The final code for the application built in this guide is in [this repository](https://github.com/josevalim/kv_umbrella) and can be used as a reference.\n\n> #### Is this guide required reading? {: .info}\n>\n> This guide is not required reading in your Elixir journey. We'll explain.\n>\n> As an Elixir developer, you will most likely use one of the many existing frameworks when writing your Elixir code. [Phoenix](https://phoenixframework.org) covers web applications, [Ecto](https://github.com/elixir-ecto/ecto) communicates with databases, you can craft embedded software with [Nerves](https://nerves-project.org/), [Nx](https://github.com/elixir-nx) powers machine learning and AI projects, [Membrane](https://membrane.stream/) assembles audio/video processing pipelines, [Broadway](https://elixir-broadway.org/) handles data ingestion and processing, and many more. These frameworks handle the lower level details of concurrency, distribution, and fault-tolerance, so you, as a user, can focus on your own needs and demands.\n>\n> On the other hand, if you want to learn the foundations these frameworks are built upon, and the abstractions that power the Elixir ecosystem, this guide will give you a tour through several important concepts.","ref":"introduction-to-mix.html"},{"type":"extras","title":"Our first project - Introduction to Mix","doc":"When you install Elixir, besides getting the `elixir`, `elixirc`, and `iex` executables, you also get an executable Elixir script named `mix`.\n\nLet's create our first project by invoking `mix new` from the command line. We'll pass the project path as the argument (`kv`, in this case). By default, the application name and module name will be retrieved from the path. So we tell Mix that our main module should be the all-uppercase `KV`, instead of the default, which would have been `Kv`:\n\n```console\n$ mix new kv --module KV\n```\n\nMix will create a directory named `kv` with a few files in it:\n\n```text\n* creating README.md\n* creating .formatter.exs\n* creating .gitignore\n* creating mix.exs\n* creating lib\n* creating lib/kv.ex\n* creating test\n* creating test/test_helper.exs\n* creating test/kv_test.exs\n```\n\nLet's take a brief look at those generated files.\n\n> #### Executables in the `PATH` {: .info}\n>\n> Mix is an Elixir executable. This means that in order to run `mix`, you need to have both `mix` and `elixir` executables in your PATH. That's what happens when you install Elixir.","ref":"introduction-to-mix.html#our-first-project"},{"type":"extras","title":"Project compilation - Introduction to Mix","doc":"A file named `mix.exs` was generated inside our new project folder (`kv`) and its main responsibility is to configure our project. Let's take a look at it:\n\n```elixir\ndefmodule KV.MixProject do\n  use Mix.Project\n\n  def project do\n    [\n      app: :kv,\n      version: \"0.1.0\",\n      elixir: \"~> 1.11\",\n      start_permanent: Mix.env() == :prod,\n      deps: deps()\n    ]\n  end\n\n  # Run \"mix help compile.app\" to learn about applications\n  def application do\n    [\n      extra_applications: [:logger]\n    ]\n  end\n\n  # Run \"mix help deps\" to learn about dependencies\n  defp deps do\n    [\n      # {:dep_from_hexpm, \"~> 0.3.0\"},\n      # {:dep_from_git, git: \"https://github.com/elixir-lang/my_dep.git\", tag: \"0.1.0\"},\n    ]\n  end\nend\n```\n\nOur `mix.exs` defines two public functions: `project`, which returns project configuration like the project name and version, and `application`, which is used to generate an application file.\n\nThere is also a private function named `deps`, which is invoked from the `project` function, that defines our project dependencies. Defining `deps` as a separate function is not required, but it helps keep the project configuration tidy.\n\nMix also generates a file at `lib/kv.ex` with a module containing exactly one function, called `hello`:\n\n```elixir\ndefmodule KV do\n  @moduledoc \"\"\"\n  Documentation for KV.\n  \"\"\"\n\n  @doc \"\"\"\n  Hello world.","ref":"introduction-to-mix.html#project-compilation"},{"type":"extras","title":"Examples - Introduction to Mix","doc":"iex> KV.hello()\n      :world\n\n  \"\"\"\n  def hello do\n    :world\n  end\nend\n\n```\n\nThis structure is enough to compile our project:\n\n```console\n$ cd kv\n$ mix compile\n```\n\nWill output:\n\n```text\nCompiling 1 file (.ex)\nGenerated kv app\n```\n\nThe `lib/kv.ex` file was compiled and an application manifest named `kv.app` was generated. All compilation artifacts are placed inside the `_build` directory using the options defined in the `mix.exs` file.\n\nOnce the project is compiled, you can start a `iex` session inside the project by running the command below. The `-S mix` is necessary to load the project in the interactive shell:\n\n```console\n$ iex -S mix\n```\n\nWe are going to work on this `kv` project, making modifications and trying out the latest changes from a `iex` session. While you may start a new session whenever there are changes to the project source code, you can also recompile the project from within `iex` with the `recompile` helper, like this:\n\n```elixir\niex> recompile()\nCompiling 1 file (.ex)\n:ok\niex> recompile()\n:noop\n```\n\nIf anything had to be compiled, you see some informative text, and get the `:ok` atom back, otherwise the function is silent, and returns `:noop`.","ref":"introduction-to-mix.html#examples"},{"type":"extras","title":"Running tests - Introduction to Mix","doc":"Mix also generated the appropriate structure for running our project tests. Mix projects usually follow the convention of having a ` _test.exs` file in the `test` directory for each file in the `lib` directory. For this reason, we can already find a `test/kv_test.exs` corresponding to our `lib/kv.ex` file. It doesn't do much at this point:\n\n```elixir\ndefmodule KVTest do\n  use ExUnit.Case\n  doctest KV\n\n  test \"greets the world\" do\n    assert KV.hello() == :world\n  end\nend\n```\n\nIt is important to note a couple of things:\n\n1. the test file is an Elixir script file (`.exs`). This is convenient because we don't need to compile test files before running them;\n\n2. we define a test module named `KVTest`, in which we [`use ExUnit.Case`](`ExUnit.Case`) to inject the testing API;\n\n3. we use one of the imported macros, `ExUnit.DocTest.doctest/1`, to indicate that the `KV` module contains doctests (we will discuss those in a later chapter);\n\n4. we use the `ExUnit.Case.test/2` macro to define a simple test;\n\nMix also generated a file named `test/test_helper.exs` which is responsible for setting up the test framework:\n\n```elixir\nExUnit.start()\n```\n\nThis file will be required by Mix every time before we run our tests. We can run tests with:\n\n```console\n$ mix test\nCompiled lib/kv.ex\nGenerated kv app\nRunning ExUnit with seed: 540224, max_cases: 16\n..\n\nFinished in 0.04 seconds\n1 doctest, 1 test, 0 failures\n```\n\nNotice that by running `mix test`, Mix has compiled the source files and generated the application manifest once again. This happens because Mix supports multiple environments, which we will discuss later in this chapter.\n\nFurthermore, you can see that ExUnit prints a dot for each successful test and automatically randomizes tests too. Let's make the test fail on purpose and see what happens.\n\nChange the assertion in `test/kv_test.exs` to the following:\n\n```elixir\nassert KV.hello() == :oops\n```\n\nNow run `mix test` again (notice this time there will be no compilation):\n\n```text\n  1) test greets the world (KVTest)\n     test/kv_test.exs:5\n     Assertion with == failed\n     code:  assert KV.hello() == :oops\n     left:  :world\n     right: :oops\n     stacktrace:\n       test/kv_test.exs:6: (test)\n\n.\n\nFinished in 0.05 seconds\n1 doctest, 1 test, 1 failure\n```\n\nFor each failure, ExUnit prints a detailed report, containing the test name with the test case, the code that failed and the values for the left side and right side (RHS) of the `==` operator.\n\nIn the second line of the failure, right below the test name, there is the location where the test was defined. If you copy the test location in full, including the file and line number, and append it to `mix test`, Mix will load and run just that particular test:\n\n```console\n$ mix test test/kv_test.exs:5\n```\n\nThis shortcut will be extremely useful as we build our project, allowing us to quickly iterate by running a single test.\n\nFinally, the stacktrace relates to the failure itself, giving information about the test and often the place the failure was generated from within the source files.","ref":"introduction-to-mix.html#running-tests"},{"type":"extras","title":"Automatic code formatting - Introduction to Mix","doc":"One of the files generated by `mix new` is the `.formatter.exs`. Elixir ships with a code formatter that is capable of automatically formatting our codebase according to a consistent style. The formatter is triggered with the `mix format` task. The generated `.formatter.exs` file configures which files should be formatted when `mix format` runs.\n\nTo give the formatter a try, change a file in the `lib` or `test` directories to include extra spaces or extra newlines, such as `def  hello  do`, and then run `mix format`.\n\nMost editors provide built-in integration with the formatter, allowing a file to be formatted on save or via a chosen keybinding. If you are learning Elixir, editor integration gives you useful and quick feedback when learning the Elixir syntax.\n\nFor companies and teams, we recommend developers to run `mix format --check-formatted` on their continuous integration servers, ensuring all current and future code follows the standard.\n\nYou can learn more about the code formatter by checking [the format task documentation](`mix format`) or by reading [the release announcement for Elixir v1.6](https://elixir-lang.org/blog/2018/01/17/elixir-v1-6-0-released/), the first version to include the formatter.","ref":"introduction-to-mix.html#automatic-code-formatting"},{"type":"extras","title":"Environments - Introduction to Mix","doc":"Mix provides the concept of \"environments\". They allow a developer to customize compilation and other options for specific scenarios. By default, Mix understands three environments:\n\n  * `:dev` — the one in which Mix tasks (like `compile`) run by default\n  * `:test` — used by `mix test`\n  * `:prod` — the one you will use to run your project in production\n\nThe environment applies only to the current project. As we will see in future chapters, any dependency you add to your project will by default run in the `:prod` environment.\n\nCustomization per environment can be done by accessing the `Mix.env/0` in your `mix.exs` file, which returns the current environment as an atom. That's what we have used in the `:start_permanent` options:\n\n```elixir\ndef project do\n  [\n    ...,\n    start_permanent: Mix.env() == :prod,\n    ...\n  ]\nend\n```\n\nWhen true, the `:start_permanent` option starts your application in permanent mode, which means the Erlang VM will crash if your application's supervision tree shuts down. Notice we don't want this behavior in dev and test because it is useful to keep the VM instance running in those environments for troubleshooting purposes.\n\nMix will default to the `:dev` environment, except for the `test` task that will default to the `:test` environment. The environment can be changed via the `MIX_ENV` environment variable:\n\n```console\n$ MIX_ENV=prod mix compile\n```\n\nOr on Windows:\n\n```batch\n> set \"MIX_ENV=prod\" && mix compile\n```\n\n> #### Mix in production {: .warning}\n>\n> Mix is a **build tool** and, as such, it is not expected to be available in production. Therefore, it is recommended to access `Mix.env/0` only in configuration files and inside `mix.exs`, never in your application code (`lib`).","ref":"introduction-to-mix.html#environments"},{"type":"extras","title":"Exploring - Introduction to Mix","doc":"There is much more to Mix, and we will continue to explore it as we build our project. A general overview is available on the [Mix documentation](`Mix`) and you can always invoke the help task to list all available tasks:\n\n```console\n$ mix help\n$ mix help compile\n```\n\nNow let's move forward and add the first modules and functions to our application.","ref":"introduction-to-mix.html#exploring"},{"type":"extras","title":"Simple state management with agents","doc":"# Simple state management with agents\n\nIn this chapter, we will learn how to keep and share state between multiple entities. If you have previous programming experience, you may think of globally shared variables, but the model we will learn here is quite different. The next chapters will generalize the concepts introduced here.\n\nIf you have skipped the *Getting Started* guide or read it long ago, be sure to re-read the [Processes](../getting-started/processes.md) chapter. We will use it as a starting point.","ref":"agents.html"},{"type":"extras","title":"The trouble with (mutable) state - Simple state management with agents","doc":"Elixir is an immutable language where nothing is shared by default. If we want to share information, which can be read and modified from multiple places, we have two main options in Elixir:\n\n  * Using processes and message passing\n  * [ETS (Erlang Term Storage)](http://www.erlang.org/doc/man/ets.html)\n\nWe covered processes in the *Getting Started* guide. ETS (Erlang Term Storage) is a new topic that we will explore in later chapters. When it comes to processes though, we rarely hand-roll our own, instead we use the abstractions available in Elixir and OTP:\n\n  * `Agent` — Simple wrappers around state.\n  * `GenServer` — \"Generic servers\" (processes) that encapsulate state, provide sync and async calls, support code reloading, and more.\n  * `Task` — Asynchronous units of computation that allow spawning a process and potentially retrieving its result at a later time.\n\nWe will explore these abstractions as we move forward. Keep in mind that they are all implemented on top of processes using the basic features provided by the VM, like `send/2`, `receive/1`, `spawn/1` and `Process.link/1`.\n\nHere, we will use agents, and create a module named `KV.Bucket`, responsible for storing our key-value entries in a way that allows them to be read and modified by other processes.","ref":"agents.html#the-trouble-with-mutable-state"},{"type":"extras","title":"Agents 101 - Simple state management with agents","doc":"`Agent`s are simple wrappers around state. If all you want from a process is to keep state, agents are a great fit. Let's start a `iex` session inside the project with:\n\n```console\n$ iex -S mix\n```\n\nAnd play a bit with agents:\n\n```elixir\niex> {:ok, agent} = Agent.start_link(fn -> [] end)\n{:ok, #PID<0.57.0>}\niex> Agent.update(agent, fn list -> [\"eggs\" | list] end)\n:ok\niex> Agent.get(agent, fn list -> list end)\n[\"eggs\"]\niex> Agent.stop(agent)\n:ok\n```\n\nWe started an agent with an initial state of an empty list. We updated the agent's state, adding our new item to the head of the list. The second argument of `Agent.update/3` is a function that takes the agent's current state as input and returns its desired new state. Finally, we retrieved the whole list. The second argument of `Agent.get/3` is a function that takes the state as input and returns the value that `Agent.get/3` itself will return. Once we are done with the agent, we can call `Agent.stop/3` to terminate the agent process.\n\nThe `Agent.update/3` function accepts as a second argument any function that receives one argument and returns a value:\n\n```elixir\niex> {:ok, agent} = Agent.start_link(fn -> [] end)\n{:ok, #PID<0.338.0>}\niex> Agent.update(agent, fn _list -> 123 end)\n:ok\niex> Agent.update(agent, fn content -> %{a: content} end)\n:ok\niex> Agent.update(agent, fn content -> [12 | [content]] end)\n:ok\niex> Agent.update(agent, fn list -> [:nop | list] end)\n:ok\niex> Agent.get(agent, fn content -> content end)\n[:nop, 12, %{a: 123}]\n```\n\nAs you can see, we can modify the agent state in any way we want. Therefore, we most likely don't want to access the Agent API throughout many different places in our code. Instead, we want to encapsulate all Agent-related functionality in a single module, which we will call `KV.Bucket`. Before we implement it, let's write some tests which will outline the API exposed by our module.\n\nCreate a file at `test/kv/bucket_test.exs` (remember the `.exs` extension) with the following:\n\n```elixir\ndefmodule KV.BucketTest do\n  use ExUnit.Case, async: true\n\n  test \"stores values by key\" do\n    {:ok, bucket} = KV.Bucket.start_link([])\n    assert KV.Bucket.get(bucket, \"milk\") == nil\n\n    KV.Bucket.put(bucket, \"milk\", 3)\n    assert KV.Bucket.get(bucket, \"milk\") == 3\n  end\nend\n```\n\n`use ExUnit.Case` is responsible for setting up our module for testing and imports many test-related functionality, such as the `test/2` macro.\n\nOur first test starts a new `KV.Bucket` by calling the `start_link/1` and passing an empty list of options. Then we perform some `get/2` and `put/3` operations on it, asserting the result.\n\nAlso note the `async: true` option passed to `ExUnit.Case`. This option makes the test case run in parallel with other `:async` test cases by using multiple cores in our machine. This is extremely useful to speed up our test suite. However, `:async` must *only* be set if the test case does not rely on or change any global values. For example, if the test requires writing to the file system or access a database, keep it synchronous (omit the `:async` option) to avoid race conditions between tests.\n\nAsync or not, our new test should obviously fail, as none of the functionality is implemented in the module being tested:\n\n```text\n** (UndefinedFunctionError) function KV.Bucket.start_link/1 is undefined (module KV.Bucket is not available)\n```\n\nIn order to fix the failing test, let's create a file at `lib/kv/bucket.ex` with the contents below. Feel free to give a try at implementing the `KV.Bucket` module yourself using agents before peeking at the implementation below.\n\n```elixir\ndefmodule KV.Bucket do\n  use Agent\n\n  @doc \"\"\"\n  Starts a new bucket.\n  \"\"\"\n  def start_link(_opts) do\n    Agent.start_link(fn -> %{} end)\n  end\n\n  @doc \"\"\"\n  Gets a value from the `bucket` by `key`.\n  \"\"\"\n  def get(bucket, key) do\n    Agent.get(bucket, &Map.get(&1, key))\n  end\n\n  @doc \"\"\"\n  Puts the `value` for the given `key` in the `bucket`.\n  \"\"\"\n  def put(bucket, key, value) do\n    Agent.update(bucket, &Map.put(&1, key, value))\n  end\nend\n```\n\nThe first step in our implementation is to call `use Agent`. Most of the functionality we will learn, such as `GenServer` and `Supervisor`, follow this pattern. For all of them, calling `use` generates a `child_spec/1` function with default configuration, which will be handy when we start supervising processes in chapter 4.\n\nThen we define a `start_link/1` function, which will effectively start the agent. It is a convention to define a `start_link/1` function that always accepts a list of options. We don't plan on using any options right now, but we might later on. We then proceed to call `Agent.start_link/1`, which receives an anonymous function that returns the Agent's initial state.\n\nWe are keeping a map inside the agent to store our keys and values. Getting and putting values on the map is done with the Agent API and the capture operator `&`, introduced in [the Getting Started guide](../getting-started/anonymous-functions.md#the-capture-operator). The agent passes its state to the anonymous function via the `&1` argument when `Agent.get/2` and `Agent.update/2` are called.\n\nNow that the `KV.Bucket` module has been defined, our test should pass! You can try it yourself by running: `mix test`.","ref":"agents.html#agents-101"},{"type":"extras","title":"Test setup with ExUnit callbacks - Simple state management with agents","doc":"Before moving on and adding more features to `KV.Bucket`, let's talk about ExUnit callbacks. As you may expect, all `KV.Bucket` tests will require a bucket agent to be up and running. Luckily, ExUnit supports callbacks that allow us to skip such repetitive tasks.\n\nLet's rewrite the test case to use callbacks:\n\n```elixir\ndefmodule KV.BucketTest do\n  use ExUnit.Case, async: true\n\n  setup do\n    {:ok, bucket} = KV.Bucket.start_link([])\n    %{bucket: bucket}\n  end\n\n  test \"stores values by key\", %{bucket: bucket} do\n    assert KV.Bucket.get(bucket, \"milk\") == nil\n\n    KV.Bucket.put(bucket, \"milk\", 3)\n    assert KV.Bucket.get(bucket, \"milk\") == 3\n  end\nend\n```\n\nWe have first defined a setup callback with the help of the `setup/1` macro. The `setup/1` macro defines a callback that is run before every test, in the same process as the test itself.\n\nNote that we need a mechanism to pass the `bucket` PID from the callback to the test. We do so by using the *test context*. When we return `%{bucket: bucket}` from the callback, ExUnit will merge this map into the test context. Since the test context is a map itself, we can pattern match the bucket out of it, providing access to the bucket inside the test:\n\n```elixir\ntest \"stores values by key\", %{bucket: bucket} do\n  # `bucket` is now the bucket from the setup block\nend\n```\n\nYou can read more about ExUnit cases in the [`ExUnit.Case` module documentation](`ExUnit.Case`) and more about callbacks in `ExUnit.Callbacks`.","ref":"agents.html#test-setup-with-exunit-callbacks"},{"type":"extras","title":"Other agent actions - Simple state management with agents","doc":"Besides getting a value and updating the agent state, agents allow us to get a value and update the agent state in one function call via `Agent.get_and_update/2`. Let's implement a `KV.Bucket.delete/2` function that deletes a key from the bucket, returning its current value:\n\n```elixir\n@doc \"\"\"\nDeletes `key` from `bucket`.\n\nReturns the current value of `key`, if `key` exists.\n\"\"\"\ndef delete(bucket, key) do\n  Agent.get_and_update(bucket, &Map.pop(&1, key))\nend\n```\n\nNow it is your turn to write a test for the functionality above! Also, be sure to explore [the documentation for the `Agent` module](`Agent`) to learn more about them.","ref":"agents.html#other-agent-actions"},{"type":"extras","title":"Client/server in agents - Simple state management with agents","doc":"Before we move on to the next chapter, let's discuss the client/server dichotomy in agents. Let's expand the `delete/2` function we have just implemented:\n\n```elixir\ndef delete(bucket, key) do\n  Agent.get_and_update(bucket, fn dict ->\n    Map.pop(dict, key)\n  end)\nend\n```\n\nEverything that is inside the function we passed to the agent happens in the agent process. In this case, since the agent process is the one receiving and responding to our messages, we say the agent process is the server. Everything outside the function is happening in the client.\n\nThis distinction is important. If there are expensive actions to be done, you must consider if it will be better to perform these actions on the client or on the server. For example:\n\n```elixir\ndef delete(bucket, key) do\n  Process.sleep(1000) # puts client to sleep\n  Agent.get_and_update(bucket, fn dict ->\n    Process.sleep(1000) # puts server to sleep\n    Map.pop(dict, key)\n  end)\nend\n```\n\nWhen a long action is performed on the server, all other requests to that particular server will wait until the action is done, which may cause some clients to timeout.\n\nIn the next chapter, we will explore GenServers, where the segregation between clients and servers is made more apparent.","ref":"agents.html#client-server-in-agents"},{"type":"extras","title":"Client-server communication with GenServer","doc":"# Client-server communication with GenServer\n\nIn the [previous chapter](agents.md), we used agents to represent our buckets. In the [introduction to mix](introduction-to-mix.md), we specified we would like to name each bucket so we can do the following:\n\n```elixir\nCREATE shopping\nOK\n\nPUT shopping milk 1\nOK\n\nGET shopping milk\n1\nOK\n```\n\nIn the session above we interacted with the \"shopping\" bucket.\n\nSince agents are processes, each bucket has a process identifier (PID), but buckets do not have a name. Back [in the Process chapter](../getting-started/processes.md), we have learned that we can register processes in Elixir by giving them atom names:\n\n```elixir\niex> Agent.start_link(fn -> %{} end, name: :shopping)\n{:ok, #PID<0.43.0>}\niex> KV.Bucket.put(:shopping, \"milk\", 1)\n:ok\niex> KV.Bucket.get(:shopping, \"milk\")\n1\n```\n\nHowever, naming dynamic processes with atoms is a terrible idea! If we use atoms, we would need to convert the bucket name (often received from an external client) to atoms, and **we should never convert user input to atoms**. This is because atoms are not garbage collected. Once an atom is created, it is never reclaimed. Generating atoms from user input would mean the user can inject enough different names to exhaust our system memory!\n\nIn practice, it is more likely you will reach the Erlang VM limit for the maximum number of atoms before you run out of memory, which will bring your system down regardless.\n\nInstead of abusing the built-in name facility, we will create our own *process registry* that associates the bucket name to the bucket process.\n\nThe registry needs to guarantee that it is always up to date. For example, if one of the bucket processes crashes due to a bug, the registry must notice this change and avoid serving stale entries. In Elixir, we say the registry needs to *monitor* each bucket. Because our *registry* needs to be able to receive and handle ad-hoc messages from the system, the `Agent` API is not enough.\n\nWe will use a `GenServer` to create a registry process that can monitor the bucket processes. GenServer provides industrial strength functionality for building servers in both Elixir and OTP.\n\nPlease read the `GenServer` module documentation for an overview if you haven't yet. Once you do so, we are ready to proceed.","ref":"genservers.html"},{"type":"extras","title":"GenServer callbacks - Client-server communication with GenServer","doc":"A GenServer is a process that invokes a limited set of functions under specific conditions. When we used a `Agent`, we would keep both the client code and the server code side by side, like this:\n\n```elixir\ndef put(bucket, key, value) do\n  Agent.update(bucket, &Map.put(&1, key, value))\nend\n```\n\nLet's break that code apart a bit:\n\n```elixir\ndef put(bucket, key, value) do\n  # Here is the client code\n  Agent.update(bucket, fn state ->\n    # Here is the server code\n    Map.put(state, key, value)\n  end)\n  # Back to the client code\nend\n```\n\nIn the code above, we have a process, which we call \"the client\" sending a request to an agent, \"the server\". The request contains an anonymous function, which must be executed by the server.\n\nIn a GenServer, the code above would be two separate functions, roughly like this:\n\n```elixir\ndef put(bucket, key, value) do\n  # Send the server a :put \"instruction\"\n  GenServer.call(bucket, {:put, key, value})\nend\n\n# Server callback\n\ndef handle_call({:put, key, value}, _from, state) do\n  {:reply, :ok, Map.put(state, key, value)}\nend\n```\n\nThere is quite a bit more ceremony in the GenServer code but, as we will see, it brings some benefits too.\n\nFor now, we will write only the server callbacks for our bucket registering logic, without providing a proper API, which we will do later.\n\nCreate a new file at `lib/kv/registry.ex` with the following contents:\n\n```elixir\ndefmodule KV.Registry do\n  use GenServer","ref":"genservers.html#genserver-callbacks"},{"type":"extras","title":"Missing Client API - will add this later - Client-server communication with GenServer","doc":"","ref":"genservers.html#missing-client-api-will-add-this-later"},{"type":"extras","title":"Defining GenServer Callbacks - Client-server communication with GenServer","doc":"@impl true\n  def init(:ok) do\n    {:ok, %{}}\n  end\n\n  @impl true\n  def handle_call({:lookup, name}, _from, names) do\n    {:reply, Map.fetch(names, name), names}\n  end\n\n  @impl true\n  def handle_cast({:create, name}, names) do\n    if Map.has_key?(names, name) do\n      {:noreply, names}\n    else\n      {:ok, bucket} = KV.Bucket.start_link([])\n      {:noreply, Map.put(names, name, bucket)}\n    end\n  end\nend\n```\n\nThere are two types of requests you can send to a GenServer: calls and casts. Calls are synchronous and the server **must** send a response back to such requests. While the server computes the response, the client is **waiting**. Casts are asynchronous: the server won't send a response back and therefore the client won't wait for one. Both requests are messages sent to the server, and will be handled in sequence. In the above implementation, we pattern-match on the `:create` messages, to be handled as cast, and on the `:lookup` messages, to be handled as call.\n\nIn order to invoke the callbacks above, we need to go through the corresponding `GenServer` functions. Let's start a registry, create a named bucket, and then look it up:\n\n```elixir\niex> {:ok, registry} = GenServer.start_link(KV.Registry, :ok)\n{:ok, #PID<0.136.0>}\niex> GenServer.cast(registry, {:create, \"shopping\"})\n:ok\niex> {:ok, bk} = GenServer.call(registry, {:lookup, \"shopping\"})\n{:ok, #PID<0.174.0>}\n```\n\nOur `KV.Registry` process received a cast with `{:create, \"shopping\"}` and a call with `{:lookup, \"shopping\"}`, in this sequence. `GenServer.cast` will immediately return, as soon as the message is sent to the `registry`. The `GenServer.call` on the other hand, is where we would be waiting for an answer, provided by the above `KV.Registry.handle_call` callback.\n\nYou may also have noticed that we have added `@impl true` before each callback. The `@impl true` informs the compiler that our intention for the subsequent function definition is to define a callback. If by any chance we make a mistake in the function name or in the number of arguments, like we define a `handle_call/2`, the compiler would warn us there isn't any `handle_call/2` to define, and would give us the complete list of known callbacks for the `GenServer` module.\n\nThis is all good and well, but we still want to offer our users an API that allows us to hide our implementation details.","ref":"genservers.html#defining-genserver-callbacks"},{"type":"extras","title":"The Client API - Client-server communication with GenServer","doc":"A GenServer is implemented in two parts: the client API and the server callbacks. You can either combine both parts into a single module or you can separate them into a client module and a server module. The client is any process that invokes the client function. The server is always the process identifier or process name that we will explicitly pass as argument to the client API. Here we'll use a single module for both the server callbacks and the client API.\n\nEdit the file at `lib/kv/registry.ex`, filling in the blanks for the client API:\n\n```elixir","ref":"genservers.html#the-client-api"},{"type":"extras","title":"Client API - Client-server communication with GenServer","doc":"@doc \"\"\"\n  Starts the registry.\n  \"\"\"\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, :ok, opts)\n  end\n\n  @doc \"\"\"\n  Looks up the bucket pid for `name` stored in `server`.\n\n  Returns `{:ok, pid}` if the bucket exists, `:error` otherwise.\n  \"\"\"\n  def lookup(server, name) do\n    GenServer.call(server, {:lookup, name})\n  end\n\n  @doc \"\"\"\n  Ensures there is a bucket associated with the given `name` in `server`.\n  \"\"\"\n  def create(server, name) do\n    GenServer.cast(server, {:create, name})\n  end\n```\n\nThe first function is `start_link/1`, which starts a new GenServer passing a list of options. `start_link/1` calls out to `GenServer.start_link/3`, which takes three arguments:\n\n1. The module where the server callbacks are implemented, in this case `__MODULE__` (meaning the current module)\n\n2. The initialization arguments, in this case the atom `:ok`\n\n3. A list of options which can be used to specify things like the name of the server. For now, we forward the list of options that we receive on `start_link/1` to `GenServer.start_link/3`\n\nThe next two functions, `lookup/2` and `create/2`, are responsible for sending these requests to the server.  In this case, we have used `{:lookup, name}` and `{:create, name}` respectively.  Requests are often specified as tuples, like this, in order to provide more than one \"argument\" in that first argument slot. It's common to specify the action being requested as the first element of a tuple, and arguments for that action in the remaining elements. Note that the requests must match the first argument to `handle_call/3` or `handle_cast/2`.\n\nThat's it for the client API. On the server side, we can implement a variety of callbacks to guarantee the server initialization, termination, and handling of requests. Those callbacks are optional and for now, we have only implemented the ones we care about. Let's recap.\n\nThe first is the `init/1` callback, that receives the second argument given to `GenServer.start_link/3` and returns `{:ok, state}`, where state is a new map. We can already notice how the `GenServer` API makes the client/server segregation more apparent. `start_link/3` happens in the client, while `init/1` is the respective callback that runs on the server.\n\nFor `call/2` requests, we implement a `handle_call/3` callback that receives the `request`, the process from which we received the request (`_from`), and the current server state (`names`). The `handle_call/3` callback returns a tuple in the format `{:reply, reply, new_state}`. The first element of the tuple, `:reply`, indicates that the server should send a reply back to the client. The second element, `reply`, is what will be sent to the client while the third, `new_state` is the new server state.\n\nFor `cast/2` requests, we implement a `handle_cast/2` callback that receives the `request` and the current server state (`names`). The `handle_cast/2` callback returns a tuple in the format `{:noreply, new_state}`. Note that in a real application we would have probably implemented the callback for `:create` with a synchronous call instead of an asynchronous cast. We are doing it this way to illustrate how to implement a cast callback.\n\nThere are other tuple formats both `handle_call/3` and `handle_cast/2` callbacks may return. There are other callbacks like `terminate/2` and `code_change/3` that we could implement. You are welcome to explore the full `GenServer` documentation to learn more about those.\n\nFor now, let's write some tests to guarantee our GenServer works as expected.","ref":"genservers.html#client-api"},{"type":"extras","title":"Testing a GenServer - Client-server communication with GenServer","doc":"Testing a GenServer is not much different from testing an agent. We will spawn the server on a setup callback and use it throughout our tests. Create a file at `test/kv/registry_test.exs` with the following:\n\n```elixir\ndefmodule KV.RegistryTest do\n  use ExUnit.Case, async: true\n\n  setup do\n    registry = start_supervised!(KV.Registry)\n    %{registry: registry}\n  end\n\n  test \"spawns buckets\", %{registry: registry} do\n    assert KV.Registry.lookup(registry, \"shopping\") == :error\n\n    KV.Registry.create(registry, \"shopping\")\n    assert {:ok, bucket} = KV.Registry.lookup(registry, \"shopping\")\n\n    KV.Bucket.put(bucket, \"milk\", 1)\n    assert KV.Bucket.get(bucket, \"milk\") == 1\n  end\nend\n```\n\nOur test case first asserts there are no buckets in our registry, creates a named bucket, looks it up, and asserts it behaves as a bucket.\n\nThere is one important difference between the `setup` block we wrote for `KV.Registry` and the one we wrote for `KV.Bucket`. Instead of starting the registry by hand by calling `KV.Registry.start_link/1`, we instead called the `ExUnit.Callbacks.start_supervised!/2` function, passing the `KV.Registry` module.\n\nThe `start_supervised!` function was injected into our test module by `use ExUnit.Case`. It does the job of starting the `KV.Registry` process, by calling its `start_link/1` function. The advantage of using `start_supervised!` is that ExUnit will guarantee that the registry process will be shutdown **before** the next test starts. In other words, it helps guarantee that the state of one test is not going to interfere with the next one in case they depend on shared resources.\n\nWhen starting processes during your tests, we should always prefer to use `start_supervised!`. We recommend you to change the `setup` block in `bucket_test.exs` to use `start_supervised!` too.\n\nRun the tests and they should all pass!","ref":"genservers.html#testing-a-genserver"},{"type":"extras","title":"The need for monitoring - Client-server communication with GenServer","doc":"Everything we have done so far could have been implemented with a `Agent`. In this section, we will see one of many things that we can achieve with a GenServer that is not possible with an Agent.\n\nLet's start with a test that describes how we want the registry to behave if a bucket stops or crashes:\n\n```elixir\ntest \"removes buckets on exit\", %{registry: registry} do\n  KV.Registry.create(registry, \"shopping\")\n  {:ok, bucket} = KV.Registry.lookup(registry, \"shopping\")\n  Agent.stop(bucket)\n  assert KV.Registry.lookup(registry, \"shopping\") == :error\nend\n```\n\nThe test above will fail on the last assertion as the bucket name remains in the registry even after we stop the bucket process.\n\nIn order to fix this bug, we need the registry to monitor every bucket it spawns. Once we set up a monitor, the registry will receive a notification every time a bucket process exits, allowing us to clean the registry up.\n\nLet's first play with monitors by starting a new console with `iex -S mix`:\n\n```elixir\niex> {:ok, pid} = KV.Bucket.start_link([])\n{:ok, #PID<0.66.0>}\niex> Process.monitor(pid)\n#Reference<0.0.0.551>\niex> Agent.stop(pid)\n:ok\niex> flush()\n{:DOWN, #Reference<0.0.0.551>, :process, #PID<0.66.0>, :normal}\n```\n\nNote `Process.monitor(pid)` returns a unique reference that allows us to match upcoming messages to that monitoring reference. After we stop the agent, we can `flush/0` all messages and notice a `:DOWN` message arrived, with the exact reference returned by `monitor`, notifying that the bucket process exited with reason `:normal`.\n\nLet's reimplement the server callbacks to fix the bug and make the test pass. First, we will modify the GenServer state to two dictionaries: one that contains `name -> pid` and another that holds `ref -> name`. Then we need to monitor the buckets on `handle_cast/2` as well as implement a `handle_info/2` callback to handle the monitoring messages. The full server callbacks implementation is shown below:\n\n```elixir","ref":"genservers.html#the-need-for-monitoring"},{"type":"extras","title":"Server callbacks - Client-server communication with GenServer","doc":"@impl true\ndef init(:ok) do\n  names = %{}\n  refs = %{}\n  {:ok, {names, refs}}\nend\n\n@impl true\ndef handle_call({:lookup, name}, _from, state) do\n  {names, _} = state\n  {:reply, Map.fetch(names, name), state}\nend\n\n@impl true\ndef handle_cast({:create, name}, {names, refs}) do\n  if Map.has_key?(names, name) do\n    {:noreply, {names, refs}}\n  else\n    {:ok, bucket} = KV.Bucket.start_link([])\n    ref = Process.monitor(bucket)\n    refs = Map.put(refs, ref, name)\n    names = Map.put(names, name, bucket)\n    {:noreply, {names, refs}}\n  end\nend\n\n@impl true\ndef handle_info({:DOWN, ref, :process, _pid, _reason}, {names, refs}) do\n  {name, refs} = Map.pop(refs, ref)\n  names = Map.delete(names, name)\n  {:noreply, {names, refs}}\nend\n\n@impl true\ndef handle_info(msg, state) do\n  require Logger\n  Logger.debug(\"Unexpected message in KV.Registry: #{inspect(msg)}\")\n  {:noreply, state}\nend\n```\n\nObserve that we were able to considerably change the server implementation without changing any of the client API. That's one of the benefits of explicitly segregating the server and the client.\n\nFinally, different from the other callbacks, we have defined a \"catch-all\" clause for `handle_info/2` that discards and logs any unknown message. To understand why, let's move on to the next section.\n\n## `call`, `cast` or `info`?\n\nSo far we have used three callbacks: `handle_call/3`, `handle_cast/2` and `handle_info/2`. Here is what we should consider when deciding when to use each:\n\n1. `handle_call/3` must be used for synchronous requests. This should be the default choice as waiting for the server reply is a useful back-pressure mechanism.\n\n2. `handle_cast/2` must be used for asynchronous requests, when you don't care about a reply. A cast does not guarantee the server has received the message and, for this reason, should be used sparingly. For example, the `create/2` function we have defined in this chapter should have used `call/2`. We have used `cast/2` for didactic purposes.\n\n3. `handle_info/2` must be used for all other messages a server may receive that are not sent via `GenServer.call/2` or `GenServer.cast/2`, including regular messages sent with `send/2`. The monitoring `:DOWN` messages are an example of this.\n\nSince any message, including the ones sent via `send/2`, go to `handle_info/2`, there is a chance that unexpected messages will arrive to the server. Therefore, if we don't define the catch-all clause, those messages could cause our registry to crash, because no clause would match. We don't need to worry about such cases for `handle_call/3` and `handle_cast/2` though. Calls and casts are only done via the `GenServer` API, so an unknown message is quite likely a developer mistake.\n\nTo help developers remember the differences between call, cast and info, the supported return values and more, we have a tiny [GenServer cheat sheet](https://elixir-lang.org/downloads/cheatsheets/gen-server.pdf).","ref":"genservers.html#server-callbacks"},{"type":"extras","title":"Monitors or links? - Client-server communication with GenServer","doc":"We have previously learned about links in the [Process chapter](../getting-started/processes.md). Now, with the registry complete, you may be wondering: when should we use monitors and when should we use links?\n\nLinks are bi-directional. If you link two processes and one of them crashes, the other side will crash too (unless it is trapping exits). A monitor is uni-directional: only the monitoring process will receive notifications about the monitored one. In other words: use links when you want linked crashes, and monitors when you just want to be informed of crashes, exits, and so on.\n\nReturning to our `handle_cast/2` implementation, you can see the registry is both linking and monitoring the buckets:\n\n```elixir\n{:ok, bucket} = KV.Bucket.start_link([])\nref = Process.monitor(bucket)\n```\n\nThis is a bad idea, as we don't want the registry to crash when a bucket crashes. The proper fix is to actually not link the bucket to the registry. Instead, we will link each bucket to a special type of process called Supervisors, which are explicitly designed to handle failures and crashes. We will learn more about them in the next chapter.","ref":"genservers.html#monitors-or-links"},{"type":"extras","title":"Supervision trees and applications","doc":"# Supervision trees and applications\n\nIn the previous chapter about `GenServer`, we implemented `KV.Registry` to manage buckets. At some point, we started monitoring buckets so we were able to take action whenever a `KV.Bucket` crashed. Although the change was relatively small, it introduced a question which is frequently asked by Elixir developers: what happens when something fails?\n\nBefore we added monitoring, if a bucket crashed, the registry would forever point to a bucket that no longer exists. If a user tried to read or write to the crashed bucket, it would fail. Any attempt at creating a new bucket with the same name would just return the PID of the crashed bucket. In other words, that registry entry for that bucket would forever be in a bad state. Once we added monitoring, the registry automatically removes the entry for the crashed bucket. Trying to lookup the crashed bucket now (correctly) says the bucket does not exist and a user of the system can successfully create a new one if desired.\n\nIn practice, we are not expecting the processes working as buckets to fail. But, if it does happen, for whatever reason, we can rest assured that our system will continue to work as intended.\n\nIf you have prior programming experience, you may be wondering: \"could we just guarantee the bucket does not crash in the first place?\". As we will see, Elixir developers tend to refer to those practices as \"defensive programming\". That's because a live production system has dozens of different reasons why something can go wrong. The disk can fail, memory can be corrupted, bugs, the network may stop working for a second, etc. If we were to write software that attempted to protect or circumvent all of those errors, we would spend more time handling failures than writing our own software!\n\nTherefore, an Elixir developer prefers to \"let it crash\" or \"fail fast\". And one of the most common ways we can recover from a failure is by restarting whatever part of the system crashed.\n\nFor example, imagine your computer, router, printer, or whatever device is not working properly. How often do you fix it by restarting it? Once we restart the device, we reset the device back to its initial state, which is well-tested and guaranteed to work. In Elixir, we apply this same approach to software: whenever a process crashes, we start a new process to perform the same job as the crashed process.\n\nIn Elixir, this is done by a Supervisor. A Supervisor is a process that supervises other processes and restarts them whenever they crash. To do so, Supervisors manage the whole life cycle of any supervised processes, including startup and shutdown.\n\nIn this chapter, we will learn how to put those concepts into practice by supervising the `KV.Registry` process. After all, if something goes wrong with the registry, the whole registry is lost and no bucket could ever be found! To address this, we will define a `KV.Supervisor` module that guarantees that our `KV.Registry` is up and running at any given moment.\n\nAt the end of the chapter, we will also talk about Applications. As we will see, Mix has been packaging all of our code into an application, and we will learn how to customize our application to guarantee that our Supervisor and the Registry are up and running whenever our system starts.","ref":"supervisor-and-application.html"},{"type":"extras","title":"Our first supervisor - Supervision trees and applications","doc":"A supervisor is a process which supervises other processes, which we refer to as child processes. The act of supervising a process includes three distinct responsibilities. The first one is to start child processes. Once a child process is running, the supervisor may restart a child process, either because it terminated abnormally or because a certain condition was reached. For example, a supervisor may restart all children if any child dies. Finally, a supervisor is also responsible for shutting down the child processes when the system is shutting down. Please see the `Supervisor` module for a more in-depth discussion.\n\nCreating a supervisor is not much different from creating a GenServer. We are going to define a module named `KV.Supervisor`, which will use the Supervisor behaviour, inside the `lib/kv/supervisor.ex` file:\n\n```elixir\ndefmodule KV.Supervisor do\n  use Supervisor\n\n  def start_link(opts) do\n    Supervisor.start_link(__MODULE__, :ok, opts)\n  end\n\n  @impl true\n  def init(:ok) do\n    children = [\n      KV.Registry\n    ]\n\n    Supervisor.init(children, strategy: :one_for_one)\n  end\nend\n```\n\nOur supervisor has a single child so far: `KV.Registry`. After we define a list of children, we call `Supervisor.init/2`, passing the children and the supervision strategy.\n\nThe supervision strategy dictates what happens when one of the children crashes. `:one_for_one` means that if a child dies, it will be the only one restarted. Since we have only one child now, that's all we need. The `Supervisor` behaviour supports several strategies, which we will discuss in this chapter.\n\nOnce the supervisor starts, it will traverse the list of children and it will invoke the `child_spec/1` function on each module.\n\nThe `child_spec/1` function returns the child specification which describes how to start the process, if the process is a worker or a supervisor, if the process is temporary, transient or permanent and so on. The `child_spec/1` function is automatically defined when we `use Agent`, `use GenServer`, `use Supervisor`, etc. Let's give it a try in the terminal with `iex -S mix`:\n\n```elixir\niex> KV.Registry.child_spec([])\n%{id: KV.Registry, start: {KV.Registry, :start_link, [[]]}}\n```\n\nWe will learn those details as we move forward on this guide. If you would rather peek ahead, check the `Supervisor` docs.\n\nAfter the supervisor retrieves all child specifications, it proceeds to start its children one by one, in the order they were defined, using the information in the `:start` key in the child specification. For our current specification, it will call `KV.Registry.start_link([])`.\n\nLet's take the supervisor for a spin:\n\n```elixir\niex> {:ok, sup} = KV.Supervisor.start_link([])\n{:ok, #PID<0.148.0>}\niex> Supervisor.which_children(sup)\n[{KV.Registry, #PID<0.150.0>, :worker, [KV.Registry]}]\n```\n\nSo far we have started the supervisor and listed its children. Once the supervisor started, it also started all of its children.\n\nWhat happens if we intentionally crash the registry started by the supervisor? Let's do so by sending it a bad input on `call`:\n\n```elixir\niex> [{_, registry, _, _}] = Supervisor.which_children(sup)\n[{KV.Registry, #PID<0.150.0>, :worker, [KV.Registry]}]\niex> GenServer.call(registry, :bad_input)\n08:52:57.311 [error] GenServer #PID<0.150.0> terminating\n** (FunctionClauseError) no function clause matching in KV.Registry.handle_call/3\niex> Supervisor.which_children(sup)\n[{KV.Registry, #PID<0.157.0>, :worker, [KV.Registry]}]\n```\n\nNotice how the supervisor automatically started a new registry, with a new PID, in place of the first one once we caused it to crash due to a bad input.\n\nIn the previous chapters, we have always started processes directly. For example, we would call `KV.Registry.start_link([])`, which would return `{:ok, pid}`, and that would allow us to interact with the registry via its `pid`. Now that processes are started by the supervisor, we have to directly ask the supervisor who its children are, and fetch the PID from the returned list of children. In practice, doing so every time would be very expensive. To address this, we often give names to processes, allowing them to be uniquely identified in a single machine from anywhere in our code.\n\nLet's learn how to do that.","ref":"supervisor-and-application.html#our-first-supervisor"},{"type":"extras","title":"Naming processes - Supervision trees and applications","doc":"While our application will have many buckets, it will only have a single registry. Therefore, whenever we start the registry, we want to give it a unique name so we can reach out to it from anywhere. We do so by passing a `:name` option to `KV.Registry.start_link/1`.\n\nLet's slightly change our children definition (in `KV.Supervisor.init/1`) to be a list of tuples instead of a list of atoms:\n\n```elixir\n  def init(:ok) do\n    children = [\n      {KV.Registry, name: KV.Registry}\n    ]\n```\n\nWith this in place, the supervisor will now start `KV.Registry` by calling `KV.Registry.start_link(name: KV.Registry)`.\n\nIf you revisit the `KV.Registry.start_link/1` implementation, you will remember it simply passes the options to GenServer:\n\n```elixir\n  def start_link(opts) do\n    GenServer.start_link(__MODULE__, :ok, opts)\n  end\n```\n\nwhich in turn will register the process with the given name. The `:name` option expects an atom for locally named processes (locally named means it is available to this machine — there are other options, which we won't discuss here). Since module identifiers are atoms (try `i(KV.Registry)` in IEx), we can name a process after the module that implements it, provided there is only one process for that name. This helps when debugging and introspecting the system.\n\nLet's give the updated supervisor a try inside `iex -S mix`:\n\n```elixir\niex> KV.Supervisor.start_link([])\n{:ok, #PID<0.66.0>}\niex> KV.Registry.create(KV.Registry, \"shopping\")\n:ok\niex> KV.Registry.lookup(KV.Registry, \"shopping\")\n{:ok, #PID<0.70.0>}\n```\n\nThis time the supervisor started a named registry, allowing us to create buckets without having to explicitly fetch the PID from the supervisor. You should also know how to make the registry crash again, without looking up its PID: give it a try.\n\n> At this point, you may be wondering: should you also locally name bucket processes? Remember buckets are started dynamically based on user input. Since local names MUST be atoms, we would have to dynamically create atoms, which is a bad idea since once an atom is defined, it is never erased nor garbage collected. This means that, if we create atoms dynamically based on user input, we will eventually run out of memory (or to be more precise, the VM will crash because it imposes a hard limit on the number of atoms). This limitation is precisely why we created our own registry (or why one would use Elixir's built-in `Registry` module).\n\nWe are getting closer and closer to a fully working system. The supervisor automatically starts the registry. But how can we automatically start the supervisor whenever our system starts? To answer this question, let's talk about applications.","ref":"supervisor-and-application.html#naming-processes"},{"type":"extras","title":"Understanding applications - Supervision trees and applications","doc":"We have been working inside an application this entire time. Every time we changed a file and ran `mix compile`, we could see a `Generated kv app` message in the compilation output.\n\nWe can find the generated `.app` file at `_build/dev/lib/kv/ebin/kv.app`. Let's have a look at its contents:\n\n```erlang\n{application,kv,\n             [{applications,[kernel,stdlib,elixir,logger]},\n              {description,\"kv\"},\n              {modules,['Elixir.KV','Elixir.KV.Bucket','Elixir.KV.Registry',\n                        'Elixir.KV.Supervisor']},\n              {registered,[]},\n              {vsn,\"0.1.0\"}]}.\n```\n\nThis file contains Erlang terms (written using Erlang syntax). Even though we are not familiar with Erlang, it is easy to guess this file holds our application definition. It contains our application `version`, all the modules defined by it, as well as a list of applications we depend on, like Erlang's `kernel`, `elixir` itself, and `logger`.\n\n> The `logger` application ships as part of Elixir. We stated that our application needs it by specifying it in the `:extra_applications` list in `mix.exs`. See the [official documentation](`Logger`) for more information.\n\nIn a nutshell, an application consists of all the modules defined in the `.app` file, including the `.app` file itself. An application has generally only two directories: `ebin`, for Elixir artifacts, such as `.beam` and `.app` files, and `priv`, with any other artifact or asset you may need in your application.\n\nAlthough Mix generates and maintains the `.app` file for us, we can customize its contents by adding new entries to the `application/0` function inside the `mix.exs` project file. We are going to do our first customization soon.","ref":"supervisor-and-application.html#understanding-applications"},{"type":"extras","title":"Starting applications - Supervision trees and applications","doc":"Each application in our system can be started and stopped. The rules for starting and stopping an application are also defined in the `.app` file. When we invoke `iex -S mix`, Mix compiles our application and then starts it.\n\nLet's see this in practice. Start a console with `iex -S mix` and try:\n\n```elixir\niex> Application.start(:kv)\n{:error, {:already_started, :kv}}\n```\n\nOops, it's already started. Mix starts the current application and all of its dependencies automatically. This is also true for `mix test` and many other Mix commands.\n\nWe can, however, stop our `:kv` application, as well as the `:logger` application:\n\n```elixir\niex> Application.stop(:kv)\n:ok\niex> Application.stop(:logger)\n:ok\n```\n\nAnd let's try to start our application again:\n\n```elixir\niex> Application.start(:kv)\n{:error, {:not_started, :logger}}\n```\n\nNow we get an error because an application that `:kv` depends on (`:logger` in this case) isn't started. We need to either start each application manually in the correct order or call `Application.ensure_all_started/1` as follows:\n\n```elixir\niex> Application.ensure_all_started(:kv)\n{:ok, [:logger, :kv]}\n```\n\nIn practice, our tools always start our applications for us, but there is an API available if you need fine-grained control.","ref":"supervisor-and-application.html#starting-applications"},{"type":"extras","title":"The application callback - Supervision trees and applications","doc":"Whenever we invoke `iex -S mix`, Mix automatically starts our application by calling `Application.start(:kv)`. But can we customize what happens when our application starts? As a matter of fact, we can! To do so, we define an application callback.\n\nThe first step is to tell our application definition (for example, our `.app` file) which module is going to implement the application callback. Let's do so by opening `mix.exs` and changing `def application` to the following:\n\n```elixir\n  def application do\n    [\n      extra_applications: [:logger],\n      mod: {KV, []}\n    ]\n  end\n```\n\nThe `:mod` option specifies the \"application callback module\", followed by the arguments to be passed on application start. The application callback module can be any module that implements the `Application` behaviour.\n\nTo implement the `Application` behaviour, we have to `use Application` and define a `start/2` function. The goal of `start/2` is to start a supervisor, which will then start any child services or execute any other code our application may need. Let's use this opportunity to start the `KV.Supervisor` we have implemented earlier in this chapter.\n\nSince we have specified `KV` as the module callback, let's change the `KV` module defined in `lib/kv.ex` to implement a `start/2` function:\n\n```elixir\ndefmodule KV do\n  use Application\n\n  @impl true\n  def start(_type, _args) do\n    # Although we don't use the supervisor name below directly,\n    # it can be useful when debugging or introspecting the system.\n    KV.Supervisor.start_link(name: KV.Supervisor)\n  end\nend\n```\n\n> Please note that by doing this, we are breaking the boilerplate test case which tested the `hello` function in `KV`. You can simply remove that test case.\n\nWhen we `use Application`, we may define a couple of functions, similar to when we used `Supervisor` or `GenServer`. This time we only had to define a `start/2` function. The `Application` behaviour also has a `stop/1` callback, but it is rarely used in practice. You can check the documentation for more information.\n\nNow that you have defined an application callback which starts our supervisor, we expect the `KV.Registry` process to be up and running as soon as we start `iex -S mix`. Let's give it another try:\n\n```elixir\niex> KV.Registry.create(KV.Registry, \"shopping\")\n:ok\niex> KV.Registry.lookup(KV.Registry, \"shopping\")\n{:ok, #PID<0.88.0>}\n```\n\nLet's recap what is happening. Whenever we invoke `iex -S mix`, it automatically starts our application by calling `Application.start(:kv)`, which then invokes the application callback. The application callback's job is to start a **supervision tree**. Right now, our supervisor has a single child named `KV.Registry`, started with name `KV.Registry`. Our supervisor could have other children, and some of these children could be their own supervisors with their own children, leading to the so-called supervision trees.","ref":"supervisor-and-application.html#the-application-callback"},{"type":"extras","title":"Projects or applications? - Supervision trees and applications","doc":"Mix makes a distinction between projects and applications. Based on the contents of our `mix.exs` file, we would say we have a Mix project that defines the `:kv` application. As we will see in later chapters, there are projects that don't define any application.\n\nWhen we say \"project\" you should think about Mix. Mix is the tool that manages your project. It knows how to compile your project, test your project and more. It also knows how to compile and start the application relevant to your project.\n\nWhen we talk about applications, we talk about OTP. Applications are the entities that are started and stopped as a whole by the runtime. You can learn more about applications and how they relate to booting and shutting down of your system as a whole in the documentation for the `Application` module.","ref":"supervisor-and-application.html#projects-or-applications"},{"type":"extras","title":"Next steps - Supervision trees and applications","doc":"Although this chapter was the first time we implemented a supervisor, it was not the first time we used one! In the previous chapter, when we used `start_supervised!` to start the registry during our tests, `ExUnit` started the registry under a supervisor managed by the ExUnit framework itself. By defining our own supervisor, we provide more structure on how we initialize, shutdown and supervise processes in our applications, aligning our production code and tests with best practices.\n\nBut we are not done yet. So far we are supervising the registry but our application is also starting buckets. Since buckets are started dynamically, we can use a special type of supervisor called `DynamicSupervisor`, which is optimized to handle such scenarios. Let's explore it next.","ref":"supervisor-and-application.html#next-steps"},{"type":"extras","title":"Supervising dynamic children","doc":"# Supervising dynamic children\n\nWe have now successfully defined our supervisor which is automatically started (and stopped) as part of our application life cycle.\n\nRemember, however, that our `KV.Registry` is both linking (via `start_link`) and monitoring (via `monitor`) bucket processes in the `handle_cast/2` callback:\n\n```elixir\n{:ok, bucket} = KV.Bucket.start_link([])\nref = Process.monitor(bucket)\n```\n\nLinks are bidirectional, which implies that a crash in a bucket will crash the registry. Although we now have the supervisor, which guarantees the registry will be back up and running, crashing the registry still means we lose all data associating bucket names to their respective processes.\n\nIn other words, we want the registry to keep on running even if a bucket crashes. Let's write a new registry test:\n\n```elixir\ntest \"removes bucket on crash\", %{registry: registry} do\n  KV.Registry.create(registry, \"shopping\")\n  {:ok, bucket} = KV.Registry.lookup(registry, \"shopping\")\n\n  # Stop the bucket with non-normal reason\n  Agent.stop(bucket, :shutdown)\n  assert KV.Registry.lookup(registry, \"shopping\") == :error\nend\n```\n\nThe test is similar to \"removes bucket on exit\" except that we are being a bit more harsh by sending `:shutdown` as the exit reason instead of `:normal`. If a process terminates with a reason other than `:normal`, all linked processes receive an EXIT signal, causing the linked process to also terminate unless it is trapping exits.\n\nSince the bucket terminated, the registry also stopped, and our test fails when trying to `GenServer.call/3` it:\n\n```text\n  1) test removes bucket on crash (KV.RegistryTest)\n     test/kv/registry_test.exs:26\n     ** (exit) exited in: GenServer.call(#PID<0.148.0>, {:lookup, \"shopping\"}, 5000)\n         ** (EXIT) no process: the process is not alive or there's no process currently associated with the given name, possibly because its application isn't started\n     code: assert KV.Registry.lookup(registry, \"shopping\") == :error\n     stacktrace:\n       (elixir) lib/gen_server.ex:770: GenServer.call/3\n       test/kv/registry_test.exs:33: (test)\n```\n\nWe are going to solve this issue by defining a new supervisor that will spawn and supervise all buckets. Opposite to the previous Supervisor we defined, the children are not known upfront, but they are rather started dynamically. For those situations, we use a supervisor optimized to such use cases called `DynamicSupervisor`. The `DynamicSupervisor` does not expect a list of children during initialization; instead each child is started manually via `DynamicSupervisor.start_child/2`.","ref":"dynamic-supervisor.html"},{"type":"extras","title":"The bucket supervisor - Supervising dynamic children","doc":"Since a `DynamicSupervisor` does not define any children during initialization, the `DynamicSupervisor` also allows us to skip the work of defining a whole separate module with the usual `start_link` function and the `init` callback. Instead, we can define a `DynamicSupervisor` directly in the supervision tree, by giving it a name and a strategy.\n\nOpen up `lib/kv/supervisor.ex` and add the dynamic supervisor as a child as follows:\n\n```elixir\n  def init(:ok) do\n    children = [\n      {KV.Registry, name: KV.Registry},\n      {DynamicSupervisor, name: KV.BucketSupervisor, strategy: :one_for_one}\n    ]\n\n    Supervisor.init(children, strategy: :one_for_one)\n  end\n```\n\nRemember that the name of a process can be any atom. So far, we have named processes with the same name as the modules that define their implementation. For example, the process defined by `KV.Registry` was given a process name of `KV.Registry`. This is simply a convention: If later there is an error in your system that says, \"process named KV.Registry crashed with reason\", we know exactly where to investigate.\n\nIn this case, there is no module, so we picked the name `KV.BucketSupervisor`. It could have been any other name. We also chose the `:one_for_one` strategy, which is currently the only available strategy for dynamic supervisors.\n\nRun `iex -S mix` so we can give our dynamic supervisor a try:\n\n```elixir\niex> {:ok, bucket} = DynamicSupervisor.start_child(KV.BucketSupervisor, KV.Bucket)\n{:ok, #PID<0.72.0>}\niex> KV.Bucket.put(bucket, \"eggs\", 3)\n:ok\niex> KV.Bucket.get(bucket, \"eggs\")\n3\n```\n\n`DynamicSupervisor.start_child/2` expects the name of the supervisor and the child specification of the child to be started.\n\nThe last step is to change the registry to use the dynamic supervisor:\n\n```elixir\n  def handle_cast({:create, name}, {names, refs}) do\n    if Map.has_key?(names, name) do\n      {:noreply, {names, refs}}\n    else\n      {:ok, pid} = DynamicSupervisor.start_child(KV.BucketSupervisor, KV.Bucket)\n      ref = Process.monitor(pid)\n      refs = Map.put(refs, ref, name)\n      names = Map.put(names, name, pid)\n      {:noreply, {names, refs}}\n    end\n  end\n```\n\nThat's enough for our tests to pass but there is a resource leakage in our application. When a bucket terminates, the supervisor will start a new bucket in its place. After all, that's the role of the supervisor!\n\nHowever, when the supervisor restarts the new bucket, the registry does not know about it. So we will have an empty bucket in the supervisor that nobody can access! To solve this, we want to say that buckets are actually temporary. If they crash, regardless of the reason, they should not be restarted.\n\nWe can do this by passing the `restart: :temporary` option to `use Agent` in `KV.Bucket`:\n\n```elixir\ndefmodule KV.Bucket do\n  use Agent, restart: :temporary\n```\n\nLet's also add a test to `test/kv/bucket_test.exs` that guarantees the bucket is temporary:\n\n```elixir\n  test \"are temporary workers\" do\n    assert Supervisor.child_spec(KV.Bucket, []).restart == :temporary\n  end\n```\n\nOur test uses the `Supervisor.child_spec/2` function to retrieve the child specification out of a module and then assert its restart value is `:temporary`. At this point, you may be wondering why use a supervisor if it never restarts its children. It happens that supervisors provide more than restarts, they are also responsible for guaranteeing proper startup and shutdown, especially in case of crashes in a supervision tree.","ref":"dynamic-supervisor.html#the-bucket-supervisor"},{"type":"extras","title":"Supervision trees - Supervising dynamic children","doc":"When we added `KV.BucketSupervisor` as a child of `KV.Supervisor`, we began to have supervisors that supervise other supervisors, forming so-called \"supervision trees\".\n\nEvery time you add a new child to a supervisor, it is important to evaluate if the supervisor strategy is correct as well as the order of child processes. In this case, we are using `:one_for_one` and the `KV.Registry` is started before `KV.BucketSupervisor`.\n\nOne flaw that shows up right away is the ordering issue. Since `KV.Registry` invokes `KV.BucketSupervisor`, then the `KV.BucketSupervisor` must be started before `KV.Registry`. Otherwise, it may happen that the registry attempts to reach the bucket supervisor before it has started.\n\nThe second flaw is related to the supervision strategy. If `KV.Registry` dies, all information linking `KV.Bucket` names to bucket processes is lost. Therefore the `KV.BucketSupervisor` and all children must terminate too - otherwise we will have orphan processes.\n\nIn light of this observation, we should consider moving to another supervision strategy. The two other candidates are `:one_for_all` and `:rest_for_one`. A supervisor using the `:rest_for_one` strategy will kill and restart child processes which were started *after* the crashed child. In this case, we would want `KV.BucketSupervisor` to terminate if `KV.Registry` terminates. This would require the bucket supervisor to be placed after the registry which violates the ordering constraints we have established two paragraphs above.\n\nSo our last option is to go all in and pick the `:one_for_all` strategy: the supervisor will kill and restart all of its children processes whenever any one of them dies. This is a completely reasonable approach for our application, since the registry can't work without the bucket supervisor, and the bucket supervisor should terminate without the registry. Let's reimplement `init/1` in `KV.Supervisor` to encode those properties:\n\n```elixir\n  def init(:ok) do\n    children = [\n      {DynamicSupervisor, name: KV.BucketSupervisor, strategy: :one_for_one},\n      {KV.Registry, name: KV.Registry}\n    ]\n\n    Supervisor.init(children, strategy: :one_for_all)\n  end\n```\n\nThere are two topics left before we move on to the next chapter.","ref":"dynamic-supervisor.html#supervision-trees"},{"type":"extras","title":"Shared state in tests - Supervising dynamic children","doc":"So far we have been starting one registry per test to ensure they are isolated:\n\n```elixir\nsetup do\n  registry = start_supervised!(KV.Registry)\n  %{registry: registry}\nend\n```\n\nSince we have changed our registry to use `KV.BucketSupervisor`, our tests are now relying on this shared supervisor even though each test has its own registry. The question is: should we?\n\nIt depends. It is ok to rely on shared state as long as we depend only on a non-shared partition of this state. Although multiple registries may start buckets on the shared bucket supervisor, those buckets and registries are isolated from each other. We would only run into concurrency issues if we used a function like `DynamicSupervisor.count_children(KV.BucketSupervisor)` which would count all buckets from all registries, potentially giving different results when tests run concurrently.\n\nSince we have relied only on a non-shared partition of the bucket supervisor so far, we don't need to worry about concurrency issues in our test suite. In case it ever becomes a problem, we can start a supervisor per test and pass it as an argument to the registry `start_link` function.","ref":"dynamic-supervisor.html#shared-state-in-tests"},{"type":"extras","title":"Observer - Supervising dynamic children","doc":"Now that we have defined our supervision tree, it is a great opportunity to introduce the Observer tool that ships with Erlang. Start your application with `iex -S mix` and key this in:\n\n```elixir\niex> :observer.start()\n```\n\n> #### Missing dependencies {: .warning}\n>\n> When running `iex` inside a project with `iex -S mix`, `observer` won't be available as a dependency. To do so, you will need to call the following functions before:\n>\n> ```elixir\n> iex> Mix.ensure_application!(:wx)             # Not necessary on Erlang/OTP 27+\n> iex> Mix.ensure_application!(:runtime_tools)  # Not necessary on Erlang/OTP 27+\n> iex> Mix.ensure_application!(:observer)\n> iex> :observer.start()\n> ```\n>\n> If any of the calls above fail, here is what may have happened: some package managers default to installing a minimized Erlang without WX bindings for GUI support. In some package managers, you may be able to replace the headless Erlang with a more complete package (look for packages named `erlang` vs `erlang-nox` on Debian/Ubuntu/Arch). In others managers, you may need to install a separate `erlang-wx` (or similarly named) package.\n>\n> There are conversations to improve this experience in future releases.\n\nA GUI should pop up containing all sorts of information about our system, from general statistics to load charts as well as a list of all running processes and applications.\n\nIn the Applications tab, you will see all applications currently running in your system alongside their supervision tree. You can select the `kv` application to explore it further:\n\n \n\nNot only that, as you create new buckets on the terminal, you should see new processes spawned in the supervision tree shown in Observer:\n\n```elixir\niex> KV.Registry.create(KV.Registry, \"shopping\")\n:ok\n```\n\nWe will leave it up to you to further explore what Observer provides. Note you can double-click any process in the supervision tree to retrieve more information about it, as well as right-click a process to send \"a kill signal\", a perfect way to emulate failures and see if your supervisor reacts as expected.\n\nAt the end of the day, tools like Observer are one of the reasons you want to always start processes inside supervision trees, even if they are temporary, to ensure they are always reachable and introspectable.\n\nNow that our buckets are properly linked and supervised, let's see how we can speed things up.","ref":"dynamic-supervisor.html#observer"},{"type":"extras","title":"Speeding up with ETS","doc":"# Speeding up with ETS\n\nEvery time we need to look up a bucket, we need to send a message to the registry. In case our registry is being accessed concurrently by multiple processes, the registry may become a bottleneck!\n\nIn this chapter, we will learn about ETS (Erlang Term Storage) and how to use it as a cache mechanism.\n\n> Warning! Don't use ETS as a cache prematurely! Log and analyze your application performance and identify which parts are bottlenecks, so you know *whether* you should cache, and *what* you should cache. This chapter is merely an example of how ETS can be used, once you've determined the need.","ref":"erlang-term-storage.html"},{"type":"extras","title":"ETS as a cache - Speeding up with ETS","doc":"ETS allows us to store any Elixir term in an in-memory table. Working with ETS tables is done via [Erlang's `:ets` module](http://www.erlang.org/doc/man/ets.html):\n\n```elixir\niex> table = :ets.new(:buckets_registry, [:set, :protected])\n#Reference<0.1885502827.460455937.234656>\niex> :ets.insert(table, {\"foo\", self()})\ntrue\niex> :ets.lookup(table, \"foo\")\n[{\"foo\", #PID<0.41.0>}]\n```\n\nWhen creating an ETS table, two arguments are required: the table name and a set of options. From the available options, we passed the table type and its access rules. We have chosen the `:set` type, which means that keys cannot be duplicated. We've also set the table's access to `:protected`, meaning only the process that created the table can write to it, but all processes can read from it. The possible access controls:\n\n  `:public` — Read/Write available to all processes.\n\n  `:protected` — Read available to all processes. Only writable by owner process. This is the default.\n\n  `:private` — Read/Write limited to owner process.\n\nBe aware that if your Read/Write call violates the access control, the operation will raise `ArgumentError`. Finally, since `:set` and `:protected` are the default values, we will skip them from now on.\n\nETS tables can also be named, allowing us to access them by a given name:\n\n```elixir\niex> :ets.new(:buckets_registry, [:named_table])\n:buckets_registry\niex> :ets.insert(:buckets_registry, {\"foo\", self()})\ntrue\niex> :ets.lookup(:buckets_registry, \"foo\")\n[{\"foo\", #PID<0.41.0>}]\n```\n\nLet's change the `KV.Registry` to use ETS tables. The first change is to modify our registry to require a name argument, we will use it to name the ETS table and the registry process itself. ETS names and process names are stored in different locations, so there is no chance of conflicts.\n\nOpen up `lib/kv/registry.ex`, and let's change its implementation. We've added comments to the source code to highlight the changes we've made:\n\n```elixir\ndefmodule KV.Registry do\n  use GenServer","ref":"erlang-term-storage.html#ets-as-a-cache"},{"type":"extras","title":"Client API - Speeding up with ETS","doc":"@doc \"\"\"\n  Starts the registry with the given options.\n\n  `:name` is always required.\n  \"\"\"\n  def start_link(opts) do\n    # 1. Pass the name to GenServer's init\n    server = Keyword.fetch!(opts, :name)\n    GenServer.start_link(__MODULE__, server, opts)\n  end\n\n  @doc \"\"\"\n  Looks up the bucket pid for `name` stored in `server`.\n\n  Returns `{:ok, pid}` if the bucket exists, `:error` otherwise.\n  \"\"\"\n  def lookup(server, name) do\n    # 2. Lookup is now done directly in ETS, without accessing the server\n    case :ets.lookup(server, name) do\n      [{^name, pid}] -> {:ok, pid}\n      [] -> :error\n    end\n  end\n\n  @doc \"\"\"\n  Ensures there is a bucket associated with the given `name` in `server`.\n  \"\"\"\n  def create(server, name) do\n    GenServer.cast(server, {:create, name})\n  end","ref":"erlang-term-storage.html#client-api"},{"type":"extras","title":"Server callbacks - Speeding up with ETS","doc":"@impl true\n  def init(table) do\n    # 3. We have replaced the names map by the ETS table\n    names = :ets.new(table, [:named_table, read_concurrency: true])\n    refs  = %{}\n    {:ok, {names, refs}}\n  end\n\n  # 4. The previous handle_call callback for lookup was removed\n\n  @impl true\n  def handle_cast({:create, name}, {names, refs}) do\n    # 5. Read and write to the ETS table instead of the map\n    case lookup(names, name) do\n      {:ok, _pid} ->\n        {:noreply, {names, refs}}\n\n      :error ->\n        {:ok, pid} = DynamicSupervisor.start_child(KV.BucketSupervisor, KV.Bucket)\n        ref = Process.monitor(pid)\n        refs = Map.put(refs, ref, name)\n        :ets.insert(names, {name, pid})\n        {:noreply, {names, refs}}\n    end\n  end\n\n  @impl true\n  def handle_info({:DOWN, ref, :process, _pid, _reason}, {names, refs}) do\n    # 6. Delete from the ETS table instead of the map\n    {name, refs} = Map.pop(refs, ref)\n    :ets.delete(names, name)\n    {:noreply, {names, refs}}\n  end\n\n  @impl true\n  def handle_info(_msg, state) do\n    {:noreply, state}\n  end\nend\n```\n\nNotice that before our changes `KV.Registry.lookup/2` sent requests to the server, but now it reads directly from the ETS table, which is shared across all processes. That's the main idea behind the cache mechanism we are implementing.\n\nIn order for the cache mechanism to work, the created ETS table needs to have access `:protected` (the default), so all clients can read from it, while only the `KV.Registry` process writes to it. We have also set `read_concurrency: true` when starting the table, optimizing the table for the common scenario of concurrent read operations.\n\nThe changes we have performed above have broken our tests because the registry requires the `:name` option when starting up. Furthermore, some registry operations such as `lookup/2` require the name to be given as an argument, instead of a PID, so we can do the ETS table lookup. Let's change the setup function in `test/kv/registry_test.exs` to fix both issues:\n\n```elixir\n  setup context do\n    _ = start_supervised!({KV.Registry, name: context.test})\n    %{registry: context.test}\n  end\n```\n\nSince each test has a unique name, we use the test name to name our registries. This way, we no longer need to pass the registry PID around, instead we identify it by the test name. Also note we assigned the result of `start_supervised!` to underscore (`_`). This idiom is often used to signal that we are not interested in the result of `start_supervised!`.\n\nOnce we change `setup`, some tests will continue to fail. You may even notice tests pass and fail inconsistently between runs. For example, the \"spawns buckets\" test:\n\n```elixir\ntest \"spawns buckets\", %{registry: registry} do\n  assert KV.Registry.lookup(registry, \"shopping\") == :error\n\n  KV.Registry.create(registry, \"shopping\")\n  assert {:ok, bucket} = KV.Registry.lookup(registry, \"shopping\")\n\n  KV.Bucket.put(bucket, \"milk\", 1)\n  assert KV.Bucket.get(bucket, \"milk\") == 1\nend\n```\n\nmay be failing on this line:\n\n```elixir\n{:ok, bucket} = KV.Registry.lookup(registry, \"shopping\")\n```\n\nHow can this line fail if we just created the bucket in the previous line?\n\nThe reason those failures are happening is because, for didactic purposes, we have made two mistakes:\n\n  1. We are prematurely optimizing (by adding this cache layer)\n  2. We are using `cast/2` (while we should be using `call/2`)","ref":"erlang-term-storage.html#server-callbacks"},{"type":"extras","title":"Race conditions? - Speeding up with ETS","doc":"Developing in Elixir does not make your code free of race conditions. However, Elixir's abstractions where nothing is shared by default make it easier to spot a race condition's root cause.\n\nWhat is happening in our tests is that there is a delay in between an operation and the time we can observe this change in the ETS table. Here is what we were expecting to happen:\n\n1. We invoke `KV.Registry.create(registry, \"shopping\")`\n2. The registry creates the bucket and updates the cache table\n3. We access the information from the table with `KV.Registry.lookup(registry, \"shopping\")`\n4. The command above returns `{:ok, bucket}`\n\nHowever, since `KV.Registry.create/2` is a cast operation, the command will return before we actually write to the table! In other words, this is happening:\n\n1. We invoke `KV.Registry.create(registry, \"shopping\")`\n2. We access the information from the table with `KV.Registry.lookup(registry, \"shopping\")`\n3. The command above returns `:error`\n4. The registry creates the bucket and updates the cache table\n\nTo fix the failure we need to make `KV.Registry.create/2` synchronous by using `call/2` rather than `cast/2`. This will guarantee that the client will only continue after changes have been made to the table. Let's back to `lib/kv/registry.ex` and change the function and its callback as follows:\n\n```elixir\ndef create(server, name) do\n  GenServer.call(server, {:create, name})\nend\n```\n\n```elixir\n@impl true\ndef handle_call({:create, name}, _from, {names, refs}) do\n  case lookup(names, name) do\n    {:ok, pid} ->\n      {:reply, pid, {names, refs}}\n\n    :error ->\n      {:ok, pid} = DynamicSupervisor.start_child(KV.BucketSupervisor, KV.Bucket)\n      ref = Process.monitor(pid)\n      refs = Map.put(refs, ref, name)\n      :ets.insert(names, {name, pid})\n      {:reply, pid, {names, refs}}\n  end\nend\n```\n\nWe changed the callback from `handle_cast/2` to `handle_call/3` and changed it to reply with the PID of the created bucket. Generally speaking, Elixir developers prefer to use `call/2` instead of `cast/2` as it also provides back-pressure — you block until you get a reply. Using `cast/2` when not necessary can also be considered a premature optimization.\n\nLet's run the tests once again. This time though, we will pass the `--trace` option:\n\n```console\n$ mix test --trace\n```\n\nThe `--trace` option is useful when your tests are deadlocking or there are race conditions, as it runs all tests synchronously (`async: true` has no effect) and shows detailed information about each test. If you run the tests multiple times you may see this intermittent failure:\n\n```text\n  1) test removes buckets on exit (KV.RegistryTest)\n     test/kv/registry_test.exs:19\n     Assertion with == failed\n     code:  assert KV.Registry.lookup(registry, \"shopping\") == :error\n     left:  {:ok, #PID<0.109.0>}\n     right: :error\n     stacktrace:\n       test/kv/registry_test.exs:23\n```\n\nAccording to the failure message, we are expecting that the bucket no longer exists on the table, but it still does! This problem is the opposite of the one we have just solved: while previously there was a delay between the command to create a bucket and updating the table, now there is a delay between the bucket process dying and its entry being removed from the table. Since this is a race condition, you may not be able to reproduce it on your machine, but it is there.\n\nLast time we fixed the race condition by replacing the asynchronous operation, a `cast`, by a `call`, which is synchronous. Unfortunately, the `handle_info/2` callback we are using to receive the `:DOWN` message and delete the entry from the ETS table does not have a synchronous equivalent. This time, we need to find a way to guarantee the registry has processed the `:DOWN` notification sent when the bucket process terminated.\n\nAn easy way to do so is by sending a synchronous request to the registry before we do the bucket lookup. The `Agent.stop/2` operation is synchronous and only returns after the bucket process terminates. Therefore, once `Agent.stop/2` returns, the registry has received the `:DOWN` message but it may not have processed it yet. In order to guarantee the processing of the `:DOWN` message, we can do a synchronous request. Since messages are processed in order, once the registry replies to the synchronous request, then the `:DOWN` message will definitely have been processed.\n\nLet's do so by creating a \"bogus\" bucket, which is a synchronous request, after `Agent.stop/2` in both \"remove\" tests at `test/kv/registry_test.exs`:\n\n```elixir\n  test \"removes buckets on exit\", %{registry: registry} do\n    KV.Registry.create(registry, \"shopping\")\n    {:ok, bucket} = KV.Registry.lookup(registry, \"shopping\")\n    Agent.stop(bucket)\n\n    # Do a call to ensure the registry processed the DOWN message\n    _ = KV.Registry.create(registry, \"bogus\")\n    assert KV.Registry.lookup(registry, \"shopping\") == :error\n  end\n\n  test \"removes bucket on crash\", %{registry: registry} do\n    KV.Registry.create(registry, \"shopping\")\n    {:ok, bucket} = KV.Registry.lookup(registry, \"shopping\")\n\n    # Stop the bucket with non-normal reason\n    Agent.stop(bucket, :shutdown)\n\n    # Do a call to ensure the registry processed the DOWN message\n    _ = KV.Registry.create(registry, \"bogus\")\n    assert KV.Registry.lookup(registry, \"shopping\") == :error\n  end\n```\n\nOur tests should now (always) pass!\n\nThis concludes our optimization chapter. We have used ETS as a cache mechanism where reads can happen from any processes but writes are still serialized through a single process. More importantly, we have also learned that once data can be read asynchronously, we need to be aware of the race conditions it might introduce.\n\nIn practice, if you find yourself in a position where you need a registry for dynamic processes, you should use the `Registry` module provided as part of Elixir. It provides functionality similar to the one we have built using a GenServer + `:ets` while also being able to perform both writes and reads concurrently. [It has been benchmarked to scale across all cores even on machines with 40 cores](https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/).\n\nNext, let's discuss external and internal dependencies and how Mix helps us manage large codebases.","ref":"erlang-term-storage.html#race-conditions"},{"type":"extras","title":"Dependencies and umbrella projects","doc":"# Dependencies and umbrella projects\n\nIn this chapter, we will discuss how to manage dependencies in Mix.\n\nOur `kv` application is complete, so it's time to implement the server that will handle the requests we defined in the first chapter:\n\n```text\nCREATE shopping\nOK\n\nPUT shopping milk 1\nOK\n\nPUT shopping eggs 3\nOK\n\nGET shopping milk\n1\nOK\n\nDELETE shopping eggs\nOK\n```\n\nHowever, instead of adding more code to the `kv` application, we are going to build the TCP server as another application that is a client of the `kv` application. Since the whole runtime and Elixir ecosystem are geared towards applications, it makes sense to break our projects into smaller applications that work together rather than building a big, monolithic app.\n\nBefore creating our new application, we must discuss how Mix handles dependencies. In practice, there are two kinds of dependencies we usually work with: internal and external dependencies. Mix supports mechanisms to work with both.","ref":"dependencies-and-umbrella-projects.html"},{"type":"extras","title":"External dependencies - Dependencies and umbrella projects","doc":"External dependencies are the ones not tied to your business domain. For example, if you need an HTTP API for your distributed KV application, you can use the [Plug](https://github.com/elixir-lang/plug) project as an external dependency.\n\nInstalling external dependencies is simple. Most commonly, we use the [Hex Package Manager](https://hex.pm), by listing the dependency inside the deps function in our `mix.exs` file:\n\n```elixir\ndef deps do\n  [{:plug, \"~> 1.0\"}]\nend\n```\n\nThis dependency refers to the latest version of Plug in the 1.x.x version series that has been pushed to Hex. This is indicated by the `~>` preceding the version number. For more information on specifying version requirements, see the documentation for the `Version` module.\n\nTypically, stable releases are pushed to Hex. If you want to depend on an external dependency still in development, Mix is able to manage Git dependencies too:\n\n```elixir\ndef deps do\n  [{:plug, git: \"https://github.com/elixir-lang/plug.git\"}]\nend\n```\n\nYou will notice that when you add a dependency to your project, Mix generates a `mix.lock` file that guarantees *repeatable builds*. The lock file must be checked in to your version control system, to guarantee that everyone who uses the project will use the same dependency versions as you.\n\nMix provides many tasks for working with dependencies, which can be seen in `mix help`:\n\n```console\n$ mix help\nmix deps              # Lists dependencies and their status\nmix deps.clean        # Deletes the given dependencies' files\nmix deps.compile      # Compiles dependencies\nmix deps.get          # Gets all out of date dependencies\nmix deps.tree         # Prints the dependency tree\nmix deps.unlock       # Unlocks the given dependencies\nmix deps.update       # Updates the given dependencies\n```\n\nThe most common tasks are `mix deps.get` and `mix deps.update`. Once fetched, dependencies are automatically compiled for you. You can read more about deps by typing `mix help deps`, and in the documentation for the `Mix.Tasks.Deps` module.","ref":"dependencies-and-umbrella-projects.html#external-dependencies"},{"type":"extras","title":"Internal dependencies - Dependencies and umbrella projects","doc":"Internal dependencies are the ones that are specific to your project. They usually don't make sense outside the scope of your project/company/organization. Most of the time, you want to keep them private, whether due to technical, economic or business reasons.\n\nIf you have an internal dependency, Mix supports two methods to work with them: Git repositories or umbrella projects.\n\nFor example, if you push the `kv` project to a Git repository, you'll need to list it in your deps code in order to use it:\n\n```elixir\ndef deps do\n  [{:kv, git: \"https://github.com/YOUR_ACCOUNT/kv.git\"}]\nend\n```\n\nIf the repository is private though, you may need to specify the private URL `git@github.com:YOUR_ACCOUNT/kv.git`. In any case, Mix will be able to fetch it for you as long as you have the proper credentials.\n\nUsing Git repositories for internal dependencies is somewhat discouraged in Elixir. Remember that the runtime and the Elixir ecosystem already provide the concept of applications. As such, we expect you to frequently break your code into applications that can be organized logically, even within a single project.\n\nHowever, if you push every application as a separate project to a Git repository, your projects may become very hard to maintain as you will spend a lot of time managing those Git repositories rather than writing your code.\n\nFor this reason, Mix supports \"umbrella projects\". Umbrella projects are used to build applications that run together in a single repository. That is exactly the style we are going to explore in the next sections.\n\nLet's create a new Mix project. We are going to creatively name it `kv_umbrella`, and this new project will have both the existing `kv` application and the new `kv_server` application inside. The directory structure will look like this:\n\n    + kv_umbrella\n      + apps\n        + kv\n        + kv_server\n\nThe interesting thing about this approach is that Mix has many conveniences for working with such projects, such as the ability to compile and test all applications inside `apps` with a single command. However, even though they are all listed together inside `apps`, they are still decoupled from each other, so you can build, test and deploy each application in isolation if you want to.\n\nSo let's get started!","ref":"dependencies-and-umbrella-projects.html#internal-dependencies"},{"type":"extras","title":"Umbrella projects - Dependencies and umbrella projects","doc":"Let's start a new project using `mix new`. This new project will be named `kv_umbrella` and we need to pass the `--umbrella` option when creating it. Do not create this new project inside the existing `kv` project!\n\n```console\n$ mix new kv_umbrella --umbrella\n* creating README.md\n* creating .formatter.exs\n* creating .gitignore\n* creating mix.exs\n* creating apps\n* creating config\n* creating config/config.exs\n```\n\nFrom the printed information, we can see far fewer files are generated. The generated `mix.exs` file is different too. Let's take a look (comments have been removed):\n\n```elixir\ndefmodule KvUmbrella.MixProject do\n  use Mix.Project\n\n  def project do\n    [\n      apps_path: \"apps\",\n      start_permanent: Mix.env() == :prod,\n      deps: deps()\n    ]\n  end\n\n  defp deps do\n    []\n  end\nend\n```\n\nWhat makes this project different from the previous one is the `apps_path: \"apps\"` entry in the project definition. This means this project will act as an umbrella. Such projects do not have source files nor tests, although they can have their own dependencies. Each child application must be defined inside the `apps` directory.\n\nLet's move inside the apps directory and start building `kv_server`. This time, we are going to pass the `--sup` flag, which will tell Mix to generate a supervision tree automatically for us, instead of building one manually as we did in previous chapters:\n\n```console\n$ cd kv_umbrella/apps\n$ mix new kv_server --module KVServer --sup\n```\n\nThe generated files are similar to the ones we first generated for `kv`, with a few differences. Let's open up `mix.exs`:\n\n```elixir\ndefmodule KVServer.MixProject do\n  use Mix.Project\n\n  def project do\n    [\n      app: :kv_server,\n      version: \"0.1.0\",\n      build_path: \"../../_build\",\n      config_path: \"../../config/config.exs\",\n      deps_path: \"../../deps\",\n      lockfile: \"../../mix.lock\",\n      elixir: \"~> 1.14\",\n      start_permanent: Mix.env() == :prod,\n      deps: deps()\n    ]\n  end\n\n  # Run \"mix help compile.app\" to learn about applications\n  def application do\n    [\n      extra_applications: [:logger],\n      mod: {KVServer.Application, []}\n    ]\n  end\n\n  # Run \"mix help deps\" to learn about dependencies\n  defp deps do\n    [\n      # {:dep_from_hexpm, \"~> 0.3.0\"},\n      # {:dep_from_git, git: \"https://github.com/elixir-lang/my_dep.git\", tag: \"0.1.0\"},\n      # {:sibling_app_in_umbrella, in_umbrella: true},\n    ]\n  end\nend\n```\n\nFirst of all, since we generated this project inside `kv_umbrella/apps`, Mix automatically detected the umbrella structure and added four lines to the project definition:\n\n```elixir\nbuild_path: \"../../_build\",\nconfig_path: \"../../config/config.exs\",\ndeps_path: \"../../deps\",\nlockfile: \"../../mix.lock\",\n```\n\nThose options mean all dependencies will be checked out to `kv_umbrella/deps`, and they will share the same build, config, and lock files. We haven't talked about configuration yet, but from here we can build the intuition that all configuration and dependencies are shared across all projects in an umbrella, and it is not per application.\n\nThe second change is in the `application` function inside `mix.exs`:\n\n```elixir\ndef application do\n  [\n    extra_applications: [:logger],\n    mod: {KVServer.Application, []}\n  ]\nend\n```\n\nBecause we passed the `--sup` flag, Mix automatically added `mod: {KVServer.Application, []}`, specifying that `KVServer.Application` is our application callback module. `KVServer.Application` will start our application supervision tree.\n\nIn fact, let's open up `lib/kv_server/application.ex`:\n\n```elixir\ndefmodule KVServer.Application do\n  # See https://hexdocs.pm/elixir/Application.html\n  # for more information on OTP Applications\n  @moduledoc false\n\n  use Application\n\n  @impl true\n  def start(_type, _args) do\n    # List all child processes to be supervised\n    children = [\n      # Starts a worker by calling: KVServer.Worker.start_link(arg)\n      # {KVServer.Worker, arg},\n    ]\n\n    # See https://hexdocs.pm/elixir/Supervisor.html\n    # for other strategies and supported options\n    opts = [strategy: :one_for_one, name: KVServer.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\nend\n```\n\nNotice that it defines the application callback function, `start/2`, and instead of defining a supervisor named `KVServer.Supervisor` that uses the `Supervisor` module, it conveniently defined the supervisor inline! You can read more about such supervisors by reading the `Supervisor` module documentation.\n\nWe can already try out our first umbrella child. We could run tests inside the `apps/kv_server` directory, but that wouldn't be much fun. Instead, go to the root of the umbrella project and run `mix test`:\n\n```console\n$ mix test\n```\n\nAnd it works!\n\nSince we want `kv_server` to eventually use the functionality we defined in `kv`, we need to add `kv` as a dependency to our application.","ref":"dependencies-and-umbrella-projects.html#umbrella-projects"},{"type":"extras","title":"Dependencies within an umbrella project - Dependencies and umbrella projects","doc":"Dependencies between applications in an umbrella project must still be explicitly defined and Mix makes it easy to do so. Open up `apps/kv_server/mix.exs` and change the `deps/0` function to the following:\n\n```elixir\ndefp deps do\n  [{:kv, in_umbrella: true}]\nend\n```\n\nThe line above makes `:kv` available as a dependency inside `:kv_server` and automatically starts the `:kv` application before the server starts.\n\nFinally, copy the `kv` application we have built so far to the `apps` directory in our new umbrella project. The final directory structure should match the structure we mentioned earlier:\n\n    + kv_umbrella\n      + apps\n        + kv\n        + kv_server\n\nWe now need to modify `apps/kv/mix.exs` to contain the umbrella entries we have seen in `apps/kv_server/mix.exs`. Open up `apps/kv/mix.exs` and add to the `project/0` function:\n\n```elixir\nbuild_path: \"../../_build\",\nconfig_path: \"../../config/config.exs\",\ndeps_path: \"../../deps\",\nlockfile: \"../../mix.lock\",\n```\n\nNow you can run tests for both projects from the umbrella root with `mix test`. Sweet!","ref":"dependencies-and-umbrella-projects.html#dependencies-within-an-umbrella-project"},{"type":"extras","title":"Don't drink the kool aid - Dependencies and umbrella projects","doc":"Umbrella projects are a convenience to help you organize and manage multiple applications. While it provides a degree of separation between applications, those applications are not fully decoupled, as they share the same configuration and the same dependencies.\n\nThe pattern of keeping multiple applications in the same repository is known as \"mono-repo\". Umbrella projects maximize this pattern by providing conveniences to compile, test and run multiple applications at once.\n\nIf you find yourself in a position where you want to use different configurations in each application for the same dependency or use different dependency versions, then it is likely your codebase has grown beyond what umbrellas can provide.\n\nThe good news is that breaking an umbrella apart is quite straightforward, as you simply need to move applications outside of the umbrella project's `apps/` directory and update the project's mix.exs file to no longer set the `build_path`, `config_path`, `deps_path`, and `lockfile` configuration. You can depend on private projects outside of the umbrella in multiple ways:\n\n  1. Move it to a separate folder within the same repository and point to it using a path dependency (the mono-repo pattern)\n  2. Move the repository to a separate Git repository and depend on it\n  3. Publish the project to a private [Hex.pm](https://hex.pm/) organization","ref":"dependencies-and-umbrella-projects.html#don-t-drink-the-kool-aid"},{"type":"extras","title":"Summing up - Dependencies and umbrella projects","doc":"In this chapter, we have learned more about Mix dependencies and umbrella projects. While we may run `kv` without a server, our `kv_server` depends directly on `kv`. By breaking them into separate applications, we gain more control in how they are developed and tested.\n\nWhen using umbrella applications, it is important to have a clear boundary between them. Our upcoming `kv_server` must only access public APIs defined in `kv`. Think of your umbrella apps as any other dependency or even Elixir itself: you can only access what is public and documented. Reaching into private functionality in your dependencies is a poor practice that will eventually cause your code to break when a new version is up.\n\nUmbrella applications can also be used as a stepping stone for eventually extracting an application from your codebase. For example, imagine a web application that has to send \"push notifications\" to its users. The whole \"push notifications system\" can be developed as a separate application in the umbrella, with its own supervision tree and APIs. If you ever run into a situation where another project needs the push notifications system, the system can be moved to a private repository or [a Hex package](https://hex.pm/).\n\nFinally, keep in mind that applications in an umbrella project all share the same configurations and dependencies. If two applications in your umbrella need to configure the same dependency in drastically different ways or even use different versions, you have probably outgrown the benefits brought by umbrellas. Remember you can break the umbrella and still leverage the benefits behind \"mono-repos\".\n\nWith our umbrella project up and running, it is time to start writing our server.","ref":"dependencies-and-umbrella-projects.html#summing-up"},{"type":"extras","title":"Task and gen_tcp","doc":"# Task and gen_tcp\n\nIn this chapter, we are going to learn how to use [Erlang's `:gen_tcp` module](http://www.erlang.org/doc/man/gen_tcp.html) to serve requests. This provides a great opportunity to explore Elixir's `Task` module. In future chapters, we will expand our server so that it can actually serve the commands.","ref":"task-and-gen-tcp.html"},{"type":"extras","title":"Echo server - Task and gen_tcp","doc":"We will start our TCP server by first implementing an echo server. It will send a response with the text it received in the request. We will slowly improve our server until it is supervised and ready to handle multiple connections.\n\nA TCP server, in broad strokes, performs the following steps:\n\n  1. Listens to a port until the port is available and it gets hold of the socket\n  2. Waits for a client connection on that port and accepts it\n  3. Reads the client request and writes a response back\n\nLet's implement those steps. Move to the `apps/kv_server` application, open up `lib/kv_server.ex`, and add the following functions:\n\n```elixir\ndefmodule KVServer do\n  require Logger\n\n  def accept(port) do\n    # The options below mean:\n    #\n    # 1. `:binary` - receives data as binaries (instead of lists)\n    # 2. `packet: :line` - receives data line by line\n    # 3. `active: false` - blocks on `:gen_tcp.recv/2` until data is available\n    # 4. `reuseaddr: true` - allows us to reuse the address if the listener crashes\n    #\n    {:ok, socket} =\n      :gen_tcp.listen(port, [:binary, packet: :line, active: false, reuseaddr: true])\n    Logger.info(\"Accepting connections on port #{port}\")\n    loop_acceptor(socket)\n  end\n\n  defp loop_acceptor(socket) do\n    {:ok, client} = :gen_tcp.accept(socket)\n    serve(client)\n    loop_acceptor(socket)\n  end\n\n  defp serve(socket) do\n    socket\n    |> read_line()\n    |> write_line(socket)\n\n    serve(socket)\n  end\n\n  defp read_line(socket) do\n    {:ok, data} = :gen_tcp.recv(socket, 0)\n    data\n  end\n\n  defp write_line(line, socket) do\n    :gen_tcp.send(socket, line)\n  end\nend\n```\n\nWe are going to start our server by calling `KVServer.accept(4040)`, where 4040 is the port. The first step in `accept/1` is to listen to the port until the socket becomes available and then call `loop_acceptor/1`. `loop_acceptor/1` is a loop accepting client connections. For each accepted connection, we call `serve/1`.\n\n`serve/1` is another loop that reads a line from the socket and writes those lines back to the socket. Note that the `serve/1` function uses the pipe operator `|>/2` to express this flow of operations. The pipe operator evaluates the left side and passes its result as the first argument to the function on the right side. The example above:\n\n```elixir\nsocket |> read_line() |> write_line(socket)\n```\n\nis equivalent to:\n\n```elixir\nwrite_line(read_line(socket), socket)\n```\n\nThe `read_line/1` implementation receives data from the socket using `:gen_tcp.recv/2` and `write_line/2` writes to the socket using `:gen_tcp.send/2`.\n\nNote that `serve/1` is an infinite loop called sequentially inside `loop_acceptor/1`, so the tail call to `loop_acceptor/1` is never reached and could be avoided. However, as we shall see, we will need to execute `serve/1` in a separate process, so we will need that tail call soon.\n\nThis is pretty much all we need to implement our echo server. Let's give it a try!\n\nStart an IEx session inside the `kv_server` application with `iex -S mix`. Inside IEx, run:\n\n```elixir\niex> KVServer.accept(4040)\n```\n\nThe server is now running, and you will even notice the console is blocked. Let's use [a `telnet` client](https://en.wikipedia.org/wiki/Telnet) to access our server. There are clients available on most operating systems, and their command lines are generally similar:\n\n```console\n$ telnet 127.0.0.1 4040\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nhello\nhello\nis it me\nis it me\nyou are looking for?\nyou are looking for?\n```\n\nType \"hello\", press enter, and you will get \"hello\" back. Excellent!\n\nMy particular telnet client can be exited by typing `ctrl + ]`, typing `quit`, and pressing ` `, but your client may require different steps.\n\nOnce you exit the telnet client, you will likely see an error in the IEx session:\n\n    ** (MatchError) no match of right hand side value: {:error, :closed}\n        (kv_server) lib/kv_server.ex:45: KVServer.read_line/1\n        (kv_server) lib/kv_server.ex:37: KVServer.serve/1\n        (kv_server) lib/kv_server.ex:30: KVServer.loop_acceptor/1\n\nThat's because we were expecting data from `:gen_tcp.recv/2` but the client closed the connection. We need to handle such cases better in future revisions of our server.\n\nFor now, there is a more important bug we need to fix: what happens if our TCP acceptor crashes? Since there is no supervision, the server dies and we won't be able to serve more requests, because it won't be restarted. That's why we must move our server to a supervision tree.","ref":"task-and-gen-tcp.html#echo-server"},{"type":"extras","title":"Tasks - Task and gen_tcp","doc":"We have learned about agents, generic servers, and supervisors. They are all meant to work with multiple messages or manage state. But what do we use when we only need to execute some task and that is it?\n\nThe `Task` module provides this functionality exactly. For example, it has a `Task.start_link/1` function that receives an anonymous function and executes it inside a new process that will be part of a supervision tree.\n\nLet's give it a try. Open up `lib/kv_server/application.ex`, and let's change the supervisor in the `start/2` function to the following:\n\n```elixir\n  def start(_type, _args) do\n    children = [\n      {Task, fn -> KVServer.accept(4040) end}\n    ]\n\n    opts = [strategy: :one_for_one, name: KVServer.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n```\n\nAs usual, we've passed a two-element tuple as a child specification, which in turn will invoke `Task.start_link/1`.\n\nWith this change, we are saying that we want to run `KVServer.accept(4040)` as a task. We are hardcoding the port for now but this could be changed in a few ways, for example, by reading the port out of the system environment when starting the application:\n\n```elixir\nport = String.to_integer(System.get_env(\"PORT\") || \"4040\")\n# ...\n{Task, fn -> KVServer.accept(port) end}\n```\n\nInsert these changes in your code and now you may start your application using the following command `PORT=4321 mix run --no-halt`, notice how we are passing the port as a variable, but still defaults to 4040 if none is given.\n\nNow that the server is part of the supervision tree, it should start automatically when we run the application. Start your server, now passing the port, and once again use the `telnet` client to make sure that everything still works:\n\n```console\n$ telnet 127.0.0.1 4321\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nsay you\nsay you\nsay me\nsay me\n```\n\nYes, it works! However, does it *scale*?\n\nTry to connect two telnet clients at the same time. When you do so, you will notice that the second client doesn't echo:\n\n```console\n$ telnet 127.0.0.1 4321\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nhello\nhello?\nHELLOOOOOO?\n```\n\nIt doesn't seem to work at all. That's because we are serving requests in the same process that are accepting connections. When one client is connected, we can't accept another client.","ref":"task-and-gen-tcp.html#tasks"},{"type":"extras","title":"Task supervisor - Task and gen_tcp","doc":"In order to make our server handle simultaneous connections, we need to have one process working as an acceptor that spawns other processes to serve requests. One solution would be to change:\n\n```elixir\ndefp loop_acceptor(socket) do\n  {:ok, client} = :gen_tcp.accept(socket)\n  serve(client)\n  loop_acceptor(socket)\nend\n```\n\nto also use `Task.start_link/1`:\n\n```elixir\ndefp loop_acceptor(socket) do\n  {:ok, client} = :gen_tcp.accept(socket)\n  Task.start_link(fn -> serve(client) end)\n  loop_acceptor(socket)\nend\n```\n\nWe are starting a linked Task directly from the acceptor process. But we've already made this mistake once. Do you remember?\n\nThis is similar to the mistake we made when we called `KV.Bucket.start_link/1` straight from the registry. That meant a failure in any bucket would bring the whole registry down.\n\nThe code above would have the same flaw: if we link the `serve(client)` task to the acceptor, a crash when serving a request would bring the acceptor, and consequently all other connections, down.\n\nWe fixed the issue for the registry by using a simple one for one supervisor. We are going to use the same tactic here, except that this pattern is so common with tasks that `Task` already comes with a solution: a simple one for one supervisor that starts temporary tasks as part of our supervision tree.\n\nLet's change `start/2` once again, to add a supervisor to our tree:\n\n```elixir\n  def start(_type, _args) do\n    port = String.to_integer(System.get_env(\"PORT\") || \"4040\")\n\n    children = [\n      {Task.Supervisor, name: KVServer.TaskSupervisor},\n      {Task, fn -> KVServer.accept(port) end}\n    ]\n\n    opts = [strategy: :one_for_one, name: KVServer.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n```\n\nWe'll now start a `Task.Supervisor` process with name `KVServer.TaskSupervisor`. Remember, since the acceptor task depends on this supervisor, the supervisor must be started first.\n\nNow we need to change `loop_acceptor/1` to use `Task.Supervisor` to serve each request:\n\n```elixir\ndefp loop_acceptor(socket) do\n  {:ok, client} = :gen_tcp.accept(socket)\n  {:ok, pid} = Task.Supervisor.start_child(KVServer.TaskSupervisor, fn -> serve(client) end)\n  :ok = :gen_tcp.controlling_process(client, pid)\n  loop_acceptor(socket)\nend\n```\n\nYou might notice that we added a line, `:ok = :gen_tcp.controlling_process(client, pid)`. This makes the child process the \"controlling process\" of the `client` socket. If we didn't do this, the acceptor would bring down all the clients if it crashed because sockets would be tied to the process that accepted them (which is the default behavior).\n\nStart a new server with `PORT=4040 mix run --no-halt` and we can now open up many concurrent telnet clients. You will also notice that quitting a client does not bring the acceptor down. Excellent!\n\nHere is the full echo server implementation:\n\n```elixir\ndefmodule KVServer do\n  require Logger\n\n  @doc \"\"\"\n  Starts accepting connections on the given `port`.\n  \"\"\"\n  def accept(port) do\n    {:ok, socket} = :gen_tcp.listen(port,\n                      [:binary, packet: :line, active: false, reuseaddr: true])\n    Logger.info \"Accepting connections on port #{port}\"\n    loop_acceptor(socket)\n  end\n\n  defp loop_acceptor(socket) do\n    {:ok, client} = :gen_tcp.accept(socket)\n    {:ok, pid} = Task.Supervisor.start_child(KVServer.TaskSupervisor, fn -> serve(client) end)\n    :ok = :gen_tcp.controlling_process(client, pid)\n    loop_acceptor(socket)\n  end\n\n  defp serve(socket) do\n    socket\n    |> read_line()\n    |> write_line(socket)\n\n    serve(socket)\n  end\n\n  defp read_line(socket) do\n    {:ok, data} = :gen_tcp.recv(socket, 0)\n    data\n  end\n\n  defp write_line(line, socket) do\n    :gen_tcp.send(socket, line)\n  end\nend\n```\n\nSince we have changed the supervisor specification, we need to ask: is our supervision strategy still correct?\n\nIn this case, the answer is yes: if the acceptor crashes, there is no need to crash the existing connections. On the other hand, if the task supervisor crashes, there is no need to crash the acceptor too.\n\nHowever, there is still one concern left, which are the restart strategies. Tasks, by default, have the `:restart` value set to `:temporary`, which means they are not restarted. This is an excellent default for the connections started via the `Task.Supervisor`, as it makes no sense to restart a failed connection, but it is a bad choice for the acceptor. If the acceptor crashes, we want to bring the acceptor up and running again.\n\nLet's fix this. We know that for a child of shape `{Task, fun}`, Elixir will invoke `Task.child_spec(fun)` to retrieve the underlying child specification. Therefore, one might imagine that to change the `{Task, fun}` specification to have a `:restart` of `:permanent`, we would need to change the `Task` module. However, that's impossible to do, as the `Task` module is defined as part of Elixir's standard library (and even if it was possible, it is unlikely it would be a good idea).\nLuckily, this can be done by using `Supervisor.child_spec/2`, which allows us to configure a child specification with new values. Let's rewrite `start/2` in `KVServer.Application` once more:\n\n```elixir\n  def start(_type, _args) do\n    port = String.to_integer(System.get_env(\"PORT\") || \"4040\")\n\n    children = [\n      {Task.Supervisor, name: KVServer.TaskSupervisor},\n      Supervisor.child_spec({Task, fn -> KVServer.accept(port) end}, restart: :permanent)\n    ]\n\n    opts = [strategy: :one_for_one, name: KVServer.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n```\n\nNow we have an always running acceptor that starts temporary task processes under an always running task supervisor.\n\nIn the next chapter, we will start parsing the client requests and sending responses, finishing our server.","ref":"task-and-gen-tcp.html#task-supervisor"},{"type":"extras","title":"Doctests, patterns, and with","doc":"# Doctests, patterns, and with\n\nIn this chapter, we will implement the code that parses the commands we described in the first chapter:\n\n```text\nCREATE shopping\nOK\n\nPUT shopping milk 1\nOK\n\nPUT shopping eggs 3\nOK\n\nGET shopping milk\n1\nOK\n\nDELETE shopping eggs\nOK\n```\n\nAfter the parsing is done, we will update our server to dispatch the parsed commands to the `:kv` application we built previously.","ref":"docs-tests-and-with.html"},{"type":"extras","title":"Doctests - Doctests, patterns, and with","doc":"On the language homepage, we mention that Elixir makes documentation a first-class citizen in the language. We have explored this concept many times throughout this guide, be it via `mix help` or by typing `h Enum` or another module in an IEx console.\n\nIn this section, we will implement the parsing functionality, document it and make sure our documentation is up to date with doctests. This helps us provide documentation with accurate code samples.\n\nLet's create our command parser at `lib/kv_server/command.ex` and start with the doctest:\n\n```elixir\ndefmodule KVServer.Command do\n  @doc ~S\"\"\"\n  Parses the given `line` into a command.","ref":"docs-tests-and-with.html#doctests"},{"type":"extras","title":"Examples - Doctests, patterns, and with","doc":"iex> KVServer.Command.parse(\"CREATE shopping\\r\\n\")\n      {:ok, {:create, \"shopping\"}}\n\n  \"\"\"\n  def parse(_line) do\n    :not_implemented\n  end\nend\n```\n\nDoctests are specified by an indentation of four spaces followed by the `iex>` prompt in a documentation string. If a command spans multiple lines, you can use `...>`, as in IEx. The expected result should start at the next line after `iex>` or `...>` line(s) and is terminated either by a newline or a new `iex>` prefix.\n\nAlso, note that we started the documentation string using `@doc ~S\"\"\"`. The `~S` prevents the `\\r\\n` characters from being converted to a carriage return and line feed until they are evaluated in the test.\n\nTo run our doctests, we'll create a file at `test/kv_server/command_test.exs` and call `doctest KVServer.Command` in the test case:\n\n```elixir\ndefmodule KVServer.CommandTest do\n  use ExUnit.Case, async: true\n  doctest KVServer.Command\nend\n```\n\nRun the test suite and the doctest should fail:\n\n```text\n  1) doctest KVServer.Command.parse/1 (1) (KVServer.CommandTest)\n     test/kv_server/command_test.exs:3\n     Doctest failed\n     doctest:\n       iex> KVServer.Command.parse(\"CREATE shopping\\r\\n\")\n       {:ok, {:create, \"shopping\"}}\n     code: KVServer.Command.parse \"CREATE shopping\\r\\n\" === {:ok, {:create, \"shopping\"}}\n     left:  :not_implemented\n     right: {:ok, {:create, \"shopping\"}}\n     stacktrace:\n       lib/kv_server/command.ex:7: KVServer.Command (module)\n```\n\nExcellent!\n\nNow let's make the doctest pass. Let's implement the `parse/1` function:\n\n```elixir\ndef parse(line) do\n  case String.split(line) do\n    [\"CREATE\", bucket] -> {:ok, {:create, bucket}}\n  end\nend\n```\n\nOur implementation splits the line on whitespace and then matches the command against a list. Using `String.split/1` means our commands will be whitespace-insensitive. Leading and trailing whitespace won't matter, nor will consecutive spaces between words. Let's add some new doctests to test this behavior along with the other commands:\n\n```elixir\n@doc ~S\"\"\"\nParses the given `line` into a command.","ref":"docs-tests-and-with.html#examples"},{"type":"extras","title":"Examples - Doctests, patterns, and with","doc":"iex> KVServer.Command.parse \"CREATE shopping\\r\\n\"\n    {:ok, {:create, \"shopping\"}}\n\n    iex> KVServer.Command.parse \"CREATE  shopping  \\r\\n\"\n    {:ok, {:create, \"shopping\"}}\n\n    iex> KVServer.Command.parse \"PUT shopping milk 1\\r\\n\"\n    {:ok, {:put, \"shopping\", \"milk\", \"1\"}}\n\n    iex> KVServer.Command.parse \"GET shopping milk\\r\\n\"\n    {:ok, {:get, \"shopping\", \"milk\"}}\n\n    iex> KVServer.Command.parse \"DELETE shopping eggs\\r\\n\"\n    {:ok, {:delete, \"shopping\", \"eggs\"}}\n\nUnknown commands or commands with the wrong number of\narguments return an error:\n\n    iex> KVServer.Command.parse \"UNKNOWN shopping eggs\\r\\n\"\n    {:error, :unknown_command}\n\n    iex> KVServer.Command.parse \"GET shopping\\r\\n\"\n    {:error, :unknown_command}\n\n\"\"\"\n```\n\nWith doctests at hand, it is your turn to make tests pass! Once you're ready, you can compare your work with our solution below:\n\n```elixir\ndef parse(line) do\n  case String.split(line) do\n    [\"CREATE\", bucket] -> {:ok, {:create, bucket}}\n    [\"GET\", bucket, key] -> {:ok, {:get, bucket, key}}\n    [\"PUT\", bucket, key, value] -> {:ok, {:put, bucket, key, value}}\n    [\"DELETE\", bucket, key] -> {:ok, {:delete, bucket, key}}\n    _ -> {:error, :unknown_command}\n  end\nend\n```\n\nNotice how we were able to elegantly parse the commands without adding a bunch of `if/else` clauses that check the command name and number of arguments!\n\nFinally, you may have observed that each doctest corresponds to a different test in our suite, which now reports a total of 7 doctests. That is because ExUnit considers the following to define two different doctests:\n\n```elixir\niex> KVServer.Command.parse(\"UNKNOWN shopping eggs\\r\\n\")\n{:error, :unknown_command}\n\niex> KVServer.Command.parse(\"GET shopping\\r\\n\")\n{:error, :unknown_command}\n```\n\nWithout new lines, as seen below, ExUnit compiles it into a single doctest:\n\n```elixir\niex> KVServer.Command.parse(\"UNKNOWN shopping eggs\\r\\n\")\n{:error, :unknown_command}\niex> KVServer.Command.parse(\"GET shopping\\r\\n\")\n{:error, :unknown_command}\n```\n\nAs the name says, doctest is documentation first and a test later. Their goal is not to replace tests but to provide up-to-date documentation. You can read more about doctests in the `ExUnit.DocTest` documentation.\n\n## `with`\n\nAs we are now able to parse commands, we can finally start implementing the logic that runs the commands. Let's add a stub definition for this function for now:\n\n```elixir\ndefmodule KVServer.Command do\n  @doc \"\"\"\n  Runs the given command.\n  \"\"\"\n  def run(command) do\n    {:ok, \"OK\\r\\n\"}\n  end\nend\n```\n\nBefore we implement this function, let's change our server to start using our new `parse/1` and `run/1` functions. Remember, our `read_line/1` function was also crashing when the client closed the socket, so let's take the opportunity to fix it, too. Open up `lib/kv_server.ex` and replace the existing server definition:\n\n```elixir\ndefp serve(socket) do\n  socket\n  |> read_line()\n  |> write_line(socket)\n\n  serve(socket)\nend\n\ndefp read_line(socket) do\n  {:ok, data} = :gen_tcp.recv(socket, 0)\n  data\nend\n\ndefp write_line(line, socket) do\n  :gen_tcp.send(socket, line)\nend\n```\n\nby the following:\n\n```elixir\ndefp serve(socket) do\n  msg =\n    case read_line(socket) do\n      {:ok, data} ->\n        case KVServer.Command.parse(data) do\n          {:ok, command} ->\n            KVServer.Command.run(command)\n          {:error, _} = err ->\n            err\n        end\n      {:error, _} = err ->\n        err\n    end\n\n  write_line(socket, msg)\n  serve(socket)\nend\n\ndefp read_line(socket) do\n  :gen_tcp.recv(socket, 0)\nend\n\ndefp write_line(socket, {:ok, text}) do\n  :gen_tcp.send(socket, text)\nend\n\ndefp write_line(socket, {:error, :unknown_command}) do\n  # Known error; write to the client\n  :gen_tcp.send(socket, \"UNKNOWN COMMAND\\r\\n\")\nend\n\ndefp write_line(_socket, {:error, :closed}) do\n  # The connection was closed, exit politely\n  exit(:shutdown)\nend\n\ndefp write_line(socket, {:error, error}) do\n  # Unknown error; write to the client and exit\n  :gen_tcp.send(socket, \"ERROR\\r\\n\")\n  exit(error)\nend\n```\n\nIf we start our server, we can now send commands to it. For now, we will get two different responses: \"OK\" when the command is known and \"UNKNOWN COMMAND\" otherwise:\n\n```console\n$ telnet 127.0.0.1 4040\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nCREATE shopping\nOK\nHELLO\nUNKNOWN COMMAND\n```\n\nThis means our implementation is going in the correct direction, but it doesn't look very elegant, does it?\n\nThe previous implementation used pipelines which made the logic straightforward to follow. However, now that we need to handle different error codes along the way, our server logic is nested inside many `case` calls.\n\nThankfully, Elixir v1.2 introduced the `with` construct, which allows you to simplify code like the above, replacing nested `case` calls with a chain of matching clauses. Let's rewrite the `serve/1` function to use `with`:\n\n```elixir\ndefp serve(socket) do\n  msg =\n    with {:ok, data} <- read_line(socket),\n         {:ok, command} <- KVServer.Command.parse(data),\n         do: KVServer.Command.run(command)\n\n  write_line(socket, msg)\n  serve(socket)\nend\n```\n\nMuch better! `with` will retrieve the value returned by the right-side of `<-` and match it against the pattern on the left side. If the value matches the pattern, `with` moves on to the next expression. In case there is no match, the non-matching value is returned.\n\nIn other words, we converted each expression given to `case/2` as a step in `with`. As soon as any of the steps return something that does not match `{:ok, x}`, `with` aborts, and returns the non-matching value.\n\nYou can read more about `with/1` in our documentation.","ref":"docs-tests-and-with.html#examples"},{"type":"extras","title":"Running commands - Doctests, patterns, and with","doc":"The last step is to implement `KVServer.Command.run/1`, to run the parsed commands against the `:kv` application. Its implementation is shown below:\n\n```elixir\n@doc \"\"\"\nRuns the given command.\n\"\"\"\ndef run(command)\n\ndef run({:create, bucket}) do\n  KV.Registry.create(KV.Registry, bucket)\n  {:ok, \"OK\\r\\n\"}\nend\n\ndef run({:get, bucket, key}) do\n  lookup(bucket, fn pid ->\n    value = KV.Bucket.get(pid, key)\n    {:ok, \"#{value}\\r\\nOK\\r\\n\"}\n  end)\nend\n\ndef run({:put, bucket, key, value}) do\n  lookup(bucket, fn pid ->\n    KV.Bucket.put(pid, key, value)\n    {:ok, \"OK\\r\\n\"}\n  end)\nend\n\ndef run({:delete, bucket, key}) do\n  lookup(bucket, fn pid ->\n    KV.Bucket.delete(pid, key)\n    {:ok, \"OK\\r\\n\"}\n  end)\nend\n\ndefp lookup(bucket, callback) do\n  case KV.Registry.lookup(KV.Registry, bucket) do\n    {:ok, pid} -> callback.(pid)\n    :error -> {:error, :not_found}\n  end\nend\n```\n\nEvery function clause dispatches the appropriate command to the `KV.Registry` server that we registered during the `:kv` application startup. Since our `:kv_server` depends on the `:kv` application, it is completely fine to depend on the services it provides.\n\nYou might have noticed we have a function head, `def run(command)`, without a body. In the [Modules and Functions](../getting-started/modules-and-functions.md#default-arguments) chapter, we learned that a bodiless function can be used to declare default arguments for a multi-clause function. Here is another use case where we use a function without a body to document what the arguments are.\n\nNote that we have also defined a private function named `lookup/2` to help with the common functionality of looking up a bucket and returning its `pid` if it exists, `{:error, :not_found}` otherwise.\n\nBy the way, since we are now returning `{:error, :not_found}`, we should amend the `write_line/2` function in `KVServer` to print such error as well:\n\n```elixir\ndefp write_line(socket, {:error, :not_found}) do\n  :gen_tcp.send(socket, \"NOT FOUND\\r\\n\")\nend\n```\n\nOur server functionality is almost complete. Only tests are missing. This time, we have left tests for last because there are some important considerations to be made.\n\n`KVServer.Command.run/1`'s implementation is sending commands directly to the server named `KV.Registry`, which is registered by the `:kv` application. This means this server is global and if we have two tests sending messages to it at the same time, our tests will conflict with each other (and likely fail). We need to decide between having unit tests that are isolated and can run asynchronously, or writing integration tests that work on top of the global state, but exercise our application's full stack as it is meant to be exercised in production.\n\nSo far we have only written unit tests, typically testing a single module directly. However, in order to make `KVServer.Command.run/1` testable as a unit we would need to change its implementation to not send commands directly to the `KV.Registry` process but instead pass a server as an argument. For example, we would need to change `run`'s signature to `def run(command, pid)` and then change all clauses accordingly:\n\n```elixir\ndef run({:create, bucket}, pid) do\n  KV.Registry.create(pid, bucket)\n  {:ok, \"OK\\r\\n\"}\nend\n\n# ... other run clauses ...\n```\n\nFeel free to go ahead and do the changes above and write some unit tests. The idea is that your tests will start an instance of the `KV.Registry` and pass it as an argument to `run/2` instead of relying on the global `KV.Registry`. This has the advantage of keeping our tests asynchronous as there is no shared state.\n\nBut let's also try something different. Let's write integration tests that rely on the global server names to exercise the whole stack from the TCP server to the bucket. Our integration tests will rely on global state and must be synchronous. With integration tests, we get coverage on how the components in our application work together at the cost of test performance. They are typically used to test the main flows in your application. For example, we should avoid using integration tests to test an edge case in our command parsing implementation.\n\nOur integration test will use a TCP client that sends commands to our server and assert we are getting the desired responses.\n\nLet's implement the integration test in `test/kv_server_test.exs` as shown below:\n\n```elixir\ndefmodule KVServerTest do\n  use ExUnit.Case\n\n  setup do\n    Application.stop(:kv)\n    :ok = Application.start(:kv)\n  end\n\n  setup do\n    opts = [:binary, packet: :line, active: false]\n    {:ok, socket} = :gen_tcp.connect('localhost', 4040, opts)\n    %{socket: socket}\n  end\n\n  test \"server interaction\", %{socket: socket} do\n    assert send_and_recv(socket, \"UNKNOWN shopping\\r\\n\") ==\n           \"UNKNOWN COMMAND\\r\\n\"\n\n    assert send_and_recv(socket, \"GET shopping eggs\\r\\n\") ==\n           \"NOT FOUND\\r\\n\"\n\n    assert send_and_recv(socket, \"CREATE shopping\\r\\n\") ==\n           \"OK\\r\\n\"\n\n    assert send_and_recv(socket, \"PUT shopping eggs 3\\r\\n\") ==\n           \"OK\\r\\n\"\n\n    # GET returns two lines\n    assert send_and_recv(socket, \"GET shopping eggs\\r\\n\") == \"3\\r\\n\"\n    assert send_and_recv(socket, \"\") == \"OK\\r\\n\"\n\n    assert send_and_recv(socket, \"DELETE shopping eggs\\r\\n\") ==\n           \"OK\\r\\n\"\n\n    # GET returns two lines\n    assert send_and_recv(socket, \"GET shopping eggs\\r\\n\") == \"\\r\\n\"\n    assert send_and_recv(socket, \"\") == \"OK\\r\\n\"\n  end\n\n  defp send_and_recv(socket, command) do\n    :ok = :gen_tcp.send(socket, command)\n    {:ok, data} = :gen_tcp.recv(socket, 0, 1000)\n    data\n  end\nend\n```\n\nOur integration test checks all server interaction, including unknown commands and not found errors. It is worth noting that, as with ETS tables and linked processes, there is no need to close the socket. Once the test process exits, the socket is automatically closed.\n\nThis time, since our test relies on global data, we have not given `async: true` to `use ExUnit.Case`. Furthermore, in order to guarantee our test is always in a clean state, we stop and start the `:kv` application before each test. In fact, stopping the `:kv` application even prints a warning on the terminal:\n\n```text\n18:12:10.698 [info] Application kv exited: :stopped\n```\n\nTo avoid printing log messages during tests, ExUnit provides a neat feature called `:capture_log`. By setting `@tag :capture_log` before each test or `@moduletag :capture_log` for the whole test module, ExUnit will automatically capture anything that is logged while the test runs. In case our test fails, the captured logs will be printed alongside the ExUnit report.\n\nBetween `use ExUnit.Case` and `setup`, add the following call:\n\n```elixir\n@moduletag :capture_log\n```\n\nIn case the test crashes, you will see a report as follows:\n\n```text\n  1) test server interaction (KVServerTest)\n     test/kv_server_test.exs:17\n     ** (RuntimeError) oops\n     stacktrace:\n       test/kv_server_test.exs:29\n\n     The following output was logged:\n\n     13:44:10.035 [notice] Application kv exited: :stopped\n```\n\nWith this simple integration test, we start to see why integration tests may be slow. Not only can this test not run asynchronously, but it also requires the expensive setup of stopping and starting the `:kv` application.\n\nAt the end of the day, it is up to you and your team to figure out the best testing strategy for your applications. You need to balance code quality, confidence, and test suite runtime. For example, we may start with testing the server only with integration tests, but if the server continues to grow in future releases, or it becomes a part of the application with frequent bugs, it is important to consider breaking it apart and writing more intensive unit tests that don't have the weight of an integration test.\n\nLet's move to the next chapter. We will finally make our system distributed by adding a bucket routing mechanism. We will use this opportunity to also improve our testing chops.","ref":"docs-tests-and-with.html#running-commands"},{"type":"extras","title":"Distributed tasks and tags","doc":"# Distributed tasks and tags\n\nIn this chapter, we will go back to the `:kv` application and add a routing layer that will allow us to distribute requests between nodes based on the bucket name.\n\nThe routing layer will receive a routing table of the following format:\n\n```elixir\n[\n  {?a..?m, :\"foo@computer-name\"},\n  {?n..?z, :\"bar@computer-name\"}\n]\n```\n\nThe router will check the first byte of the bucket name against the table and dispatch to the appropriate node based on that. For example, a bucket starting with the letter \"a\" (`?a` represents the Unicode codepoint of the letter \"a\") will be dispatched to node `foo@computer-name`.\n\nIf the matching entry points to the node evaluating the request, then we've finished routing, and this node will perform the requested operation. If the matching entry points to a different node, we'll pass the request to said node, which will look at its own routing table (which may be different from the one in the first node) and act accordingly. If no entry matches, an error will be raised.\n\n> Note: we will be using two nodes in the same machine throughout this chapter. You are free to use two (or more) different machines on the same network but you need to do some prep work. First of all, you need to ensure all machines have a `~/.erlang.cookie` file with exactly the same value. Then you need to guarantee [epmd](http://www.erlang.org/doc/man/epmd.html) is running on a port that is not blocked (you can run `epmd -d` for debug info).","ref":"distributed-tasks.html"},{"type":"extras","title":"Our first distributed code - Distributed tasks and tags","doc":"Elixir ships with facilities to connect nodes and exchange information between them. In fact, we use the same concepts of processes, message passing and receiving messages when working in a distributed environment because Elixir processes are *location transparent*. This means that when sending a message, it doesn't matter if the recipient process is on the same node or on another node, the VM will be able to deliver the message in both cases.\n\nIn order to run distributed code, we need to start the VM with a name. The name can be short (when in the same network) or long (requires the full computer address). Let's start a new IEx session:\n\n```console\n$ iex --sname foo\n```\n\nYou can see now the prompt is slightly different and shows the node name followed by the computer name:\n\n    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n    iex(foo@jv)1>\n\nMy computer is named `jv`, so I see `foo@jv` in the example above, but you will get a different result. We will use `foo@computer-name` in the following examples and you should update them accordingly when trying out the code.\n\nLet's define a module named `Hello` in this shell:\n\n```elixir\niex> defmodule Hello do\n...>   def world, do: IO.puts \"hello world\"\n...> end\n```\n\nIf you have another computer on the same network with both Erlang and Elixir installed, you can start another shell on it. If you don't, you can start another IEx session in another terminal. In either case, give it the short name of `bar`:\n\n```console\n$ iex --sname bar\n```\n\nNote that inside this new IEx session, we cannot access `Hello.world/0`:\n\n```elixir\niex> Hello.world\n** (UndefinedFunctionError) function Hello.world/0 is undefined (module Hello is not available)\n    Hello.world()\n```\n\nHowever, we can spawn a new process on `foo@computer-name` from `bar@computer-name`! Let's give it a try (where `@computer-name` is the one you see locally):\n\n```elixir\niex> Node.spawn_link(:\"foo@computer-name\", fn -> Hello.world() end)\n#PID<9014.59.0>\nhello world\n```\n\nElixir spawned a process on another node and returned its PID. The code then executed on the other node where the `Hello.world/0` function exists and invoked that function. Note that the result of \"hello world\" was printed on the current node `bar` and not on `foo`. In other words, the message to be printed was sent back from `foo` to `bar`. This happens because the process spawned on the other node (`foo`) knows all the output should be sent back to the original node!\n\nWe can send and receive messages from the PID returned by `Node.spawn_link/2` as usual. Let's try a quick ping-pong example:\n\n```elixir\niex> pid = Node.spawn_link(:\"foo@computer-name\", fn ->\n...>   receive do\n...>     {:ping, client} -> send(client, :pong)\n...>   end\n...> end)\n#PID<9014.59.0>\niex> send(pid, {:ping, self()})\n{:ping, #PID<0.73.0>}\niex> flush()\n:pong\n:ok\n```\n\nFrom our quick exploration, we could conclude that we should use `Node.spawn_link/2` to spawn processes on a remote node every time we need to do a distributed computation. However, we have learned throughout this guide that spawning processes outside of supervision trees should be avoided if possible, so we need to look for other options.\n\nThere are three better alternatives to `Node.spawn_link/2` that we could use in our implementation:\n\n1. We could use Erlang's [:erpc](http://www.erlang.org/doc/man/erpc.html) module to execute functions on a remote node. Inside the `bar@computer-name` shell above, you can call `:erpc.call(:\"foo@computer-name\", Hello, :world, [])` and it will print \"hello world\"\n\n2. We could have a server running on the other node and send requests to that node via the `GenServer` API. For example, you can call a server on a remote node by using `GenServer.call({name, node}, arg)` or passing the remote process PID as the first argument\n\n3. We could use [tasks](`Task`), which we have learned about in [a previous chapter](task-and-gen-tcp.md), as they can be spawned on both local and remote nodes\n\nThe options above have different properties. The GenServer would serialize your requests on a single server, while tasks are effectively running asynchronously on the remote node, with the only serialization point being the spawning done by the supervisor.\n\nFor our routing layer, we are going to use tasks, but feel free to explore the other alternatives too.","ref":"distributed-tasks.html#our-first-distributed-code"},{"type":"extras","title":"async/await - Distributed tasks and tags","doc":"So far we have explored tasks that are started and run in isolation, without regard to their return value. However, sometimes it is useful to run a task to compute a value and read its result later on. For this, tasks also provide the `async/await` pattern:\n\n```elixir\ntask = Task.async(fn -> compute_something_expensive() end)\nres  = compute_something_else()\nres + Task.await(task)\n```\n\n`async/await` provides a very simple mechanism to compute values concurrently. Not only that, `async/await` can also be used with the same `Task.Supervisor` we have used in previous chapters. We just need to call `Task.Supervisor.async/2` instead of `Task.Supervisor.start_child/2` and use `Task.await/2` to read the result later on.","ref":"distributed-tasks.html#async-await"},{"type":"extras","title":"Distributed tasks - Distributed tasks and tags","doc":"Distributed tasks are exactly the same as supervised tasks. The only difference is that we pass the node name when spawning the task on the supervisor. Open up `lib/kv/supervisor.ex` from the `:kv` application. Let's add a task supervisor as the last child of the tree:\n\n```elixir\n{Task.Supervisor, name: KV.RouterTasks},\n```\n\nNow, let's start two named nodes again, but inside the `:kv` application:\n\n```console\n$ iex --sname foo -S mix\n$ iex --sname bar -S mix\n```\n\nFrom inside `bar@computer-name`, we can now spawn a task directly on the other node via the supervisor:\n\n```elixir\niex> task = Task.Supervisor.async({KV.RouterTasks, :\"foo@computer-name\"}, fn ->\n...>   {:ok, node()}\n...> end)\n%Task{\n  mfa: {:erlang, :apply, 2},\n  owner: #PID<0.122.0>,\n  pid: #PID<12467.88.0>,\n  ref: #Reference<0.0.0.400>\n}\niex> Task.await(task)\n{:ok, :\"foo@computer-name\"}\n```\n\nOur first distributed task retrieves the name of the node the task is running on. Notice we have given an anonymous function to `Task.Supervisor.async/2` but, in distributed cases, it is preferable to give the module, function, and arguments explicitly:\n\n```elixir\niex> task = Task.Supervisor.async({KV.RouterTasks, :\"foo@computer-name\"}, Kernel, :node, [])\n%Task{\n  mfa: {Kernel, :node, 0},\n  owner: #PID<0.122.0>,\n  pid: #PID<12467.89.0>,\n  ref: #Reference<0.0.0.404>\n}\niex> Task.await(task)\n:\"foo@computer-name\"\n```\n\nThe difference is that anonymous functions require the target node to have exactly the same code version as the caller. Using module, function, and arguments is more robust because you only need to find a function with matching arity in the given module.\n\nWith this knowledge in hand, let's finally write the routing code.","ref":"distributed-tasks.html#distributed-tasks"},{"type":"extras","title":"Routing layer - Distributed tasks and tags","doc":"Create a file at `lib/kv/router.ex` with the following contents:\n\n```elixir\ndefmodule KV.Router do\n  @doc \"\"\"\n  Dispatch the given `mod`, `fun`, `args` request\n  to the appropriate node based on the `bucket`.\n  \"\"\"\n  def route(bucket, mod, fun, args) do\n    # Get the first byte of the binary\n    first = :binary.first(bucket)\n\n    # Try to find an entry in the table() or raise\n    entry =\n      Enum.find(table(), fn {enum, _node} ->\n        first in enum\n      end) || no_entry_error(bucket)\n\n    # If the entry node is the current node\n    if elem(entry, 1) == node() do\n      apply(mod, fun, args)\n    else\n      {KV.RouterTasks, elem(entry, 1)}\n      |> Task.Supervisor.async(KV.Router, :route, [bucket, mod, fun, args])\n      |> Task.await()\n    end\n  end\n\n  defp no_entry_error(bucket) do\n    raise \"could not find entry for #{inspect bucket} in table #{inspect table()}\"\n  end\n\n  @doc \"\"\"\n  The routing table.\n  \"\"\"\n  def table do\n    # Replace computer-name with your local machine name\n    [{?a..?m, :\"foo@computer-name\"}, {?n..?z, :\"bar@computer-name\"}]\n  end\nend\n```\n\nLet's write a test to verify our router works. Create a file named `test/kv/router_test.exs` containing:\n\n```elixir\ndefmodule KV.RouterTest do\n  use ExUnit.Case, async: true\n\n  test \"route requests across nodes\" do\n    assert KV.Router.route(\"hello\", Kernel, :node, []) ==\n             :\"foo@computer-name\"\n    assert KV.Router.route(\"world\", Kernel, :node, []) ==\n             :\"bar@computer-name\"\n  end\n\n  test \"raises on unknown entries\" do\n    assert_raise RuntimeError, ~r/could not find entry/, fn ->\n      KV.Router.route(<<0>>, Kernel, :node, [])\n    end\n  end\nend\n```\n\nThe first test invokes `Kernel.node/0`, which returns the name of the current node, based on the bucket names \"hello\" and \"world\". According to our routing table so far, we should get `foo@computer-name` and `bar@computer-name` as responses, respectively.\n\nThe second test checks that the code raises for unknown entries.\n\nIn order to run the first test, we need to have two nodes running. Move into `apps/kv` and let's restart the node named `bar` which is going to be used by tests.\n\n```console\n$ iex --sname bar -S mix\n```\n\nAnd now run tests with:\n\n```console\n$ elixir --sname foo -S mix test\n```\n\nThe test should pass.","ref":"distributed-tasks.html#routing-layer"},{"type":"extras","title":"Test filters and tags - Distributed tasks and tags","doc":"Although our tests pass, our testing structure is getting more complex. In particular, running tests with only `mix test` causes failures in our suite, since our test requires a connection to another node.\n\nLuckily, ExUnit ships with a facility to tag tests, allowing us to run specific callbacks or even filter tests altogether based on those tags. We have already used the `:capture_log` tag in the previous chapter, which has its semantics specified by ExUnit itself.\n\nThis time let's add a `:distributed` tag to `test/kv/router_test.exs`:\n\n```elixir\n@tag :distributed\ntest \"route requests across nodes\" do\n```\n\nWriting `@tag :distributed` is equivalent to writing `@tag distributed: true`.\n\nWith the test properly tagged, we can now check if the node is alive on the network and, if not, we can exclude all distributed tests. Open up `test/test_helper.exs` inside the `:kv` application and add the following:\n\n```elixir\nexclude =\n  if Node.alive?(), do: [], else: [distributed: true]\n\nExUnit.start(exclude: exclude)\n```\n\nNow run tests with `mix test`:\n\n```console\n$ mix test\nExcluding tags: [distributed: true]\n\n.......\n\nFinished in 0.05 seconds\n9 tests, 0 failures, 1 excluded\n```\n\nThis time all tests passed and ExUnit warned us that distributed tests were being excluded. If you run tests with `$ elixir --sname foo -S mix test`, one extra test should run and successfully pass as long as the `bar@computer-name` node is available.\n\nThe `mix test` command also allows us to dynamically include and exclude tags. For example, we can run `$ mix test --include distributed` to run distributed tests regardless of the value set in `test/test_helper.exs`. We could also pass `--exclude` to exclude a particular tag from the command line. Finally, `--only` can be used to run only tests with a particular tag:\n\n```console\n$ elixir --sname foo -S mix test --only distributed\n```\n\nYou can read more about filters, tags, and the default tags in the `ExUnit.Case` module documentation.","ref":"distributed-tasks.html#test-filters-and-tags"},{"type":"extras","title":"Wiring it all up - Distributed tasks and tags","doc":"Now with our routing system in place, let's change `KVServer` to use the router. Replace the `lookup/2` function in `KVServer.Command` from this:\n\n```elixir\ndefp lookup(bucket, callback) do\n  case KV.Registry.lookup(KV.Registry, bucket) do\n    {:ok, pid} -> callback.(pid)\n    :error -> {:error, :not_found}\n  end\nend\n```\n\nby this:\n\n```elixir\ndefp lookup(bucket, callback) do\n  case KV.Router.route(bucket, KV.Registry, :lookup, [KV.Registry, bucket]) do\n    {:ok, pid} -> callback.(pid)\n    :error -> {:error, :not_found}\n  end\nend\n```\n\nInstead of directly looking up the registry, we are using the router instead to match a specific node. Then we get a `pid` that can be from any process in our cluster. From now on, `GET`, `PUT` and `DELETE` requests are all routed to the appropriate node.\n\nLet's also make sure that when a new bucket is created it ends up on the correct node. Replace the `run/1` function in `KVServer.Command`, the one that matches the `:create` command, with the following:\n\n```elixir\ndef run({:create, bucket}) do\n  case KV.Router.route(bucket, KV.Registry, :create, [KV.Registry, bucket]) do\n    pid when is_pid(pid) -> {:ok, \"OK\\r\\n\"}\n    _ -> {:error, \"FAILED TO CREATE BUCKET\"}\n  end\nend\n```\n\nNow if you run the tests, you will see that an existing test that checks the server interaction will fail, as it will attempt to use the routing table. To address this failure, change the `test_helper.exs` for `:kv_server` application as we did for `:kv` and add `@tag :distributed` to this test too:\n\n```elixir\n@tag :distributed\ntest \"server interaction\", %{socket: socket} do\n```\n\nHowever, keep in mind that by making the test distributed, we will likely run it less frequently, since we may not do the distributed setup on every test run. We will learn how to address this in the next chapter, by effectively learning how to make the routing table configurable.","ref":"distributed-tasks.html#wiring-it-all-up"},{"type":"extras","title":"Summing up - Distributed tasks and tags","doc":"We have only scratched the surface of what is possible when it comes to distribution.\n\nIn all of our examples, we relied on Erlang's ability to automatically connect nodes whenever there is a request. For example, when we invoked `Node.spawn_link(:\"foo@computer-name\", fn -> Hello.world() end)`, Erlang automatically connected to said node and started a new process. However, you may also want to take a more explicit approach to connections, by using `Node.connect/1` and `Node.disconnect/1`.\n\nBy default, Erlang establishes a fully meshed network, which means all nodes are connected to each other. Under this topology, the Erlang distribution is known to scale to several dozens of nodes in the same cluster. Erlang also has the concept of hidden nodes, which can allow developers to assemble custom topologies as seen in projects such as [Partisan](https://github.com/lasp-lang/partisan).\n\nIn production, you may have nodes connecting and disconnecting at any time. In such scenarios, you need to provide *node discoverability*. Libraries such as [libcluster](https://github.com/bitwalker/libcluster/) and [dns_cluster](https://github.com/phoenixframework/dns_cluster) provide several strategies for node discoverability using DNS, Kubernetes, etc.\n\nDistributed key-value stores, used in real-life, need to consider the fact nodes may go up and down at any time and also migrate the bucket across nodes. Even further, buckets often need to be duplicated between nodes, so a failure in a node does not lead to the whole bucket being lost. This process is called *replication*. Our implementation won't attempt to tackle such problems. Instead, we assume there is a fixed number of nodes and therefore use a fixed routing table.\n\nThese topics can be daunting at first but remember that most Elixir frameworks abstract those concerns for you. For example, when using [the Phoenix web framework](https://phoenixframework.org), its plug-and-play abstractions take care of sending messages and tracking how users join and leave a cluster. However, if you are interested in distributed systems after all, there is much to explore. Here are some additional references:\n\n  * [The excellent Distribunomicon chapter from Learn You Some Erlang](http://learnyousomeerlang.com/distribunomicon)\n  * [Erlang's global module](https://www.erlang.org/doc/man/global.html), which can provide global names and global locks, allowing unique names and unique locks in a whole cluster of machines\n  * [Erlang's pg module](https://www.erlang.org/doc/man/pg.html), which allows process to join different groups shared across the whole cluster\n  * [Phoenix PubSub project](https://github.com/phoenixframework/phoenix_pubsub), which provides a distributed messaging system and a distributed presence system for tracking users and processes in a cluster\n\nYou will also find many libraries for building distributed systems within the overall Erlang ecosystem. For now, it is time to go back to our simple distributed key-value store and learn how to configure and package it for production.","ref":"distributed-tasks.html#summing-up"},{"type":"extras","title":"Configuration and releases","doc":"# Configuration and releases\n\nIn this last guide, we will make the routing table for our distributed key-value store configurable, and then finally package the software for production.\n\nLet's do this.","ref":"config-and-releases.html"},{"type":"extras","title":"Application environment - Configuration and releases","doc":"So far we have hard-coded the routing table into the `KV.Router` module. However, we would like to make the table dynamic. This allows us not only to configure development/test/production, but also to allow different nodes to run with different entries in the routing table. There is a feature of OTP that does exactly that: the application environment.\n\nEach application has an environment that stores the application's specific configuration by key. For example, we could store the routing table in the `:kv` application environment, giving it a default value and allowing other applications to change the table as needed.\n\nOpen up `apps/kv/mix.exs` and change the `application/0` function to return the following:\n\n```elixir\ndef application do\n  [\n    extra_applications: [:logger],\n    env: [routing_table: []],\n    mod: {KV, []}\n  ]\nend\n```\n\nWe have added a new `:env` key to the application. It returns the application default environment, which has an entry of key `:routing_table` and value of an empty list. It makes sense for the application environment to ship with an empty table, as the specific routing table depends on the testing/deployment structure.\n\nIn order to use the application environment in our code, we need to replace `KV.Router.table/0` with the definition below:\n\n```elixir\n@doc \"\"\"\nThe routing table.\n\"\"\"\ndef table do\n  Application.fetch_env!(:kv, :routing_table)\nend\n```\n\nWe use `Application.fetch_env!/2` to read the entry for `:routing_table` in `:kv`'s environment. You can find more information and other functions to manipulate the app environment in the `Application` module.\n\nSince our routing table is now empty, our distributed tests should fail. Restart the apps and re-run tests to see the failure:\n\n```console\n$ iex --sname bar -S mix\n$ elixir --sname foo -S mix test --only distributed\n```\n\nWe need a way to configure the application environment. That's when we use configuration files.","ref":"config-and-releases.html#application-environment"},{"type":"extras","title":"Configuration - Configuration and releases","doc":"Configuration files provide a mechanism for us to configure the environment of any application. Elixir provides two configuration entry points:\n\n  * `config/config.exs` — this file is read at build time, before we compile our application and before we even load our dependencies. This means we can't access the code in our application nor in our dependencies. However, it means we can control how they are compiled\n\n  * `config/runtime.exs` — this file is read after our application and dependencies are compiled and therefore it can configure how our application works at runtime. If you want to read system environment variables (via `System.get_env/1`) or any sort of external configuration, this is the appropriate place to do so\n\nFor example, we can configure IEx default prompt to another value. Let's create the `config/runtime.exs` file with the following content:\n\n```elixir\nimport Config\nconfig :iex, default_prompt: \">>>\"\n```\n\nStart IEx with `iex -S mix` and you can see that the IEx prompt has changed.\n\nThis means we can also configure our `:routing_table` directly in the `config/runtime.exs` file. However, which configuration value should we use?\n\nCurrently we have two tests tagged with `@tag :distributed`. The \"server interaction\" test in `KVServerTest`, and the \"route requests across nodes\" in `KV.RouterTest`. Both tests are failing since they require a routing table, which is currently empty.\n\nFor simplicity, we will define a routing table that always points to the current node. That's the table we will use for development and most of our tests. Back in `config/runtime.exs`, add this line:\n\n```elixir\nconfig :kv, :routing_table, [{?a..?z, node()}]\n```\n\nWith such a simple table available, we can now remove `@tag :distributed` from the test in `test/kv_server_test.exs`. If you run the complete suite, the test should now pass.\n\nHowever, for the tests in `KV.RouterTest`, we effectively need two nodes in our routing table. To do so, we will write a setup block that runs before all tests in that file. The setup block will change the application environment and revert it back once we are done, like this:\n\n```elixir\ndefmodule KV.RouterTest do\n  use ExUnit.Case\n\n  setup_all do\n    current = Application.get_env(:kv, :routing_table)\n\n    Application.put_env(:kv, :routing_table, [\n      {?a..?m, :\"foo@computer-name\"},\n      {?n..?z, :\"bar@computer-name\"}\n    ])\n\n    on_exit fn -> Application.put_env(:kv, :routing_table, current) end\n  end\n\n  @tag :distributed\n  test \"route requests across nodes\" do\n```\n\nNote we removed `async: true` from `use ExUnit.Case`. Since the application environment is a global storage, tests that modify it cannot run concurrently. With all changes in place, all tests should pass, including the distributed one.","ref":"config-and-releases.html#configuration"},{"type":"extras","title":"Releases - Configuration and releases","doc":"Now that our application runs distributed, you may be wondering how we can package our application to run in production. After all, all of our code so far depends on Erlang and Elixir versions that are installed in your current system. To achieve this goal, Elixir provides releases.\n\nA release is a self-contained directory that consists of your application code, all of its dependencies, plus the whole Erlang Virtual Machine (VM) and runtime. Once a release is assembled, it can be packaged and deployed to a target as long as the target runs on the same operating system (OS) distribution and version as the machine that assembled the release.\n\nIn a regular project, we can assemble a release by simply running `mix release`. However, we have an umbrella project, and in such cases Elixir requires some extra input from us. Let's see what is necessary:\n\n```shell\n$ MIX_ENV=prod mix release\n** (Mix) Umbrella projects require releases to be explicitly defined with a non-empty applications key that chooses which umbrella children should be part of the releases:\n\nreleases: [\n  foo: [\n    applications: [child_app_foo: :permanent]\n  ],\n  bar: [\n    applications: [child_app_bar: :permanent]\n  ]\n]\n\nAlternatively you can perform the release from the children applications\n```\n\nThat's because an umbrella project gives us plenty of options when deploying the software. We can:\n\n  * deploy all applications in the umbrella to a node that will work as both TCP server and key-value storage\n\n  * deploy the `:kv_server` application to work only as a TCP server as long as the routing table points only to other nodes\n\n  * deploy only the `:kv` application when we want a node to work only as storage (no TCP access)\n\nAs a starting point, let's define a release that includes both `:kv_server` and `:kv` applications. We will also add a version to it. Open up the `mix.exs` in the umbrella root and add inside `def project`:\n\n```elixir\nreleases: [\n  foo: [\n    version: \"0.0.1\",\n    applications: [kv_server: :permanent, kv: :permanent]\n  ]\n]\n```\n\nThat defines a release named `foo` with both `kv_server` and `kv` applications. Their mode is set to `:permanent`, which means that, if those applications crash, the whole node terminates. That's reasonable since those applications are essential to our system.\n\nBefore we assemble the release, let's also define our routing table for production. Given we expect to have two nodes, we need to update `config/runtime.exs` to look like this:\n\n```elixir\nimport Config\n\nconfig :kv, :routing_table, [{?a..?z, node()}]\n\nif config_env() == :prod do\n  config :kv, :routing_table, [\n    {?a..?m, :\"foo@computer-name\"},\n    {?n..?z, :\"bar@computer-name\"}\n  ]\nend\n```\n\nWe have hard-coded the table and node names, which is good enough for our example, but you would likely move it to an external configuration system in an actual production setup. We have also wrapped it in a `config_env() == :prod` check, so this configuration does not apply to other environments.\n\nWith the configuration in place, let's give assembling the release another try:\n\n    $ MIX_ENV=prod mix release foo\n    * assembling foo-0.0.1 on MIX_ENV=prod\n    * skipping runtime configuration (config/runtime.exs not found)\n\n    Release created at _build/prod/rel/foo!\n\n        # To start your system\n        _build/prod/rel/foo/bin/foo start\n\n    Once the release is running:\n\n        # To connect to it remotely\n        _build/prod/rel/foo/bin/foo remote\n\n        # To stop it gracefully (you may also send SIGINT/SIGTERM)\n        _build/prod/rel/foo/bin/foo stop\n\n    To list all commands:\n\n        _build/prod/rel/foo/bin/foo\n\nExcellent! A release was assembled in `_build/prod/rel/foo`. Inside the release, there will be a `bin/foo` file which is the entry point to your system. It supports multiple commands, such as:\n\n  * `bin/foo start`, `bin/foo start_iex`, `bin/foo restart`, and `bin/foo stop` — for general management of the release\n\n  * `bin/foo rpc COMMAND` and `bin/foo remote` — for running commands on the running system or to connect to the running system\n\n  * `bin/foo eval COMMAND` — to start a fresh system that runs a single command and then shuts down\n\n  * `bin/foo daemon` and `bin/foo daemon_iex` — to start the system as a daemon on Unix-like systems\n\n  * `bin/foo install` — to install the system as a service on Windows machines\n\nIf you run `bin/foo start`, it will start the system using a short name (`--sname`) equal to the release name, which in this case is `foo`. The next step is to start a system named `bar`, so we can connect `foo` and `bar` together, like we did in the previous chapter. But before we achieve this, let's talk a bit about the benefits of releases.","ref":"config-and-releases.html#releases"},{"type":"extras","title":"Why releases? - Configuration and releases","doc":"Releases allow developers to precompile and package all of their code and the runtime into a single unit. The benefits of releases are:\n\n  * Code preloading. The VM has two mechanisms for loading code: interactive and embedded. By default, it runs in the interactive mode which dynamically loads modules when they are used for the first time. The first time your application calls `Enum.map/2`, the VM will find the `Enum` module and load it. There's a downside. When you start a new server in production, it may need to load many other modules, causing the first requests to have an unusual spike in response time. Releases run in embedded mode, which loads all available modules upfront, guaranteeing your system is ready to handle requests after booting.\n\n  * Configuration and customization. Releases give developers fine grained control over system configuration and the VM flags used to start the system.\n\n  * Self-contained. A release does not require the source code to be included in your production artifacts. All of the code is precompiled and packaged. Releases do not even require Erlang or Elixir on your servers, as they include the Erlang VM and its runtime by default. Furthermore, both Erlang and Elixir standard libraries are stripped to bring only the parts you are actually using.\n\n  * Multiple releases. You can assemble different releases with different configuration per application or even with different applications altogether.\n\nWe have written extensive documentation on releases, so [please check the official documentation for more information](`mix release`). For now, we will continue exploring some of the features outlined above.","ref":"config-and-releases.html#why-releases"},{"type":"extras","title":"Assembling multiple releases - Configuration and releases","doc":"So far, we have assembled a release named `foo`, but our routing table contains information for both `foo` and `bar`. Let's start `foo`:\n\n    $ _build/prod/rel/foo/bin/foo start\n    16:58:58.508 [info]  Accepting connections on port 4040\n\nAnd let's connect to it and issue a request in another terminal:\n\n    $ telnet 127.0.0.1 4040\n    Trying 127.0.0.1...\n    Connected to localhost.\n    Escape character is '^]'.\n    CREATE bitsandpieces\n    OK\n    PUT bitsandpieces sword 1\n    OK\n    GET bitsandpieces sword\n    1\n    OK\n    GET shopping foo\n    Connection closed by foreign host.\n\nOur application works already when we operate on the bucket named \"bitsandpieces\". But since the \"shopping\" bucket would be stored on `bar`, the request fails as `bar` is not available. If you go back to the terminal running `foo`, you will see:\n\n    17:16:19.555 [error] Task #PID<0.622.0> started from #PID<0.620.0> terminating\n    ** (stop) exited in: GenServer.call({KV.RouterTasks, :\"bar@computer-name\"}, {:start_task, [{:\"foo@josemac-2\", #PID<0.622.0>, #PID<0.622.0>}, [#PID<0.622.0>, #PID<0.620.0>, #PID<0.618.0>], :monitor, {KV.Router, :route, [\"shopping\", KV.Registry, :lookup, [KV.Registry, \"shopping\"]]}], :temporary, nil}, :infinity)\n        ** (EXIT) no connection to bar@computer-name\n        (elixir) lib/gen_server.ex:1010: GenServer.call/3\n        (elixir) lib/task/supervisor.ex:454: Task.Supervisor.async/6\n        (kv) lib/kv/router.ex:21: KV.Router.route/4\n        (kv_server) lib/kv_server/command.ex:74: KVServer.Command.lookup/2\n        (kv_server) lib/kv_server.ex:29: KVServer.serve/1\n        (elixir) lib/task/supervised.ex:90: Task.Supervised.invoke_mfa/2\n        (stdlib) proc_lib.erl:249: :proc_lib.init_p_do_apply/3\n    Function: #Function<0.128611034/0 in KVServer.loop_acceptor/1>\n        Args: []\n\nLet's now define a release for `:bar`. One first step could be to define a release exactly like `foo` inside `mix.exs`. Additionally we will set the `cookie` option on both releases to `weknoweachother` in order for them to allow connections from each other. See the [Distributed Erlang Documentation](http://www.erlang.org/doc/reference_manual/distributed.html) for further information on this topic:\n\n```elixir\nreleases: [\n  foo: [\n    version: \"0.0.1\",\n    applications: [kv_server: :permanent, kv: :permanent],\n    cookie: \"weknoweachother\"\n  ],\n  bar: [\n    version: \"0.0.1\",\n    applications: [kv_server: :permanent, kv: :permanent],\n    cookie: \"weknoweachother\"\n  ]\n]\n```\n\nAnd now let's assemble both releases:\n\n```shell\n$ MIX_ENV=prod mix release foo\n$ MIX_ENV=prod mix release bar\n```\n\nStop `foo` if it's still running and re-start it to load the `cookie`:\n\n```shell\n$ _build/prod/rel/foo/bin/foo start\n```\n\nAnd start `bar` in another terminal:\n\n```shell\n$ _build/prod/rel/bar/bin/bar start\n```\n\nYou should see an error like the error below happen 5 times, before the application finally shuts down:\n\n```text\n    17:21:57.567 [error] Task #PID<0.620.0> started from KVServer.Supervisor terminating\n    ** (MatchError) no match of right hand side value: {:error, :eaddrinuse}\n        (kv_server) lib/kv_server.ex:12: KVServer.accept/1\n        (elixir) lib/task/supervised.ex:90: Task.Supervised.invoke_mfa/2\n        (stdlib) proc_lib.erl:249: :proc_lib.init_p_do_apply/3\n    Function: #Function<0.98032413/0 in KVServer.Application.start/2>\n        Args: []\n```\n\nThat's happening because the release `foo` is already listening on port `4040` and `bar` is trying to do the same! One option could be to move the `:port` configuration to the application environment, like we did for the routing table, and setup different ports per node.\n\nBut let's try something else. Let's make it so the `bar` release contains only the `:kv` application. So it works as a storage but it won't have a front-end. Change the `:bar` information to this:\n\n```elixir\nreleases: [\n  foo: [\n    version: \"0.0.1\",\n    applications: [kv_server: :permanent, kv: :permanent],\n    cookie: \"weknoweachother\"\n  ],\n  bar: [\n    version: \"0.0.1\",\n    applications: [kv: :permanent],\n    cookie: \"weknoweachother\"\n  ]\n]\n```\n\nAnd now let's assemble `bar` once more:\n\n    $ MIX_ENV=prod mix release bar\n\nAnd finally successfully boot it:\n\n    $ _build/prod/rel/bar/bin/bar start\n\nIf you connect to localhost once again and perform another request, now everything should work, as long as the routing table contains the correct node names. Outstanding!\n\nWith releases, we were able to \"cut different slices\" of our project and prepared them to run in production, all packaged into a single directory.","ref":"config-and-releases.html#assembling-multiple-releases"},{"type":"extras","title":"Configuring releases - Configuration and releases","doc":"Releases also provide built-in hooks for configuring almost every need of the production system:\n\n  * `config/config.exs` — provides build-time application configuration, which is executed before our application compiles. This file often imports configuration files based on the environment, such as `config/dev.exs` and `config/prod.exs`.\n\n  * `config/runtime.exs` — provides runtime application configuration. It is executed every time the release boots and is further extensible via config providers.\n\n  * `rel/env.sh.eex` and `rel/env.bat.eex` — template files that are copied into every release and executed on every command to set up environment variables, including ones specific to the VM, and the general environment.\n\n  * `rel/vm.args.eex` — a template file that is copied into every release and provides static configuration of the Erlang Virtual Machine and other runtime flags.\n\nAs we have seen, `config/config.exs` and `config/runtime.exs` are loaded during releases and regular Mix commands. On the other hand, `rel/env.sh.eex` and `rel/vm.args.eex` are specific to releases. Let's take a look.","ref":"config-and-releases.html#configuring-releases"},{"type":"extras","title":"Operating System environment configuration - Configuration and releases","doc":"Every release contains an environment file, named `env.sh` on Unix-like systems and `env.bat` on Windows machines, that executes before the Elixir system starts. In this file, you can execute any OS-level code, such as invoke other applications, set environment variables and so on. Some of those environment variables can even configure how the release itself runs.\n\nFor instance, releases run using short-names (`--sname`). However, if you want to actually run a distributed key-value store in production, you will need multiple nodes and start the release with the `--name` option. We can achieve this by setting the `RELEASE_DISTRIBUTION` environment variable inside the `env.sh` and `env.bat` files. Mix already has a template for said files which we can customize, so let's ask Mix to copy them to our application:\n\n    $ mix release.init\n    * creating rel/vm.args.eex\n    * creating rel/remote.vm.args.eex\n    * creating rel/env.sh.eex\n    * creating rel/env.bat.eex\n\nIf you open up `rel/env.sh.eex`, you will see:\n\n```shell\n#!/bin/sh\n\n# # Sets and enables heart (recommended only in daemon mode)\n# case $RELEASE_COMMAND in\n#   daemon*)\n#     HEART_COMMAND=\"$RELEASE_ROOT/bin/$RELEASE_NAME $RELEASE_COMMAND\"\n#     export HEART_COMMAND\n#     export ELIXIR_ERL_OPTIONS=\"-heart\"\n#     ;;\n#   *)\n#     ;;\n# esac\n\n# # Set the release to load code on demand (interactive) instead of preloading (embedded).\n# export RELEASE_MODE=interactive\n\n# # Set the release to work across nodes.\n# # RELEASE_DISTRIBUTION must be \"sname\" (local), \"name\" (distributed) or \"none\".\n# export RELEASE_DISTRIBUTION=name\n# export RELEASE_NODE=<%= @release.name %>\n```\n\nThe steps necessary to work across nodes is already commented out as an example. You can enable full distribution by uncommenting the last two lines by removing the leading `# `.\n\nIf you are on Windows, you will have to open up `rel/env.bat.eex`, where you will find this:\n\n```bat\n@echo off\nrem Set the release to load code on demand (interactive) instead of preloading (embedded).\nrem set RELEASE_MODE=interactive\n\nrem Set the release to work across nodes.\nrem RELEASE_DISTRIBUTION must be \"sname\" (local), \"name\" (distributed) or \"none\".\nrem set RELEASE_DISTRIBUTION=name\nrem set RELEASE_NODE=<%= @release.name %>\n```\n\nOnce again, uncomment the last two lines by removing the leading `rem ` to enable full distribution. And that's all!","ref":"config-and-releases.html#operating-system-environment-configuration"},{"type":"extras","title":"VM arguments - Configuration and releases","doc":"The `rel/vm.args.eex` allows you to specify low-level flags that control how the Erlang VM and its runtime operate. You specify entries as if you were specifying arguments in the command line with code comments also supported. Here is the default generated file:","ref":"config-and-releases.html#vm-arguments"},{"type":"extras","title":"Customize flags given to the VM: https://www.erlang.org/doc/man/erl.html - Configuration and releases","doc":"## -mode/-name/-sname/-setcookie are configured via env vars, do not set them here","ref":"config-and-releases.html#customize-flags-given-to-the-vm-https-www-erlang-org-doc-man-erl-html"},{"type":"extras","title":"Increase number of concurrent ports/sockets - Configuration and releases","doc":"##+Q 65536","ref":"config-and-releases.html#increase-number-of-concurrent-ports-sockets"},{"type":"extras","title":"Tweak GC to run more often - Configuration and releases","doc":"##-env ERL_FULLSWEEP_AFTER 10\n\nYou can see [a complete list of VM arguments and flags in the Erlang documentation](http://www.erlang.org/doc/man/erl.html).","ref":"config-and-releases.html#tweak-gc-to-run-more-often"},{"type":"extras","title":"Summing up - Configuration and releases","doc":"Throughout the guide, we have built a very simple distributed key-value store as an opportunity to explore many constructs like generic servers, supervisors, tasks, agents, applications and more. Not only that, we have written tests for the whole application, got familiar with ExUnit, and learned how to use the Mix build tool to accomplish a wide range of tasks.\n\nIf you are looking for a distributed key-value store to use in production, you should definitely look into [Riak](http://riak.com/products/riak-kv/), which also runs in the Erlang VM. In Riak, the buckets are replicated, to avoid data loss, and instead of a router, they use [consistent hashing](https://en.wikipedia.org/wiki/Consistent_hashing) to map a bucket to a node. A consistent hashing algorithm helps reduce the amount of data that needs to be migrated when new storage nodes are added to your live system.\n\nOf course, Elixir can be used for much more than distributed key-value stores. Embedded systems, data-processing and data-ingestion, web applications, audio/video streaming systems, and others are many of the different domains Elixir excels at. We hope this guide has prepared you to explore any of those domains or any future domain you may desire to bring Elixir into.\n\nHappy coding!","ref":"config-and-releases.html#summing-up"},{"type":"extras","title":"Compatibility and deprecations","doc":"# Compatibility and deprecations\n\nElixir is versioned according to a vMAJOR.MINOR.PATCH schema.\n\nElixir is currently at major version v1. A new backwards compatible minor release happens every 6 months. Patch releases are not scheduled and are made whenever there are bug fixes or security patches.\n\nElixir applies bug fixes only to the latest minor branch. Security patches are available for the last 5 minor branches:\n\nElixir version | Support\n:------------- | :-----------------------------\n1.17           | Bug fixes and security patches\n1.16           | Security patches only\n1.15           | Security patches only\n1.14           | Security patches only\n1.13           | Security patches only\n\nNew releases are announced in the read-only [announcements mailing list](https://groups.google.com/group/elixir-lang-ann). All security releases [will be tagged with `[security]`](https://groups.google.com/forum/#!searchin/elixir-lang-ann/%5Bsecurity%5D%7Csort:date).\n\nThere are currently no plans for a major v2 release.","ref":"compatibility-and-deprecations.html"},{"type":"extras","title":"Between non-major Elixir versions - Compatibility and deprecations","doc":"Elixir minor and patch releases are backwards compatible: well-defined behaviors and documented APIs in a given version will continue working on future versions.\n\nAlthough we expect the vast majority of programs to remain compatible over time, it is impossible to guarantee that no future change will break any program. Under some unlikely circumstances, we may introduce changes that break existing code:\n\n  * Security: a security issue in the implementation may arise whose resolution requires backwards incompatible changes. We reserve the right to address such security issues.\n\n  * Bugs: if an API has undesired behavior, a program that depends on the buggy behavior may break if the bug is fixed. We reserve the right to fix such bugs.\n\n  * Compiler front-end: improvements may be done to the compiler, introducing new warnings for ambiguous modes and providing more detailed error messages. Those can lead to compilation errors (when running with `--warning-as-errors`) or tooling failures when asserting on specific error messages (although one should avoid such). We reserve the right to do such improvements.\n\n  * Imports: new functions may be added to the `Kernel` module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using `import Kernel, except: [...]` with a list of all functions you don't want to be imported from `Kernel`. We reserve the right to do such additions.\n\nIn order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the [\"Deprecations\" section](#deprecations).\n\nThe only exception to the compatibility guarantees above are experimental features, which will be explicitly marked as such, and do not provide any compatibility guarantee until they are stabilized.","ref":"compatibility-and-deprecations.html#between-non-major-elixir-versions"},{"type":"extras","title":"Between Elixir and Erlang/OTP - Compatibility and deprecations","doc":"Erlang/OTP versioning is independent from the versioning of Elixir. Erlang releases a new major version yearly. Our goal is to support the last three Erlang major versions by the time Elixir is released. The compatibility table is shown below.\n\nElixir version | Supported Erlang/OTP versions\n:------------- | :-------------------------------\n1.17           | 25 - 27\n1.16           | 24 - 26\n1.15           | 24 - 26\n1.14           | 23 - 25 (and Erlang/OTP 26 from v1.14.5)\n1.13           | 22 - 24 (and Erlang/OTP 25 from v1.13.4)\n1.12           | 22 - 24\n1.11           | 21 - 23 (and Erlang/OTP 24 from v1.11.4)\n1.10           | 21 - 22 (and Erlang/OTP 23 from v1.10.3)\n1.9            | 20 - 22\n1.8            | 20 - 22\n1.7            | 19 - 22\n1.6            | 19 - 20 (and Erlang/OTP 21 from v1.6.6)\n1.5            | 18 - 20\n1.4            | 18 - 19 (and Erlang/OTP 20 from v1.4.5)\n1.3            | 18 - 19\n1.2            | 18 - 18 (and Erlang/OTP 19 from v1.2.6)\n1.1            | 17 - 18\n1.0            | 17 - 17 (and Erlang/OTP 18 from v1.0.5)\n\nElixir may add compatibility to new Erlang/OTP versions on patch releases, such as support for Erlang/OTP 20 in v1.4.5. Those releases are made for convenience and typically contain the minimum changes for Elixir to run without errors, if any changes are necessary. Only the next minor release, in this case v1.5.0, effectively leverages the new features provided by the latest Erlang/OTP release.","ref":"compatibility-and-deprecations.html#between-elixir-and-erlang-otp"},{"type":"extras","title":"Deprecations - Compatibility and deprecations","doc":"","ref":"compatibility-and-deprecations.html#deprecations"},{"type":"extras","title":"Policy - Compatibility and deprecations","doc":"Elixir deprecations happen in 3 steps:\n\n  1. The feature is soft-deprecated. It means both CHANGELOG and documentation must list the feature as deprecated but no warning is effectively emitted by running the code. There is no requirement to soft-deprecate a feature.\n\n  2. The feature is effectively deprecated by emitting warnings on usage. This is also known as hard-deprecation. In order to deprecate a feature, the proposed alternative MUST exist for AT LEAST THREE minor versions. For example, `Enum.uniq/2` was soft-deprecated in favor of `Enum.uniq_by/2` in Elixir v1.1. This means a deprecation warning may only be emitted by Elixir v1.4 or later.\n\n  3. The feature is removed. This can only happen on major releases. This means deprecated features in Elixir v1.x shall only be removed by Elixir v2.x.","ref":"compatibility-and-deprecations.html#policy"},{"type":"extras","title":"Table of deprecations - Compatibility and deprecations","doc":"The first column is the version the feature was hard deprecated. The second column shortly describes the deprecated feature and the third column explains the replacement and from which the version the replacement is available from.\n\nVersion | Deprecated feature                                  | Replaced by (available since)\n:-------| :-------------------------------------------------- | :---------------------------------------------------------------\n[v1.17] | Single-quoted charlists (`'foo'`)                   | `~c\"foo\"` (v1.0)\n[v1.17] | `left..right` in patterns and guards                | `left..right//step` (v1.11)\n[v1.17] | `ExUnit.Case.register_test/4`                       | `register_test/6` (v1.10)\n[v1.17] | `:all` in `IO.read/2` and `IO.binread/2`            | `:eof` (v1.13)\n[v1.16] | `~R/.../`                                           | `~r/.../` (v1.0)\n[v1.16] | Ranges with negative steps in `Enum.slice/2`        | Explicit steps in ranges (v1.11)\n[v1.16] | Ranges with negative steps in `String.slice/2`      | Explicit steps in ranges (v1.11)\n[v1.15] | `Calendar.ISO.day_of_week/3`                        | `Calendar.ISO.day_of_week/4` (v1.11)\n[v1.15] | `Exception.exception?/1`                            | `Kernel.is_exception/1` (v1.11)\n[v1.15] | `Regex.regex?/1`                                    | `Kernel.is_struct/2` (`Kernel.is_struct(term, Regex)`) (v1.11)\n[v1.15] | `Logger.warn/2`                                     | `Logger.warning/2` (v1.11)\n[v1.14] | `use Bitwise`                                       | `import Bitwise` (v1.0)\n[v1.14] | `~~~/1`                                             | `bnot/2` (v1.0)\n[v1.14] | `Application.get_env/3` and similar in module body  | `Application.compile_env/3` (v1.10)\n[v1.14] | Compiled patterns in `String.starts_with?/2`        | Pass a list of strings instead (v1.0)\n[v1.14] | `Mix.Tasks.Xref.calls/1`                            | Compilation tracers (outlined in `Code`) (v1.10)\n[v1.14] | `$levelpad` in Logger                               | *None*\n[v1.14] | `<\\|>` as a custom operator                         | Another custom operator (v1.0)\n[v1.13] | `!` and `!=` in Version requirements                | `~>` or `>=` (v1.0)\n[v1.13] | `Mix.Config`                                        | `Config` (v1.9)\n[v1.13] | `:strip_beam` config to `mix escript.build`         | `:strip_beams` (v1.9)\n[v1.13] | `Macro.to_string/2`                                 | `Macro.to_string/1` (v1.0)\n[v1.13] | `System.get_pid/0`                                  | `System.pid/0` (v1.9)\n[v1.12] | `^^^/2`                                             | `bxor/2` (v1.0)\n[v1.12] | `@foo()` to read module attributes                  | Remove the parenthesis (v1.0)\n[v1.12] | `use EEx.Engine`                                    | Explicitly delegate to EEx.Engine instead (v1.0)\n[v1.12] | `:xref` compiler in Mix                             | Nothing (it always runs as part of the compiler now)\n[v1.11] | `Mix.Project.compile/2`                             | `Mix.Task.run(\"compile\", args)` (v1.0)\n[v1.11] | `Supervisor.Spec.worker/3` and `Supervisor.Spec.supervisor/3` | The new child specs outlined in `Supervisor` (v1.5)\n[v1.11] | `Supervisor.start_child/2` and `Supervisor.terminate_child/2` | `DynamicSupervisor` (v1.6)\n[v1.11] | `System.stacktrace/1`                               | `__STACKTRACE__` in `try/catch/rescue` (v1.7)\n[v1.10] | `Code.ensure_compiled?/1`                           | `Code.ensure_compiled/1` (v1.0)\n[v1.10] | `Code.load_file/2`                                  | `Code.require_file/2` (v1.0) or `Code.compile_file/2` (v1.7)\n[v1.10] | `Code.loaded_files/0`                               | `Code.required_files/0` (v1.7)\n[v1.10] | `Code.unload_file/1`                                | `Code.unrequire_files/1` (v1.7)\n[v1.10] | Passing non-chardata to `Logger.log/2`              | Explicitly convert to string with `to_string/1` (v1.0)\n[v1.10] | `:compile_time_purge_level` in `Logger` app environment | `:compile_time_purge_matching` in `Logger` app environment (v1.7)\n[v1.10] | `Supervisor.Spec.supervise/2`                       | The new child specs outlined in `Supervisor` (v1.5)\n[v1.10] | `:simple_one_for_one` strategy in `Supervisor`      | `DynamicSupervisor` (v1.6)\n[v1.10] | `:restart` and `:shutdown` in `Task.Supervisor.start_link/1` | `:restart` and `:shutdown` in `Task.Supervisor.start_child/3` (v1.6)\n[v1.9]  | Enumerable keys in `Map.drop/2`, `Map.split/2`, and `Map.take/2` | Call `Enum.to_list/1` on the second argument before hand (v1.0)\n[v1.9]  | `Mix.Project.load_paths/1`                          | `Mix.Project.compile_path/1` (v1.0)\n[v1.9]  | Passing `:insert_replaced` to `String.replace/4`    | Use `:binary.replace/4` (v1.0)\n[v1.8]  | Passing a non-empty list to `Collectable.into/1`    | `++/2` or `Keyword.merge/2` (v1.0)\n[v1.8]  | Passing a non-empty list to `:into` in `for/1`      | `++/2` or `Keyword.merge/2` (v1.0)\n[v1.8]  | Passing a non-empty list to `Enum.into/2`           | `++/2` or `Keyword.merge/2` (v1.0)\n[v1.8]  | Time units in its plural form, such as: `:seconds`, `:milliseconds`, and the like | Use the singular form, such as: `:second`, `:millisecond`, and so on (v1.4)\n[v1.8]  | `Inspect.Algebra.surround/3`                        | `Inspect.Algebra.concat/2` and `Inspect.Algebra.nest/2` (v1.0)\n[v1.8]  | `Inspect.Algebra.surround_many/6`                   | `Inspect.Algebra.container_doc/6` (v1.6)\n[v1.9]  | `--detached` in `Kernel.CLI`                        | `--erl \"-detached\"` (v1.0)\n[v1.8]  | `Kernel.ParallelCompiler.files/2`                   | `Kernel.ParallelCompiler.compile/2` (v1.6)\n[v1.8]  | `Kernel.ParallelCompiler.files_to_path/2`           | `Kernel.ParallelCompiler.compile_to_path/2` (v1.6)\n[v1.8]  | `Kernel.ParallelRequire.files/2`                    | `Kernel.ParallelCompiler.require/2` (v1.6)\n[v1.8]  | Returning `{:ok, contents}` or `:error` from `Mix.Compilers.Erlang.compile/6`'s callback | Return `{:ok, contents, warnings}` or `{:error, errors, warnings}` (v1.6)\n[v1.8]  | `System.cwd/0` and `System.cwd!/0`                  | `File.cwd/0` and `File.cwd!/0` (v1.0)\n[v1.7]  | `Code.get_docs/2`                                   | `Code.fetch_docs/1` (v1.7)\n[v1.7]  | `Enum.chunk/2,3,4`                                  | `Enum.chunk_every/2` and [`Enum.chunk_every/3,4`](`Enum.chunk_every/4`) (v1.5)\n[v1.7]  | Calling `super/1` in`GenServer` callbacks           | Implementing the behaviour explicitly without calling `super/1` (v1.0)\n[v1.7]  | [`not left in right`](`in/2`)                | [`left not in right`](`in/2`) (v1.5)\n[v1.7]  | `Registry.start_link/3`                             | `Registry.start_link/1` (v1.5)\n[v1.7]  | `Stream.chunk/2,3,4`                                | `Stream.chunk_every/2` and [`Stream.chunk_every/3,4`](`Stream.chunk_every/4`) (v1.5)\n[v1.6]  | `Enum.partition/2`                                  | `Enum.split_with/2` (v1.4)\n[v1.6]  | `Macro.unescape_tokens/1,2`                         | Use `Enum.map/2` to traverse over the arguments (v1.0)\n[v1.6]  | `Module.add_doc/6`                                  | [`@doc`](`Module`) module attribute (v1.0)\n[v1.6]  | `Range.range?/1`                                    | Pattern match on [`_.._`](`../2`) (v1.0)\n[v1.5]  | `()` to mean `nil`                                  | `nil` (v1.0)\n[v1.5]  | `char_list/0` type                                  | `t:charlist/0` type (v1.3)\n[v1.5]  | `Atom.to_char_list/1`                               | `Atom.to_charlist/1` (v1.3)\n[v1.5]  | `Enum.filter_map/3`                                 | `Enum.filter/2` + `Enum.map/2` or `for/1` comprehensions (v1.0)\n[v1.5]  | `Float.to_char_list/1`                              | `Float.to_charlist/1` (v1.3)\n[v1.5]  | `GenEvent` module                                   | `Supervisor` and `GenServer` (v1.0); [`GenStage`](https://hex.pm/packages/gen_stage) (v1.3); [`:gen_event`](`:gen_event`) (Erlang/OTP 17)\n[v1.5]  | `<%=` in middle and end expressions in `EEx`        | Use `<%` (`<%=` is allowed only in start expressions) (v1.0)\n[v1.5]  | `:as_char_lists` value in `t:Inspect.Opts.t/0` type | `:as_charlists` value (v1.3)\n[v1.5]  | `:char_lists` key in `t:Inspect.Opts.t/0` type      | `:charlists` key (v1.3)\n[v1.5]  | `Integer.to_char_list/1,2`                          | `Integer.to_charlist/1` and `Integer.to_charlist/2` (v1.3)\n[v1.5]  | `to_char_list/1`                                    | `to_charlist/1` (v1.3)\n[v1.5]  | `List.Chars.to_char_list/1`                         | `List.Chars.to_charlist/1` (v1.3)\n[v1.5]  | `@compile {:parse_transform, _}` in `Module`        | *None*\n[v1.5]  | `Stream.filter_map/3`                               | `Stream.filter/2` + `Stream.map/2` (v1.0)\n[v1.5]  | `String.ljust/3` and `String.rjust/3`               | Use `String.pad_leading/3` and `String.pad_trailing/3` with a binary padding (v1.3)\n[v1.5]  | `String.lstrip/1` and `String.rstrip/1`             | `String.trim_leading/1` and `String.trim_trailing/1` (v1.3)\n[v1.5]  | `String.lstrip/2` and `String.rstrip/2`             | Use `String.trim_leading/2` and `String.trim_trailing/2` with a binary as second argument (v1.3)\n[v1.5]  | `String.strip/1` and `String.strip/2`               | `String.trim/1` and `String.trim/2` (v1.3)\n[v1.5]  | `String.to_char_list/1`                             | `String.to_charlist/1` (v1.3)\n[v1.4]  | Anonymous functions with no expression after `->`   | Use an expression or explicitly return `nil` (v1.0)\n[v1.4]  | Support for making [private functions](`defp/2`) overridable | Use [public functions](`def/2`) (v1.0)\n[v1.4]  | Variable used as function call                      | Use parentheses (v1.0)\n[v1.4]  | `Access.key/1`                                      | `Access.key/2` (v1.3)\n[v1.4]  | `Behaviour` module                                  | `@callback` module attribute (v1.0)\n[v1.4]  | `Enum.uniq/2`                                       | `Enum.uniq_by/2` (v1.2)\n[v1.4]  | `Float.to_char_list/2`                              | `:erlang.float_to_list/2` (Erlang/OTP 17)\n[v1.4]  | `Float.to_string/2`                                 | `:erlang.float_to_binary/2` (Erlang/OTP 17)\n[v1.4]  | `HashDict` module                                   | `Map` (v1.2)\n[v1.4]  | `HashSet` module                                    | `MapSet` (v1.1)\n[v1.4]  | `IEx.Helpers.import_file/2`                         | `IEx.Helpers.import_file_if_available/1` (v1.3)\n[v1.4]  | `Mix.Utils.camelize/1`                              | `Macro.camelize/1` (v1.2)\n[v1.4]  | `Mix.Utils.underscore/1`                            | `Macro.underscore/1` (v1.2)\n[v1.4]  |  Multi-letter aliases in `OptionParser`             | Use single-letter aliases (v1.0)\n[v1.4]  | `Set` module                                        | `MapSet` (v1.1)\n[v1.4]  | `Stream.uniq/2`                                     | `Stream.uniq_by/2` (v1.2)\n[v1.3]  | `\\x{X*}` inside strings/sigils/charlists            | `\\uXXXX` or `\\u{X*}` (v1.1)\n[v1.3]  | `Dict` module                                       | `Keyword` (v1.0) or `Map` (v1.2)\n[v1.3]  | `:append_first` option in `defdelegate/2`           | Define the function explicitly (v1.0)\n[v1.3]  | Map/dictionary as 2nd argument in `Enum.group_by/3` | `Enum.reduce/3` (v1.0)\n[v1.3]  | `Keyword.size/1`                                    | `length/1` (v1.0)\n[v1.3]  | `Map.size/1`                                        | `map_size/1` (v1.0)\n[v1.3]  | `/r` option in `Regex`                              | `/U` (v1.1)\n[v1.3]  | `Set` behaviour                                     | `MapSet` data structure (v1.1)\n[v1.3]  | `String.valid_character?/1`                         | `String.valid?/1` (v1.0)\n[v1.3]  | `Task.find/2`                                       | Use direct message matching (v1.0)\n[v1.3]  | Non-map as 2nd argument in `URI.decode_query/2`     | Use a map (v1.0)\n[v1.2]  | `Dict` behaviour                                    | `Map` and `Keyword` (v1.0)\n[v1.1]  | `?\\xHEX`                                            | `0xHEX` (v1.0)\n[v1.1]  | `Access` protocol                                   | `Access` behaviour (v1.1)\n[v1.1]  | `as: true \\| false` in `alias/2` and `require/2`    | *None*\n\n[v1.1]: https://github.com/elixir-lang/elixir/blob/v1.1/CHANGELOG.md#4-deprecations\n[v1.2]: https://github.com/elixir-lang/elixir/blob/v1.2/CHANGELOG.md#changelog-for-elixir-v12\n[v1.3]: https://github.com/elixir-lang/elixir/blob/v1.3/CHANGELOG.md#4-deprecations\n[v1.4]: https://github.com/elixir-lang/elixir/blob/v1.4/CHANGELOG.md#4-deprecations\n[v1.5]: https://github.com/elixir-lang/elixir/blob/v1.5/CHANGELOG.md#4-deprecations\n[v1.6]: https://github.com/elixir-lang/elixir/blob/v1.6/CHANGELOG.md#4-deprecations\n[v1.7]: https://github.com/elixir-lang/elixir/blob/v1.7/CHANGELOG.md#4-hard-deprecations\n[v1.8]: https://github.com/elixir-lang/elixir/blob/v1.8/CHANGELOG.md#4-hard-deprecations\n[v1.9]: https://github.com/elixir-lang/elixir/blob/v1.9/CHANGELOG.md#4-hard-deprecations\n[v1.10]: https://github.com/elixir-lang/elixir/blob/v1.10/CHANGELOG.md#4-hard-deprecations\n[v1.11]: https://github.com/elixir-lang/elixir/blob/v1.11/CHANGELOG.md#4-hard-deprecations\n[v1.12]: https://github.com/elixir-lang/elixir/blob/v1.12/CHANGELOG.md#4-hard-deprecations\n[v1.13]: https://github.com/elixir-lang/elixir/blob/v1.13/CHANGELOG.md#4-hard-deprecations\n[v1.14]: https://github.com/elixir-lang/elixir/blob/v1.14/CHANGELOG.md#4-hard-deprecations\n[v1.15]: https://github.com/elixir-lang/elixir/blob/v1.15/CHANGELOG.md#4-hard-deprecations\n[v1.16]: https://github.com/elixir-lang/elixir/blob/v1.16/CHANGELOG.md#4-hard-deprecations\n[v1.17]: https://github.com/elixir-lang/elixir/blob/v1.17/CHANGELOG.md#4-hard-deprecations","ref":"compatibility-and-deprecations.html#table-of-deprecations"},{"type":"extras","title":"Gradual set-theoretic types","doc":"# Gradual set-theoretic types\n\nElixir is in the process of incorporating set-theoretic types into the compiler. This document outlines the current stage of our implementation.\n\nThe current milestone aims to infer types from patterns and guards and use them to type check programs, enabling the Elixir compiler to find faults and bugs in codebases without requiring changes to existing software. The underlying principles, theory, and roadmap of our work have been outlined in [\"The Design Principles of the Elixir Type System\" by Giuseppe Castagna, Guillaume Duboc, José Valim](https://arxiv.org/abs/2306.06391).","ref":"gradual-set-theoretic-types.html"},{"type":"extras","title":"Supported types - Gradual set-theoretic types","doc":"At the moment, Elixir developers will interact with set-theoretic types only through warnings found by the type system. All data types in the language are modelled:\n\n  * `binary()`, `integer()`, `float()`, `pid()`, `port()`, `reference()` - these types are indivisible. This means both `1` and `13` get the same `integer()` type.\n\n  * `atom()` - it represents all atoms and it is divisible. For instance, the atom `:foo` and `:hello_world` are also valid (distinct) types.\n\n  * `map()` and structs - maps can be \"closed\" or \"open\". Closed maps only allow the specified keys, such as `%{key: atom(), value: integer()}`. Open maps support any other keys in addition to the ones listed and their definition starts with `...`, such as `%{..., key: atom(), value: integer()}`. Structs are closed maps with the `__struct__` key.\n\n  * `tuple()`, `list()`, and `function()` - currently they are modelled as indivisible types. The next Elixir versions will also introduce fine-grained types here.","ref":"gradual-set-theoretic-types.html#supported-types"},{"type":"extras","title":"Set operations - Gradual set-theoretic types","doc":"We can compose set-theoretic types by using set operations (hence the name). For example, to say a function returns either atoms or integers, one could write: `atom() or integer()`.\n\nIntersections are available via the `and` operator, such as `atom() and integer()`, which in this case it becomes the empty set `none()`. `term()` is the union of all types, also known as the \"top\" type.\n\nIntersections are useful when modelling functions. For example, imagine the following function:\n\n```elixir\ndef negate(x) when is_integer(x), do: -x\ndef negate(x) when is_boolean(x), do: not x\n```\n\nIf you give it an integer, it negates it. If you give it a boolean, it negates it.\n\nWe can say this function has the type `(integer() -> integer())` because it is capable of receiving an integer and returning an integer. In this case, `(integer() -> integer())` is a set that represents all functions that can receive an integer and return an integer. Even though this function can receive other arguments and return other values, it is still part of the `(integer() -> integer())` set.\n\nThis function also has the type `(boolean() -> boolean())`, because it receives the booleans and returns booleans. Therefore, we can say the overall type of the function is `(integer() -> integer()) and (boolean() -> boolean())`. The intersection means the function belongs to both sets.\n\nAt this point, some may ask, why not a union? As a real-world example, take a t-shirt with green and yellow stripes. We can say the t-shirt belongs to the set of \"t-shirts with green color\". We can also say the t-shirt belongs to the set of \"t-shirts with yellow color\". Let's see the difference between unions and intersections:\n\n  * `(t_shirts_with_green() or t_shirts_with_yellow())` - contains t-shirts with either green or yellow, such as green, green and red, green and yellow, yellow, yellow and red, etc.\n\n  * `(t_shirts_with_green() and t_shirts_with_yellow())` - contains t-shirts with both green and yellow (and also other colors)\n\nSince the t-shirt has both colors, we say it belongs to the intersection of both sets. The same way that a function that goes from `(integer() -> integer())` and `(boolean() -> boolean())` is also an intersection. In practice, it does not make sense to define the union of two functions in Elixir, so the compiler will always point to the right direction.\n\nFinally, we can also negate types by using `not`. For example, to express all atoms, except the atoms `:foo` and `:bar`, one can write: `atom() and not (:foo or :bar)`.","ref":"gradual-set-theoretic-types.html#set-operations"},{"type":"extras","title":"The `dynamic()` type - Gradual set-theoretic types","doc":"Existing Elixir programs do not have type declarations, but we still want to be able to type check them. This is done with the introduction of the `dynamic()` type.\n\nWhen Elixir sees the following function:\n\n```elixir\ndef negate(x) when is_integer(x), do: -x\ndef negate(x) when is_boolean(x), do: not x\n```\n\nElixir type checks it as if the function had the type `(dynamic() -> dynamic())`. We say `dynamic()` is a gradual type, which leads us to *gradual set-theoretic types*.\n\nThe simplest way to reason about `dynamic()` in Elixir is that it is a range of types. If you have a type `atom() or integer()`, the underlying code needs to work with both `atom() or integer()`. For example, if you call `Integer.to_string(var)`, and `var` has type `atom() or integer()`, the type system will emit a warning, because `Integer.to_string/1` does not accept atoms.\n\nHowever, by intersecting a type with `dynamic()`, we make the type gradual and therefore only a subset of the type needs to be valid. For instance, if you call `Integer.to_string(var)`, and `var` has type `dynamic() and (atom() or integer())`, the type system will not emit a warning, because `Integer.to_string/1` works with at least one of the types. For convenience, most programs will write `dynamic(atom() or integer())` instead of the intersection. They are equivalent.\n\nCompared to other gradually typed languages, the `dynamic()` type in Elixir is quite powerful: it restricts our program to certain types, via intersections, while still emitting warnings once it is certain the code will fail. This makes `dynamic()` an excellent tool for typing existing Elixir code with meaningful warnings.\n\nOnce Elixir introduces typed function signatures, typed Elixir programs will behave as a statically typed code, unless the `dynamic()` type is used. This brings us to one last remark about dynamic types in Elixir: dynamic types are always at the root. For example, when you write a tuple of type `{:ok, dynamic()}`, Elixir will rewrite it to `dynamic({:ok, term()})`. While this has the downside that you cannot make part of a tuple/map/list gradual, only the whole tuple/map/list, it comes with the upside that dynamic is always explicitly at the root, making it harder to accidentally sneak `dynamic()` in a statically typed program.","ref":"gradual-set-theoretic-types.html#the-dynamic-type"},{"type":"extras","title":"Roadmap - Gradual set-theoretic types","doc":"The current milestone is to implement type inference and type checking of Elixir programs without changes to the Elixir language. At this stage, we want to collect feedback on the quality of error messages and performance, and therefore the type system has no user facing API.\n\nIf the results are satisfactory, the next milestone will include a mechanism for defining typed structs. Elixir programs frequently pattern match on structs, which reveals information about the struct fields, but it knows nothing about their respective types. By propagating types from structs and their fields throughout the program, we will increase the type system’s ability to find errors while further straining our type system implementation. Proposals including the required changes to the language surface will be sent to the community once we reach this stage.\n\nThe third milestone is to introduce set-theoretic type signatures for functions. Unfortunately, the existing Erlang Typespecs are not precise enough for set-theoretic types and they will be phased out of the language and have their postprocessing moved into a separate library once this stage concludes.","ref":"gradual-set-theoretic-types.html#roadmap"},{"type":"extras","title":"Acknowledgements - Gradual set-theoretic types","doc":"The type system was made possible thanks to a partnership between  [CNRS](https://www.cnrs.fr/) and [Remote](https://remote.com/). The research was partially supported by [Supabase](https://supabase.com/) and [Fresha](https://www.fresha.com/). The development work is sponsored by [Fresha](https://www.fresha.com/), [Starfish*](https://starfish.team/), and [Dashbit](https://dashbit.co/).","ref":"gradual-set-theoretic-types.html#acknowledgements"},{"type":"extras","title":"Library guidelines","doc":"# Library guidelines\n\nThis document outlines general guidelines for those writing and publishing\nElixir libraries meant to be consumed by other developers.","ref":"library-guidelines.html"},{"type":"extras","title":"Getting started - Library guidelines","doc":"You can create a new Elixir library by running the `mix new` command:\n\n    $ mix new my_library\n\nThe project name is given in the `snake_case` convention where all letters are lowercase and words are separate with underscores. This is the same convention used by variables, function names and atoms in Elixir. See the [Naming Conventions](naming-conventions.md) document for more information.\n\nEvery project has a `mix.exs` file, with instructions on how to build, compile, run tests, and so on. Libraries commonly have a `lib` directory, which includes Elixir source code, and a `test` directory. A `src` directory may also exist for Erlang sources.\n\nThe `mix new` command also allows the `--sup` option to scaffold a new project with a supervision tree out of the box. For more information on running your project, see the official [Mix & OTP guide](../mix-and-otp/introduction-to-mix.md) or [Mix documentation](`Mix`).","ref":"library-guidelines.html#getting-started"},{"type":"extras","title":"Publishing - Library guidelines","doc":"Writing code is only the first of many steps to publish a package. We strongly recommend developers to:\n\n  * Choose a versioning schema. Elixir requires versions to be in the format `MAJOR.MINOR.PATCH` but the meaning of those numbers is up to you. Most projects choose [Semantic Versioning](https://semver.org/).\n\n  * Choose a [license](https://choosealicense.com/). The most common licenses in the Elixir community are the [MIT License](https://choosealicense.com/licenses/mit/) and the [Apache License 2.0](https://choosealicense.com/licenses/apache-2.0/). The latter is also the one used by Elixir itself.\n\n  * Run the [code formatter](`mix format`). The code formatter formats your code according to a consistent style shared by your library and the whole community, making it easier for other developers to understand your code and contribute.\n\n  * Write tests. Elixir ships with a test-framework named [ExUnit](`ExUnit`). The project generated by `mix new` includes sample tests and doctests.\n\n  * Write documentation. The Elixir community is proud of treating documentation as a first-class citizen and making documentation easily accessible. Libraries contribute to the status quo by providing complete API documentation with examples for their modules, types and functions. See the [Writing documentation](../getting-started/writing-documentation.md) chapter of the Getting Started guide for more information. Projects like [ExDoc](https://github.com/elixir-lang/ex_doc) can be used to generate HTML and EPUB documents from the documentation. ExDoc also supports \"extra pages\", like this one that you are reading. Such pages augment the documentation with tutorials, guides, references, and even cheat-sheets.\n\n  * Follow best practices. The Elixir project documents [a series of anti-patterns](../anti-patterns/what-anti-patterns.md) that you may want to avoid in your code. The [process-related anti-patterns](../anti-patterns/process-anti-patterns.md) and [meta-programming anti-patterns](../anti-patterns/macro-anti-patterns.md) are of special attention to library authors.\n\nProjects are often made available to other developers [by publishing a Hex package](https://hex.pm/docs/publish). Hex also [supports private packages for organizations](https://hex.pm/pricing). If ExDoc is configured for the Mix project, publishing a package on Hex will also automatically publish the generated documentation to [HexDocs](https://hexdocs.pm).","ref":"library-guidelines.html#publishing"},{"type":"extras","title":"Dependency handling - Library guidelines","doc":"When your library is published and used as a dependency, its [lockfile](https://hexdocs.pm/mix/Mix.Project.html#module-configuration) (usually named `mix.lock`) is _ignored by the host project_. Running `mix deps.get` in the host project attempts to get the latest possible versions of your library’s dependencies, as specified by the requirements in the `deps` section of your `mix.exs`. These versions might be greater than those stored in your `mix.lock` (and hence used in your tests / CI).\n\nOn the other hand, contributors of your library, need a deterministic build, which implies the presence of `mix.lock` in your Version Control System (VCS).\n\nThe best practice of handling `mix.lock` file therefore would be to keep it in VCS, and run two different Continuous Integration (CI) workflows: the usual deterministic one, and another one, that starts with `mix deps.unlock --all` and always compiles your library and runs tests against latest versions of dependencies. The latter one might be even run nightly or otherwise recurrently to stay notified about any possible issue in regard to dependencies updates.","ref":"library-guidelines.html#dependency-handling"},{"type":"extras","title":"Naming conventions","doc":"# Naming conventions\n\nThis document is a reference of the naming conventions in Elixir, from casing to punctuation characters.\n\nThe naming convention is, by definition, a subset of the Elixir syntax. A convention aims to\nfollow and set best practices for language and the community. If instead you want a complete reference into the Elixir syntax, beyond its conventions, see [the Syntax reference](syntax-reference.md).","ref":"naming-conventions.html"},{"type":"extras","title":"Casing - Naming conventions","doc":"Elixir developers must use `snake_case` when defining variables, function names, module attributes, and the like:\n\n    some_map = %{this_is_a_key: \"and a value\"}\n    is_map(some_map)\n\nAliases, commonly used as module names, are an exception as they must be capitalized and written in `CamelCase`, like `OptionParser`. For aliases, capital letters are kept in acronyms, like `ExUnit.CaptureIO` or `Mix.SCM`.\n\nAtoms can be written either in `:snake_case` or `:CamelCase`, although the convention is to use the snake case version throughout Elixir.\n\nGenerally speaking, filenames follow the `snake_case` convention of the module they define. For example, `MyApp` should be defined inside the `my_app.ex` file. However, this is only a convention. At the end of the day any filename can be used as they do not affect the compiled code in any way.","ref":"naming-conventions.html#casing"},{"type":"extras","title":"Underscore (`_foo`) - Naming conventions","doc":"Elixir relies on underscores in different situations.\n\nFor example, a value that is not meant to be used must be assigned to `_` or to a variable starting with underscore:\n\n    iex> {:ok, _contents} = File.read(\"README.md\")\n\nFunction names may also start with an underscore. Such functions are never imported by default:\n\n    iex> defmodule Example do\n    ...>   def _wont_be_imported do\n    ...>     :oops\n    ...>   end\n    ...> end\n\n    iex> import Example\n    iex> _wont_be_imported()\n    ** (CompileError) iex:1: undefined function _wont_be_imported/0\n\nDue to this property, Elixir relies on functions starting with underscore to attach compile-time metadata to modules. Such functions are most often in the `__foo__` format. For example, every module in Elixir has an [`__info__/1`](`c:Module.__info__/1`) function:\n\n    iex> String.__info__(:functions)\n    [at: 2, capitalize: 1, chunk: 2, ...]\n\nElixir also includes five special forms that follow the double underscore format: `__CALLER__/0`, `__DIR__/0`, `__ENV__/0`and `__MODULE__/0` retrieve compile-time information about the current environment, while `__STACKTRACE__/0` retrieves the stacktrace for the current exception.","ref":"naming-conventions.html#underscore-_foo"},{"type":"extras","title":"Trailing bang (`foo!`) - Naming conventions","doc":"A trailing bang (exclamation mark) signifies a function or macro where failure cases raise an exception.\n\nMany functions come in pairs, such as `File.read/1` and `File.read!/1`. `File.read/1` will return a success or failure tuple, whereas `File.read!/1` will return a plain value or else raise an exception:\n\n    iex> File.read(\"file.txt\")\n    {:ok, \"file contents\"}\n    iex> File.read(\"no_such_file.txt\")\n    {:error, :enoent}\n\n    iex> File.read!(\"file.txt\")\n    \"file contents\"\n    iex> File.read!(\"no_such_file.txt\")\n    ** (File.Error) could not read file no_such_file.txt: no such file or directory\n\nThe version without `!` is preferred when you want to handle different outcomes using pattern matching:\n\n    case File.read(file) do\n      {:ok, body} -> # do something with the `body`\n      {:error, reason} -> # handle the error caused by `reason`\n    end\n\nHowever, if you expect the outcome to always be successful (for instance, if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure.\n\nWhen thinking about failure cases for functions, we are thinking strictly about errors that happen within their domain, such as failing to open a file. Errors that come from invalid argument types, for example, must always raise regardless if the function has a bang or not. The exception is often an `ArgumentError` or a detailed `FunctionClauseError`:\n\n    iex(1)> File.read(123)\n    ** (FunctionClauseError) no function clause matching in IO.chardata_to_string/1\n\n        The following arguments were given to IO.chardata_to_string/1:\n\n            # 1\n            123\n\n        Attempted function clauses (showing 2 out of 2):\n\n            def chardata_to_string(string) when is_binary(string)\n            def chardata_to_string(list) when is_list(list)\n\nMore examples of paired functions: `Base.decode16/2` and `Base.decode16!/2`, `File.cwd/0` and `File.cwd!/0`.\n\nThere are also some non-paired functions, with no non-bang variant. The bang still signifies that it will raise an exception on failure. Example: `Protocol.assert_protocol!/1`.\n\nIn macro code, the bang on `alias!/1` and `var!/2` signifies that [macro hygiene](../meta-programming/macros.md#macro-hygiene) is set aside.","ref":"naming-conventions.html#trailing-bang-foo"},{"type":"extras","title":"Trailing question mark (`foo?`) - Naming conventions","doc":"Functions that return a boolean are named with a trailing question mark.\n\nExamples: `Keyword.keyword?/1`, `Mix.debug?/0`, `String.contains?/2`\n\nHowever, functions that return booleans and are valid in guards follow another convention, described next.\n\n## `is_` prefix (`is_foo`)\n\nType checks and other boolean checks that are allowed in guard clauses are named with an `is_` prefix.\n\nExamples: `Integer.is_even/1`, `is_list/1`\n\nThese functions and macros follow the Erlang convention of an `is_` prefix, instead of a trailing question mark, precisely to indicate that they are allowed in guard clauses.\n\nNote that type checks that are not valid in guard clauses do not follow this convention. For example: `Keyword.keyword?/1`.","ref":"naming-conventions.html#trailing-question-mark-foo"},{"type":"extras","title":"Special names - Naming conventions","doc":"Some names have specific meaning in Elixir. We detail those cases below.","ref":"naming-conventions.html#special-names"},{"type":"extras","title":"length and size - Naming conventions","doc":"When you see `size` in a function name, it means the operation runs in constant time (also written as \"O(1) time\") because the size is stored alongside the data structure.\n\nExamples: `map_size/1`, `tuple_size/1`\n\nWhen you see `length`, the operation runs in linear time (\"O(n) time\") because the entire data structure has to be traversed.\n\nExamples: `length/1`, `String.length/1`\n\nIn other words, functions using the word \"size\" in its name will take the same amount of time whether the data structure is tiny or huge. Conversely, functions having \"length\" in its name will take more time as the data structure grows in size.","ref":"naming-conventions.html#length-and-size"},{"type":"extras","title":"get, fetch, fetch! - Naming conventions","doc":"When you see the functions `get`, `fetch`, and `fetch!` for key-value data structures, you can expect the following behaviours:\n\n  * `get` returns a default value (which itself defaults to `nil`) if the key is not present, or returns the requested value.\n  * `fetch` returns `:error` if the key is not present, or returns `{:ok, value}` if it is.\n  * `fetch!` *raises* if the key is not present, or returns the requested value.\n\nExamples: `Map.get/2`, `Map.fetch/2`, `Map.fetch!/2`, `Keyword.get/2`, `Keyword.fetch/2`, `Keyword.fetch!/2`","ref":"naming-conventions.html#get-fetch-fetch"},{"type":"extras","title":"compare - Naming conventions","doc":"The function `compare/2` should return `:lt` if the first term is less than the second, `:eq` if the two\nterms compare as equivalent, or `:gt` if the first term is greater than the second.\n\nExamples: `DateTime.compare/2`\n\nNote that this specific convention is important due to the expectations of `Enum.sort/2`","ref":"naming-conventions.html#compare"},{"type":"extras","title":"Operators reference","doc":"# Operators reference\n\nThis document is a complete reference of operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden.","ref":"operators.html"},{"type":"extras","title":"Operator precedence and associativity - Operators reference","doc":"The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity:\n\nOperator                                       | Associativity\n---------------------------------------------- | -------------\n`@`                                            | Unary\n`.`                                            | Left\n`+` `-` `!` `^` `not`                          | Unary\n`**`                                           | Left\n`*` `/`                                        | Left\n`+` `-`                                        | Left\n`++` `--` `+++` `---` `..` `<>`                | Right\n`in` `not in`                                  | Left\n`\\|>` `<<<` `>>>` `<<~` `~>>` `<~` `~>` `<~>`  | Left\n`<` `>` `<=` `>=`                              | Left\n`==` `!=` `=~` `===` `!==`                     | Left\n`&&` `&&&` `and`                               | Left\n`\\|\\|` `\\|\\|\\|` `or`                           | Left\n`=`                                            | Right\n`&`, `...`                                     | Unary\n`=>` (valid only inside `%{}`)                 | Right\n`\\|`                                           | Right\n`::`                                           | Right\n`when`                                         | Right\n`<-` `\\\\`                                      | Left","ref":"operators.html#operator-precedence-and-associativity"},{"type":"extras","title":"General operators - Operators reference","doc":"Elixir provides the following built-in operators:\n\n  * [`+`](`+/1`) and [`-`](`-/1`) - unary positive/negative\n  * [`+`](`+/2`), [`-`](`-/2`), [`*`](`*/2`), and [`/`](`//2`) - basic arithmetic operations\n  * [`++`](`++/2`) and [`--`](`--/2`) - list concatenation and subtraction\n  * [`and`](`and/2`) and [`&&`](`&&/2`) - strict and relaxed boolean \"and\"\n  * [`or`](`or/2`) and [`||`](`||/2`) - strict and relaxed boolean \"or\"\n  * [`not`](`not/1`) and [`!`](`!/1`) - strict and relaxed boolean \"not\"\n  * [`in`](`in/2`) and [`not in`](`in/2`) - membership\n  * [`@`](`@/1`) - module attribute\n  * [`..`](`../0`), [`..`](`../2`), and [`..//`](`..///3`) - range creation\n  * [`<>`](`<>/2`) - binary concatenation\n  * [`|>`](`|>/2`) - pipeline\n  * [`=~`](`=~/2`) - text-based match\n\nMany of those can be used in guards; consult the [list of allowed guard functions and operators](patterns-and-guards.md#list-of-allowed-functions-and-operators).\n\nAdditionally, there are a few other operators that Elixir parses but doesn't actually use.\nSee [Custom and overridden operators](#custom-and-overridden-operators) below for a list and for guidelines about their use.\n\nSome other operators are special forms and cannot be overridden:\n\n  * [`^`](`^/1`) - pin operator\n  * [`.`](`./2`) - dot operator\n  * [`=`](`=/2`) - match operator\n  * [`&`](`&/1`) - capture operator\n  * [`::`](`::/2`) - type operator\n\nFinally, these operators appear in the precedence table above but are only meaningful within certain constructs:\n\n  * `=>` - see [`%{}`](`%{}/1`)\n  * `when` - see [Guards](patterns-and-guards.md#guards)\n  * `<-` - see [`for`](`for/1`) and [`with`](`with/1`)\n  * `\\\\` - see [Default arguments](`Kernel#def/2-default-arguments`)","ref":"operators.html#general-operators"},{"type":"extras","title":"Comparison operators - Operators reference","doc":"Elixir provides the following built-in comparison operators (all of which can be used in guards):\n\n  * [`==`](`==/2`) - equal to\n  * [`===`](`===/2`) - strictly equal to\n  * [`!=`](`!=/2`) - not equal to\n  * [`!==`](`!==/2`) - strictly not equal to\n  * [`<`](`</2`) - less-than\n  * [`>`](`>/2`) - greater-than\n  * [`<=`](`<=/2`) - less-than or equal to\n  * [`>=`](`>=/2`) - greater-than or equal to\n\nThe only difference between [`==`](`==/2`) and [`===`](`===/2`) is that [`===`](`===/2`) is strict when it comes to comparing integers and floats:\n\n```elixir\niex> 1 == 1.0\ntrue\niex> 1 === 1.0\nfalse\n```\n\n[`!=`](`!=/2`) and [`!==`](`!==/2`) act as the negation of [`==`](`==/2`) and [`===`](`===/2`), respectively.","ref":"operators.html#comparison-operators"},{"type":"extras","title":"Custom and overridden operators - Operators reference","doc":"","ref":"operators.html#custom-and-overridden-operators"},{"type":"extras","title":"Defining custom operators - Operators reference","doc":"Elixir is capable of parsing a predefined set of operators. It's not possible to define new operators (as supported by some languages). However, not all operators that Elixir can parse are *used* by Elixir: for example, `+` and `||` are used by Elixir for addition and boolean *or*, but `<~>` is not used (but valid).\n\nTo define an operator, you can use the usual `def*` constructs (`def`, `defp`, `defmacro`, and so on) but with a syntax similar to how the operator is used:\n\n```elixir\ndefmodule MyOperators do\n  # We define ~> to return the maximum of the given two numbers,\n  # and <~ to return the minimum.\n\n  def a ~> b, do: max(a, b)\n  def a <~ b, do: min(a, b)\nend\n```\n\nTo use the newly defined operators, you **have to** import the module that defines them:\n\n```elixir\niex> import MyOperators\niex> 1 ~> 2\n2\niex> 1 <~ 2\n1\n```\n\nThe following is a table of all the operators that Elixir is capable of parsing, but that are not used by default:\n\n  * `|||`\n  * `&&&`\n  * `<<<`\n  * `>>>`\n  * `<<~`\n  * `~>>`\n  * `<~`\n  * `~>`\n  * `<~>`\n  * `+++`\n  * `---`\n\nThe following operators are used by the `Bitwise` module when imported: [`&&&`](`Bitwise.&&&/2`), [`<<<`](`Bitwise.<<</2`), [`>>>`](`Bitwise.>>>/2`), and [`|||`](`Bitwise.|||/2`). See the `Bitwise` documentation for more information.\n\nNote that the Elixir community generally discourages custom operators. They can be hard to read and even more to understand, as they don't have a descriptive name like functions do. That said, some specific cases or custom domain specific languages (DSLs) may justify these practices.\n\nIt is also possible to replace predefined operators, such as `+`, but doing so is extremely discouraged.","ref":"operators.html#defining-custom-operators"},{"type":"extras","title":"Patterns and guards","doc":"# Patterns and guards\n\nElixir provides pattern matching, which allows us to assert on the shape or extract values from data structures. Patterns are often augmented with guards, which give developers the ability to perform more complex checks, albeit limited.\n\nThis document provides a complete reference on patterns and guards, their semantics, where they are allowed, and how to extend them.","ref":"patterns-and-guards.html"},{"type":"extras","title":"Patterns - Patterns and guards","doc":"Patterns in Elixir are made of variables, literals, and data structure specific syntax. One of the most used constructs to perform pattern matching is the match operator ([`=`](`=/2`)):\n\n```iex\niex> x = 1\n1\niex> 1 = x\n1\n```\n\nIn the example above, `x` starts without a value and has `1` assigned to it. Then, we compare the value of `x` to the literal `1`, which succeeds as they are both `1`.\n\nMatching `x` against 2 would raise:\n\n```iex\niex> 2 = x\n** (MatchError) no match of right hand side value: 1\n```\n\nPatterns are not bidirectional. If you have a variable `y` that was never assigned to (often called an unbound variable) and you write `1 = y`, an error will be raised:\n\n```iex\niex> 1 = y\n** (CompileError) iex:2: undefined variable \"y\"\n```\n\nIn other words, patterns are allowed only on the left side of `=`. The right side of `=` follows the regular evaluation semantics of the language.\n\nNow let's cover the pattern matching rules for each construct and then for each relevant data types.","ref":"patterns-and-guards.html#patterns"},{"type":"extras","title":"Variables - Patterns and guards","doc":"Variables in patterns are always assigned to:\n\n```iex\niex> x = 1\n1\niex> x = 2\n2\niex> x\n2\n```\n\nIn other words, Elixir supports rebinding. In case you don't want the value of a variable to change, you can use the pin operator (`^`):\n\n```iex\niex> x = 1\n1\niex> ^x = 2\n** (MatchError) no match of right hand side value: 2\n```\n\nIf the same variable appears multiple times in the same pattern, then all of them must be bound to the same value:\n\n```iex\niex> {x, x} = {1, 1}\n{1, 1}\niex> {x, x} = {1, 2}\n** (MatchError) no match of right hand side value: {1, 2}\n```\n\nThe underscore variable (`_`) has a special meaning as it can never be bound to any value. It is especially useful when you don't care about certain value in a pattern:\n\n```iex\niex> {_, integer} = {:not_important, 1}\n{:not_important, 1}\niex> integer\n1\niex> _\n** (CompileError) iex:3: invalid use of _\n```","ref":"patterns-and-guards.html#variables"},{"type":"extras","title":"Literals (numbers and atoms) - Patterns and guards","doc":"Atoms and numbers (integers and floats) can appear in patterns and they are always represented as is. For example, an atom will only match an atom if they are the same atom:\n\n```iex\niex> :atom = :atom\n:atom\niex> :atom = :another_atom\n** (MatchError) no match of right hand side value: :another_atom\n```\n\nSimilar rule applies to numbers. Finally, note that numbers in patterns perform strict comparison. In other words, integers to do not match floats:\n\n```iex\niex> 1 = 1.0\n** (MatchError) no match of right hand side value: 1.0\n```","ref":"patterns-and-guards.html#literals-numbers-and-atoms"},{"type":"extras","title":"Tuples - Patterns and guards","doc":"Tuples may appear in patterns using the curly brackets syntax (`{}`). A tuple in a pattern will match only tuples of the same size, where each individual tuple element must also match:\n\n```iex\niex> {:ok, integer} = {:ok, 13}\n{:ok, 13}\n\n# won't match due to different size\niex> {:ok, integer} = {:ok, 11, 13}\n** (MatchError) no match of right hand side value: {:ok, 11, 13}\n\n# won't match due to mismatch on first element\niex> {:ok, binary} = {:error, :enoent}\n** (MatchError) no match of right hand side value: {:error, :enoent}\n```","ref":"patterns-and-guards.html#tuples"},{"type":"extras","title":"Lists - Patterns and guards","doc":"Lists may appear in patterns using the square brackets syntax (`[]`). A list in a pattern will match only lists of the same size, where each individual list element must also match:\n\n```iex\niex> [:ok, integer] = [:ok, 13]\n[:ok, 13]\n\n# won't match due to different size\niex> [:ok, integer] = [:ok, 11, 13]\n** (MatchError) no match of right hand side value: [:ok, 11, 13]\n\n# won't match due to mismatch on first element\niex> [:ok, binary] = [:error, :enoent]\n** (MatchError) no match of right hand side value: [:error, :enoent]\n```\n\nOpposite to tuples, lists also allow matching on non-empty lists by using the `[head | tail]` notation, which matches on the `head` and `tail` of a list:\n\n```iex\niex> [head | tail] = [1, 2, 3]\n[1, 2, 3]\niex> head\n1\niex> tail\n[2, 3]\n```\n\nMultiple elements may prefix the `| tail` construct:\n\n```iex\niex> [first, second | tail] = [1, 2, 3]\n[1, 2, 3]\niex> tail\n[3]\n```\n\nNote `[head | tail]` does not match empty lists:\n\n```elixir\niex> [head | tail] = []\n** (MatchError) no match of right hand side value: []\n```\n\nGiven charlists are represented as a list of integers, one can also perform prefix matches on charlists using the list concatenation operator ([`++`](`++/2`)):\n\n```elixir\niex> ~c\"hello \" ++ world = ~c\"hello world\"\n~c\"hello world\"\niex> world\n~c\"world\"\n```\n\nWhich is equivalent to matching on `[?h, ?e, ?l, ?l, ?o, ?\\s | world]`. Suffix matches (`hello ++ ~c\" world\"`) are not valid patterns.","ref":"patterns-and-guards.html#lists"},{"type":"extras","title":"Maps - Patterns and guards","doc":"Maps may appear in patterns using the percentage sign followed by the curly brackets syntax (`%{}`). Opposite to lists and tuples, maps perform a subset match. This means a map pattern will match any other map that has at least all of the keys in the pattern.\n\nHere is an example where all keys match:\n\n```iex\niex> %{name: name} = %{name: \"meg\"}\n%{name: \"meg\"}\niex> name\n\"meg\"\n```\n\nHere is when a subset of the keys match:\n\n```iex\niex> %{name: name} = %{name: \"meg\", age: 23}\n%{age: 23, name: \"meg\"}\niex> name\n\"meg\"\n```\n\nIf a key in the pattern is not available in the map, then they won't match:\n\n```iex\niex> %{name: name, age: age} = %{name: \"meg\"}\n** (MatchError) no match of right hand side value: %{name: \"meg\"}\n```\n\nNote that the empty map will match all maps, which is a contrast to tuples and lists, where an empty tuple or an empty list will only match empty tuples and empty lists respectively:\n\n```iex\niex> %{} = %{name: \"meg\"}\n%{name: \"meg\"}\n```\n\nFinally, note map keys in patterns must always be literals or previously bound variables matched with the pin operator.","ref":"patterns-and-guards.html#maps"},{"type":"extras","title":"Structs - Patterns and guards","doc":"Structs may appear in patterns using the percentage sign, the struct module name or a variable followed by the curly brackets syntax (`%{}`).\n\nGiven the following struct:\n\n```elixir\ndefmodule User do\n  defstruct [:name]\nend\n```\n\nHere is an example where all keys match:\n\n```iex\niex> %User{name: name} = %User{name: \"meg\"}\n%User{name: \"meg\"}\niex> name\n\"meg\"\n```\n\nIf an unknown key is given, the compiler will raise an error:\n\n```iex\niex> %User{type: type} = %User{name: \"meg\"}\n** (CompileError) iex: unknown key :type for struct User\n```\n\nThe struct name can be extracted when putting a variable instead of a module name:\n\n```elixir\niex> %struct_name{} = %User{name: \"meg\"}\n%User{name: \"meg\"}\niex> struct_name\nUser\n```","ref":"patterns-and-guards.html#structs"},{"type":"extras","title":"Binaries - Patterns and guards","doc":"Binaries may appear in patterns using the double less-than/greater-than syntax ([`<<>>`](`<<>>/1`)). A binary in a pattern can match multiple segments at the same time, each with different type, size, and unit:\n\n```iex\niex> < > = <<123, 56>>\n\"{8\"\niex> val\n31544\n```\n\nSee the documentation for [`<<>>`](`<<>>/1`) for a complete definition of pattern matching for binaries.\n\nFinally, remember that strings in Elixir are UTF-8 encoded binaries. This means that, similar to charlists, prefix matches on strings are also possible with the binary concatenation operator ([`<>`](`<>/2`)):\n\n```elixir\niex> \"hello \" <> world = \"hello world\"\n\"hello world\"\niex> world\n\"world\"\n```\n\nSuffix matches (`hello <> \" world\"`) are not valid patterns.","ref":"patterns-and-guards.html#binaries"},{"type":"extras","title":"Guards - Patterns and guards","doc":"Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed, such as function definitions, case clauses, and others.\n\nNot all expressions are allowed in guard clauses, but only a handful of them. This is a deliberate choice. This way, Elixir (through Erlang) ensures that all guards are predictable (no mutations or other side-effects) and they can be optimized and performed efficiently.","ref":"patterns-and-guards.html#guards"},{"type":"extras","title":"List of allowed functions and operators - Patterns and guards","doc":"You can find the built-in list of guards [in the `Kernel` module](`Kernel#guards`). Here is an overview:\n\n  * comparison operators ([`==`](`==/2`), [`!=`](`!=/2`), [`===`](`===/2`), [`!==`](`!==/2`),\n    [`<`](`</2`), [`<=`](`<=/2`), [`>`](`>/2`), [`>=`](`>=/2`))\n  * strictly boolean operators ([`and`](`and/2`), [`or`](`or/2`), [`not`](`not/1`)). Note [`&&`](`&&/2`), [`||`](`||/2`), and [`!`](`!/1`) sibling operators are **not allowed** as they're not *strictly* boolean - meaning they don't require arguments to be booleans\n  * arithmetic unary operators ([`+`](`+/1`), [`-`](`-/1`))\n  * arithmetic binary operators ([`+`](`+/2`), [`-`](`-/2`), [`*`](`*/2`), [`/`](`//2`))\n  * [`in`](`in/2`) and [`not in`](`in/2`) operators (as long as the right-hand side is a list or a range)\n  * \"type-check\" functions (`is_list/1`, `is_number/1`, and the like)\n  * functions that work on built-in data types (`abs/1`, `hd/1`, `map_size/1`, and others)\n  * the `map.field` syntax\n\nThe module `Bitwise` also includes a handful of [Erlang bitwise operations as guards](Bitwise.html#guards).\n\nMacros constructed out of any combination of the above guards are also valid guards - for example, `Integer.is_even/1`. For more information, see the \"Custom patterns and guards expressions\" section shown below.","ref":"patterns-and-guards.html#list-of-allowed-functions-and-operators"},{"type":"extras","title":"Why guards - Patterns and guards","doc":"Let's see an example of a guard used in a function clause:\n\n```elixir\ndef empty_map?(map) when map_size(map) == 0, do: true\ndef empty_map?(map) when is_map(map), do: false\n```\n\nGuards start with the `when` operator, followed by a guard expression. The clause will be executed if and only if the guard expression returns `true`. Multiple boolean conditions can be combined with the [`and`](`and/2`) and [`or`](`or/2`) operators.\n\nWriting the `empty_map?/1` function by only using pattern matching would not be possible (as pattern matching on `%{}` would match *any* map, not only the empty ones).","ref":"patterns-and-guards.html#why-guards"},{"type":"extras","title":"Non-passing guards - Patterns and guards","doc":"A function clause will be executed if and only if its guard expression evaluates to `true`. If any other value is returned, the function clause will be skipped. In particular, guards have no concept of \"truthy\" or \"falsy\".\n\nFor example, imagine a function that checks that the head of a list is not `nil`:\n\n```elixir\ndef not_nil_head?([head | _]) when head, do: true\ndef not_nil_head?(_), do: false\n\nnot_nil_head?([\"some_value\", \"another_value\"])\n#=> false\n```\n\nEven though the head of the list is not `nil`, the first clause for `not_nil_head?/1` fails because the expression does not evaluate to `true`, but to `\"some_value\"`, therefore triggering the second clause which returns `false`. To make the guard behave correctly, you must ensure that the guard evaluates to `true`, like so:\n\n```elixir\ndef not_nil_head?([head | _]) when head != nil, do: true\ndef not_nil_head?(_), do: false\n\nnot_nil_head?([\"some_value\", \"another_value\"])\n#=> true\n```","ref":"patterns-and-guards.html#non-passing-guards"},{"type":"extras","title":"Errors in guards - Patterns and guards","doc":"In guards, when functions would normally raise exceptions, they cause the guard to fail instead.\n\nFor example, the `tuple_size/1` function only works with tuples. If we use it with anything else, an argument error is raised:\n\n```elixir\niex> tuple_size(\"hello\")\n** (ArgumentError) argument error\n```\n\nHowever, when used in guards, the corresponding clause will fail to match instead of raising an error:\n\n```elixir\niex> case \"hello\" do\n...>   something when tuple_size(something) == 2 ->\n...>     :worked\n...>   _anything_else ->\n...>     :failed\n...> end\n:failed\n```\n\nIn many cases, we can take advantage of this. In the code above, we used `tuple_size/1` to both check that the given value is a tuple *and* check its size (instead of using `is_tuple(something) and tuple_size(something) == 2`).\n\nHowever, if your guard has multiple conditions, such as checking for tuples or maps, it is best to call type-check functions like `is_tuple/1` before `tuple_size/1`, otherwise the whole guard will fail if a tuple is not given. Alternatively, your function clause can use multiple guards as shown in the following section.","ref":"patterns-and-guards.html#errors-in-guards"},{"type":"extras","title":"Multiple guards in the same clause - Patterns and guards","doc":"There exists an additional way to simplify a chain of `or` expressions in guards: Elixir supports writing \"multiple guards\" in the same clause. The following code:\n\n```elixir\ndef is_number_or_nil(term) when is_integer(term) or is_float(term) or is_nil(term),\n  do: :maybe_number\ndef is_number_or_nil(_other),\n  do: :something_else\n```\n\ncan be alternatively written as:\n\n```elixir\ndef is_number_or_nil(term)\n    when is_integer(term)\n    when is_float(term)\n    when is_nil(term) do\n  :maybe_number\nend\n\ndef is_number_or_nil(_other) do\n  :something_else\nend\n```\n\nIf each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. To illustrate this, the following function will not detect empty tuples:\n\n```elixir\ndefmodule Check do\n  # If given a tuple, map_size/1 will raise, and tuple_size/1 will not be evaluated\n  def empty?(val) when map_size(val) == 0 or tuple_size(val) == 0, do: true\n  def empty?(_val), do: false\nend\n\nCheck.empty?(%{})\n#=> true\n\nCheck.empty?({})\n#=> false # true was expected!\n```\n\nThis could be corrected by ensuring that no exception is raised, either via type checks like `is_map(val) and map_size(val) == 0`, or by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated.\n\n```elixir\ndefmodule Check do\n  # If given a tuple, map_size/1 will raise, and the second guard will be evaluated\n  def empty?(val)\n      when map_size(val) == 0\n      when tuple_size(val) == 0,\n      do: true\n\n  def empty?(_val), do: false\nend\n\nCheck.empty?(%{})\n#=> true\n\nCheck.empty?({})\n#=> true\n```","ref":"patterns-and-guards.html#multiple-guards-in-the-same-clause"},{"type":"extras","title":"Where patterns and guards can be used - Patterns and guards","doc":"In the examples above, we have used the match operator ([`=`](`=/2`)) and function clauses to showcase patterns and guards respectively. Here is the list of the built-in constructs in Elixir that support patterns and guards.\n\n  * `match?/2`:\n\n    ```elixir\n    match?({:ok, value} when value > 0, {:ok, 13})\n    ```\n\n  * function clauses:\n\n    ```elixir\n    def type(term) when is_integer(term), do: :integer\n    def type(term) when is_float(term), do: :float\n    ```\n\n  * [`case`](`case/2`) expressions:\n\n    ```elixir\n    case x do\n      1 -> :one\n      2 -> :two\n      n when is_integer(n) and n > 2 -> :larger_than_two\n    end\n    ```\n\n  * anonymous functions (`fn/1`):\n\n    ```elixir\n    larger_than_two? = fn\n      n when is_integer(n) and n > 2 -> true\n      n when is_integer(n) -> false\n    end\n    ```\n\n  * [`for`](`for/1`) and [`with`](`with/1`) support patterns and guards on the left side of `<-`:\n\n    ```elixir\n    for x when x >= 0 <- [1, -2, 3, -4], do: x\n    ```\n\n    `with` also supports the `else` keyword, which supports patterns matching and guards.\n\n  * [`try`](`try/1`) supports patterns and guards on `catch` and `else`\n\n  * [`receive`](`receive/1`) supports patterns and guards to match on the received messages.\n\n  * custom guards can also be defined with `defguard/1` and `defguardp/1`. A custom guard can only be defined based on existing guards.\n\nNote that the match operator ([`=`](`=/2`)) does *not* support guards:\n\n```elixir\n{:ok, binary} = File.read(\"some/file\")\n```","ref":"patterns-and-guards.html#where-patterns-and-guards-can-be-used"},{"type":"extras","title":"Custom patterns and guards expressions - Patterns and guards","doc":"Only the constructs listed in this page are allowed in patterns and guards. However, we can take advantage of macros to write custom patterns guards that can simplify our programs or make them more domain-specific. At the end of the day, what matters is that the *output* of the macros boils down to a combination of the constructs above.\n\nFor example, the `Record` module in Elixir provides a series of macros to be used in patterns and guards that allows tuples to have named fields during compilation.\n\nFor defining your own guards, Elixir even provides conveniences in `defguard` and `defguardp`. Let's look at a quick case study: we want to check whether an argument is an even or an odd integer. With pattern matching this is impossible because there is an infinite number of integers, and therefore we can't pattern match on every single one of them. Therefore we must use guards. We will just focus on checking for even numbers since checking for the odd ones is almost identical.\n\nSuch a guard would look like this:\n\n```elixir\ndef my_function(number) when is_integer(number) and rem(number, 2) == 0 do\n  # do stuff\nend\n```\n\nIt would be repetitive to write every time we need this check. Instead, you can use `defguard/1` and `defguardp/1` to create guard macros. Here's an example how:\n\n```elixir\ndefmodule MyInteger do\n  defguard is_even(term) when is_integer(term) and rem(term, 2) == 0\nend\n```\n\nand then:\n\n```elixir\nimport MyInteger, only: [is_even: 1]\n\ndef my_function(number) when is_even(number) do\n  # do stuff\nend\n```\n\nWhile it's possible to create custom guards with macros, it's recommended to define them using `defguard/1` and `defguardp/1` which perform additional compile-time checks.","ref":"patterns-and-guards.html#custom-patterns-and-guards-expressions"},{"type":"extras","title":"Syntax reference","doc":"# Syntax reference\n\nElixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). This means the Elixir syntax is mostly uniform with a handful of \"syntax sugar\" constructs to reduce the noise in common Elixir idioms.\n\nThis document covers all of Elixir syntax constructs as a reference and then discuss their exact AST representation.","ref":"syntax-reference.html"},{"type":"extras","title":"Reserved words - Syntax reference","doc":"These are the reserved words in the Elixir language. They are detailed throughout this guide but summed up here for convenience:\n\n  * `true`, `false`, `nil` - used as atoms\n  * `when`, `and`, `or`, `not`, `in` - used as operators\n  * `fn` - used for anonymous function definitions\n  * `do`, `end`, `catch`, `rescue`, `after`, `else` - used in do-end blocks","ref":"syntax-reference.html#reserved-words"},{"type":"extras","title":"Data types - Syntax reference","doc":"","ref":"syntax-reference.html#data-types"},{"type":"extras","title":"Numbers - Syntax reference","doc":"Integers (`1234`) and floats (`123.4`) in Elixir are represented as a sequence of digits that may be separated by underscore for readability purposes, such as `1_000_000`. Integers never contain a dot (`.`) in their representation. Floats contain a dot and at least one other digit after the dot. Floats also support the scientific notation, such as `123.4e10` or `123.4E10`.","ref":"syntax-reference.html#numbers"},{"type":"extras","title":"Atoms - Syntax reference","doc":"Unquoted atoms start with a colon (`:`) which must be immediately followed by a Unicode letter or an underscore. The atom may continue using a sequence of Unicode letters, numbers, underscores, and `@`. Atoms may end in `!` or `?`. Valid unquoted atoms are: `:ok`, `:ISO8601`, and `:integer?`.\n\nIf the colon is immediately followed by a pair of double- or single-quotes surrounding the atom name, the atom is considered quoted. In contrast with an unquoted atom, this one can be made of any Unicode character (not only letters), such as `:'🌢 Elixir'`, `:\"++olá++\"`, and `:\"123\"`.\n\nQuoted and unquoted atoms with the same name are considered equivalent, so `:atom`, `:\"atom\"`, and `:'atom'` represent the same atom. The only catch is that the compiler will warn when quotes are used in atoms that do not need to be quoted.\n\nAll operators in Elixir are also valid atoms. Valid examples are `:foo`, `:FOO`, `:foo_42`, `:foo@bar`, and `:++`. Invalid examples are `:@foo` (`@` is not allowed at start), `:123` (numbers are not allowed at start), and `:(*)` (not a valid operator).\n\n`true`, `false`, and `nil` are reserved words that are represented by the atoms `:true`, `:false` and `:nil` respectively.\n\nTo learn more about all Unicode characters allowed in atom, see the [Unicode syntax](unicode-syntax.md) document.","ref":"syntax-reference.html#atoms"},{"type":"extras","title":"Strings - Syntax reference","doc":"Single-line strings in Elixir are written between double-quotes, such as `\"foo\"`. Any double-quote inside the string must be escaped with `\\ `. Strings support Unicode characters and are stored as UTF-8 encoded binaries.\n\nMulti-line strings in Elixir are written with three double-quotes, and can have unescaped quotes within them. The resulting string will end with a newline. The indentation of the last `\"\"\"` is used to strip indentation from the inner string. For example:\n\n```elixir\niex> test = \"\"\"\n...>     this\n...>     is\n...>     a\n...>     test\n...> \"\"\"\n\"    this\\n    is\\n    a\\n    test\\n\"\niex> test = \"\"\"\n...>     This\n...>     Is\n...>     A\n...>     Test\n...>     \"\"\"\n\"This\\nIs\\nA\\nTest\\n\"\n```\n\nStrings are always represented as themselves in the AST.","ref":"syntax-reference.html#strings"},{"type":"extras","title":"Charlists - Syntax reference","doc":"Charlists in Elixir are written in single-quotes, such as `'foo'`. Any single-quote inside the string must be escaped with `\\ `. Charlists are made of non-negative integers, where each integer represents a Unicode code point.\n\nMulti-line charlists are written with three single-quotes (`'''`), the same way multi-line strings are.\n\nCharlists are always represented as themselves in the AST.\n\nFor more in-depth information, please read the \"Charlists\" section in the `List` module.","ref":"syntax-reference.html#charlists"},{"type":"extras","title":"Lists, tuples and binaries - Syntax reference","doc":"Data structures such as lists, tuples, and binaries are marked respectively by the delimiters `[...]`, `{...}`, and `<<...>>`. Each element is separated by comma. A trailing comma is also allowed, such as in `[1, 2, 3,]`.","ref":"syntax-reference.html#lists-tuples-and-binaries"},{"type":"extras","title":"Maps and keyword lists - Syntax reference","doc":"Maps use the `%{...}` notation and each key-value is given by pairs marked with `=>`, such as `%{\"hello\" => 1, 2 => \"world\"}`.\n\nBoth keyword lists (list of two-element tuples where the first element is atom) and maps with atom keys support a keyword notation where the colon character `:` is moved to the end of the atom. `%{hello: \"world\"}` is equivalent to `%{:hello => \"world\"}` and `[foo: :bar]` is equivalent to `[{:foo, :bar}]`. This notation is a syntax sugar that emits the same AST representation. It will be explained in later sections.","ref":"syntax-reference.html#maps-and-keyword-lists"},{"type":"extras","title":"Structs - Syntax reference","doc":"Structs built on the map syntax by passing the struct name between `%` and `{`. For example, `%User{...}`.","ref":"syntax-reference.html#structs"},{"type":"extras","title":"Expressions - Syntax reference","doc":"","ref":"syntax-reference.html#expressions"},{"type":"extras","title":"Variables - Syntax reference","doc":"Variables in Elixir must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The variable may continue using a sequence of Unicode letters, numbers, and underscores. Variables may end in `?` or `!`. To learn more about all Unicode characters allowed in variables, see the [Unicode syntax](unicode-syntax.md) document.\n\n[Elixir's naming conventions](naming-conventions.md) recommend variables to be in `snake_case` format.","ref":"syntax-reference.html#variables"},{"type":"extras","title":"Non-qualified calls (local calls) - Syntax reference","doc":"Non-qualified calls, such as `add(1, 2)`, must start with characters and then follow the same rules as variables, which are optionally followed by parentheses, and then arguments.\n\nParentheses are required for zero-arity calls (i.e. calls without arguments), to avoid ambiguity with variables. If parentheses are used, they must immediately follow the function name *without spaces*. For example, `add (1, 2)` is a syntax error, since `(1, 2)` is treated as an invalid block which is attempted to be given as a single argument to `add`.\n\n[Elixir's naming conventions](naming-conventions.md) recommend calls to be in `snake_case` format.","ref":"syntax-reference.html#non-qualified-calls-local-calls"},{"type":"extras","title":"Operators - Syntax reference","doc":"As many programming languages, Elixir also support operators as non-qualified calls with their precedence and associativity rules. Constructs such as `=`, `when`, `&` and `@` are simply treated as operators. See [the Operators page](operators.md) for a full reference.","ref":"syntax-reference.html#operators"},{"type":"extras","title":"Qualified calls (remote calls) - Syntax reference","doc":"Qualified calls, such as `Math.add(1, 2)`, must start with characters and then follow the same rules as variables, which are optionally followed by parentheses, and then arguments. Qualified calls also support operators, such as `Kernel.+(1, 2)`. Elixir also allows the function name to be written between double- or single-quotes, allowing any character in between the quotes, such as `Math.\"++add++\"(1, 2)`.\n\nSimilar to non-qualified calls, parentheses have different meaning for zero-arity calls (i.e. calls without arguments). If parentheses are used, such as `mod.fun()`, it means a function call. If parenthesis are skipped, such as `map.field`, it means accessing a field of a map.\n\n[Elixir's naming conventions](naming-conventions.md) recommend calls to be in `snake_case` format.","ref":"syntax-reference.html#qualified-calls-remote-calls"},{"type":"extras","title":"Aliases - Syntax reference","doc":"Aliases are constructs that expand to atoms at compile-time. The alias `String` expands to the atom `:\"Elixir.String\"`. Aliases must start with an ASCII uppercase character which may be followed by any ASCII letter, number, or underscore. Non-ASCII characters are not supported in aliases.\n\nMultiple aliases can be joined with `.`, such as `MyApp.String`, and it expands to the atom `:\"Elixir.MyApp.String\"`. The dot is effectively part of the name but it can also be used for composition. If you define `alias MyApp.Example, as: Example` in your code, then `Example` will always expand to `:\"Elixir.MyApp.Example\"` and `Example.String` will expand to `:\"Elixir.MyApp.Example.String\"`.\n\n[Elixir's naming conventions](naming-conventions.md) recommend aliases to be in `CamelCase` format.","ref":"syntax-reference.html#aliases"},{"type":"extras","title":"Module attributes - Syntax reference","doc":"Module attributes are module-specific storage and are written as the composition of the unary operator `@` with variables and local calls. For example, to write to a module attribute named `foo`, use `@foo \"value\"`, and use `@foo` to read from it. Given module attributes are written using existing constructs, they follow the same rules above defined for operators, variables, and local calls.","ref":"syntax-reference.html#module-attributes"},{"type":"extras","title":"Blocks - Syntax reference","doc":"Blocks are multiple Elixir expressions separated by newlines or semi-colons. A new block may be created at any moment by using parentheses.","ref":"syntax-reference.html#blocks"},{"type":"extras","title":"Left to right arrow - Syntax reference","doc":"The left to right arrow (`->`) is used to establish a relationship between left and right, commonly referred as clauses. The left side may have zero, one, or more arguments; the right side is zero, one, or more expressions separated by new line. The `->` may appear one or more times between one of the following terminators: `do`-`end`, `fn`-`end` or `(`-`)`. When `->` is used, only other clauses are allowed between those terminators. Mixing clauses and regular expressions is invalid syntax.\n\nIt is seen on `case` and `cond` constructs between `do` and `end`:\n\n```elixir\ncase 1 do\n  2 -> 3\n  4 -> 5\nend\n\ncond do\n  true -> false\nend\n```\n\nSeen in typespecs between `(` and `)`:\n\n```elixir\n(integer(), boolean() -> integer())\n```\n\nIt is also used between `fn` and `end` for building anonymous functions:\n\n```elixir\nfn\n  x, y -> x + y\nend\n```","ref":"syntax-reference.html#left-to-right-arrow"},{"type":"extras","title":"Sigils - Syntax reference","doc":"Sigils start with `~` and are followed by one lowercase letter or by one or more uppercase letters, immediately followed by one of the following pairs:\n\n  * `(` and `)`\n  * `{` and `}`\n  * `[` and `]`\n  * `<` and `>`\n  * `\"` and `\"`\n  * `'` and `'`\n  * `|` and `|`\n  * `/` and `/`\n\nAfter closing the pair, zero or more ASCII letters and digits can be given as a modifier. Sigils are expressed as non-qualified calls prefixed with `sigil_` where the first argument is the sigil contents as a string and the second argument is a list of integers as modifiers:\n\nIf the sigil letter is in uppercase, no interpolation is allowed in the sigil, otherwise its contents may be dynamic. Compare the results of the sigils below for more information:\n\n```elixir\n~s/f#{\"o\"}o/\n~S/f#{\"o\"}o/\n```\n\nSigils are useful to encode text with their own escaping rules, such as regular expressions, datetimes, and others.","ref":"syntax-reference.html#sigils"},{"type":"extras","title":"The Elixir AST - Syntax reference","doc":"Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). Elixir's AST is a regular Elixir data structure composed of the following elements:\n\n  * atoms - such as `:foo`\n  * integers - such as `42`\n  * floats - such as `13.1`\n  * strings - such as `\"hello\"`\n  * lists - such as `[1, 2, 3]`\n  * tuples with two elements - such as `{\"hello\", :world}`\n  * tuples with three elements, representing calls or variables, as explained next\n\nThe building block of Elixir's AST is a call, such as:\n\n```elixir\nsum(1, 2, 3)\n```\n\nwhich is represented as a tuple with three elements:\n\n```elixir\n{:sum, meta, [1, 2, 3]}\n```\n\nthe first element is an atom (or another tuple), the second element is a list of two-element tuples with metadata (such as line numbers) and the third is a list of arguments.\n\nWe can retrieve the AST for any Elixir expression by calling `quote`:\n\n```elixir\nquote do\n  sum()\nend\n#=> {:sum, [], []}\n```\n\nVariables are also represented using a tuple with three elements and a combination of lists and atoms, for example:\n\n```elixir\nquote do\n  sum\nend\n#=> {:sum, [], Elixir}\n```\n\nYou can see that variables are also represented with a tuple, except the third element is an atom expressing the variable context.\n\nOver the course of this section, we will explore many Elixir syntax constructs alongside their AST representations.","ref":"syntax-reference.html#the-elixir-ast"},{"type":"extras","title":"Operators - Syntax reference","doc":"Operators are treated as non-qualified calls:\n\n```elixir\nquote do\n  1 + 2\nend\n#=> {:+, [], [1, 2]}\n```\n\nNote that `.` is also an operator. Remote calls use the dot in the AST with two arguments, where the second argument is always an atom:\n\n```elixir\nquote do\n  foo.bar(1, 2, 3)\nend\n#=> {{:., [], [{:foo, [], Elixir}, :bar]}, [], [1, 2, 3]}\n```\n\nCalling anonymous functions uses the dot in the AST with a single argument, mirroring the fact the function name is \"missing\" from right side of the dot:\n\n```elixir\nquote do\n  foo.(1, 2, 3)\nend\n#=> {{:., [], [{:foo, [], Elixir}]}, [], [1, 2, 3]}\n```","ref":"syntax-reference.html#operators"},{"type":"extras","title":"Aliases - Syntax reference","doc":"Aliases are represented by an `__aliases__` call with each segment separated by a dot as an argument:\n\n```elixir\nquote do\n  Foo.Bar.Baz\nend\n#=> {:__aliases__, [], [:Foo, :Bar, :Baz]}\n\nquote do\n  __MODULE__.Bar.Baz\nend\n#=> {:__aliases__, [], [{:__MODULE__, [], Elixir}, :Bar, :Baz]}\n```\n\nAll arguments, except the first, are guaranteed to be atoms.","ref":"syntax-reference.html#aliases"},{"type":"extras","title":"Data structures - Syntax reference","doc":"Remember that lists are literals, so they are represented as themselves in the AST:\n\n```elixir\nquote do\n  [1, 2, 3]\nend\n#=> [1, 2, 3]\n```\n\nTuples have their own representation, except for two-element tuples, which are represented as themselves:\n\n```elixir\nquote do\n  {1, 2}\nend\n#=> {1, 2}\n\nquote do\n  {1, 2, 3}\nend\n#=> {:{}, [], [1, 2, 3]}\n```\n\nBinaries have a representation similar to tuples, except they are tagged with `:<<>>` instead of `:{}`:\n\n```elixir\nquote do\n  <<1, 2, 3>>\nend\n#=> {:<<>>, [], [1, 2, 3]}\n```\n\nThe same applies to maps, where pairs are treated as a list of tuples with two elements:\n\n```elixir\nquote do\n  %{1 => 2, 3 => 4}\nend\n#=> {:%{}, [], [{1, 2}, {3, 4}]}\n```","ref":"syntax-reference.html#data-structures"},{"type":"extras","title":"Blocks - Syntax reference","doc":"Blocks are represented as a `__block__` call with each line as a separate argument:\n\n```elixir\nquote do\n  1\n  2\n  3\nend\n#=> {:__block__, [], [1, 2, 3]}\n\nquote do 1; 2; 3; end\n#=> {:__block__, [], [1, 2, 3]}\n```","ref":"syntax-reference.html#blocks"},{"type":"extras","title":"Left to right arrow - Syntax reference","doc":"The left to right arrow (`->`) is represented similar to operators except that they are always part of a list, its left side represents a list of arguments and the right side is an expression.\n\nFor example, in `case` and `cond`:\n\n```elixir\nquote do\n  case 1 do\n    2 -> 3\n    4 -> 5\n  end\nend\n#=> {:case, [], [1, [do: [{:->, [], [[2], 3]}, {:->, [], [[4], 5]}]]]}\n\nquote do\n  cond do\n    true -> false\n  end\nend\n#=> {:cond, [], [[do: [{:->, [], [[true], false]}]]]}\n```\n\nBetween `(` and `)`:\n\n```elixir\nquote do\n  (1, 2 -> 3\n   4, 5 -> 6)\nend\n#=> [{:->, [], [[1, 2], 3]}, {:->, [], [[4, 5], 6]}]\n```\n\nBetween `fn` and `end`:\n\n```elixir\nquote do\n  fn\n    1, 2 -> 3\n    4, 5 -> 6\n  end\nend\n#=> {:fn, [], [{:->, [], [[1, 2], 3]}, {:->, [], [[4, 5], 6]}]}\n```","ref":"syntax-reference.html#left-to-right-arrow"},{"type":"extras","title":"Qualified tuples - Syntax reference","doc":"Qualified tuples (`foo.{bar, baz}`) are represented by a `{:., [], [expr, :{}]}` call, where the `expr` represents the left hand side of the dot, and the arguments represent the elements inside the curly braces. This is used in Elixir to provide multi aliases:\n\n```elixir\nquote do\n  Foo.{Bar, Baz}\nend\n#=> {{:., [], [{:__aliases__, [], [:Foo]}, :{}]}, [], [{:__aliases__, [], [:Bar]}, {:__aliases__, [], [:Baz]}]}\n```","ref":"syntax-reference.html#qualified-tuples"},{"type":"extras","title":"Optional syntax - Syntax reference","doc":"All of the constructs above are part of Elixir's syntax and have their own representation as part of the Elixir AST. This section will discuss the remaining constructs that are alternative representations of the constructs above. In other words, the constructs below can be represented in more than one way in your Elixir code and retain AST equivalence. We call this \"Optional Syntax\".\n\nFor a lightweight introduction to Elixir's Optional Syntax, [see this document](../getting-started/optional-syntax.md). Below we continue with a more complete reference.","ref":"syntax-reference.html#optional-syntax"},{"type":"extras","title":"Integers in other bases and Unicode code points - Syntax reference","doc":"Elixir allows integers to contain `_` to separate digits and provides conveniences to represent integers in other bases:\n\n```elixir\n1_000_000\n#=> 1000000\n\n0xABCD\n#=> 43981 (Hexadecimal base)\n\n0o01234567\n#=> 342391 (Octal base)\n\n0b10101010\n#=> 170 (Binary base)\n\n?é\n#=> 233 (Unicode code point)\n```\n\nThose constructs exist only at the syntax level. All of the examples above are represented as their underlying integers in the AST.","ref":"syntax-reference.html#integers-in-other-bases-and-unicode-code-points"},{"type":"extras","title":"Access syntax - Syntax reference","doc":"The access syntax is represented as a call to `Access.get/2`:\n\n```elixir\nquote do\n  opts[arg]\nend\n#=> {{:., [], [Access, :get]}, [], [{:opts, [], Elixir}, {:arg, [], Elixir}]}\n```","ref":"syntax-reference.html#access-syntax"},{"type":"extras","title":"Optional parentheses - Syntax reference","doc":"Elixir provides optional parentheses on local and remote calls with one or more arguments:\n\n```elixir\nquote do\n  sum 1, 2, 3\nend\n#=> {:sum, [], [1, 2, 3]}\n```\n\nThe above is treated the same as `sum(1, 2, 3)` by the parser. You can remove the parentheses on all calls with at least one argument.\n\nYou can also skip parentheses on qualified calls, such as `Foo.bar 1, 2, 3`. Parentheses are required when invoking anonymous functions, such as `f.(1, 2, 3)`.\n\nIn practice, developers prefer to add parentheses to most of their calls. They are skipped mainly in Elixir's control-flow constructs, such as `defmodule`, `if`, `case`, etc, and in certain DSLs.","ref":"syntax-reference.html#optional-parentheses"},{"type":"extras","title":"Keywords - Syntax reference","doc":"Keywords in Elixir are a list of tuples of two elements, where the first element is an atom. Using the base constructs, they would be represented as:\n\n```elixir\n[{:foo, 1}, {:bar, 2}]\n```\n\nHowever, Elixir introduces a syntax sugar where the keywords above may be written as follows:\n\n```elixir\n[foo: 1, bar: 2]\n```\n\nAtoms with foreign characters, such as whitespace, must be wrapped in quotes. This rule applies to keywords as well:\n\n```elixir\n[{:\"foo bar\", 1}, {:\"bar baz\", 2}] == [\"foo bar\": 1, \"bar baz\": 2]\n```\n\nRemember that, because lists and two-element tuples are quoted literals, by definition keywords are also literals (in fact, the only reason tuples with two elements are quoted literals is to support keywords as literals).\n\nIn order to be valid keyword syntax, `:` cannot be preceded by any whitespace (`foo : 1` is invalid) and has to be followed by whitespace (`foo:1` is invalid).","ref":"syntax-reference.html#keywords"},{"type":"extras","title":"Keywords as last arguments - Syntax reference","doc":"Elixir also supports a syntax where if the last argument of a call is a keyword list then the square brackets can be skipped. This means that the following:\n\n```elixir\nif(condition, do: this, else: that)\n```\n\nis the same as\n\n```elixir\nif(condition, [do: this, else: that])\n```\n\nwhich in turn is the same as\n\n```elixir\nif(condition, [{:do, this}, {:else, that}])\n```\n\n### `do`-`end` blocks\n\nThe last syntax convenience are `do`-`end` blocks. `do`-`end` blocks are equivalent to keywords as the last argument of a function call, where the block contents are wrapped in parentheses. For example:\n\n```elixir\nif true do\n  this\nelse\n  that\nend\n```\n\nis the same as:\n\n```elixir\nif(true, do: (this), else: (that))\n```\n\nwhich we have explored in the previous section.\n\nParentheses are important to support multiple expressions. This:\n\n```elixir\nif true do\n  this\n  that\nend\n```\n\nis the same as:\n\n```elixir\nif(true, do: (\n  this\n  that\n))\n```\n\nInside `do`-`end` blocks you may introduce other keywords, such as `else` used in the `if` above. The supported keywords between `do`-`end` are static and are:\n\n  * `after`\n  * `catch`\n  * `else`\n  * `rescue`\n\nYou can see them being used in constructs such as `receive`, `try`, and others.","ref":"syntax-reference.html#keywords-as-last-arguments"},{"type":"extras","title":"Typespecs reference","doc":"# Typespecs reference\n\nElixir comes with a notation for declaring types and specifications. This document is a\nreference into their uses and syntax.\n\nElixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because:\n\n  * they provide documentation (for example, tools such as [`ExDoc`](https://hexdocs.pm/ex_doc/) show type specifications in the documentation)\n  * they're used by tools such as [Dialyzer](`:dialyzer`), that can analyze code with typespecs to find type inconsistencies and possible bugs\n\nType specifications (most often referred to as *typespecs*) are defined in different contexts using the following attributes:\n\n  * `@type`\n  * `@opaque`\n  * `@typep`\n  * `@spec`\n  * `@callback`\n  * `@macrocallback`\n\nIn addition, you can use `@typedoc` to document a custom `@type` definition.\n\nSee the \"User-defined types\" and \"Defining a specification\" sub-sections below for more information on defining types and typespecs.","ref":"typespecs.html"},{"type":"extras","title":"A simple example - Typespecs reference","doc":"defmodule StringHelpers do\n      @typedoc \"A word from the dictionary\"\n      @type word() :: String.t()\n\n      @spec long_word?(word()) :: boolean()\n      def long_word?(word) when is_binary(word) do\n        String.length(word) > 8\n      end\n    end\n\nIn the example above:\n\n  * We declare a new type (`word()`) that is equivalent to the string type (`String.t()`).\n\n  * We describe the type using a `@typedoc`, which will be included in the generated documentation.\n\n  * We specify that the `long_word?/1` function takes an argument of type `word()` and\n    returns a boolean (`boolean()`), that is, either `true` or `false`.","ref":"typespecs.html#a-simple-example"},{"type":"extras","title":"Types and their syntax - Typespecs reference","doc":"The syntax Elixir provides for type specifications is similar to [the one in Erlang](https://www.erlang.org/doc/reference_manual/typespec.html). Most of the built-in types provided in Erlang (for example, `pid()`) are expressed in the same way: `pid()` (or simply `pid`). Parameterized types (such as `list(integer)`) are supported as well and so are remote types (such as [`Enum.t()`](`t:Enum.t/0`)). Integers and atom literals are allowed as types (for example, `1`, `:atom`, or `false`). All other types are built out of unions of predefined types. Some types can also be declared using their syntactical notation, such as `[type]` for lists, `{type1, type2, ...}` for tuples and `<<_ * _>>` for binaries.\n\nThe notation to represent the union of types is the pipe `|`. For example, the typespec `type :: atom() | pid() | tuple()` creates a type `type` that can be either an `atom`, a `pid`, or a `tuple`. This is usually called a [sum type](https://en.wikipedia.org/wiki/Tagged_union) in other languages","ref":"typespecs.html#types-and-their-syntax"},{"type":"extras","title":"Basic types - Typespecs reference","doc":"type ::\n          any()                     # the top type, the set of all terms\n          | none()                  # the bottom type, contains no terms\n          | atom()\n          | map()                   # any map\n          | pid()                   # process identifier\n          | port()                  # port identifier\n          | reference()\n          | tuple()                 # tuple of any size","ref":"typespecs.html#basic-types"},{"type":"extras","title":"Numbers - Typespecs reference","doc":"| float()\n          | integer()\n          | neg_integer()           # ..., -3, -2, -1\n          | non_neg_integer()       # 0, 1, 2, 3, ...\n          | pos_integer()           # 1, 2, 3, ...","ref":"typespecs.html#numbers"},{"type":"extras","title":"Lists - Typespecs reference","doc":"| list(type)                                                    # proper list ([]-terminated)\n          | nonempty_list(type)                                           # non-empty proper list\n          | maybe_improper_list(content_type, termination_type)           # proper or improper list\n          | nonempty_improper_list(content_type, termination_type)        # improper list\n          | nonempty_maybe_improper_list(content_type, termination_type)  # non-empty proper or improper list\n\n          | Literals                # Described in section \"Literals\"\n          | BuiltIn                 # Described in section \"Built-in types\"\n          | Remotes                 # Described in section \"Remote types\"\n          | UserDefined             # Described in section \"User-defined types\"","ref":"typespecs.html#lists"},{"type":"extras","title":"Literals - Typespecs reference","doc":"The following literals are also supported in typespecs:\n\n    type ::","ref":"typespecs.html#literals"},{"type":"extras","title":"Atoms - Typespecs reference","doc":":atom                           # atoms: :foo, :bar, ...\n          | true | false | nil            # special atom literals","ref":"typespecs.html#atoms"},{"type":"extras","title":"Bitstrings - Typespecs reference","doc":"| <<>>                          # empty bitstring\n          | <<_::size>>                   # size is 0 or a positive integer\n          | <<_::_*unit>>                 # unit is an integer from 1 to 256\n          | <<_::size, _::_*unit>>\n\n                                          ## (Anonymous) Functions\n          | (-> type)                     # zero-arity, returns type\n          | (type1, type2 -> type)        # two-arity, returns type\n          | (... -> type)                 # any arity, returns type","ref":"typespecs.html#bitstrings"},{"type":"extras","title":"Integers - Typespecs reference","doc":"| 1                             # integer\n          | 1..10                         # integer from 1 to 10","ref":"typespecs.html#integers"},{"type":"extras","title":"Lists - Typespecs reference","doc":"| [type]                        # list with any number of type elements\n          | []                            # empty list\n          | [...]                         # shorthand for nonempty_list(any())\n          | [type, ...]                   # shorthand for nonempty_list(type)\n          | [key: value_type]             # keyword list with optional key :key of value_type","ref":"typespecs.html#lists"},{"type":"extras","title":"Maps - Typespecs reference","doc":"| %{}                                   # empty map\n          | %{key: value_type}                    # map with required key :key of value_type\n          | %{key_type => value_type}             # map with required pairs of key_type and value_type\n          | %{required(key_type) => value_type}   # map with required pairs of key_type and value_type\n          | %{optional(key_type) => value_type}   # map with optional pairs of key_type and value_type\n          | %SomeStruct{}                         # struct with all fields of any type\n          | %SomeStruct{key: value_type}          # struct with required key :key of value_type","ref":"typespecs.html#maps"},{"type":"extras","title":"Tuples - Typespecs reference","doc":"| {}                            # empty tuple\n          | {:ok, type}                   # two-element tuple with an atom and any type","ref":"typespecs.html#tuples"},{"type":"extras","title":"Built-in types - Typespecs reference","doc":"The following types are also provided by Elixir as shortcuts on top of the basic and literal types described above.\n\nBuilt-in type           | Defined as\n:---------------------- | :---------\n`term()`                | `any()`\n`arity()`               | `0..255`\n`as_boolean(t)`         | `t`\n`binary()`              | `<<_::_*8>>`\n`nonempty_binary()`     | `<<_::8, _::_*8>>`\n`bitstring()`           | `<<_::_*1>>`\n`nonempty_bitstring()`  | `<<_::1, _::_*1>>`\n`boolean()`             | `true` \\| `false`\n`byte()`                | `0..255`\n`char()`                | `0..0x10FFFF`\n`charlist()`            | `[char()]`\n`nonempty_charlist()`   | `[char(), ...]`\n`fun()`                 | `(... -> any)`\n`function()`            | `fun()`\n`identifier()`          | `pid()` \\| `port()` \\| `reference()`\n`iodata()`              | `iolist()` \\| `binary()`\n`iolist()`              | `maybe_improper_list(byte() \\| binary() \\| iolist(), binary() \\| [])`\n`keyword()`             | `[{atom(), any()}]`\n`keyword(t)`            | `[{atom(), t}]`\n`list()`                | `[any()]`\n`nonempty_list()`       | `nonempty_list(any())`\n`maybe_improper_list()` | `maybe_improper_list(any(), any())`\n`nonempty_maybe_improper_list()` | `nonempty_maybe_improper_list(any(), any())`\n`mfa()`                 | `{module(), atom(), arity()}`\n`module()`              | `atom()`\n`no_return()`           | `none()`\n`node()`                | `atom()`\n`number()`              | `integer()` \\| `float()`\n`struct()`              | `%{:__struct__ => atom(), optional(atom()) => any()}`\n`timeout()`             | `:infinity` \\| `non_neg_integer()`\n\n`as_boolean(t)` exists to signal users that the given value will be treated as a boolean, where `nil` and `false` will be evaluated as `false` and everything else is `true`. For example, `Enum.filter/2` has the following specification: `filter(t, (element -> as_boolean(term))) :: list`.","ref":"typespecs.html#built-in-types"},{"type":"extras","title":"Remote types - Typespecs reference","doc":"Any module is also able to define its own types and the modules in Elixir are no exception. For example, the `Range` module defines a `t/0` type that represents a range: this type can be referred to as `t:Range.t/0`. In a similar fashion, a string is `t:String.t/0`, and so on.","ref":"typespecs.html#remote-types"},{"type":"extras","title":"Maps - Typespecs reference","doc":"The key types in maps are allowed to overlap, and if they do, the leftmost key takes precedence.\nA map value does not belong to this type if it contains a key that is not in the allowed map keys.\n\nIf you want to denote that keys that were not previously defined in the map are allowed,\nit is common to end a map type with `optional(any) => any`.\n\nNote that the syntactic representation of `map()` is `%{optional(any) => any}`, not `%{}`. The notation `%{}` specifies the singleton type for the empty map.","ref":"typespecs.html#maps"},{"type":"extras","title":"Keyword Lists - Typespecs reference","doc":"Beyond `keyword()` and `keyword(t)`, it can be helpful to compose a spec for an expected keyword list.\nFor example:\n\n```elixir\n@type option :: {:name, String.t} | {:max, pos_integer} | {:min, pos_integer}\n@type options :: [option()]\n```\n\nThis makes it clear that only these options are allowed, none are required, and order does not matter.\n\nIt also allows composition with existing types.\nFor example:\n\n```elixir\n@type option :: {:my_option, String.t()} | GenServer.option()\n\n@spec start_link([option()]) :: GenServer.on_start()\ndef start_link(opts) do\n  {my_opts, gen_server_opts} = Keyword.split(opts, [:my_option])\n  GenServer.start_link(__MODULE__, my_opts, gen_server_opts)\nend\n```\n\nThe following spec syntaxes are equivalent:\n\n```elixir\n@type options [{:name, String.t} | {:max, pos_integer} | {:min, pos_integer}]\n\n@type options [name: String.t, max: pos_integer, min: pos_integer]\n```","ref":"typespecs.html#keyword-lists"},{"type":"extras","title":"User-defined types - Typespecs reference","doc":"The `@type`, `@typep`, and `@opaque` module attributes can be used to define new types:\n\n    @type type_name :: type\n    @typep type_name :: type\n    @opaque type_name :: type\n\nA type defined with `@typep` is private. An opaque type, defined with `@opaque` is a type where the internal structure of the type will not be visible, but the type is still public.\n\nTypes can be parameterized by defining variables as parameters; these variables can then be used to define the type.\n\n    @type dict(key, value) :: [{key, value}]","ref":"typespecs.html#user-defined-types"},{"type":"extras","title":"Defining a specification - Typespecs reference","doc":"A specification for a function can be defined as follows:\n\n    @spec function_name(type1, type2) :: return_type\n\nGuards can be used to restrict type variables given as arguments to the function.\n\n    @spec function(arg) :: [arg] when arg: atom\n\nIf you want to specify more than one variable, you separate them by a comma.\n\n    @spec function(arg1, arg2) :: {arg1, arg2} when arg1: atom, arg2: integer\n\nType variables with no restriction can also be defined using `var`.\n\n    @spec function(arg) :: [arg] when arg: var\n\nThis guard notation only works with `@spec`, `@callback`, and `@macrocallback`.\n\nYou can also name your arguments in a typespec using `arg_name :: arg_type` syntax. This is particularly useful in documentation as a way to differentiate multiple arguments of the same type (or multiple elements of the same type in a type definition):\n\n    @spec days_since_epoch(year :: integer, month :: integer, day :: integer) :: integer\n    @type color :: {red :: integer, green :: integer, blue :: integer}\n\nSpecifications can be overloaded, just like ordinary functions.\n\n    @spec function(integer) :: atom\n    @spec function(atom) :: integer","ref":"typespecs.html#defining-a-specification"},{"type":"extras","title":"Behaviours - Typespecs reference","doc":"Behaviours in Elixir (and Erlang) are a way to separate and abstract the generic part of a component (which becomes the *behaviour module*) from the specific part (which becomes the *callback module*).\n\nA behaviour module defines a set of functions and macros (referred to as *callbacks*) that callback modules implementing that behaviour must export. This \"interface\" identifies the specific part of the component. For example, the `GenServer` behaviour and functions abstract away all the message-passing (sending and receiving) and error reporting that a \"server\" process will likely want to implement from the specific parts such as the actions that this server process has to perform.\n\nSay we want to implement a bunch of parsers, each parsing structured data: for example, a JSON parser and a MessagePack parser. Each of these two parsers will *behave* the same way: both will provide a `parse/1` function and an `extensions/0` function. The `parse/1` function will return an Elixir representation of the structured data, while the `extensions/0` function will return a list of file extensions that can be used for each type of data (e.g., `.json` for JSON files).\n\nWe can create a `Parser` behaviour:\n\n```elixir\ndefmodule Parser do\n  @doc \"\"\"\n  Parses a string.\n  \"\"\"\n  @callback parse(String.t) :: {:ok, term} | {:error, atom}\n\n  @doc \"\"\"\n  Lists all supported file extensions.\n  \"\"\"\n  @callback extensions() :: [String.t]\nend\n```\n\nAs seen in the example above, defining a callback is a matter of defining a specification for that callback, made of:\n\n  * the callback name (`parse` or `extensions` in the example)\n  * the arguments that the callback must accept (`String.t`)\n  * the *expected* type of the callback return value\n\nModules adopting the `Parser` behaviour will have to implement all the functions defined with the `@callback` attribute. As you can see, `@callback` expects a function name but also a function specification like the ones used with the `@spec` attribute we saw above.","ref":"typespecs.html#behaviours"},{"type":"extras","title":"Implementing behaviours - Typespecs reference","doc":"Implementing a behaviour is straightforward:\n\n```elixir\ndefmodule JSONParser do\n  @behaviour Parser\n\n  @impl Parser\n  def parse(str), do: {:ok, \"some json \" <> str} # ... parse JSON\n\n  @impl Parser\n  def extensions, do: [\".json\"]\nend\n```\n\n```elixir\ndefmodule CSVParser do\n  @behaviour Parser\n\n  @impl Parser\n  def parse(str), do: {:ok, \"some csv \" <> str} # ... parse CSV\n\n  @impl Parser\n  def extensions, do: [\".csv\"]\nend\n```\n\nIf a module adopting a given behaviour doesn't implement one of the callbacks required by that behaviour, a compile-time warning will be generated.\n\nFurthermore, with `@impl` you can also make sure that you are implementing the **correct** callbacks from the given behaviour in an explicit manner. For example, the following parser implements both `parse` and `extensions`. However, thanks to a typo, `BADParser` is implementing `parse/0` instead of `parse/1`.\n\n```elixir\ndefmodule BADParser do\n  @behaviour Parser\n\n  @impl Parser\n  def parse, do: {:ok, \"something bad\"}\n\n  @impl Parser\n  def extensions, do: [\"bad\"]\nend\n```\n\nThis code generates a warning letting you know that you are mistakenly implementing `parse/0` instead of `parse/1`.\nYou can read more about `@impl` in the [module documentation](`Module#module-impl`).","ref":"typespecs.html#implementing-behaviours"},{"type":"extras","title":"Using behaviours - Typespecs reference","doc":"Behaviours are useful because you can pass modules around as arguments and you can then *call back* to any of the functions specified in the behaviour. For example, we can have a function that receives a filename, several parsers, and parses the file based on its extension:\n\n```elixir\n@spec parse_path(Path.t(), [module()]) :: {:ok, term} | {:error, atom}\ndef parse_path(filename, parsers) do\n  with {:ok, ext} <- parse_extension(filename),\n       {:ok, parser} <- find_parser(ext, parsers),\n       {:ok, contents} <- File.read(filename) do\n    parser.parse(contents)\n  end\nend\n\ndefp parse_extension(filename) do\n  if ext = Path.extname(filename) do\n    {:ok, ext}\n  else\n    {:error, :no_extension}\n  end\nend\n\ndefp find_parser(ext, parsers) do\n  if parser = Enum.find(parsers, fn parser -> ext in parser.extensions() end) do\n    {:ok, parser}\n  else\n    {:error, :no_matching_parser}\n  end\nend\n```\n\nYou could also invoke any parser directly: `CSVParser.parse(...)`.\n\nNote you don't need to define a behaviour in order to dynamically dispatch on a module, but those features often go hand in hand.","ref":"typespecs.html#using-behaviours"},{"type":"extras","title":"Optional callbacks - Typespecs reference","doc":"Optional callbacks are callbacks that callback modules may implement if they want to, but are not required to. Usually, behaviour modules know if they should call those callbacks based on configuration, or they check if the callbacks are defined with `function_exported?/3` or `macro_exported?/3`.\n\nOptional callbacks can be defined through the `@optional_callbacks` module attribute, which has to be a keyword list with function or macro name as key and arity as value. For example:\n\n    defmodule MyBehaviour do\n      @callback vital_fun() :: any\n      @callback non_vital_fun() :: any\n      @macrocallback non_vital_macro(arg :: any) :: Macro.t\n      @optional_callbacks non_vital_fun: 0, non_vital_macro: 1\n    end\n\nOne example of optional callback in Elixir's standard library is `c:GenServer.format_status/1`.","ref":"typespecs.html#optional-callbacks"},{"type":"extras","title":"Inspecting behaviours - Typespecs reference","doc":"The `@callback` and `@optional_callbacks` attributes are used to create a `behaviour_info/1` function available on the defining module. This function can be used to retrieve the callbacks and optional callbacks defined by that module.\n\nFor example, for the `MyBehaviour` module defined in \"Optional callbacks\" above:\n\n    MyBehaviour.behaviour_info(:callbacks)\n    #=> [vital_fun: 0, \"MACRO-non_vital_macro\": 2, non_vital_fun: 0]\n    MyBehaviour.behaviour_info(:optional_callbacks)\n    #=> [\"MACRO-non_vital_macro\": 2, non_vital_fun: 0]\n\nWhen using `iex`, the `IEx.Helpers.b/1` helper is also available.","ref":"typespecs.html#inspecting-behaviours"},{"type":"extras","title":"Pitfalls - Typespecs reference","doc":"There are some known pitfalls when using typespecs, they are documented next.","ref":"typespecs.html#pitfalls"},{"type":"extras","title":"The `string()` type - Typespecs reference","doc":"Elixir discourages the use of the `string()` type. The `string()` type refers to Erlang strings, which are known as \"charlists\" in Elixir. They do not refer to Elixir strings, which are UTF-8 encoded binaries. To avoid confusion, if you attempt to use the type `string()`, Elixir will emit a warning. You should use `charlist()`, `nonempty_charlist()`, `binary()` or `String.t()` accordingly, or any of the several literal representations for these types.\n\nNote that `String.t()` and `binary()` are equivalent to analysis tools. Although, for those reading the documentation, `String.t()` implies it is a UTF-8 encoded binary.","ref":"typespecs.html#the-string-type"},{"type":"extras","title":"Functions which raise an error - Typespecs reference","doc":"Typespecs do not need to indicate that a function can raise an error; any function can fail any time if given invalid input.\nIn the past, the Elixir standard library sometimes used `no_return()` to indicate this, but these usages have been removed.\n\nThe `no_return()` type also should not be used for functions which do return but whose purpose is a \"side effect\", such as `IO.puts/1`.\nIn these cases, the expected return type is `:ok`.\n\nInstead, `no_return()` should be used as the return type for functions which can never return a value.\nThis includes functions which loop forever calling `receive`, or which exist specifically to raise an error, or which shut down the VM.","ref":"typespecs.html#functions-which-raise-an-error"},{"type":"extras","title":"Unicode syntax","doc":"# Unicode syntax\n\nElixir supports Unicode throughout the language. This document is a complete reference of how\nElixir supports Unicode in its syntax.\n\nStrings (`\"olá\"`) and charlists (`'olá'`) support Unicode since Elixir v1.0. Strings are UTF-8 encoded. Charlists are lists of Unicode code points. In such cases, the contents are kept as written by developers, without any transformation.\n\nElixir also supports Unicode in variables, atoms, and calls since Elixir v1.5. The focus of this document is to provide a high-level introduction to how Elixir allows Unicode in its syntax. We also provide technical documentation describing how Elixir complies with the Unicode specification.\n\nTo check the Unicode version of your current Elixir installation, run `String.Unicode.version()`.","ref":"unicode-syntax.html"},{"type":"extras","title":"Introduction - Unicode syntax","doc":"Elixir allows Unicode characters in its variables, atoms, and calls. However, the Unicode characters must still obey the rules of the language syntax. In particular, variables and calls cannot start with an uppercase letter. From now on, we will refer to those terms as identifiers.\n\nThe characters allowed in identifiers are the ones specified by Unicode. Generally speaking, it is restricted to characters typically used by the writing system of human languages still in activity. In particular, it excludes symbols such as emojis, alternate numeric representations, musical notes, and the like.\n\nElixir imposes many restrictions on identifiers for security purposes. For example, the word \"josé\" can be written in two ways in Unicode: as the combination of the characters `j o s é` and as a combination of the characters `j o s e ́ `, where the accent is its own character. The former is called NFC form and the latter is the NFD form. Elixir normalizes all characters to be the in the NFC form.\n\nElixir also disallows mixed-scripts in most scenarios. For example, it is not possible to name a variable `аdmin`, where `а` is in Cyrillic and the remaining characters are in Latin. Doing so will raise the following error:\n\n```text\n** (SyntaxError) invalid mixed-script identifier found: аdmin\n\nMixed-script identifiers are not supported for security reasons. 'аdmin' is made of the following scripts:\n\n  \\u0430 а {Cyrillic}\n  \\u0064 d {Latin}\n  \\u006D m {Latin}\n  \\u0069 i {Latin}\n  \\u006E n {Latin}\n\nMake sure all characters in the identifier resolve to a single script or a highly\nrestrictive script. See https://hexdocs.pm/elixir/unicode-syntax.html for more information.\n```\n\nThe character must either be all in Cyrillic or all in Latin. The only mixed-scripts that Elixir allows, according to the Highly Restrictive Unicode recommendations, are:\n\n  * Latin and Han with Bopomofo\n  * Latin and Japanese\n  * Latin and Korean\n\nFinally, Elixir will also warn on confusable identifiers in the same file. For example, Elixir will emit a warning if you use both variables `а` (Cyrillic) and `а` (Latin) in your code.\n\nThat's the overall introduction of how Unicode is used in Elixir identifiers. In a nutshell, its goal is to support different writing systems in use today while keeping the Elixir language itself clear and secure.\n\nFor the technical details, see the next sections that cover the technical Unicode requirements.","ref":"unicode-syntax.html#introduction"},{"type":"extras","title":"Unicode Annex #31 - Unicode syntax","doc":"Elixir implements the requirements outlined in the [Unicode Annex #31](https://unicode.org/reports/tr31/), version 15.0.","ref":"unicode-syntax.html#unicode-annex-31"},{"type":"extras","title":"R1. Default Identifiers - Unicode syntax","doc":"The general Elixir identifier rule is specified as:\n\n      :=    *  ?\n\nwhere ` ` uses the same categories as the spec but normalizes them to the NFC form (see R4):\n\n> characters derived from the Unicode General Category of uppercase letters, lowercase letters, titlecase letters, modifier letters, other letters, letter numbers, plus `Other_ID_Start`, minus `Pattern_Syntax` and `Pattern_White_Space` code points\n>\n> In set notation: `[\\p{L}\\p{Nl}\\p{Other_ID_Start}-\\p{Pattern_Syntax}-\\p{Pattern_White_Space}]`.\n\nand ` ` uses the same categories as the spec but normalizes them to the NFC form (see R4):\n\n> ID_Start characters, plus characters having the Unicode General Category of nonspacing marks, spacing combining marks, decimal number, connector punctuation, plus `Other_ID_Continue`, minus `Pattern_Syntax` and `Pattern_White_Space` code points.\n>\n> In set notation: `[\\p{ID_Start}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\p{Other_ID_Continue}-\\p{Pattern_Syntax}-\\p{Pattern_White_Space}]`.\n\n` ` is an addition specific to Elixir that includes only the code points `?` (003F) and `!` (0021).\n\nThe spec also provides a ` ` set, but Elixir does not include any character on this set. Therefore, the identifier rule has been simplified to consider this.\n\nElixir does not allow the use of ZWJ or ZWNJ in identifiers and therefore does not implement R1a. Bidirectional control characters are also not supported. R1b is guaranteed for backwards compatibility purposes.\n\n#### Atoms\n\nUnicode atoms in Elixir follow the identifier rule above with the following modifications:\n\n  * ` ` additionally includes the code point `_` (005F)\n  * ` ` additionally includes the code point `@` (0040)\n\nNote atoms can also be quoted, which allows any characters, such as `:\"hello elixir\"`. All Elixir operators are also valid atoms, such as `:+`, `:@`, `:|>`, and others. The full description of valid atoms is available in the [\"Atoms\" section in the syntax reference](syntax-reference.md#atoms).\n\n#### Variables, local calls, and remote calls\n\nVariables in Elixir follow the identifier rule above with the following modifications:\n\n  * ` ` additionally includes the code point `_` (005F)\n  * ` ` additionally excludes Lu (letter uppercase) and Lt (letter titlecase) characters\n\nIn set notation: `[\\u{005F}\\p{Ll}\\p{Lm}\\p{Lo}\\p{Nl}\\p{Other_ID_Start}-\\p{Pattern_Syntax}-\\p{Pattern_White_Space}]`.\n\n#### Aliases\n\nAliases in Elixir only allow ASCII characters, starting in uppercase, and no punctuation characters.","ref":"unicode-syntax.html#r1-default-identifiers"},{"type":"extras","title":"R3. Pattern_White_Space and Pattern_Syntax Characters - Unicode syntax","doc":"Elixir supports only code points `\\t` (0009), `\\n` (000A), `\\r` (000D) and `\\s` (0020) as whitespace and therefore does not follow requirement R3. R3 requires a wider variety of whitespace and syntax characters to be supported.","ref":"unicode-syntax.html#r3-pattern_white_space-and-pattern_syntax-characters"},{"type":"extras","title":"R4. Equivalent Normalized Identifiers - Unicode syntax","doc":"Identifiers in Elixir are case sensitive.\n\nElixir normalizes all atoms and variables to NFC form. Quoted-atoms and strings can, however, be in any form and are not verified by the parser.\n\nIn other words, the atom `:josé` can only be written with the code points `006A 006F 0073 00E9` or `006A 006F 0073 0065 0301`, but Elixir will rewrite it to the former (from Elixir 1.14). On the other hand, `:\"josé\"` may be written as `006A 006F 0073 00E9` or `006A 006F 0073 0065 0301` and its form will be retained, since it is written between quotes.\n\nChoosing requirement R4 automatically excludes requirements R5, R6, and R7.","ref":"unicode-syntax.html#r4-equivalent-normalized-identifiers"},{"type":"extras","title":"Unicode Technical Standard #39 - Unicode syntax","doc":"Elixir conforms to the clauses outlined in the [Unicode Technical Standard #39](https://unicode.org/reports/tr39/) on Security, version 15.0.","ref":"unicode-syntax.html#unicode-technical-standard-39"},{"type":"extras","title":"C1. General Security Profile for Identifiers - Unicode syntax","doc":"Elixir will not allow tokenization of identifiers with codepoints in `\\p{Identifier_Status=Restricted}`.\n\n> An implementation following the General Security Profile does not permit any characters in \\p{Identifier_Status=Restricted}, ...\n\nFor instance, the 'HANGUL FILLER' (`ㅤ`) character, which is often invisible, is an uncommon codepoint and will trigger this warning.\n\nSee the note below about additional normalizations, which can perform automatic replacement of some Restricted identifiers.","ref":"unicode-syntax.html#c1-general-security-profile-for-identifiers"},{"type":"extras","title":"C2. Confusable detection - Unicode syntax","doc":"Elixir will warn on identifiers that look the same, but aren't. Examples: in `а = a = 1`, the two 'a' characters are Cyrillic and Latin, and could be confused for each other; in `力 = カ = 1`, both are Japanese, but different codepoints, in different scripts of that writing system. Confusable identifiers can lead to hard-to-catch bugs (say, due to copy-pasted code) and can be unsafe, so we will warn about identifiers within a single file that could be confused with each other.\n\nWe use the means described in Section 4, 'Confusable Detection', with one noted modification\n\n> Alternatively, it shall declare that it uses a modification, and provide a precise list of character mappings that are added to or removed from the provided ones.\n\nElixir will not warn on confusability for identifiers made up exclusively of characters in a-z, A-Z, 0-9, and _. This is because ASCII identifiers have existed for so long that the programming community has had their own means of dealing with confusability between identifiers like `l,1` or `O,0` (for instance, fonts designed for programming usually make it easy to differentiate between those characters).","ref":"unicode-syntax.html#c2-confusable-detection"},{"type":"extras","title":"C3. Mixed Script Detection - Unicode syntax","doc":"Elixir will not allow tokenization of mixed-script identifiers unless the mixing is one of the exceptions defined in UTS 39 5.2, 'Highly Restrictive'. We use the means described in Section 5.1, Mixed-Script Detection, to determine if script mixing is occurring, with the modification documented in the section 'Additional Normalizations', below.\n\nExamples: Elixir allows an identifiers like `幻ㄒㄧㄤ`, even though it includes characters from multiple 'scripts', because those scripts all 'resolve' to Japanese when applying the resolution rules from UTS 39 5.1. It also allows an atom like `:Tシャツ`, the Japanese word for 't-shirt', which incorporates a Latin capital T, because {Latn, Jpan} is one of the allowed script mixing in the definition of 'Highly Restrictive' in UTS 39 5.2, and it 'covers' the string.\n\nHowever, Elixir would prevent tokenization in code like `if аdmin, do: :ok, else: :err`, where the scriptset for the 'a' character is {Cyrillic} but all other characters have scriptsets of {Latin}. The scriptsets fail to resolve, and the scriptsets from the definition of 'Highly Restrictive' in UTS 39 5.2 do not cover the string either, so a descriptive error is shown.","ref":"unicode-syntax.html#c3-mixed-script-detection"},{"type":"extras","title":"C4, C5 (inapplicable) - Unicode syntax","doc":"'C4 - Restriction Level detection' conformance is not claimed and does not apply to identifiers in code; rather, it applies to classifying the level of safety of a given arbitrary string into one of 5 restriction levels.\n\n'C5 - Mixed number detection' conformance is inapplicable as Elixir does not support Unicode numbers.","ref":"unicode-syntax.html#c4-c5-inapplicable"},{"type":"extras","title":"Addition normalizations and documented UTS 39 modifications - Unicode syntax","doc":"As of Elixir 1.14, some codepoints in `\\p{Identifier_Status=Restricted}` are *normalized* to other, unrestricted codepoints.\n\nInitially this is only done to translate MICRO SIGN `µ` to Greek lowercase mu, `μ`.\n\nThis is not a modification of UTS39 clauses C1 (General Security Profile) or C2 (Confusability Detection); however, it is a documented modification of C3, 'Mixed-Script detection'.\n\nMixed-script detection is modified by these normalizations to the extent that the normalized codepoint is given the union of scriptsets from both characters.\n\n  * For instance, in the example of MICRO => MU, Micro was a 'Common'-script character -- the same script given to the '_' underscore codepoint -- and thus the normalized character's scriptset will be {Greek, Common}. 'Common' intersects with all non-empty scriptsets, and thus the normalized character can be used in tokens written in any script without causing script mixing.\n\n  * The code points normalized in this fashion are those that are in use in the community, and judged not likely to cause issues with unsafe script mixing. For instance, the MICRO or MU codepoint may be used in an atom or variable dealing with microseconds.","ref":"unicode-syntax.html#addition-normalizations-and-documented-uts-39-modifications"}],"proglang":"elixir","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.37.1"}}