<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.37.1">
    <meta name="project" content="Elixir v1.17.3">


    <title>Code-related anti-patterns — Elixir v1.17.3</title>

    <link rel="stylesheet" href="dist/html-elixir-PD7PAHEK.css" />

      <link rel="canonical" href="https://hexdocs.pm/elixir/code-anti-patterns.html" />

    <script defer src="dist/sidebar_items-3D721A5F.js"></script>
    <script defer src="docs_config.js"></script>
    <script>var Module={arguments: ["eval.avm"] }</script>
    <script defer src="dist/AtomVM.js"></script>
    <script defer src="dist/html-KNMUZUZQ.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="https://elixir-lang.org/docs.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="Elixir" />
        </a>

      <div>
        <a href="https://elixir-lang.org/docs.html" class="sidebar-projectName" translate="no">
Elixir
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v1.17.3
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of Elixir</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>Code-related anti-patterns</h1>


      <a href="https://github.com/elixir-lang/elixir/blob/cee31ab46f2cd47a942d236470216376b53fb41a/lib/elixir/pages/anti-patterns/code-anti-patterns.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>

<p>This document outlines potential anti-patterns related to your code and particular Elixir idioms and features.</p><h2 id="comments-overuse" class="section-heading">
  <a href="#comments-overuse" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Comments overuse</span>
</h2>
<h4>Problem</h4><p>When you overuse comments or comment self-explanatory code, it can have the effect of making code <em>less readable</em>.</p><h4>Example</h4><pre><code class="makeup elixir" translate="no"><span class="c1"># Returns the Unix timestamp of 5 minutes from the current time</span><span class="w">
</span><span class="kd">defp</span><span class="w"> </span><span class="nf">unix_five_min_from_now</span><span class="w"> </span><span class="k" data-group-id="1046771630-1">do</span><span class="w">
  </span><span class="c1"># Get the current time</span><span class="w">
  </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">DateTime</span><span class="o">.</span><span class="n">utc_now</span><span class="p" data-group-id="1046771630-2">(</span><span class="p" data-group-id="1046771630-2">)</span><span class="w">

  </span><span class="c1"># Convert it to a Unix timestamp</span><span class="w">
  </span><span class="n">unix_now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">DateTime</span><span class="o">.</span><span class="n">to_unix</span><span class="p" data-group-id="1046771630-3">(</span><span class="n">now</span><span class="p">,</span><span class="w"> </span><span class="ss">:second</span><span class="p" data-group-id="1046771630-3">)</span><span class="w">

  </span><span class="c1"># Add five minutes in seconds</span><span class="w">
  </span><span class="n">unix_now</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p" data-group-id="1046771630-4">(</span><span class="mi">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="1046771630-4">)</span><span class="w">
</span><span class="k" data-group-id="1046771630-1">end</span></code></pre><h4>Refactoring</h4><p>Prefer clear and self-explanatory function names, module names, and variable names when possible. In the example above, the function name explains well what the function does, so you likely won't need the comment before it. The code also explains the operations well through variable names and clear function calls.</p><p>You could refactor the code above like this:</p><pre><code class="makeup elixir" translate="no"><span class="na">@five_min_in_seconds</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">unix_five_min_from_now</span><span class="w"> </span><span class="k" data-group-id="5145630338-1">do</span><span class="w">
  </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">DateTime</span><span class="o">.</span><span class="n">utc_now</span><span class="p" data-group-id="5145630338-2">(</span><span class="p" data-group-id="5145630338-2">)</span><span class="w">
  </span><span class="n">unix_now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">DateTime</span><span class="o">.</span><span class="n">to_unix</span><span class="p" data-group-id="5145630338-3">(</span><span class="n">now</span><span class="p">,</span><span class="w"> </span><span class="ss">:second</span><span class="p" data-group-id="5145630338-3">)</span><span class="w">
  </span><span class="n">unix_now</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">@five_min_in_seconds</span><span class="w">
</span><span class="k" data-group-id="5145630338-1">end</span></code></pre><p>We removed the unnecessary comments. We also added a <code class="inline">@five_min_in_seconds</code> module attribute, which serves the additional purpose of giving a name to the &quot;magic&quot; number <code class="inline">60 * 5</code>, making the code clearer and more expressive.</p><h4>Additional remarks</h4><p>Elixir makes a clear distinction between <strong>documentation</strong> and code comments. The language has built-in first-class support for documentation through <code class="inline">@doc</code>, <code class="inline">@moduledoc</code>, and more. See the <a href="writing-documentation.html">&quot;Writing documentation&quot;</a> guide for more information.</p><h2 id="complex-else-clauses-in-with" class="section-heading">
  <a href="#complex-else-clauses-in-with" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Complex <code class="inline">else</code> clauses in <code class="inline">with</code></span>
</h2>
<h4>Problem</h4><p>This anti-pattern refers to <code class="inline">with</code> statements that flatten all its error clauses into a single complex <code class="inline">else</code> block. This situation is harmful to the code readability and maintainability because it's difficult to know from which clause the error value came.</p><h4>Example</h4><p>An example of this anti-pattern, as shown below, is a function <code class="inline">open_decoded_file/1</code> that reads a Base64-encoded string content from a file and returns a decoded binary string. This function uses a <code class="inline">with</code> statement that needs to handle two possible errors, all of which are concentrated in a single complex <code class="inline">else</code> block.</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">open_decoded_file</span><span class="p" data-group-id="8157378296-1">(</span><span class="n">path</span><span class="p" data-group-id="8157378296-1">)</span><span class="w"> </span><span class="k" data-group-id="8157378296-2">do</span><span class="w">
  </span><span class="k">with</span><span class="w"> </span><span class="p" data-group-id="8157378296-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">encoded</span><span class="p" data-group-id="8157378296-3">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nc">File</span><span class="o">.</span><span class="n">read</span><span class="p" data-group-id="8157378296-4">(</span><span class="n">path</span><span class="p" data-group-id="8157378296-4">)</span><span class="p">,</span><span class="w">
       </span><span class="p" data-group-id="8157378296-5">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">decoded</span><span class="p" data-group-id="8157378296-5">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nc">Base</span><span class="o">.</span><span class="n">decode64</span><span class="p" data-group-id="8157378296-6">(</span><span class="n">encoded</span><span class="p" data-group-id="8157378296-6">)</span><span class="w"> </span><span class="k" data-group-id="8157378296-7">do</span><span class="w">
    </span><span class="p" data-group-id="8157378296-8">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">trim</span><span class="p" data-group-id="8157378296-9">(</span><span class="n">decoded</span><span class="p" data-group-id="8157378296-9">)</span><span class="p" data-group-id="8157378296-8">}</span><span class="w">
  </span><span class="k" data-group-id="8157378296-7">else</span><span class="w">
    </span><span class="p" data-group-id="8157378296-10">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="8157378296-10">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="8157378296-11">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="ss">:badfile</span><span class="p" data-group-id="8157378296-11">}</span><span class="w">
    </span><span class="ss">:error</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="8157378296-12">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="ss">:badencoding</span><span class="p" data-group-id="8157378296-12">}</span><span class="w">
  </span><span class="k" data-group-id="8157378296-7">end</span><span class="w">
</span><span class="k" data-group-id="8157378296-2">end</span></code></pre><p>In the code above, it is unclear how each pattern on the left side of <code class="inline">&lt;-</code> relates to their error at the end. The more patterns in a <code class="inline">with</code>, the less clear the code gets, and the more likely it is that unrelated failures will overlap each other.</p><h4>Refactoring</h4><p>In this situation, instead of concentrating all error handling within a single complex <code class="inline">else</code> block, it is better to normalize the return types in specific private functions. In this way, <code class="inline">with</code> can focus on the success case and the errors are normalized closer to where they happen, leading to better organized and maintainable code.</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">open_decoded_file</span><span class="p" data-group-id="6821178230-1">(</span><span class="n">path</span><span class="p" data-group-id="6821178230-1">)</span><span class="w"> </span><span class="k" data-group-id="6821178230-2">do</span><span class="w">
  </span><span class="k">with</span><span class="w"> </span><span class="p" data-group-id="6821178230-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">encoded</span><span class="p" data-group-id="6821178230-3">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">file_read</span><span class="p" data-group-id="6821178230-4">(</span><span class="n">path</span><span class="p" data-group-id="6821178230-4">)</span><span class="p">,</span><span class="w">
       </span><span class="p" data-group-id="6821178230-5">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">decoded</span><span class="p" data-group-id="6821178230-5">}</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">base_decode64</span><span class="p" data-group-id="6821178230-6">(</span><span class="n">encoded</span><span class="p" data-group-id="6821178230-6">)</span><span class="w"> </span><span class="k" data-group-id="6821178230-7">do</span><span class="w">
    </span><span class="p" data-group-id="6821178230-8">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">trim</span><span class="p" data-group-id="6821178230-9">(</span><span class="n">decoded</span><span class="p" data-group-id="6821178230-9">)</span><span class="p" data-group-id="6821178230-8">}</span><span class="w">
  </span><span class="k" data-group-id="6821178230-7">end</span><span class="w">
</span><span class="k" data-group-id="6821178230-2">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">file_read</span><span class="p" data-group-id="6821178230-10">(</span><span class="n">path</span><span class="p" data-group-id="6821178230-10">)</span><span class="w"> </span><span class="k" data-group-id="6821178230-11">do</span><span class="w">
  </span><span class="k">case</span><span class="w"> </span><span class="nc">File</span><span class="o">.</span><span class="n">read</span><span class="p" data-group-id="6821178230-12">(</span><span class="n">path</span><span class="p" data-group-id="6821178230-12">)</span><span class="w"> </span><span class="k" data-group-id="6821178230-13">do</span><span class="w">
    </span><span class="p" data-group-id="6821178230-14">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span><span class="p" data-group-id="6821178230-14">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="6821178230-15">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span><span class="p" data-group-id="6821178230-15">}</span><span class="w">
    </span><span class="p" data-group-id="6821178230-16">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="6821178230-16">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="6821178230-17">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="ss">:badfile</span><span class="p" data-group-id="6821178230-17">}</span><span class="w">
  </span><span class="k" data-group-id="6821178230-13">end</span><span class="w">
</span><span class="k" data-group-id="6821178230-11">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">base_decode64</span><span class="p" data-group-id="6821178230-18">(</span><span class="n">contents</span><span class="p" data-group-id="6821178230-18">)</span><span class="w"> </span><span class="k" data-group-id="6821178230-19">do</span><span class="w">
  </span><span class="k">case</span><span class="w"> </span><span class="nc">Base</span><span class="o">.</span><span class="n">decode64</span><span class="p" data-group-id="6821178230-20">(</span><span class="n">contents</span><span class="p" data-group-id="6821178230-20">)</span><span class="w"> </span><span class="k" data-group-id="6821178230-21">do</span><span class="w">
    </span><span class="p" data-group-id="6821178230-22">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">decoded</span><span class="p" data-group-id="6821178230-22">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="6821178230-23">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">decoded</span><span class="p" data-group-id="6821178230-23">}</span><span class="w">
    </span><span class="ss">:error</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="6821178230-24">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="ss">:badencoding</span><span class="p" data-group-id="6821178230-24">}</span><span class="w">
  </span><span class="k" data-group-id="6821178230-21">end</span><span class="w">
</span><span class="k" data-group-id="6821178230-19">end</span></code></pre><h2 id="complex-extractions-in-clauses" class="section-heading">
  <a href="#complex-extractions-in-clauses" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Complex extractions in clauses</span>
</h2>
<h4>Problem</h4><p>When we use multi-clause functions, it is possible to extract values in the clauses for further usage and for pattern matching/guard checking. This extraction itself does not represent an anti-pattern, but when you have <em>extractions made across several clauses and several arguments of the same function</em>, it becomes hard to know which extracted parts are used for pattern/guards and what is used only inside the function body. This anti-pattern is related to <a href="design-anti-patterns.html#unrelated-multi-clause-function">Unrelated multi-clause function</a>, but with implications of its own. It impairs the code readability in a different way.</p><h4>Example</h4><p>The multi-clause function <code class="inline">drive/1</code> is extracting fields of an <code class="inline">%User{}</code> struct for usage in the clause expression (<code class="inline">age</code>) and for usage in the function body (<code class="inline">name</code>):</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">drive</span><span class="p" data-group-id="5726766357-1">(</span><span class="p" data-group-id="5726766357-2">%</span><span class="nc" data-group-id="5726766357-2">User</span><span class="p" data-group-id="5726766357-2">{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="n">age</span><span class="p" data-group-id="5726766357-2">}</span><span class="p" data-group-id="5726766357-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="k" data-group-id="5726766357-3">do</span><span class="w">
  </span><span class="s">&quot;</span><span class="si" data-group-id="5726766357-4">#{</span><span class="n">name</span><span class="si" data-group-id="5726766357-4">}</span><span class="s"> can drive&quot;</span><span class="w">
</span><span class="k" data-group-id="5726766357-3">end</span><span class="w">

</span><span class="kd">def</span><span class="w"> </span><span class="nf">drive</span><span class="p" data-group-id="5726766357-5">(</span><span class="p" data-group-id="5726766357-6">%</span><span class="nc" data-group-id="5726766357-6">User</span><span class="p" data-group-id="5726766357-6">{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="n">age</span><span class="p" data-group-id="5726766357-6">}</span><span class="p" data-group-id="5726766357-5">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="k" data-group-id="5726766357-7">do</span><span class="w">
  </span><span class="s">&quot;</span><span class="si" data-group-id="5726766357-8">#{</span><span class="n">name</span><span class="si" data-group-id="5726766357-8">}</span><span class="s"> cannot drive&quot;</span><span class="w">
</span><span class="k" data-group-id="5726766357-7">end</span></code></pre><p>While the example above is small and does not constitute an anti-pattern, it is an example of mixed extraction and pattern matching. A situation where <code class="inline">drive/1</code> was more complex, having many more clauses, arguments, and extractions, would make it hard to know at a glance which variables are used for pattern/guards and which ones are not.</p><h4>Refactoring</h4><p>As shown below, a possible solution to this anti-pattern is to extract only pattern/guard related variables in the signature once you have many arguments or multiple clauses:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">drive</span><span class="p" data-group-id="4088153814-1">(</span><span class="p" data-group-id="4088153814-2">%</span><span class="nc" data-group-id="4088153814-2">User</span><span class="p" data-group-id="4088153814-2">{</span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="n">age</span><span class="p" data-group-id="4088153814-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user</span><span class="p" data-group-id="4088153814-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="k" data-group-id="4088153814-3">do</span><span class="w">
  </span><span class="p" data-group-id="4088153814-4">%</span><span class="nc" data-group-id="4088153814-4">User</span><span class="p" data-group-id="4088153814-4">{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="4088153814-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user</span><span class="w">
  </span><span class="s">&quot;</span><span class="si" data-group-id="4088153814-5">#{</span><span class="n">name</span><span class="si" data-group-id="4088153814-5">}</span><span class="s"> can drive&quot;</span><span class="w">
</span><span class="k" data-group-id="4088153814-3">end</span><span class="w">

</span><span class="kd">def</span><span class="w"> </span><span class="nf">drive</span><span class="p" data-group-id="4088153814-6">(</span><span class="p" data-group-id="4088153814-7">%</span><span class="nc" data-group-id="4088153814-7">User</span><span class="p" data-group-id="4088153814-7">{</span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="n">age</span><span class="p" data-group-id="4088153814-7">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user</span><span class="p" data-group-id="4088153814-6">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="k" data-group-id="4088153814-8">do</span><span class="w">
  </span><span class="p" data-group-id="4088153814-9">%</span><span class="nc" data-group-id="4088153814-9">User</span><span class="p" data-group-id="4088153814-9">{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="4088153814-9">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user</span><span class="w">
  </span><span class="s">&quot;</span><span class="si" data-group-id="4088153814-10">#{</span><span class="n">name</span><span class="si" data-group-id="4088153814-10">}</span><span class="s"> cannot drive&quot;</span><span class="w">
</span><span class="k" data-group-id="4088153814-8">end</span></code></pre><h2 id="dynamic-atom-creation" class="section-heading">
  <a href="#dynamic-atom-creation" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Dynamic atom creation</span>
</h2>
<h4>Problem</h4><p>An <a href="Atom.html"><code class="inline">Atom</code></a> is an Elixir basic type whose value is its own name. Atoms are often useful to identify resources or express the state, or result, of an operation. Creating atoms dynamically is not an anti-pattern by itself; however, atoms are not garbage collected by the Erlang Virtual Machine, so values of this type live in memory during a software's entire execution lifetime. The Erlang VM limits the number of atoms that can exist in an application by default to <em>1_048_576</em>, which is more than enough to cover all atoms defined in a program, but attempts to serve as an early limit for applications which are &quot;leaking atoms&quot; through dynamic creation.</p><p>For these reason, creating atoms dynamically can be considered an anti-pattern when the developer has no control over how many atoms will be created during the software execution. This unpredictable scenario can expose the software to unexpected behavior caused by excessive memory usage, or even by reaching the maximum number of <em>atoms</em> possible.</p><h4>Example</h4><p>Picture yourself implementing code that converts string values into atoms. These strings could have been received from an external system, either as part of a request into our application, or as part of a response to your application. This dynamic and unpredictable scenario poses a security risk, as these uncontrolled conversions can potentially trigger out-of-memory errors.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyRequestHandler</span><span class="w"> </span><span class="k" data-group-id="1138723217-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">parse</span><span class="p" data-group-id="1138723217-2">(</span><span class="p" data-group-id="1138723217-3">%{</span><span class="s">&quot;status&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;message&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">message</span><span class="p" data-group-id="1138723217-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c">_payload</span><span class="p" data-group-id="1138723217-2">)</span><span class="w"> </span><span class="k" data-group-id="1138723217-4">do</span><span class="w">
    </span><span class="p" data-group-id="1138723217-5">%{</span><span class="ss">status</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">to_atom</span><span class="p" data-group-id="1138723217-6">(</span><span class="n">status</span><span class="p" data-group-id="1138723217-6">)</span><span class="p">,</span><span class="w"> </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="n">message</span><span class="p" data-group-id="1138723217-5">}</span><span class="w">
  </span><span class="k" data-group-id="1138723217-4">end</span><span class="w">
</span><span class="k" data-group-id="1138723217-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">MyRequestHandler</span><span class="o">.</span><span class="n">parse</span><span class="p" data-group-id="4242920554-1">(</span><span class="p" data-group-id="4242920554-2">%{</span><span class="s">&quot;status&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;ok&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;message&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;all good&quot;</span><span class="p" data-group-id="4242920554-2">}</span><span class="p" data-group-id="4242920554-1">)</span><span class="w">
</span><span class="p" data-group-id="4242920554-3">%{</span><span class="ss">status</span><span class="p">:</span><span class="w"> </span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;all good&quot;</span><span class="p" data-group-id="4242920554-3">}</span></code></pre><p>When we use the <a href="String.html#to_atom/1"><code class="inline">String.to_atom/1</code></a> function to dynamically create an atom, it essentially gains potential access to create arbitrary atoms in our system, causing us to lose control over adhering to the limits established by the BEAM. This issue could be exploited by someone to create enough atoms to shut down a system.</p><h4>Refactoring</h4><p>To eliminate this anti-pattern, developers must either perform explicit conversions by mapping strings to atoms or replace the use of <a href="String.html#to_atom/1"><code class="inline">String.to_atom/1</code></a> with <a href="String.html#to_existing_atom/1"><code class="inline">String.to_existing_atom/1</code></a>. An explicit conversion could be done as follows:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyRequestHandler</span><span class="w"> </span><span class="k" data-group-id="5634112710-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">parse</span><span class="p" data-group-id="5634112710-2">(</span><span class="p" data-group-id="5634112710-3">%{</span><span class="s">&quot;status&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;message&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">message</span><span class="p" data-group-id="5634112710-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c">_payload</span><span class="p" data-group-id="5634112710-2">)</span><span class="w"> </span><span class="k" data-group-id="5634112710-4">do</span><span class="w">
    </span><span class="p" data-group-id="5634112710-5">%{</span><span class="ss">status</span><span class="p">:</span><span class="w"> </span><span class="n">convert_status</span><span class="p" data-group-id="5634112710-6">(</span><span class="n">status</span><span class="p" data-group-id="5634112710-6">)</span><span class="p">,</span><span class="w"> </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="n">message</span><span class="p" data-group-id="5634112710-5">}</span><span class="w">
  </span><span class="k" data-group-id="5634112710-4">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">convert_status</span><span class="p" data-group-id="5634112710-7">(</span><span class="s">&quot;ok&quot;</span><span class="p" data-group-id="5634112710-7">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:ok</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">convert_status</span><span class="p" data-group-id="5634112710-8">(</span><span class="s">&quot;error&quot;</span><span class="p" data-group-id="5634112710-8">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:error</span><span class="w">
  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">convert_status</span><span class="p" data-group-id="5634112710-9">(</span><span class="s">&quot;redirect&quot;</span><span class="p" data-group-id="5634112710-9">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:redirect</span><span class="w">
</span><span class="k" data-group-id="5634112710-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">MyRequestHandler</span><span class="o">.</span><span class="n">parse</span><span class="p" data-group-id="8676644395-1">(</span><span class="p" data-group-id="8676644395-2">%{</span><span class="s">&quot;status&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;status_not_seen_anywhere&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;message&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;all good&quot;</span><span class="p" data-group-id="8676644395-2">}</span><span class="p" data-group-id="8676644395-1">)</span><span class="w">
</span><span class="gt">** (FunctionClauseError) no function clause matching in MyRequestHandler.convert_status/1</span></code></pre><p>By explicitly listing all supported statuses, you guarantee only a limited number of conversions may happen. Passing an invalid status will lead to a function clause error.</p><p>An alternative is to use <a href="String.html#to_existing_atom/1"><code class="inline">String.to_existing_atom/1</code></a>, which will only convert a string to atom if the atom already exists in the system:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyRequestHandler</span><span class="w"> </span><span class="k" data-group-id="1588522199-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">parse</span><span class="p" data-group-id="1588522199-2">(</span><span class="p" data-group-id="1588522199-3">%{</span><span class="s">&quot;status&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;message&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">message</span><span class="p" data-group-id="1588522199-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c">_payload</span><span class="p" data-group-id="1588522199-2">)</span><span class="w"> </span><span class="k" data-group-id="1588522199-4">do</span><span class="w">
    </span><span class="p" data-group-id="1588522199-5">%{</span><span class="ss">status</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">to_existing_atom</span><span class="p" data-group-id="1588522199-6">(</span><span class="n">status</span><span class="p" data-group-id="1588522199-6">)</span><span class="p">,</span><span class="w"> </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="n">message</span><span class="p" data-group-id="1588522199-5">}</span><span class="w">
  </span><span class="k" data-group-id="1588522199-4">end</span><span class="w">
</span><span class="k" data-group-id="1588522199-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">MyRequestHandler</span><span class="o">.</span><span class="n">parse</span><span class="p" data-group-id="9797289459-1">(</span><span class="p" data-group-id="9797289459-2">%{</span><span class="s">&quot;status&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;status_not_seen_anywhere&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;message&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;all good&quot;</span><span class="p" data-group-id="9797289459-2">}</span><span class="p" data-group-id="9797289459-1">)</span><span class="w">
</span><span class="gt">** (ArgumentError) errors were found at the given arguments:</span><span class="w">

  </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="n">st</span><span class="w"> </span><span class="ss">argument</span><span class="p">:</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">already</span><span class="w"> </span><span class="n">existing</span><span class="w"> </span><span class="n">atom</span></code></pre><p>In such cases, passing an unknown status will raise as long as the status was not defined anywhere as an atom in the system. However, assuming <code class="inline">status</code> can be either <code class="inline">:ok</code>, <code class="inline">:error</code>, or <code class="inline">:redirect</code>, how can you guarantee those atoms exist? You must ensure those atoms exist somewhere <strong>in the same module</strong> where <a href="String.html#to_existing_atom/1"><code class="inline">String.to_existing_atom/1</code></a> is called. For example, if you had this code:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyRequestHandler</span><span class="w"> </span><span class="k" data-group-id="1092385225-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">parse</span><span class="p" data-group-id="1092385225-2">(</span><span class="p" data-group-id="1092385225-3">%{</span><span class="s">&quot;status&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;message&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">message</span><span class="p" data-group-id="1092385225-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c">_payload</span><span class="p" data-group-id="1092385225-2">)</span><span class="w"> </span><span class="k" data-group-id="1092385225-4">do</span><span class="w">
    </span><span class="p" data-group-id="1092385225-5">%{</span><span class="ss">status</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">to_existing_atom</span><span class="p" data-group-id="1092385225-6">(</span><span class="n">status</span><span class="p" data-group-id="1092385225-6">)</span><span class="p">,</span><span class="w"> </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="n">message</span><span class="p" data-group-id="1092385225-5">}</span><span class="w">
  </span><span class="k" data-group-id="1092385225-4">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">handle</span><span class="p" data-group-id="1092385225-7">(</span><span class="p" data-group-id="1092385225-8">%{</span><span class="ss">status</span><span class="p">:</span><span class="w"> </span><span class="n">status</span><span class="p" data-group-id="1092385225-8">}</span><span class="p" data-group-id="1092385225-7">)</span><span class="w"> </span><span class="k" data-group-id="1092385225-9">do</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="k" data-group-id="1092385225-10">do</span><span class="w">
      </span><span class="ss">:ok</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">...</span><span class="w">
      </span><span class="ss">:error</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">...</span><span class="w">
      </span><span class="ss">:redirect</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">...</span><span class="w">
    </span><span class="k" data-group-id="1092385225-10">end</span><span class="w">
  </span><span class="k" data-group-id="1092385225-9">end</span><span class="w">
</span><span class="k" data-group-id="1092385225-1">end</span></code></pre><p>All valid statuses are defined as atoms within the same module, and that's enough. If you want to be explicit, you could also have a function that lists them:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">valid_statuses</span><span class="w"> </span><span class="k" data-group-id="4970073304-1">do</span><span class="w">
  </span><span class="p" data-group-id="4970073304-2">[</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="ss">:redirect</span><span class="p" data-group-id="4970073304-2">]</span><span class="w">
</span><span class="k" data-group-id="4970073304-1">end</span></code></pre><p>However, keep in mind using a module attribute or defining the atoms in the module body, outside of a function, are not sufficient, as the module body is only executed during compilation and it is not necessarily part of the compiled module loaded at runtime.</p><h2 id="long-parameter-list" class="section-heading">
  <a href="#long-parameter-list" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Long parameter list</span>
</h2>
<h4>Problem</h4><p>In a functional language like Elixir, functions tend to explicitly receive all inputs and return all relevant outputs, instead of relying on mutations or side-effects. As functions grow in complexity, the amount of arguments (parameters) they need to work with may grow, to a point where the function's interface becomes confusing and prone to errors during use.</p><h4>Example</h4><p>In the following example, the <code class="inline">loan/6</code> functions takes too many arguments, causing its interface to be confusing and potentially leading developers to introduce errors during calls to this function.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Library</span><span class="w"> </span><span class="k" data-group-id="3369509877-1">do</span><span class="w">
  </span><span class="c1"># Too many parameters that can be grouped!</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">loan</span><span class="p" data-group-id="3369509877-2">(</span><span class="n">user_name</span><span class="p">,</span><span class="w"> </span><span class="n">email</span><span class="p">,</span><span class="w"> </span><span class="n">password</span><span class="p">,</span><span class="w"> </span><span class="n">user_alias</span><span class="p">,</span><span class="w"> </span><span class="n">book_title</span><span class="p">,</span><span class="w"> </span><span class="n">book_ed</span><span class="p" data-group-id="3369509877-2">)</span><span class="w"> </span><span class="k" data-group-id="3369509877-3">do</span><span class="w">
    </span><span class="n">...</span><span class="w">
  </span><span class="k" data-group-id="3369509877-3">end</span><span class="w">
</span><span class="k" data-group-id="3369509877-1">end</span></code></pre><h4>Refactoring</h4><p>To address this anti-pattern, related arguments can be grouped using key-value data structures, such as maps, structs, or even keyword lists in the case of optional arguments. This effectively reduces the number of arguments and the key-value data structures adds clarity to the caller.</p><p>For this particular example, the arguments to <code class="inline">loan/6</code> can be grouped into two different maps, thereby reducing its arity to <code class="inline">loan/2</code>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Library</span><span class="w"> </span><span class="k" data-group-id="9575949656-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">loan</span><span class="p" data-group-id="9575949656-2">(</span><span class="p" data-group-id="9575949656-3">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="ss">email</span><span class="p">:</span><span class="w"> </span><span class="n">email</span><span class="p">,</span><span class="w"> </span><span class="ss">password</span><span class="p">:</span><span class="w"> </span><span class="n">password</span><span class="p">,</span><span class="w"> </span><span class="ss">alias</span><span class="p">:</span><span class="w"> </span><span class="kn">alias</span><span class="p" data-group-id="9575949656-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9575949656-4">%{</span><span class="ss">title</span><span class="p">:</span><span class="w"> </span><span class="n">title</span><span class="p">,</span><span class="w"> </span><span class="ss">ed</span><span class="p">:</span><span class="w"> </span><span class="n">ed</span><span class="p" data-group-id="9575949656-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">book</span><span class="p" data-group-id="9575949656-2">)</span><span class="w"> </span><span class="k" data-group-id="9575949656-5">do</span><span class="w">
    </span><span class="n">...</span><span class="w">
  </span><span class="k" data-group-id="9575949656-5">end</span><span class="w">
</span><span class="k" data-group-id="9575949656-1">end</span></code></pre><p>In some cases, the function with too many arguments may be a private function, which gives us more flexibility over how to separate the function arguments. One possible suggestion for such scenarios is to split the arguments in two maps (or tuples): one map keeps the data that may change, and the other keeps the data that won't change (read-only). This gives us a mechanical option to refactor the code.</p><p>Other times, a function may legitimately take half a dozen or more completely unrelated arguments. This may suggest the function is trying to do too much and would be better broken into multiple functions, each responsible for a smaller piece of the overall responsibility.</p><h2 id="namespace-trespassing" class="section-heading">
  <a href="#namespace-trespassing" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Namespace trespassing</span>
</h2>
<h4>Problem</h4><p>This anti-pattern manifests when a package author or a library defines modules outside of its &quot;namespace&quot;. A library should use its name as a &quot;prefix&quot; for all of its modules. For example, a package named <code class="inline">:my_lib</code> should define all of its modules within the <code class="inline">MyLib</code> namespace, such as <code class="inline">MyLib.User</code>, <code class="inline">MyLib.SubModule</code>, <code class="inline">MyLib.Application</code>, and <code class="inline">MyLib</code> itself.</p><p>This is important because the Erlang VM can only load one instance of a module at a time. So if there are multiple libraries that define the same module, then they are incompatible with each other due to this limitation. By always using the library name as a prefix, it avoids module name clashes due to the unique prefix.</p><h4>Example</h4><p>This problem commonly manifests when writing an extension of another library. For example, imagine you are writing a package that adds authentication to <a href="https://github.com/elixir-plug/plug">Plug</a> called <code class="inline">:plug_auth</code>. You must avoid defining modules within the <code class="inline">Plug</code> namespace:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Plug.Auth</span><span class="w"> </span><span class="k" data-group-id="4526145327-1">do</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="4526145327-1">end</span></code></pre><p>Even if <code class="inline">Plug</code> does not currently define a <code class="inline">Plug.Auth</code> module, it may add such a module in the future, which would ultimately conflict with <code class="inline">plug_auth</code>'s definition.</p><h4>Refactoring</h4><p>Given the package is named <code class="inline">:plug_auth</code>, it must define modules inside the <code class="inline">PlugAuth</code> namespace:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">PlugAuth</span><span class="w"> </span><span class="k" data-group-id="3590971590-1">do</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="3590971590-1">end</span></code></pre><h4>Additional remarks</h4><p>There are few known exceptions to this anti-pattern:</p><ul><li><p><a href="Kernel.html#defimpl/2">Protocol implementations</a> are, by design, defined under the protocol namespace</p></li><li><p>In some scenarios, the namespace owner may allow exceptions to this rule. For example, in Elixir itself, you defined <a href="https://hexdocs.pm/mix/Mix.Task.html">custom Mix tasks</a> by placing them under the <code class="inline">Mix.Tasks</code> namespace, such as <code class="inline">Mix.Tasks.PlugAuth</code></p></li><li><p>If you are the maintainer for both <code class="inline">plug</code> and <code class="inline">plug_auth</code>, then you may allow <code class="inline">plug_auth</code> to define modules with the <code class="inline">Plug</code> namespace, such as <code class="inline">Plug.Auth</code>. However, you are responsible for avoiding or managing any conflicts that may arise in the future</p></li></ul><h2 id="non-assertive-map-access" class="section-heading">
  <a href="#non-assertive-map-access" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Non-assertive map access</span>
</h2>
<h4>Problem</h4><p>In Elixir, it is possible to access values from <a href="Map.html"><code class="inline">Map</code></a>s, which are key-value data structures, either statically or dynamically.</p><p>When a key is expected to exist in a map, it must be accessed using the <code class="inline">map.key</code> notation, making it clear to developers (and the compiler) that the key must exist. If the key does not exist, an exception is raised (and in some cases also compiler warnings). This is also known as the static notation, as the key is known at the time of writing the code.</p><p>When a key is optional, the <code class="inline">map[:key]</code> notation must be used instead. This way, if the informed key does not exist, <code class="inline">nil</code> is returned. This is the dynamic notation, as it also supports dynamic key access, such as <code class="inline">map[some_var]</code>.</p><p>When you use <code class="inline">map[:key]</code> to access a key that always exists in the map, you are making the code less clear for developers and for the compiler, as they now need to work with the assumption the key may not be there. This mismatch may also make it harder to track certain bugs. If the key is unexpectedly missing, you will have a <code class="inline">nil</code> value propagate through the system, instead of raising on map access.</p><h4>Example</h4><p>The function <code class="inline">plot/1</code> tries to draw a graphic to represent the position of a point in a Cartesian plane. This function receives a parameter of <a href="Map.html"><code class="inline">Map</code></a> type with the point attributes, which can be a point of a 2D or 3D Cartesian coordinate system. This function uses dynamic access to retrieve values for the map keys:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Graphics</span><span class="w"> </span><span class="k" data-group-id="5246495312-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">plot</span><span class="p" data-group-id="5246495312-2">(</span><span class="n">point</span><span class="p" data-group-id="5246495312-2">)</span><span class="w"> </span><span class="k" data-group-id="5246495312-3">do</span><span class="w">
    </span><span class="c1"># Some other code...</span><span class="w">
    </span><span class="p" data-group-id="5246495312-4">{</span><span class="n">point</span><span class="p" data-group-id="5246495312-5">[</span><span class="ss">:x</span><span class="p" data-group-id="5246495312-5">]</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="p" data-group-id="5246495312-6">[</span><span class="ss">:y</span><span class="p" data-group-id="5246495312-6">]</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="p" data-group-id="5246495312-7">[</span><span class="ss">:z</span><span class="p" data-group-id="5246495312-7">]</span><span class="p" data-group-id="5246495312-4">}</span><span class="w">
  </span><span class="k" data-group-id="5246495312-3">end</span><span class="w">
</span><span class="k" data-group-id="5246495312-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">point_2d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8193804004-1">%{</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="8193804004-1">}</span><span class="w">
</span><span class="p" data-group-id="8193804004-2">%{</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="8193804004-2">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">point_3d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8193804004-3">%{</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="ss">z</span><span class="p">:</span><span class="w"> </span><span class="mi">7</span><span class="p" data-group-id="8193804004-3">}</span><span class="w">
</span><span class="p" data-group-id="8193804004-4">%{</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="ss">z</span><span class="p">:</span><span class="w"> </span><span class="mi">7</span><span class="p" data-group-id="8193804004-4">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Graphics</span><span class="o">.</span><span class="n">plot</span><span class="p" data-group-id="8193804004-5">(</span><span class="n">point_2d</span><span class="p" data-group-id="8193804004-5">)</span><span class="w">
</span><span class="p" data-group-id="8193804004-6">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="8193804004-6">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Graphics</span><span class="o">.</span><span class="n">plot</span><span class="p" data-group-id="8193804004-7">(</span><span class="n">point_3d</span><span class="p" data-group-id="8193804004-7">)</span><span class="w">
</span><span class="p" data-group-id="8193804004-8">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p" data-group-id="8193804004-8">}</span></code></pre><p>Given we want to plot both 2D and 3D points, the behavior above is expected. But what happens if we forget to pass a point with either <code class="inline">:x</code> or <code class="inline">:y</code>?</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">bad_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7495794340-1">%{</span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="ss">z</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="7495794340-1">}</span><span class="w">
</span><span class="p" data-group-id="7495794340-2">%{</span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="ss">z</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="7495794340-2">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Graphics</span><span class="o">.</span><span class="n">plot</span><span class="p" data-group-id="7495794340-3">(</span><span class="n">bad_point</span><span class="p" data-group-id="7495794340-3">)</span><span class="w">
</span><span class="p" data-group-id="7495794340-4">{</span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="7495794340-4">}</span></code></pre><p>The behavior above is unexpected because our function should not work with points without a <code class="inline">:x</code> key. This leads to subtle bugs, as we may now pass <code class="inline">nil</code> to another function, instead of raising early on.</p><h4>Refactoring</h4><p>To remove this anti-pattern, we must use the dynamic <code class="inline">map[:key]</code> syntax and the static <code class="inline">map.key</code> notation according to our requirements. We expect <code class="inline">:x</code> and <code class="inline">:y</code> to always exist, but not <code class="inline">:z</code>. The next code illustrates the refactoring of <code class="inline">plot/1</code>, removing this anti-pattern:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Graphics</span><span class="w"> </span><span class="k" data-group-id="7784252542-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">plot</span><span class="p" data-group-id="7784252542-2">(</span><span class="n">point</span><span class="p" data-group-id="7784252542-2">)</span><span class="w"> </span><span class="k" data-group-id="7784252542-3">do</span><span class="w">
    </span><span class="c1"># Some other code...</span><span class="w">
    </span><span class="p" data-group-id="7784252542-4">{</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="p" data-group-id="7784252542-5">[</span><span class="ss">:z</span><span class="p" data-group-id="7784252542-5">]</span><span class="p" data-group-id="7784252542-4">}</span><span class="w">
  </span><span class="k" data-group-id="7784252542-3">end</span><span class="w">
</span><span class="k" data-group-id="7784252542-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">Graphics</span><span class="o">.</span><span class="n">plot</span><span class="p" data-group-id="3383384165-1">(</span><span class="n">point_2d</span><span class="p" data-group-id="3383384165-1">)</span><span class="w">
</span><span class="p" data-group-id="3383384165-2">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="3383384165-2">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Graphics</span><span class="o">.</span><span class="n">plot</span><span class="p" data-group-id="3383384165-3">(</span><span class="n">bad_point</span><span class="p" data-group-id="3383384165-3">)</span><span class="w">
</span><span class="gt">** (KeyError) key :x not found in: %{y: 3, z: 4}</span><span class="w">
  </span><span class="n">graphic</span><span class="o">.</span><span class="n">ex</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="w"> </span><span class="nc">Graphics</span><span class="o">.</span><span class="n">plot</span><span class="o">/</span><span class="mi">1</span></code></pre><p>Overall, the usage of <code class="inline">map.key</code> and <code class="inline">map[:key]</code> encode important information about your data structure, allowing developers to be clear about their intent. See both <a href="Map.html"><code class="inline">Map</code></a> and <a href="Access.html"><code class="inline">Access</code></a> module documentation for more information and examples.</p><p>An alternative to refactor this anti-pattern is to use pattern matching, defining explicit clauses for 2d vs 3d points:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Graphics</span><span class="w"> </span><span class="k" data-group-id="7126629407-1">do</span><span class="w">
  </span><span class="c1"># 3d</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">plot</span><span class="p" data-group-id="7126629407-2">(</span><span class="p" data-group-id="7126629407-3">%{</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="ss">z</span><span class="p">:</span><span class="w"> </span><span class="n">z</span><span class="p" data-group-id="7126629407-3">}</span><span class="p" data-group-id="7126629407-2">)</span><span class="w"> </span><span class="k" data-group-id="7126629407-4">do</span><span class="w">
    </span><span class="c1"># Some other code...</span><span class="w">
    </span><span class="p" data-group-id="7126629407-5">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p" data-group-id="7126629407-5">}</span><span class="w">
  </span><span class="k" data-group-id="7126629407-4">end</span><span class="w">

  </span><span class="c1"># 2d</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">plot</span><span class="p" data-group-id="7126629407-6">(</span><span class="p" data-group-id="7126629407-7">%{</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="7126629407-7">}</span><span class="p" data-group-id="7126629407-6">)</span><span class="w"> </span><span class="k" data-group-id="7126629407-8">do</span><span class="w">
    </span><span class="c1"># Some other code...</span><span class="w">
    </span><span class="p" data-group-id="7126629407-9">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="7126629407-9">}</span><span class="w">
  </span><span class="k" data-group-id="7126629407-8">end</span><span class="w">
</span><span class="k" data-group-id="7126629407-1">end</span></code></pre><p>Pattern-matching is specially useful when matching over multiple keys as well as on the values themselves at once.</p><p>Another option is to use structs. By default, structs only support static access to its fields. In such scenarios, you may consider defining structs for both 2D and 3D points:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Point2D</span><span class="w"> </span><span class="k" data-group-id="7384908007-1">do</span><span class="w">
  </span><span class="na">@enforce_keys</span><span class="w"> </span><span class="p" data-group-id="7384908007-2">[</span><span class="ss">:x</span><span class="p">,</span><span class="w"> </span><span class="ss">:y</span><span class="p" data-group-id="7384908007-2">]</span><span class="w">
  </span><span class="kd">defstruct</span><span class="w"> </span><span class="p" data-group-id="7384908007-3">[</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="7384908007-3">]</span><span class="w">
</span><span class="k" data-group-id="7384908007-1">end</span></code></pre><p>Generally speaking, structs are useful when sharing data structures across modules, at the cost of adding a compile time dependency between these modules. If module <code class="inline">A</code> uses a struct defined in module <code class="inline">B</code>, <code class="inline">A</code> must be recompiled if the fields in the struct <code class="inline">B</code> change.</p><h4>Additional remarks</h4><p>This anti-pattern was formerly known as <a href="https://github.com/lucasvegi/Elixir-Code-Smells#accessing-non-existent-mapstruct-fields">Accessing non-existent map/struct fields</a>.</p><h2 id="non-assertive-pattern-matching" class="section-heading">
  <a href="#non-assertive-pattern-matching" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Non-assertive pattern matching</span>
</h2>
<h4>Problem</h4><p>Overall, Elixir systems are composed of many supervised processes, so the effects of an error are localized to a single process, and don't propagate to the entire application. A supervisor detects the failing process, reports it, and possibly restarts it. This anti-pattern arises when developers write defensive or imprecise code, capable of returning incorrect values which were not planned for, instead of programming in an assertive style through pattern matching and guards.</p><h4>Example</h4><p>The function <code class="inline">get_value/2</code> tries to extract a value from a specific key of a URL query string. As it is not implemented using pattern matching, <code class="inline">get_value/2</code> always returns a value, regardless of the format of the URL query string passed as a parameter in the call. Sometimes the returned value will be valid. However, if a URL query string with an unexpected format is used in the call, <code class="inline">get_value/2</code> will extract incorrect values from it:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Extract</span><span class="w"> </span><span class="k" data-group-id="8224527506-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">get_value</span><span class="p" data-group-id="8224527506-2">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">desired_key</span><span class="p" data-group-id="8224527506-2">)</span><span class="w"> </span><span class="k" data-group-id="8224527506-3">do</span><span class="w">
    </span><span class="n">parts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">split</span><span class="p" data-group-id="8224527506-4">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&amp;&quot;</span><span class="p" data-group-id="8224527506-4">)</span><span class="w">

    </span><span class="nc">Enum</span><span class="o">.</span><span class="n">find_value</span><span class="p" data-group-id="8224527506-5">(</span><span class="n">parts</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="8224527506-6">fn</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="n">key_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">split</span><span class="p" data-group-id="8224527506-7">(</span><span class="n">pair</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;=&quot;</span><span class="p" data-group-id="8224527506-7">)</span><span class="w">
      </span><span class="nc">Enum</span><span class="o">.</span><span class="n">at</span><span class="p" data-group-id="8224527506-8">(</span><span class="n">key_value</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="8224527506-8">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">desired_key</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">at</span><span class="p" data-group-id="8224527506-9">(</span><span class="n">key_value</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="8224527506-9">)</span><span class="w">
    </span><span class="k" data-group-id="8224527506-6">end</span><span class="p" data-group-id="8224527506-5">)</span><span class="w">
  </span><span class="k" data-group-id="8224527506-3">end</span><span class="w">
</span><span class="k" data-group-id="8224527506-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="c1"># URL query string with the planned format - OK!</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Extract</span><span class="o">.</span><span class="n">get_value</span><span class="p" data-group-id="5874620101-1">(</span><span class="s">&quot;name=Lucas&amp;university=UFMG&amp;lab=ASERG&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lab&quot;</span><span class="p" data-group-id="5874620101-1">)</span><span class="w">
</span><span class="s">&quot;ASERG&quot;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Extract</span><span class="o">.</span><span class="n">get_value</span><span class="p" data-group-id="5874620101-2">(</span><span class="s">&quot;name=Lucas&amp;university=UFMG&amp;lab=ASERG&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;university&quot;</span><span class="p" data-group-id="5874620101-2">)</span><span class="w">
</span><span class="s">&quot;UFMG&quot;</span><span class="w">
</span><span class="c1"># Unplanned URL query string format - Unplanned value extraction!</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Extract</span><span class="o">.</span><span class="n">get_value</span><span class="p" data-group-id="5874620101-3">(</span><span class="s">&quot;name=Lucas&amp;university=institution=UFMG&amp;lab=ASERG&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;university&quot;</span><span class="p" data-group-id="5874620101-3">)</span><span class="w">
</span><span class="s">&quot;institution&quot;</span><span class="w">   </span><span class="c1"># &lt;= why not &quot;institution=UFMG&quot;? or only &quot;UFMG&quot;?</span></code></pre><h4>Refactoring</h4><p>To remove this anti-pattern, <code class="inline">get_value/2</code> can be refactored through the use of pattern matching. So, if an unexpected URL query string format is used, the function will crash instead of returning an invalid value. This behavior, shown below, allows clients to decide how to handle these errors and doesn't give a false impression that the code is working correctly when unexpected values are extracted:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Extract</span><span class="w"> </span><span class="k" data-group-id="3245161567-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">get_value</span><span class="p" data-group-id="3245161567-2">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">desired_key</span><span class="p" data-group-id="3245161567-2">)</span><span class="w"> </span><span class="k" data-group-id="3245161567-3">do</span><span class="w">
    </span><span class="n">parts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">split</span><span class="p" data-group-id="3245161567-4">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&amp;&quot;</span><span class="p" data-group-id="3245161567-4">)</span><span class="w">

    </span><span class="nc">Enum</span><span class="o">.</span><span class="n">find_value</span><span class="p" data-group-id="3245161567-5">(</span><span class="n">parts</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="3245161567-6">fn</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="p" data-group-id="3245161567-7">[</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="3245161567-7">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">split</span><span class="p" data-group-id="3245161567-8">(</span><span class="n">pair</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;=&quot;</span><span class="p" data-group-id="3245161567-8">)</span><span class="w"> </span><span class="c1"># &lt;= pattern matching</span><span class="w">
      </span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">desired_key</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">value</span><span class="w">
    </span><span class="k" data-group-id="3245161567-6">end</span><span class="p" data-group-id="3245161567-5">)</span><span class="w">
  </span><span class="k" data-group-id="3245161567-3">end</span><span class="w">
</span><span class="k" data-group-id="3245161567-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="c1"># URL query string with the planned format - OK!</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Extract</span><span class="o">.</span><span class="n">get_value</span><span class="p" data-group-id="9364371320-1">(</span><span class="s">&quot;name=Lucas&amp;university=UFMG&amp;lab=ASERG&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name&quot;</span><span class="p" data-group-id="9364371320-1">)</span><span class="w">
</span><span class="s">&quot;Lucas&quot;</span><span class="w">
</span><span class="c1"># Unplanned URL query string format - Crash explaining the problem to the client!</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Extract</span><span class="o">.</span><span class="n">get_value</span><span class="p" data-group-id="9364371320-2">(</span><span class="s">&quot;name=Lucas&amp;university=institution=UFMG&amp;lab=ASERG&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;university&quot;</span><span class="p" data-group-id="9364371320-2">)</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: [&quot;university&quot;, &quot;institution&quot;, &quot;UFMG&quot;]</span><span class="w">
  </span><span class="n">extract</span><span class="o">.</span><span class="n">ex</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="w"> </span><span class="n">anonymous</span><span class="w"> </span><span class="k" data-group-id="9364371320-3">fn</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">Extract</span><span class="o">.</span><span class="n">get_value</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="c1"># &lt;= left hand: [key, value] pair</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Extract</span><span class="o">.</span><span class="n">get_value</span><span class="p" data-group-id="9364371320-4">(</span><span class="s">&quot;name=Lucas&amp;university&amp;lab=ASERG&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;university&quot;</span><span class="p" data-group-id="9364371320-4">)</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: [&quot;university&quot;]</span><span class="w">
  </span><span class="n">extract</span><span class="o">.</span><span class="n">ex</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="w"> </span><span class="n">anonymous</span><span class="w"> </span><span class="k" data-group-id="9364371320-5">fn</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">Extract</span><span class="o">.</span><span class="n">get_value</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="c1"># &lt;= left hand: [key, value] pair</span></code></pre><p>Elixir and pattern matching promote an assertive style of programming where you handle the known cases. Once an unexpected scenario arises, you can decide to address it accordingly based on practical examples, or conclude the scenario is indeed invalid and the exception is the desired choice.</p><p><a href="Kernel.SpecialForms.html#case/2"><code class="inline">case/2</code></a> is another important construct in Elixir that help us write assertive code, by matching on specific patterns. For example, if a function returns <code class="inline">{:ok, ...}</code> or <code class="inline">{:error, ...}</code>, prefer to explicitly match on both patterns:</p><pre><code class="makeup elixir" translate="no"><span class="k">case</span><span class="w"> </span><span class="n">some_function</span><span class="p" data-group-id="2249744665-1">(</span><span class="n">arg</span><span class="p" data-group-id="2249744665-1">)</span><span class="w"> </span><span class="k" data-group-id="2249744665-2">do</span><span class="w">
  </span><span class="p" data-group-id="2249744665-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="2249744665-3">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="c1"># ...</span><span class="w">
  </span><span class="p" data-group-id="2249744665-4">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="2249744665-4">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="2249744665-2">end</span></code></pre><p>In particular, avoid matching solely on <code class="inline">_</code>, as shown below:</p><pre><code class="makeup elixir" translate="no"><span class="k">case</span><span class="w"> </span><span class="n">some_function</span><span class="p" data-group-id="9160767852-1">(</span><span class="n">arg</span><span class="p" data-group-id="9160767852-1">)</span><span class="w"> </span><span class="k" data-group-id="9160767852-2">do</span><span class="w">
  </span><span class="p" data-group-id="9160767852-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="9160767852-3">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="c1"># ...</span><span class="w">
  </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="9160767852-2">end</span></code></pre><p> Matching on <code class="inline">_</code> is less clear in intent and it may hide bugs if <code class="inline">some_function/1</code> adds new return values in the future.</p><h4>Additional remarks</h4><p>This anti-pattern was formerly known as <a href="https://github.com/lucasvegi/Elixir-Code-Smells#speculative-assumptions">Speculative assumptions</a>.</p><h2 id="non-assertive-truthiness" class="section-heading">
  <a href="#non-assertive-truthiness" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Non-assertive truthiness</span>
</h2>
<h4>Problem</h4><p>Elixir provides the concept of truthiness: <code class="inline">nil</code> and <code class="inline">false</code> are considered &quot;falsy&quot; and all other values are &quot;truthy&quot;. Many constructs in the language, such as <a href="Kernel.html#&&/2"><code class="inline">&amp;&amp;/2</code></a>, <a href="Kernel.html#%7C%7C/2"><code class="inline">||/2</code></a>, and <a href="Kernel.html#!/1"><code class="inline">!/1</code></a> handle truthy and falsy values. Using those operators is not an anti-pattern. However, using those operators when all operands are expected to be booleans, may be an anti-pattern.</p><h4>Example</h4><p>The simplest scenario where this anti-pattern manifests is in conditionals, such as:</p><pre><code class="makeup elixir" translate="no"><span class="k">if</span><span class="w"> </span><span class="n">is_binary</span><span class="p" data-group-id="1938509418-1">(</span><span class="n">name</span><span class="p" data-group-id="1938509418-1">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="1938509418-2">(</span><span class="n">age</span><span class="p" data-group-id="1938509418-2">)</span><span class="w"> </span><span class="k" data-group-id="1938509418-3">do</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="1938509418-3">else</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="1938509418-3">end</span></code></pre><p>Given both operands of <a href="Kernel.html#&&/2"><code class="inline">&amp;&amp;/2</code></a> are booleans, the code is more generic than necessary, and potentially unclear.</p><h4>Refactoring</h4><p>To remove this anti-pattern, we can replace <a href="Kernel.html#&&/2"><code class="inline">&amp;&amp;/2</code></a>, <a href="Kernel.html#%7C%7C/2"><code class="inline">||/2</code></a>, and <a href="Kernel.html#!/1"><code class="inline">!/1</code></a> by <a href="Kernel.html#and/2"><code class="inline">and/2</code></a>, <a href="Kernel.html#or/2"><code class="inline">or/2</code></a>, and <a href="Kernel.html#not/1"><code class="inline">not/1</code></a> respectively. These operators assert at least their first argument is a boolean:</p><pre><code class="makeup elixir" translate="no"><span class="k">if</span><span class="w"> </span><span class="n">is_binary</span><span class="p" data-group-id="8228374826-1">(</span><span class="n">name</span><span class="p" data-group-id="8228374826-1">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="8228374826-2">(</span><span class="n">age</span><span class="p" data-group-id="8228374826-2">)</span><span class="w"> </span><span class="k" data-group-id="8228374826-3">do</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="8228374826-3">else</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="8228374826-3">end</span></code></pre><p>This technique may be particularly important when working with Erlang code. Erlang does not have the concept of truthiness. It never returns <code class="inline">nil</code>, instead its functions may return <code class="inline">:error</code> or <code class="inline">:undefined</code> in places an Elixir developer would return <code class="inline">nil</code>. Therefore, to avoid accidentally interpreting <code class="inline">:undefined</code> or <code class="inline">:error</code> as a truthy value, you may prefer to use <a href="Kernel.html#and/2"><code class="inline">and/2</code></a>, <a href="Kernel.html#or/2"><code class="inline">or/2</code></a>, and <a href="Kernel.html#not/1"><code class="inline">not/1</code></a> exclusively when interfacing with Erlang APIs.</p>
</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="what-anti-patterns.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
What are anti-patterns?
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="design-anti-patterns.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Design-related anti-patterns
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="Elixir.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.37.1) for the

          <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

      </p>

    </footer>
  </div>
</main>
</div>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10.2.3/dist/mermaid.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    mermaid.initialize({
      startOnLoad: false,
      theme: document.body.className.includes("dark") ? "dark" : "default"
    });
    let id = 0;
    for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
        graphEl.innerHTML = svg;
        bindFunctions?.(graphEl);
        preEl.insertAdjacentElement("afterend", graphEl);
        preEl.remove();
      });
    }
  });
</script>

  </body>
</html>
