defmodule FissionLib.RemoteObject do
  defstruct ref: nil
end

defimpl Jason.Encoder, for: FissionLib.RemoteObject do
  def encode(value, opts) when value.ref != nil do
    key = :emscripten.from_remote_object(value.ref, :key)
    Jason.Encode.map(%{fission_ref: key}, opts)
  end
end

defmodule FissionLib.Wasm do
  @moduledoc """
  Functions for interacting with JS side.
  """
  alias FissionLib.RemoteObject

  defguardp is_tagged_emscripten(msg) when elem(msg, 0) == :emscripten
  defguardp is_call(msg) when elem(elem(msg, 1), 0) == :call and tuple_size(elem(msg, 1)) == 3
  defguardp is_cast(msg) when elem(elem(msg, 1), 0) == :cast and tuple_size(elem(msg, 1)) == 2

  defguard is_wasm_message(msg) when is_tagged_emscripten(msg) and (is_call(msg) or is_cast(msg))

  @type promise :: term()

  @typedoc """
  Message received from JS side with binary data.
  """
  @type raw_message ::
          {:emscripten, {:call, promise(), data :: binary()}}
          | {:emscripten, {:cast, data :: binary()}}

  @typedoc """
  Parsed raw message with data transformed to terms.
  """
  @type wasm_message ::
          {:wasm_call, data :: term(), promise()}
          | {:wasm_cast, data :: term()}

  @type handler_result ::
          {:resolve, promise_reply :: term(), result :: term()}
          | {:reject, promise_reply :: term(), result :: term()}
          | term()

  @type message_handler :: (wasm_message() -> handler_result())

  @typedoc """
  See `run_js/2` docs.
  """
  @type js_function() :: String.t()

  @type run_js_opts() :: [{:return, [:key | :value]} | {:bindings, map()}]

  @type js_data() :: %{
          :ref => %RemoteObject{},
          optional(:key) => term(),
          optional(:value) => term()
        }

  @type run_js_return() :: {:ok, js_data()} | {:error, term()}

  @type register_event_listener_opts() :: [
          {:event_keys, [atom()]},
          {:target, String.t()},
          {:selector, String.t()}
        ]

  @doc """
  Deserializes raw message and calls handler with it. If the message was a :wasm_call, settles the promise with a value.
  Returns handler result.
  """
  @spec handle_message!(raw_message(), message_handler()) :: term()
  def handle_message!(raw_msg, handler) when is_wasm_message(raw_msg) do
    case parse_message!(raw_msg) do
      {:wasm_call, message, promise} ->
        {promise_state, promise_reply, result} = handler.({:wasm_call, message})

        case promise_state do
          :resolve -> resolve(promise_reply, promise)
          :reject -> reject(promise_reply, promise)
        end

        result

      message ->
        handler.(message)
    end
  end

  @doc """
  Deserializes message received from JS side.
  """
  @spec parse_message!(raw_message()) :: wasm_message()
  def parse_message!({:emscripten, {:call, promise, raw_message}}) do
    {:ok, message} = deserialize(raw_message)
    {:wasm_call, message, promise}
  end

  def parse_message!({:emscripten, {:cast, raw_message}}) do
    {:ok, message} = deserialize(raw_message)
    {:wasm_cast, message}
  end

  @spec resolve(term(), promise()) :: :ok
  def resolve(term, promise) do
    with {:ok, raw_message} <- serialize(term) do
      :emscripten.promise_resolve(promise, raw_message)
      :ok
    end
  end

  @spec reject(term(), promise()) :: :ok
  def reject(term, promise) do
    with {:ok, raw_message} <- serialize(term) do
      :emscripten.promise_reject(promise, raw_message)
      :ok
    end
  end

  @doc """
  Runs JS code in browser's main thread in the WASM iframe context. Takes a JS function as string. The JS function takes an object with following keys:
  - `wasm`: the underlying WASM module generated by emscripten.
  - `bindings`: the arguments passed from Elixir and deserialized at JS side.
  - `window`: the main window context. Use it instead of calling (implicitly or explicitly) iframe window in the function.
  - `key`: a key generated for value returned from function.

  Value returned from function is saved in JS context. It's lifetime is tied to (possibly) returned ref.
  If ref is garbage collected by Elixir VM, value is destroyed in JS too.

  `opts`:
  - `bindings`: a map of serializable Elixir values passed to the function. Default: `%{}`
  - `return`: a list controlling what should be returned to Elixir. Possible values: `:key`, `:value`. Default: `[]`

  Passing bindings and returning value introduces overhead related to serializing and deserializing values. By default only ref is returned.
  """
  @spec run_js(js_function(), run_js_opts()) :: run_js_return()
  @spec run_js(js_function()) :: run_js_return()
  def run_js(function, opts \\ []) do
    %{return: return, bindings: bindings} = opts_to_map(opts, return: [], bindings: %{})

    with {:ok, wrapped_js_fn} <- with_wrapper(function, bindings),
         {:ok, ref} <- run_js_fn(wrapped_js_fn),
         {:ok, value} <- prepare_js_result(ref, [:ref | return]) do
      {:ok, value}
    end
  rescue
    e -> {:error, e}
  end

  @doc """
  Notifies JS that Elixir side finished initializing.
  """
  def send_elixir_ready(main_process_name) do
    {:ok, _} =
      """
      ({ wasm, bindings }) => {
        wasm.onElixirReady(bindings.main);
      }
      """
      |> run_js(bindings: %{main: main_process_name})

    :ok
  end

  @doc """
  Registers event listener for element with given `selector`. Events will be sent to the process registered under `target` name.
  To get event data, specify needed keys in `event_keys` list.

  To unregister listener, use returned ref with `unregister_event_listener/1`
  """
  @spec register_event_listener(String.t(), register_event_listener_opts()) :: run_js_return()
  def register_event_listener(event_name, opts) do
    %{event_keys: event_keys, target: target, selector: selector} =
      opts_to_map(opts, event_keys: [], target: nil, selector: nil)

    """
    ({ wasm, bindings, window, key }) => {
      const { selector, event_name, target, event_keys } = bindings;

      const getEventData = (event) => {
        const data = {};
        for(const key of event_keys) {
          data[key] = event[key];
        }
        return data;
      };
      const fn = (event) => {
        wasm.cast(target, [event_name, getEventData(event)]);
      };
      const node = window.document.querySelector(selector);
      node.addEventListener(event_name, fn);
      const cleanupFn = () => {
        node.removeEventListener(event_name, fn);
        wasm.cleanupFunctions.delete(key);
      };
      wasm.cleanupFunctions.set(key, cleanupFn);

      return cleanupFn;
    }
    """
    |> run_js(
      bindings: %{
        selector: selector,
        event_name: event_name,
        target: target,
        event_keys: event_keys
      }
    )
  end

  def unregister_event_listener(ref) do
    """
    ({ bindings }) => {
      bindings.cleanupFn();
    }
    """
    |> run_js(bindings: %{cleanupFn: ref})
  end

  defp with_wrapper(js_function, bindings) do
    with {:ok, serialized_bindings} <- serialize(bindings) do
      code = """
      (Module, key) => {
        try {
          return (#{js_function})({
            wasm: Module,
            bindings: Module.deserialize('#{serialized_bindings}'),
            window: window.parent,
            key: key
          });
        } catch (e) {
          console.error(e);
        }
      }
      """

      {:ok, code}
    end
  end

  @doc false
  defp deserialize(message) do
    Jason.decode(message)
  end

  @doc false
  defp serialize(term) do
    Jason.encode(term)
  end

  defp run_js_fn(code) do
    with {:ok, ref} <- :emscripten.run_remote_object_fn_script(code, main_thread: true) do
      {:ok, %RemoteObject{ref: ref}}
    end
  end

  defp prepare_js_result(remote_object, types) do
    type_with_value = fn type, map ->
      case js_result(remote_object, type) do
        {:ok, result} -> {:cont, Map.put(map, type, result)}
        {:error, error} -> {:halt, {:error, error}}
      end
    end

    with %{} = result = Enum.reduce_while(types, %{}, type_with_value) do
      {:ok, result}
    end
  end

  defp js_result(%RemoteObject{} = remote_object, :ref), do: {:ok, remote_object}
  defp js_result(%RemoteObject{ref: ref}, :key), do: :emscripten.from_remote_object(ref, :key)

  defp js_result(%RemoteObject{ref: ref}, :value) do
    with {:ok, serialized} <- :emscripten.from_remote_object(ref, :value) do
      deserialize(serialized)
    end
  end

  defp opts_to_map(opts, values), do: opts |> Keyword.validate!(values) |> Map.new()
end
